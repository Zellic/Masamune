[{"title": "2. Input-dependent iteration in Lend modules BeginBlocker may slow down or stop block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "BeginBlocker is a function that is executed at the beginning of every block, even if there are no transactions. It should have a light and constant computational footprint to avoid any negative impacts on block production. Too much computational weight at the beginning of each block may cause block production to slow down, or even surpass Tendermints propose timeout, which results in a halt of the blockchain. Consequently, it is best practice to make the BeginBlocker execution independent, or at least sub-linearly dependent, from the amount of data stored on-chain. In the Lend module in x/lend/abci.go:13-23, the execution loops through all stored borrows in order to balance stable rates. Since borrows cardinality will grow with chain adoption or due to a spam attack, the issue described above will occur.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Batch mechanism in Liquidation modules BeginBlocker may allow malicious manipulations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "the Liquidation In x/liquidation/keeper/liquidate_borrow.go:11-113 x/liquidation/keeper/liquidate_vaults.go:12-93, through all the borrow positions in order to check the collateral ratio health. BeginBlocker, modules specically in and the execution loops Since positions cardinality will grow with chain adoption or due to a spam attack, in order to defend against issues like Input dependent iteration in Lend modules BeginBlocker may slow down or stop block production, functions implement a batching mechanism. It splits borrowing positions slice into dierent partitions of params.LiquidationBatchSize size. This implies that it could happen that positions that are not healthy in a block interval but are not included in a batch of that interval are not liquidated. This implementation also exposes a vulnerability where a malicious actor could manipulate the mentioned slice in order to create positions that will not be liquidated in a dened interval.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Error raised in BeginBlocker could lead to state corruption", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "In x/liquidation/abci.go:13-27 and x/lend/abci.go:13-23 both Lend and Liquidation modules wrap an ApplyFuncIfNoError function in order to gracefully handle errors. BeginBlockers execution logic their in This function logs errors but has no control over the state and no mechanism to revert partial updates. This implies that if an error is raised in the middle of an execution ow, the execution will stop and log the error, but no action will be taken in order to revert state updates that have been done leading to state corruption.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Incorrect conditions when rebalancing stable rates", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "In x/lend/keeper/iter.go:203-209, the RebalanceStableRates function checks conditions to see if rebalancing must be triggered. The Commodo documentation states that stable rates should be decreased if    + 20% and increased if  + 20%         90% . However, the actual implementation is using dierent conditions. Stable rates are decreased if    + 20% and increased if,  + 20%      >  90% . This leads to a malfunctioning stable interest rate model. An attacker may create multiple accounts with borrowing positions with a stable interest rate for an asset and ensure that the borrowing rate is slightly less than 20% so that the increase condition will never be triggered to rebalance the stable rate even though the utilization ratio hits more than 90%. When the utilization ratio hits 100%, it impacts lenders unable to withdraw their stable assets.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. FundModAcc allows funds to be sent to any module which may result in permanently lost funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The FundModAcc function in x/lend/keeper/keeper.go:1388 allows for the caller to specify any module name for funding. This is problematic because funds could be sent to a module that is not designed to handle them making them stuck in the module. The BankKeeper will return an error if the module name is invalid, but as long as the module name specied is valid, this function will allow for funds to be sent. While any address may call this function, we do not classify it as critical since users would not normally be sending funds directly to a module.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Borrow positions InterestAccumulated is not updated before liquidation, leading to an incorrect interest calculation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "in The x/liquidation/keeper/liquidate_borrow.go:11 does not update the borrow positions InterestAccumulated before performing the liquidation operations. LiquidateBorrows function As a result, a stale value of borrowPos.InterestAccumulated is being used in x/liquidation/keeper/liquidate_borrow.go:60, 76, and 94 to calculate the currentCollateralizationRatio, which leads to an incorrect value. a when addition, in In x/liquidation/keeper/liquidate_borrow.go:115, the stale value is used to set LockedVault.UpdatedAmountOut. This can become especially problematic when the borrow position is large and the interest has not been updated for a long time period, in which case the LockedVault.UpdatedAmountOut will be incorrect by a considerable amount. created borrow locked being is", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. BeginBlocker allows for errors to silently pass without being logged", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The functions called during BeginBlocker do not properly propagate error information. Instead, they continue execution and silently pass on the condition that caused the error. This results in suboptimal visibility of the conditions that are causing errors. example, For in x/liquidation/keeper/liquidate_vaults.go:12 simply executes continue when errors are encountered. LiquidateVaults function the While we acknowledge that an error or panic should not necessarily halt the BeginBlocker, it is best practice to log the conditions that are causing errors. In this example, a liquidatable vault could be silently passed because there is no visibility into which errors are being encountered or even which vaults caused the errors.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Missing validation checks in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "There are some missing validation checks in the following transaction message types as well as the Lend modules governance handler messages:  In x/lend/types/pair.go:18, validation is done only on CPoolName eld.  In x/lend/types/pair.go:25, validation on AssetToPairMapping is not implemented.  In x/lend/types/pair.go:29, validation on AssetRatesParams is not implemented.  In x/lend/types/gov.go:195, validation on AuctionParams is not implemented.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Vault collateralitzationRatio does not account for newly accumulated interest", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "LiquidateVaults The in x/liquidation/keeper/liquidate_vaults.go:12 uses an outdated value of because totalOut vault.InterestAccumulated is not updated. collateralitzationRatio calculate function to In fact, the vault interest is updated in line 71 when the CalculateVaultInterest function is called. This results in collateralitzationRatio not reecting the current accumulated interest. We report this as minor because unlike the issue Borrow positions InterestAccumulated is not updated before liquidation, in this case, LiquidateVaults updates the position so the LockedVault.UpdatedAmountOut is correctly evaluated.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Incorrect value provided to VerifyCollateralizationRatio function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The VerifyCollateralizationRatio function takes liquidationThreshold as the last parameter and uses it the collateralization ratio is greater than the liquidation threshold. to perform validation for whether or not in order In four dierent instances, the function is incorrectly called with the LTV instead of the liquidationThreshold:  x/lend/keeper/keeper.go:541  x/lend/keeper/keeper.go:662  x/lend/keeper/keeper.go:720  x/lend/keeper/keeper.go:1159 This implies that depending on the value of LTV set by governance, the function either always returns ErrorCollateralizationRatio or bypasses the validation which could lead to unexpected results.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. UpdateLendPairsRecords allows governance to update lend pairs even if they have liquidity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The UpdateLendPairsRecords function in x/lend/keeper/pair.go:39 allows governance to update either AssetIn or AssetOut for an existing lend pair. If that existing lend pair is currently being utilized, this could have unintended consequences. Based on the documentation it does not seem that there is any specic reason for allowing updates of lend pairs.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. AddAuctionParamsData does not prevent existing data from being overwritten", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The AddAuctionParamsData function in x/lend/keeper/pair.go:227 does not ensure that existing data with the same key does not exist before saving the provided AuctionParams. This allows governance to overwrite existing data. We classify this as a minor issue because only governance can call this function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. AddAssetRatesParams returns incorrect error message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The AddAssetRatesParams function in x/lend/keeper/pair.go:200 returns the incorrect error \"Asset Rates Params not found\" when the record already exists.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. CLI uses ags instead of arguments to parse proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "In  x/lend/client/cli/tx.go:437,  x/lend/client/cli/tx.go:523,  x/lend/client/cli/tx.go:778, and  x/lend/client/cli/tx.go:901, for the commands the CmdAddNewLendPairsProposal, CmdAddPoolProposal, and CmdAddNewAssetRatesParamsProposal, CmdAddNewAuctionParamsProposal governance proposals currently receive a proposal le as a ag.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unneeded positivity validation for unsigned integers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "the ValidateBasic functions in x/lend/types/tx.go validate that the ID All parameter is a positive number. As unsigned integer type can never be negative, those checks are redundant. Therefore, they can be removed.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Unnecessary aliases pattern increase technical debt", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "are there Currently, in x/lend/types/expected_keepers.go, while the keeper uses the functions from alias.go that reference expected/keeper.go. Having an alias.go le dening all functions of external modules is not necessary and decreases maintainability. external modules functions dened some for", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Duplicated ValidateBasic invocation in CLI", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "Some CLI commands dened in  x/lend/client/cli/tx.go:426,  x/lend/client/cli/tx.go:517,  x/lend/client/cli/tx.go:615,  x/lend/client/cli/tx.go:693,  x/lend/client/cli/tx.go:761,  x/lend/client/cli/tx.go:894, and  x/lend/client/cli/tx.go:986, call the msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI or GenerateOrBroadcastTxWithFactory. As msg.ValidateBasic is already called inside GenerateOrBroadcastTxWithFactory, this is an unnecessary and duplicated invocation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Blacklist policy is not enforced for other chain addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/blockibc_middleware.go:111-115, the sender address is checked to not be blacklisted when performing an IBC token transfer. Since ICS-20 token transfers involve escrowing USDC to other chains, the blacklist policy should ensure that other blacklisted chain addresses cannot redeem the locked USDC with their IBC vouchers. However, this is not possible due to the AccAddressFromBech32 validation in x/tokenfactory/types/message_blacklist.go:45-48, which can only validate native Bech32 prex addresses. This implies that addresses on other chains can redeem USDC independent of a blacklist, since they cannot be blocked by the blacklist. For example, the following command fails when trying to blacklist a Juno address: nobled --home $CHAINDIR/$CHAINID tx tokenfactory blacklist juno1t8ehvswxjfn3ejzkjtntcyrqwvmvuknzy3ajxy --from $(nobled keys show blacklister -a) -y Error: invalid blacklist address (invalid Bech32 prefix; expected noble, got juno): invalid address This issue also aects the receiver blacklist policy in app/ante.go:89-93 when initiating an ICS-20 token transfer. Consequently, the blacklister will not be able to prevent users from transferring USDC to malicious addresses on other chains. We classify this issue as major because the blacklist policy is considered an important security feature in Nobles architecture.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Minting denom can be transacted through IBC during a paused state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "x/tokenfactory/blockibc_middleware.go:92-114, In OnRecvPacket handler does not validate the keepers paused state when receiving ICS-20 fungible token transfer packets. When the keepers paused state is true, all internal and external transfers are disallowed, as seen in app/ante.go:39-43. However, other chains can still transact USDC tokens to the native chain, eectively bypassing the paused state. the We classify this issue as major because the paused state is considered an important security feature in Nobles architecture.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. IBC middleware does not parse denoms trace when receiving ICS-20 packet data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/blockibc_middleware.go:101-103, security measure will be skipped if the packets denom is not the congured minting denom. As mentioned in lines 83-85, this is to ensure that the sender and receiver are not blacklisted if they were to transact an IBC voucher representation of USDC. the blacklist However, this approach will never work because the receiving packets denomination is constructed with a record of channels for which they have been transferred across chains, such as transfer/channel-40/uusdc. Consequently, the condition in line 101 will always evaluate as true, eectively bypassing the blacklist policy in lines 105-115.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Incorrect minterController genesis state validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/types/genesis.go:54, the MinterControllerKey function is used to derive the minter controller key from a minter controller address. However, the minter controller address is passed as an elem.Minter in the current implementation. This sets an incorrect minter controller key to validate a duplicated index. Therefore, as the specied key does not contain any data, accessing data onchain would not be possible.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Deviation from specication: A controller can set up any number of minters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "to the the specication, ConfigureMinter According in x/tokenfactory/keeper/msg_server_configure_minter.go:12 should only be called by the minterController and set its corresponding minter. However, the current implementation of ConfigureMinter does not validate that the minter address being congured matches the specied address that the MinterController controls. The same in issue x/tokenfactory/keeper/msg_server_remove_minter.go:12. Because of that, the relationship between MultiController and minter becomes one-to-many instead of one-to-one. This deviates from the specication. RemoveMinter function function exists the in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Separation of privileged addresses is not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "While there has been an extensive eort made to develop privileged accessed roles within the Noble chain, privilege separation of these roles is not properly enforced. Currently, there is no validation to ensure that these privileges cannot be shared by a single address. In the unlikely case of a compromised account, account sharing may have severe implications. For example, the Owner can assign the Blacklister, Master Minter, and Pauser roles to itself. While new addresses can easily be generated and all roles can technically be owned by the same entity using dierent addresses, it is best practice to restrict address reuse. Another step that can be taken to reduce the impact of a compromised account is to implement timelocks to prevent frequent updates of addresses.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Modifying minting denom allows blacklisted users to transact the old denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/genesis.go:45-47, supplying a dierent MintingDenom will cause the SetMintingDenom function to modify the mint denom. This is problematic since the blacklist functionality only works based on the current minting denom, as the decorator in app/ante.go:67-98 only validates that the addresses are not blacklisted if the transacted denom is the congured minting denom. Consequently, blacklisted users who were previously unable to transact the old minting denom can now transact that denom like other users. Additionally, all minters would need to update their old allowances denom to continue minting new tokens. We classify this issue as minor because only the governance can cause it, which requires cooperation among impacted parties.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Minters can be added during a paused state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/keeper/msg_server_configure_minter_controller.go:12 the x/tokenfactory/keeper/msg_server_configure_minter.go:12, and functions can be ConfigureMinterController and ConfigureMinter keeper executed even if the keepers paused state is set to true. This is inconsistent with the pausing section of the token design specication. As mentioned in that specication, adding minters should be prevented while the contract is paused.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Amino codec must be registered to support end users with hardware devices like Ledger", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/types/codec.go:77, Amino should be used to register all interfaces and concrete types for the tokenfactory module. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Incomplete genesis validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/types/genesis.go:29-63, validating all the provided GenesisState attributes. the Validate function is not There is no logic in place that validates Pauser, Owner and Blacklister addresses and that enforces Denom to be a non-empty string.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Missing validation for existing blacklisted address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/keeper/msg_server_blacklist.go, the Blacklist function is used for adding new addresses, however in its current implementation, it is not veried whether a new address is already on a blacklist or not. As a result, the operation succeeds without an error, which may give indexers or other o-chain services the misleading impression that a specic address has not yet been blacklisted.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Missing blacklist validation during minter conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In the x/tokenfactory/keeper/msg_server_configure_minter.go, ConfigureMinter method is used to add a minter. However, its current implementation does not check if the provided msg.Address is on a blacklist. This allows adding a blacklisted address as a minter.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Tokenfactory does not perform two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "in The x/tokenfactory/keeper/msg_server_update_owner.go:12 does not perform a UpdateOwner function two-step ownership transfer. In the unlikely event that the new owner is set to an incorrect address, then the owner will not be able to be reset, and the owner functionality will be lost.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Succinct event emission restricts information available to indexers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "All dened messages emit TypedEvent events containing the submitted message. However, those events contain only limited detail and may not represent enough information for indexers and other o-chain services.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Amount and Allowance message attributes are not validated to be greater than zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In the ValidateBasic functions in  x/tokenfactory/types/message_burn.go:45,  x/tokenfactory/types/message_configure_minter.go:41, and  x/tokenfactory/types/message_mint.go:41, the Amount and Allowance attributes are not validated to be greater than zero. This implies that messages that contain invalid values can pass the ValidateBasic validation without triggering an error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Incorrect eld numbers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "The GenesisState message in proto/tokenfactory/genesis.proto uses an incorrect eld number starting from 9. The minterControllerList should have 9, and mintingDenom should have 10 eld numbers.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. InitChainer and BeginBlocker are set twice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In app/app.go:571-572 and app/app.go:593-594, SetBeginBlocker methods are called twice, which is inecient. the SetInitChainer and", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Unnecessary validation of From address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "Additional validation for the From address in ValidateBasic functions in the lines below are not necessary since that address belongs to the transaction sender address and is already validated:  x/tokenfactory/types/message_blacklist.go:41  x/tokenfactory/types/message_burn.go:41  x/tokenfactory/types/message_configure_minter_controller.go:4  x/tokenfactory/types/message_configure_minter.go:42  x/tokenfactory/types/message_mint.go:42  x/tokenfactory/types/message_pause.go:40  x/tokenfactory/types/message_remove_minter_controller.go:41  x/tokenfactory/types/message_remove_minter.go:41  x/tokenfactory/types/message_unblacklist.go:41  x/tokenfactory/types/message_unpause.go:40  x/tokenfactory/types/message_update_blacklister.go:41  x/tokenfactory/types/message_update_master_minter.go:41  x/tokenfactory/types/message_update_owner.go:41  x/tokenfactory/types/message_update_pauser.go:41", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Duplicated ValidateBasic invocation in CLI", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "CLI commands transaction All in registered x/tokenfactory/client/cli/tx.go call the msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI. As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI, this is an unnecessary and duplicated invocation. GetTxCmd function the in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. No matter whether the user supplies one or more entries with the duplicated denom in the asset_amounts array of either the try_mint or the try_receive_burn function, only the rst entry will be used, all others will be ignored. In the case of a duplicate native token, a user could send just one entry in the asset_amounts argument to the try_mint function, but there will be a duplicate in subtraction contracts/nebula-cluster/src/contract/handle.rs:478. When that calculated happens, in contract from contracts/nebula-penalty/src/contract.rs:134 will stay the same (since the imbalance just shifts to the right). The denominator in line 137 will get smaller though, which will lead to a higher minted token amount for the attacker. If the attacker immediately burns the cluster tokens, they can drain assets from the cluster. inventory amount penalty reward token from the the the the of assert_sent_native_token_balance in The not contracts/nebula-cluster/src/contract/handle.rs:464 prevent this issue since it checks the amount in every iteration, and not the sum of the amounts across all tokens with the same denom. does We classify this issue as minor since it is caused by a wrong parameterization which can only be changed during initialization, by governance or the composition oracle. Recommendation We recommend checking the assets argument in the init and try_reset_target functions for duplicates and returning an error if any duplicates are found. Status: Resolved 5. No validation of initial cluster target weight sum to equal 100", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nebula/Nebula - Audit Report.pdf", "body": "1. No matter whether the user supplies one or more entries with the duplicated denom in the asset_amounts array of either the try_mint or the try_receive_burn function, only the rst entry will be used, all others will be ignored. In the case of a duplicate native token, a user could send just one entry in the asset_amounts argument to the try_mint function, but there will be a duplicate in subtraction contracts/nebula-cluster/src/contract/handle.rs:478. When that calculated happens, in contract from contracts/nebula-penalty/src/contract.rs:134 will stay the same (since the imbalance just shifts to the right). The denominator in line 137 will get smaller though, which will lead to a higher minted token amount for the attacker. If the attacker immediately burns the cluster tokens, they can drain assets from the cluster. inventory amount penalty reward token from the the the the of assert_sent_native_token_balance in The not contracts/nebula-cluster/src/contract/handle.rs:464 prevent this issue since it checks the amount in every iteration, and not the sum of the amounts across all tokens with the same denom. does We classify this issue as minor since it is caused by a wrong parameterization which can only be changed during initialization, by governance or the composition oracle. Recommendation We recommend checking the assets argument in the init and try_reset_target functions for duplicates and returning an error if any duplicates are found. Status: Resolved 5. No validation of initial cluster target weight sum to equal 100", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Attacker can bypass self-call validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf", "body": "validate_msg_calculate_usage The in contracts/croncat-tasks/src/helpers.rs:88 does not properly validate the value of contract_addr for the WasmMsg::Execute message type. This value is partially the task cannot call any of the validated in check_for_self_calls, associated CronCat addresses, but it does not account for the edge case that one of these addresses can be provided as all uppercase letters. This is possible for WasmMsg::Execute task actions that don't include queries. to check that function For example an attacker can specify an all uppercase version of the manager contract address, and then pass an address to update the owner and take control of the manager contract. These messages will also not cause errors during the address validation by the underlying Cosmos SDK, which is triggered from the wasm modules MsgExecuteContract message validation. The WasmMsg will be routed by the wasm module and will undergo stateless function will check validation in the message's ValidateBasic function. This msg.Contract with the sdk.AccAddressFromBech32, which returns the type AccAddress []byte. It does not dierentiate if the supplied address is in uppercase or lowercase. They will both normalize to the same byte slice, as long as the chain prex has the same case. See Appendex A: Test 1 Case 2 for more detail. The following shows two Bech32 addresses that both evaluate to the same account address: 395441E922FCBDC6BEC9B76EAC2C7D647B50D66F cosmos1892yr6fzlj7ud0kfkah2ctrav3a4p4n060ze8f 395441E922FCBDC6BEC9B76EAC2C7D647B50D66F COSMOS1892YR6FZLJ7UD0KFKAH2CTRAV3A4P4N060ZE8F", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Task contracts execute_update_config is permissionless", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf", "body": "execute_update_config in The contracts/croncat-tasks/src/contract.rs:96 allows any caller to execute a cong update for the Tasks contract. This will allow an attacker to gain complete control over the Tasks contract by updating critical parameters, for example, setting themselves as the contract owner. function", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Agents can bypass task delegation mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf", "body": "execute_proxy_call in The contracts/croncat-manager/src/contract.rs:188-208 incorrectly assumes that when a calling agent supplies a task hash the task is event based. This will allow agents to bypass the task delegation logic and directly execute tasks on a rst come rst serve basis. function This is based on the assumption that agents are all behaving according to the client software. But an agent owner could modify the client software to game this system and prot from receiving a disproportionate amount of tasks. For example, a malicious agent client could query to nd out which slot tasks are executable, and then simply call execute_proxy_call with the task_hash to avoid the agent_task checks in line 217. On chains that support Skip, this could even become a MEV opportunity where agents would compete to get their bundle accepted and frontrun the normal task delegation logic. This would completely exclude other agents that are acting normally. A proof of concept for this attack is available i", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Unbounded iteration in the tax modules AnteHandler could be used by an attacker to slow down or halt the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/tax/keeper/taxdecorator.go:76-81, the ApplyTax function called from the tax modules AnteHandler is performing an unbounded iteration over the feeCoins provided by users. An attacker could craft a message with a signicant number of Coins with the intention of slowing down the block production, which in extreme cases may lead to Tendermints propose timeout to be surpassed. This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of peers hit the timeout and halt simultaneously, block production may stop. A test case is provided in Appendix 1.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. ValidateMinter does not guarantee that provided parameters are adherent to the dened minting schedule", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/mint/types/minter.go:43, the ValidateMinter function does not verify that the parameters passed on genesis are conformant with the equation that denes the minting schedule. There is a risk that one or more of them are not correct, which would lead to a awed minting schedule. Once this happens, there is no straightforward way to return to the intended trajectory. It is important to note, nevertheless, that there are checks to ensure that the total minted amount does not exceed a predened threshold.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Silently handled broken invariant could lead to inconsistent chain state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/mint/abci.go:41-44, during the calculation of the time interval between two subsequent blocks, the guard that checks that the timestamp of the current block is greater than the previous one does not panic or return an error. Instead, it assigns blocks with the same timestamp, letting the execution ow continue. Since the code should always enforce the invariant   >  0 incorrect subsequent block order or simultaneous blocks should result in an error and eventually halt the chain. We classify this as a minor issue since Tendermint is already enforcing this invariant.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. The feeCaps parameter is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/tax/types/params.go:103-113, the validateFeeCaps function that is invoked by ValidateBasic is not validating the feeCaps parameter. Instead, a TODO comment is present as a reminder to implement the validation logic. Consequently, every string value could be provided as feeCaps parameter.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Minting cap is not enforced during genesis", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "the In x/mint/types/minter.go:48, TotalMinted parameter is positive, but it does not validate that the value is less than the MintingCap. the ValidateMinter function ensures that This implies that during genesis, a TotalMinted parameter value that exceeds the MintingCap amount is accepted and stored.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. The FixedMintedAmount parameter value is incoherent with the documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/mint/types/minter.go:11, FixedMintedAmount is set implies that 0.0825% of the total amount of tokens is minted per year. to 103125 which However, implementation and could lead to an unintended minting schedule. the docs dene this number to be 0.08% which is incoherent with the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Royalty contract owners can steal royalty funds by changing the funds recipient address.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/royalty/src/contract.rs:126 i.e recipient The update_royalty() function allows updating address and royalty rate a NFT minter wishes to charge, However, this function can also called by the royalty contract owner who can provide recipient address of its convenience in the used calculating the recipient value at contracts/royalty/src/contract.rs:126. This would allow the contract owner to rug pull all the royalty funds of the NFT minters. royalty parameters, arguments function that can", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Bidding contract owners can abuse their authority to front-run threshold values leading to unfair auctions.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/bidding/src/contract.rs:82, 151 In English auctions, bid acceptance is directly proportional to the bid amount. By changing the threshold value during the auction phase using the update_config() function, the owner can decrease the threshold value such that his bid becomes the highest and overwrites the current highest bid using the place_bid() function. Even if the owner changes the threshold value during the auction without having any intention to gain an advantage, this still leads to unfair auctions as other participants may try to outbid the current highest bid compared to the previous threshold value.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Contract owner could steal funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-contract-queuing At - src/execute.rs:249 The refund() function can only be called by the queuing contract owner and that will allow them to remove all the CW20 tokens it holds without sending the NFT to the appropriate owner who puts their order in the queue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Whitelisting in queuing contract can be bypassed by directly queuering the storage contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-contract-queuing At - src/execute.rs:114 The queue() function checks for the whitelisted address at each stage, and allows only the whitelisted addresses to claim tokens in claim(). The logic that checks the whitelisting queries the info.sender contract directly. The contract can respond to the query with any whitelisted address.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Change of storage contract address may lead to loss of funds.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/storage.rs:80 execute_change_storage()changes the storage address. This may lead to loss of funds if the storage address for the given maker address already exists and the new code_id doesnt have the appropriate functions to claim assets out of it.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Cyclic dependencies are present in auction_house and royalty contracts that would break the initialization of the respective contracts.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/contract.rs:37, contracts/royalty/src/contract.rs:28 Instationation of the auction_house contract requires the address of the royalty contract whilst instantiation of the royalty contract requires the address of the auction_house contract. Because of this cyclic interdependency, it would not be possible to deploy both of the contracts with valid params.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. The non-atomic nature of the place_bid function may lead to locked funds.", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/storage/src/order.rs:208,209 contracts/bidding/src/contract.rs:99 To place a bid, a user needs to send funds to the storage contract rst and then call the place_bid() function of the bidding contract , which triggers the bidding_lock() function in the storage contract to lock funds. This is a 2-step process which may lead to locking of funds if the second transaction fails. To retrieve those funds users have to explicitly call the claim_assets()funciton. This process may introduce some inconsistencies and non-atomic behaviour may cause more gas consumption.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Incorrect nonce management", "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf", "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/contract.rs:194 Nonces can be passed as a parameter when calling the approve_order()function that makes no usage no nonce as it is controlled by the user itself. This will allow the replication of order and restrict adding as new order if the same nonce gets used.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Setup function can be used by anyone to take control of the gateway contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the Solidity contract contracts/src/AxelarGatewayMultisig.sol the setup function can be called multiple times by anyone, allowing an adversary to take over control of the key privileged roles. This is due to the function being externally callable and not protected by any pre-condition other than not being callable on the implementation contract directly. However, since the storage contract the proxy this guard does not prevent unauthorized invocations. is that of This issue also applies to contracts/src/AxelarGatewaySinglesig.sol (out of scope).", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Non-unique key for identifying voting topics implementations may lead to lost proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the Solidity contract contracts/src/AdminMultisigBase.sol function the hash of msg.data is used to identify proposal topics. This value is used as a key to store the topic in the eternal storage contract (key-value store). However, msg.data simply encodes functions and parameters, meaning that repeated proposal of the same operation will result in the key being calculated with the same result. In this case, the previous proposal would be overwritten in storage and lost. msg.data can also be malleable due to dierent libraries or wallets adding trailing zeros which could lead to key mismatch (see issue Manual storage management in upgradability pattern used is error-prone and may lead to storage key conicts).", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Gateway contract address depend on token symbol only and might clash", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "Token contracts and burner contracts are deployed using the create2 opcode, in order to deterministically calculate the addresses on both sides. Since the initialization code remains constant for all tokens the only distinguishing factor for dierent deployments is the salt used in the address calculation. To this end, the codebase uses the hash of the token symbol. Since the token symbol becomes the only identier of an asset, tokens with the same symbol will clash, resulting in the same contract address. Eectively, only 3 bytes of input are used to produce a 32-byte hash value. This may lead to accidental overwriting of assets.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Expired polls can be voted on", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the x/vote/types/types.go module, the Vote method lacks a check whether the poll has been expired, allowing expired polls to be voted on.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Manual storage management in upgradability pattern used is error-prone and may lead to storage key conicts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "The Solidity smart contracts use an eternal storage pattern using a hash of an identier key as a manual storage pointer.. This introduces a source of potential errors since keys with the same name result in the same hash causing storage to be overwritten. The reverse can also occur if the source of the key calculation may be encoded slightly dierently by o-chain libraries. An example of this occurring is the msg.data eld used as a key in contracts/src/AdminMultisigBase.sol. This eld may have trailing zeros, depending on the wallet implementation used to interact with the smart contract, resulting in dierent key calculations and failure to look up the correct entry.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. ExportGenesis should return the genesis state instead of nil", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the x/axelarnet module, the genesis export returns nil.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Panic used for non-eligible validators in ination calculation breaks iteration for the other eligible bonded validator", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "Function handleTssInflation in x/reward/abci.go uses panic during the bonded validator iteration when a validator is found to be not eligible. This will skip the other eligible bonded validators.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Single invalid key causes subsequent valid keys to be skipped when batch-registering external keys", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the RegisterExternalKeys function in x/tss/keeper/msg_server.go, the iteration skips valid keys when an invalid key is present in the slice by returning from the method when it nds any validation error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. RouteIBCTransfer is not considering all the valid chain entries in case of error during iteration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the x/axelarnet module message server function, the RouteIBCTransfers returns on encountering an error during iterations. This will cause the method to skip all other entries in the slice over which the iteration is performed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Permissionless trade execution allows for price manipulation and arbitrage opportunities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "In contracts/pf-dca/src/execute.rs:66-81, the try_perform_dca function is permissionless, introducing a number of risks. While the execution of a single transaction might pose a small risk, i.e. a loss of funds for users due to arbitrage opportunities for another users, a coordinated attack that uses a larger amount of scheduled transactions might have a severe impact by extending (or even creating) such arbitrage opportunities to a degree that they could become market manipulations and enable the attacker to buy/sell funds at large discounts/premia. First, an attacker could use a set of scheduled transactions to manipulate oracle spot prices or TWAPs by triggering them simultaneously in a low liquidity environment. Second, an attacker can always arbitrage the slippage of the scheduled transactions by placing an order in front and behind the target transaction  a so-called sandwich attack. As the attacker can send the PerformDca message themself, this gives them the ability to write scripts that optimize for such an attack, for example reverting in the case of an unforeseen event. Third, an attacker can combine the rst two attacks for an inverted sandwich attack: The attacker could use one set of transactions to manipulate some oracle price to sell their own asset at a higher price and use a second set of transactions to provide enough liquidity to sell at the manipulated price, irrespective of the slippage limit. In addition to arbitrage, the owner might be forced to execute additional DCAs that are ready for execution when planning to cash out by having their CancelDca transaction front-run. However, this scenario will cause a minor inconvenience to the user compared to the above. The potential impact of this issue could be considered critical. We classify it as major though since the likelihood of exploitation is low as it requires a subset of the following market conditions: High slippage tolerances or large amounts of scheduled transactions within a short period of time and/or an oracle to be manipulated.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Lack of validation of conguration parameters upon instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The pf-dca contract does not perform any validation on the conguration parameters set upon potentially causing issues that could render the contract unusable. in contracts/pf-dca/src/contract.rs:53-64, instantiation  destination_wallet address is not validated. An invalid address could cause any swap to fail as the message in line 138 will have an invalid recipient. In addition, the current implementation does not follow the documentation that states the destination wallet should default to the senders address.  source_denom is not validated. A wrong letter case of a denom or a denom that does in contracts/pf-dca/src/execute.rs:104-108 to fail, potentially leaving the amount to be swapped sitting idle in the contract. swap message exist will dened related cause not the  The destinations vector can be empty or the denoms not sanitized. This will lead to either no swaps happening at all or swaps failing.  max_slippage can be any Decimal number, even outside of the 0-100 range leading to potential inconsistencies. In addition, a high slippage is not recommended as it will allow for arbitrage opportunities as the ones described at Permissionless trade execution allows for price manipulation and arbitrage opportunities.  router_contract address is not validated, which would cause all swaps to fail if an invalid address is provided.  swap_interval can be set to zero, eectively allowing users to trigger all the swaps at once. We classify this issue as major given that none of the above parameters can be updated once the contract is deployed, which means that any of these errors require a new deployment.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. DCA end not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The pf-dca contract does not enforce the congurations num_trades limit on the number of trades performed in contracts/pf-dca/src/execute.rs:66-121. This allows users to keep using the PerformDca message for as long as the contract has enough funds to perform additional swaps. Although not implying a security risk per se, the actual implementation diers from the implied behavior and STATE.num_trades_executed, which are not used otherwise. DcaConfig.num_trades existence the by of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. DCA execution might run out of gas if too many destinations are congured", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "the iterations performed over In contracts/pf-dca/src/execute.rs:83-86, destinations might run out of gas if too many destinations are congured. As a consequence, trade execution might fail permanently. In that case, the only way to recover the assets in the contract is the cancellation of the whole DCA.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Rounding issues on swap message creation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The pf-dca contract allows swapping into multiple destination denoms, distributing the total amount using their assigned weight. The calculation of the nal amount to be traded to each denom is done in contracts/pf-dca/src/execute.rs:92-100. The division by total_weight is an integer division, leaving any remainder to stay idle in the contract until the user decides to cancel the DCA. This corresponds to rounding down/using the oor function. A proof of concept unit test can be found in the Appendix: Rounding issues on swap message creation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Users assets can get stuck in the DCA contract until cancelation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "pf-dca are The contracts/pf-dca/src/contract.rs:45 to satisfy that all trades contract enough checks assets only if sent   in along can be funded with the correct amount should satisfy   =   *   per trade. The documentation states that the total amount     such that it is required that the user submits the correct amount of funds. However, the code allows initializing contract with      *  , creating a possibility for  users to lock up excessive amounts of funds accidentally. The only way for the user to receive those funds back is to cancel the whole strategy, which would then require them to re-instantiate to resume the strategy with the correct amount of assets. In addition, when the swaps for a given asset fail, the remaining not swapped assets are left in the contract with no way for the user to either claim them or retry the swap. This may lead to frozen funds accumulating in the contract, unusable by the user until cancellation of the strategy.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Coarse-grained authorization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "pf-dca in The contracts/pf-dca/src/helpers.rs:7 does not follow best practices for authorization since it combines two separate entities into one layer of privileges by giving access to privileged functionality to both owner and destination_wallet. verify_sender contracts function For example, if the owner tries to pause the contract in order to stop the money ow into the destination_wallet, the destination_wallet can revert this action by unpausing the contract. The only way for the owner to prevent this is to cancel the DCA. In the future, when further functionality is added, this may lead to an overly privileged party with unintended consequences.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Commented code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The contracts within the scope of this audit include commented code. Although not a security issue, commented code indicates that the codebase may not yet be ready for release and may negatively aect readability and maintainability. The following instances were found:  contracts/pf-dca/src/state.rs:5-29  packages/phase-finance/src/msg.rs:45-50 In addition, language potentially harmful contracts/pf-dca/src/tests.rs:135 packages/phase-finance/src/constant.rs:1. to the clients reputation was found in and", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Ineective resume and pause operations allowed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "pf-dca in The contracts/pf-dca/src/execute.rs:34 and 46 do not check if the contract is actually paused or not. resume_dca pause_dca contracts functions and Although not a security issue, pausing or unpausing a contract that is not already in that state will just spend gas without actually changing the contracts state.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The following contract and package do not enable overflow-checks for the release prole:  contracts/pf-dca/Cargo.toml  packages/phase-finance/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Unnecessary panics negatively aect usability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "In contracts/pf-dca/src/helpers.rs, the conversion from string to Uint128 is assuming valid data due to the ltering of anything dierent than numbers. There are two cases that are unhandled though:  Empty strings (when token_string is not starting with number)  Numbers that are too big to parse Those cases cause the function to panic, negatively aecting the user experience compared to error messages.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attackers can drain relayer funds and hence DoS the bridge by spamming create_agent transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "parachain/pallets/control/src/lib.rs:128-161, In create_agent extrinsic creates a CreateAgent message and adds it to a queue for eventual commitment. This allows it to be selected and sent by a relayer to the Ethereum Gateway contract. the For each such message, the relayer is expected to execute the submit function of the in order to process the CreateAgent Command. This requires the Gateway contract relayer to pay the gas to instantiate a new Agent contract. Since the create_agent extrinsic can be sent permissionlessly by anyone, a potential vulnerability arises where an attacker could create a large number of accounts and spam the network with create_agent messages while only bearing the relatively low fees of the create_agent extrinsic dened by its weights. This would cause the queue to be loaded with CreateAgent messages and, since their execution could be relatively expensive for the relayer, relayers may run out of funds or cease operations in anticipation of high costs. This results in a denial-of-service (DoS) of the channel due to its ordered nature. In order to execute any message, all the other messages before it need to be executed. If the cost of executing all the previous messages is not economically feasible for relayers, the channel is stuck and messages are not relayed anymore.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attackers can drain sovereign funds and hence DoS the bridge by spamming registerToken transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In contracts/src/Gateway.sol:418-424, users to register a new asset on Asset Hub. the registerToken function enables However, the Asset Hub create extrinsic mandates a deposit of 10 DOT when creating a new at documentation https://wiki.polkadot.network/docs/learn-assets#creation-and-management. detailed asset, found the as in Consequently, every execution of contract necessitates the sovereign account to perform a 10 DOT deposit to the Asset Hub. the registerToken function within the Gateway Given that the origin is not covering this fee, there exists the potential for malicious actors to exploit this process. Attackers could spam the network with registerToken messages to exhaust sovereign account's funds, eectively implying a denial-of-service (DoS) attack of the channel. In fact, since channels are ordered by the nonce, to execute any message, all the other messages before it need to be executed. If the cost of executing all the previous messages is not economically viable, the channel could be stuck and messages will not be relayed anymore.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. submit extrinsic always returns Ok, causing stuck funds in the Agent contract in case of errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "parachain/pallets/inbound-queue/src/lib.rs:206-241, In function returns Ok regardless of whether errors occur during its execution. the submit This potential oversight poses the risk of funds becoming stuck on the Ethereum Agent contract in case an error emerges during the SendToken Command process on the Polkadot side. transfers tokens from Ethereum, the If a user corresponding Agent contract. Retrieving these funds requires the user to possess the bridged tokens on a Polkadot chain and bridge them through the Bridge Hub and the outbound-queue pallet. If an error occurs during the submit function, no bridged tokens will be minted on the Polkadot side. Without those bridged tokens, the locked funds will be unrecoverably stuck in the Ethereum Agent contract, resulting in a loss for the user. they are transferred to the escrow of", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Administrative Commands are not implemented on Polkadot side", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "After analyzing the code included in the scope of the audit, it was found that in the case of the outbound-queue palette, core Commands were not implemented, making it impossible to actively manage the bridge. This includes Commands such as:  CreateChannel  UpdateChannel  SetOperatingMode  TransferNativeFromAgent It is worth noting that the codebase submitted for this audit contains implementations for these commands on the Ethereum side. We report this issue as major instead of critical since none of the missing Commands present an immediate security threat. However, the repercussions could be signicant, leading to the inability to manage the bridge and limiting its functionality.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Throttling mechanism could delay critical governance operations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "parachain/pallets/outbound-queue/src/lib.rs:351-375, a the queue is implemented in order to bound the execution of throttling the In mechanism for on_finalize function. This throttling mechanism limits the number of messages retrieved per block from the outbound-queue pallet to a maximum of MaxMessagesPerBlock messages. Consequently, the processing of messages could be delayed depending on the number of messages in the queue of the outbound-queue pallet, but also depending on the number of other pallets interacting with their queues since the message-queue pallet selects autonomously each block which client pallet to serve and there is no guarantee that the outbound-queue is selected. This could potentially cause delays in the execution of important commands like SetOperatingMode or Upgrade that should be dispatched in a timely manner in order to address malfunctioning or exploits of the bridge. For instance, an attacker could exploit CreateAgent commands to saturate the queue. this by enqueuing a substantial number of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Unrestricted Agent funds transfer via transferNativeFromAgent command", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In contracts/src/Gateway.sol:400-412, function enables agents to transfer any number of restriction on the originating channel. the transferNativeFromAgent funds from any agent, without any This implies that a user creating an agent could potentially exploit this message to steal all funds within the channel. While there is currently no way to call transferNativeFromAgent, we report this issue with major severity since it could have critical consequences if not addressed properly.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Multiple attempts of random value draw through replicated ticket submissions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In contracts/src/BeefyClient.sol:231-290, attackers could exploit the light client by initiating multiple ticket submissions to obtain a favorable random value from prevRandao. This could be accomplished through the replication of actions such as submitInitial or submitInitialWithHandover and commitPrevRandao. ticket, Although a safeguard in line 272 disallows the invocation of commitPrevRandao for the or same submitInitialWithHandover to generate a new ticket to attempt to draw a favorable ticket. submitInitial attackers remains feasible use for to it", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Corrupted messages in the queue are skipped, leading to stuck funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In parachain/pallets/outbound-queue/src/lib.rs:270-274, the execution of do_process_message is initiated by the message-queue pallet to handle messages. In line 272, the message is parsed, and if it fails, the ProcessMessageError::Corrupt error to permanently discard the message. This outcome can lead to a situation where tokens have already been burned in Asset Hub, and the discarded message results in the corresponding tokens on Ethereum being indenitely stuck in the Agent contract. is returned. This error subsequently prompts the message-queue pallet Moreover, having corrupted messages in the queue means that the state is corrupted and actions should be taken in order to protect user funds, for example pausing pallet operations.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. The outbound queue continues processing messages even if PalletOperatingMode is Halted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In the parachain/pallets/outbound-queue/src/lib.rs:351-374, process_message function lacks a validation step for the PalletOperatingMode status. While it is not possible to submit new messages while PalletOperatingMode is Halted, existing messages already in the queue (which could hold a signicant number of messages) can be further processed. In the event of an emergency situation this would result in messages continuing to be relayed even after governance halts operations.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Implementation of the generalized_index_bit function diers from the specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "the parachain/primitives/beacon/src/merkle_proof.rs:44, In generalized_index_bit function implementation diers from the specication given in https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#get_generaliz ed_index_bit. Because of this, the generated merkle_root is not compliant with the specication.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "11. Partial update may temporarily stall the bridge", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "During the execution of the submit extrinsic of the ethereum-beacon-client pallet, the in verify_update parachain/pallets/ethereum-beacon-client/src/lib.rs:362-482 is invoked to validate the provided update. function dened However, next_sync_committee_update, no error is raised, where the light client reference period is not updated. if the update includes a header from the next period but does not provide the leading to a partial state update it becomes impossible to update the light client state due to the period Consequently, mismatch, causing all the subsequent calls to the submit extrinsic to return an error and halting bridge operations until governance forces a new checkpoint. This issue has been found by the client after the audit report has been published, but has been reviewed by our team and added to this report for completeness.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "12. Risk of token loss and channel immobilization after Gateway contract upgrade", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In contracts/src/Gateway.sol:367-373, during the course of upgrade function execution, governance has the capability to execute the initialize function providing a new set of initParams as input. However, since the initialize function creates two new agents for Bridge Hub and Asset Hub that will overwrite the addresses of existing ones, this process inadvertently results in the inaccessibility of tokens bridged by these agents, leading to an irreversible loss. Moreover, channels, as the initialization process also resets the nonce to zero. it has the unintended consequence of indenitely immobilizing the associated We classify this issue as minor since it can only be caused through governance.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Malicious ERC-20 contracts could be used to mislead users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "Due to the ability to permissionlessly bridge arbitrary tokens from Ethereum to Polkadot, attackers could create malicious ERC-20 token contracts that do not actually put tokens into escrow on Ethereum and use this mechanism to mislead users. This can be achieved through the logic in contracts/src/utils/SafeTransfer.sol:13-21. An attacker could implement a contract featuring a TransferFrom function that consistently yields true results. Using this contract, they could execute the registerToken function and subsequently invoke sendTokens to facilitate a successful execution. This process would lead to event emission, command relay, and token creation on the bridge without the necessity of holding funds in the Ethereum agent's escrow. Attackers could use this behavior to pursue phishing campaigns or otherwise mislead users by using tokens not redeemable on Ethereum.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Updates of the Gateway address in the inbound-queue pallet would result in a stuck bridge", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In parachain/pallets/inbound-queue/src/lib.rs:243-249, the set_gateway extrinsic enables governance to update the Gateway Ethereum contract address. since the However, GlobalConsensusEthereumAccountConvertsFor, updating it would cause the pallet to not be able to control funds on Asset Hub anymore. Gateway compute address used the to is Furthermore, messages already in the queue would retain data tied to the old gateway address, rendering their processing impossible. Consequently, advancing the nonce becomes unachievable, eectively causing the bridge to become non-operational. We classify this issue as minor since it can only be caused through governance.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Missing mechanism for excessive fee reimbursement", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In contracts/src/Gateway.sol:466-485, while executing the _submitOutbound function, verication is conducted in line 474 to ensure that the user has sent an adequate amount of ETH to cover the required fees. However, the current implementation lacks a mechanism for reimbursing users who have sent an excessive amount of fees. Consequently, any surplus funds sent to this contract will be stuck in the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Misleading query output for non-existent channels", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "in the event of a non-existent channel In contracts/src/Gateway.sol:196-204, provided as input, the channelNoncesOf and channelFeeRewardOf functions will always return a misleading (0,0) tuple, which does not accurately represent store values due to the channel's absence.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Missing validations in Gateway contracts constructor", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In contracts/src/Gateway.sol:74-93, while executing the Gateway constructor, there is no validation to ensure that ASSET_HUB_AGENT_ID and BRIDGE_HUB_AGENT_ID are distinct. Similarly, ASSET_HUB_PARA_ID and BRIDGE_HUB_PARA_ID are not validated to not be equal. This validation is essential instantiate, wherein the bridge hub data could overwrite the asset hub data. to prevent potential conicts during the execution of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. XCM transfers are subject to limitations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In parachain/primitives/router/src/outbound/mod.rs:38 the validate function is employed to check XCM messages originating from the Asset Hub parachain. translates XCM instructions to AgentExecuteCommand and, It generates a new ticket for the OutboundQueue. if validation passes, However, not all valid XCM scripts pass this validation due to their fee execution handling. In 215-228, the fee_info function identies expected fees from XCM instructions. Specically:  A combination of WithdrawAsset and BuyExecution indicates the message's origin intends to pay the fees.  The UnpaidExecution instruction signies the origin anticipates zero-cost execution. lines 111-114 reject XCM messages from origins willing to pay the fee. This is Yet, inconsistent since both fee payment scenarios should be viable, especially given the assumption that Asset Hub transfers utilize the bridge-transfer pallet.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Message replay attack possible after u64::MAX messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In parachain/pallets/inbound-queue/src/lib.rs:192-200, increment overows after u64::MAX messages. the nonce value Consequently, after u64::MAX messages, previous messages. it will be possible to replay in sequence all We classify this issue as minor since it is very costly to execute u64::MAX messages.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "20. Hard-coded gas usage can make the Ethereum side of the bridge unusable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In contracts/src/Gateway:29, a static value known as DISPATCH_GAS is employed for executing smart contract calls within the Gateway contract. However, it is possible that introduction of Ethereum Ethereums gas model changes over time due to the continual Improvement Proposals (EIPs) that alter the gas consumption of opcodes. This introduces a risk wherein certain function call executions within the Gateway contract may become infeasible if the gas required surpasses the sum of DISPATCH_GAS and BUFFER_GAS. In such cases, transactions would revert, thereby rendering core operations like upgrades or the creation of agents impossible. the upgrade function call, since the logic contract's This is most problematic for initialize function denition, which plays a pivotal role in the upgrade process, is not predetermined. This lack of predictability can lead to a situation where the upgrade function reverts if an insucient gas value is provided. Consequently, determining the precise value for DISPATCH_GAS becomes an exceedingly challenging endeavor.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "21. Excessive gas usage in corner cases", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "Within contracts/src/Gateway.sol:99-181, the submitInbound Solidity function behaves as follows: 1. Validate the channel from the originating parachain. 2. Verify the message proof. 3. Conrm the header commitment. 4. Validate the nonce and increment it. 5. Reward the relayer. 6. Check the remaining gas. 7. Dispatch the message. 8. Emit an event for completion. Steps 2 and 3 are resource-intensive, consuming signicant gas. Meanwhile, steps 4 and 5 are signicantly less resource demanding. If an erroneous nonce is submitted by a relayer, or the agent lacks sucient funds for rewarding the relayer, the function reverts, wasting the computation from steps 2 and 3.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "22. Change in function order or indexes during parachain upgrades could lead to execution of wrong functions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf", "body": "In contracts/src/Assets.sol:108, the param createTokenCallID is designated as the reference for the execution of a specic function on the parachain side. However, it is the indices associated with functions may change during the course of possible that parachain pallet upgrades. This can occur when developers of the pallets fail to employ the call_index attribute for dispatchables or neglect to maintain consistent call indices across various upgrades. As a consequence, the Snowbridge implementation might inadvertently trigger a dissimilar dispatchable function on the predened index if it does not adapt its bridge settings to align with the evolving codebase of the parachain.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. payout function may panic due to lack of fee and royalty validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "The payout function in contracts/marketplace/src/execute.rs:890-946 handles the distribution of funds when a sale is being nalized. There are a number of parties that may be paid during the sale of an NFT, such as the seller, nder, artist, and the network. Each of these parties has a dened percentage they receive which is dened in various conguration parameters. The payout function does properly validate that the sum of each of these payment parameters is not greater than 100%. finders_fee, network_fee, and royalty.share should be validated to ensure that their sum is not greater than the payment. The amounts of seller_share_msg, royalty, finders_fee, and network_fee are all independently calculated o of the original payment value with no respect to their sum. An example of a situation that would cause a panic is if a certain collection had an abnormally high royalty.share. For example, let's say the royalty.share is 95%. The subtraction of   royalty.share, network_fee, and finders_fee in line 931 would be greater than the original payment and cause a panic due to an underow (the workspace has overflow-checks enabled, which causes underows to panic).", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Misconguring stale bid duration causes operators to be unable to remove stale bids", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "the contract instantiation During in contracts/marketplace/src/execute.rs:49, msg.stale_bid_duration is not validated to have the input cast as Duration::Time, which is inconsistent with updating of parameters in contracts/marketplace/src/sudo.rs:96-98. As a result, a misconguration of initializing the stale bid duration as Duration::Height would cause the execution to fail in lines 745 and 796 because the Duration enum does not allow addition of time and height. execution message process during sudo", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Bidder can specify unchecked nders fee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "and execute_accept_collection_bid lines execute_accept_bid the contracts/marketplace/src/execute.rs:513 bid.finders_fee_bps if there is no existing ask when a seller accepts a bid. This is problematic because nothing stops a bidder from specifying a very high value. While the nder's fee would still go to the sellers specied nder, it may be a proportion that is higher than the seller expected. in use and When creating an ask, params.max_finders_fee_percent, but mentioned above. the nders fee is validated to ensure that this check doesnt occur it is less than in the cases Example: 1. A user creates a bid with a very high nders fee of 90% (high but not enough to error). They would need to create a bid on an NFT that doesnt currently have an ask. 2. Owner would accept the bid 3. 4. The sellers specied nder would get nearly all of the value from the NFT sale, and If there is no ask, then bid.finders_fee_bps is used the seller would not. It is important to note that the caller still species the nder's address when accepting a bid. If this nder value was also pulled from the bid, this would be a critical issue allowing bidders to pay virtually nothing for NFTs.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Percentage and basis point values lack maximum value validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "contracts/marketplace/src/execute.rs:47 of In max_finders_fee_percent and bid_removal_reward_percent are converted to Decimal::percent values but are not checked to ensure that they do not exceed 100%. If it would be harmful to the either of these values were to be set to greater than 100%, protocol. It is best practice to enforce a hard limit on percent values. values and 50, the During the payout calculation, the nders fee could be greater than 100% which will cause the calculations to underow, but this would panic because of enable overflow-checks. Additionally, in execute_remove_stale_bid, a bid_removal_reward_percent greater than 100% would result in a reward greater than the value of the original bid. is situation in This also contracts/marketplace/src/sudo.rs:58. trading_fee_percent, max_finders_fee_percent, and bid_removal_reward_bps should all be validated to ensure that they are not greater than 100%. sudo_update_params function present the in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Sellers can update the price for inactive ask requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "execute_update_ask_price in The contracts/marketplace/src/execute.rs:306 allows the seller to update their NFT asking price without validating whether the associated ask request is expired or inactive. This might cause a misconception to the seller that their ask request is still valid and available for bidders to bid, which may not be true. functionality", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Bidders may set themselves as nder and receive nders fee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "the execute_set_bid in In contracts/marketplace/src/execute.rs:334, when a bid is placed on an NFT with a FixedPrice auction, the nder is specied by the set_bid caller. That nder is then passed to the finalize_sale function and in the payout function, the address is then paid the nders fee. This function does contain any logic to verify that the nder address specied is not info.sender. This means that the function does not prevent bidders from specifying themselves as the nder and receiving the illegitimate nder fee. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Existing operators will be overwritten", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "sudo_update_params The in contracts/marketplace/src/sudo.rs:86-88 does not incrementally add operators, instead, it will overwrite the existing vector with the new operators. This may become problematic as the number of operators grows. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. A large number of hooks may cause out of gas errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "The sudo_add_sale_hook, sudo_add_ask_hook, and sudo_add_bid_hook functions in contracts/marketplace/src/sudo.rs do not impose a maximum number of hooks that may be added. As the marketplace scales, the number of hooks may begin to grow and cause out-of-gas errors. Note that this is recoverable because the contract contains hook removal functionality. It is best practice to impose a maximum number of hooks as they increase the gas cost of the call.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Release candidate dependencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "contract/marketplace/Cargo.toml:36-37, In cosmwasm-storage crates are specied at a release candidate version. the cosmwasm-std and As rc software is by convention still in development we suggest not using it in production.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. reserved_for should only be used when the sale type is not an auction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "When bidders attempt to bid on an existing ask request via   execute_set_bid functionality, the reserved_for value would be validated to ensure only the seller specied bidder can seen bid in asked contracts/marketplace/src/execute.rs:378-382. While this functionality is intended for sellers to reserve the sales for a specic bidder, it would defeat the purpose of the auction if the sales type is not xed price. request the on as", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. map_validate does not ensure the address vector is deduplicated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "The map_validate function in contracts/marketplace/src/helpers.rs:28-33 does not ensure that the provided vector of addresses is deduplicated, which is inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "there While level, checks contracts/marketplace/Cargo.toml does not explicitly enable overflow-checks for the release prole. workspace overow are the at While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Potentially unexpected hook behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf", "body": "There are several scenarios throughout the marketplace contract where actions may be performed without triggering the expected hooks. While this is not inherently a vulnerability, it may lead to unintended consequences if these scenarios are not explicitly considered when implementing hooks. For example, a seller can call SetAsk multiple times to eectively update/overwrite their current ask. This will trigger the HookAction::Create hook multiple times, but not the HookAction::Delete hook, which may be unexpected. The same issue is also found when setting bids.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attackers can perform an inexpensive DoS attack by spamming Deposit transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf", "body": "In x/gov/keeper/deposit.go:166-180, the functions RefundAndDeleteDeposits and DeleteAndBurnDeposits are invoked within the EndBlocker function of the gov module. However, since these functions perform unbounded loops through all Deposits associated with proposals that have expired, an attacker could create a large number of accounts and send from each of them a Deposit transaction to attack the mentioned unbounded iteration and perform a DoS attack on the chain. Even worse, an attacker could send Deposit transactions containing more than one Coin. In such cases, the SendCoinsFromModuleToAccount function would be triggered to iterate through all the Coins for each Deposit item retrieved from storage. Note that the gas cost associated with a Deposit transaction can be as low as the minimum gas price a validator congures multiplied by the provided gas. In the case of the Cosmos Hub the recommended gas price is 0.0025 uATOM and the associated transaction gas cost is 0.00039705 ATOM. Attackers might opt for depositing 0uatom or utilize worthless coins generated through a tokenfactory module, while paying only 397.05 ATOM on the Cosmos Hub for gas to execute 1,000,000 transactions and generate an equivalent number of Deposit records. This is exacerbated by the fact that the deposit functionality does not prevent deposit amounts of 0uatom. This attack might be even cheaper on other Cosmos SDK chains, depending on the congured minimum gas price and the value of the native coin. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the chain to slow down or, in the worst case, even halt. A test case showcasing this issue is provided in the Appendix 1.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attackers can steal funds using the tip postHandler", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf", "body": "In x/auth/posthandler/tips.go:39-58, specify a tipper account that pays a tip to the feePayer. the tip Posthandler allows users to However, since there is no validation on who can charge the tipper, an attacker could specify any tipper account to the feePayer. funds from them that are sent in order to steal", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Attackers can perform an inexpensive DoS attack by spamming Grant transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf", "body": "In x/authz/keeper/keeper.go:378-403, the DequeueAndDeleteExpiredGrants function is executed during the authz module's EndBlocker function to remove all expired grants from the store. However, to do so, an iteration occurs over all the expired grants in the GrantQueue, and for each of the retrieved GrantQueueItems, another iteration takes place over all the items in the associated MsgTypeUrls slice. Note that the gas cost associated with a Grant transaction can be as low as the minimum gas price a validator congures multiplied by the provided gas. In the case of the Cosmos Hub the recommended gas price is 0.0025 uATOM and the associated transaction gas cost is 0.00017513 ATOM. Attackers might pay only 175.13 ATOM on the Cosmos Hub for gas to execute 1,000,000 transactions and generate an equivalent number of Grant records. This is exacerbated by the fact that attackers can target a specic block to execute all the iterations by specifying the expiration parameter in the Grant. This attack might be even cheaper on other Cosmos SDK chains, depending on the congured minimum gas price and the value of the native coin. If such an attack is executed, the EndBlocker function can consume a signicant time and resources causing the chain to slow down or, in the worst case, even halt.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. The postHandler is called with a context that does not embed transaction updates and the current mode", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf", "body": "In baseapp/baseapp.go:735-760, within the runTx function, the postHandler is invoked following the execution of messages performed by the runMsgCtx. if However, the provided mode does not align with either runTxModeDeliver or runTxModeSimulate, the postHandler is executed solely with the updates from the the scenario introduces a potential error anteHandler. This postHandler contains logic that relies on the updated state, which is its intended purpose. risk, especially if For instance, the tip postHandler may encounter diculties in verifying whether the in coins tipper from x/auth/posthandler/tips.go:39-58 runTxModeDeliver. facilitate mode possesses sucient dierent transfer the is the to if", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. The PrepareProposal function could silently fail due to deferred panic handling", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf", "body": "In baseapp/abci.go:275-286, the PrepareProposal function includes a deferred function returning handle abci.ResponsePrepareProposal{Txs: req.Txs}. designed panics and to This mechanism leads to the execution of transactions even if the PrepareProposal function panics. If a panic occurs within the prepareProposal handler, it typically indicates a broken invariant, and allowing the proposer to proceed with sending transactions in the order specied by the CometBFTs mempool could be problematic. for Consider, instance, a blockchain where security relies on the execution order of transactions or on Blockbusters lanes to prioritize specic types of messages. In such a scenario, the presence of this deferred function could potentially compromise the security and integrity of the protocol.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. PrepareProposalHandler does not adhere to ABCI++ interface specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf", "body": "In the PrepareProposalHandler function in baseapp/baseapp.go:957, if there is no mempool set for the DefaultProposalHandler, then the function will simply return the req.Txs specied in the request. This is problematic as it may potentially return a list of transactions that exceeds RequestPrepareProposal.max_tx_bytes. Additionally, the function will also return an unchecked list of transactions if the defer function is triggered by a panic in the PrepareProposal function. In both cases, it will directly return the req.Txs without checking that the list does not exceed the maximum bytes limit. This does not adhere to the CometBFT specication: CometBFT MAY include a list of transactions in RequestPrepareProposal.txs whose total size the size of in bytes exceeds RequestPrepareProposal.max_tx_bytes. Therefore, the RequestPrepareProposal.txs is greater the MUST Application RequestPrepareProposal.max_tx_bytes limit is respected by those transactions returned in ResponsePrepareProposal.txs . than RequestPrepareProposal.max_tx_bytes, transactions remove ensure that to if", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Acknowledged 16. Lack of role-based access controls for the pausing mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Ninja Blaze/2024-05-06 Audit Report - Ninja Blaze Double v1.0.pdf", "body": "The codebase implements a pausing mechanism, which is in line with best practices. However, all of the contract's administrative functions are centralized in the admin role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that might be managed by a multisig or a governance contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. The staking contract is not able to mint or burn coins", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "BlockBeforeSend in The message, contracts/periphery/staking/src/contract.rs:229, the Osmosis chain when sending tokens through the Bank module, and it is used by the protocol to execute custom logic to map tokens to the recipient during a send operation. executed by dened Sudo is This hook is implemented under the assumption that it is not executed when minting or burning tokens. assumption does not hold, however, This the SendCoinsFromModuleToAccount function here which calls SendCoins here, which implies that the BlockBeforeSend hook is executed even during mint and burn operations. since the mint operation calls Since from is the address of the tokenfactory module, an error will occur in line 243 when trying to decrease its zero balance. This makes the contract unusable. Please see the test_mint test case to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Total voting power does not account for the changes in the builder unlock contract and funds in the IBC outbound contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "calc_total_voting_power_at The contracts/periphery/gov/src/contract.rs:1059 calculates power at a certain height. function dened in the total voting To do so, it fetches the total supply from the staking contract, the number of coins locked in the builders unlock schedule, and the voting power at the proposals submission. This leads to an incorrect voting power because the tokens returned by the builder unlock contracts BuilderUnlockQueryMsg::State query can be inuenced by new allocations and user withdrawals. Additionally, it does not account for funds in the IBC outbound contract, leading to a wrong total voting power calculation. Consequently, the proposals' quorum and results are not correctly computed.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Proposal voting results can be manipulated through ash loans and builder unlock allocations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "The governance contract accounts for multiple voting sources to determine the outcome of a proposal. However, some of these sources allow attackers to inate their voting power by taking a ash loan, allowing them to execute governance attacks. be can inated The voting power calculated from the tokens staked in the voting-power-outbound contract in contracts/periphery/gov/src/contract.rs:1041-1046 reects the amount on the same block instead of a previous block. An attacker could request a ash loan, Lock a large number of tokens in the voting-power-outbound contract, CastVote in the governance contract, Unlock the tokens from voting-power-outbound, and nally repay the ash loan. Following these steps, they could manipulate the result of any proposal in their favor by paying only the ash loan fee. queried data the as the builders unlock contract determines the users voting power using the Additionally, BuilderUnlockQueryMsg::Allocation query in line 1029. This is problematic because a user can vote on the proposal, call ProposeNewReceiver to transfer the receivers address to another controlled address, call ClaimReceiver, and nally vote on the same proposal again to manipulate the outcome of the poll.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. First depositor can be front-run for unfair prot causing direct losses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "The staking contract does not prevent the rst depositor from being front-run to eectively get fewer shares than planned, from which the attacker will prot. a user the number of In contracts/periphery/staking/src/contract.rs:112-118, shares and received_tokens. However, if a malicious depositor makes a large enough donation to the vault at the right time, increasing total_deposit, the next depositor will not receive their expected amount of shares. on total_shares, total_deposit, depends receives The below describes a potential exploit scenario that could be followed by an attacker Mallory to take advantage of a victim Alice: 1. Upon identifying that Alice is trying to make the rst deposit of x tokens into the staking contract, Mallory front-runs their transaction with two calls: a. Making a minimal initial deposit, let's say 1 token, to obtain one unit of shares and setting total_shares to one. b. Donating x/2 tokens to the contract, increasing the total_deposit value without increasing total_shares. 2. Alices transaction gets executed containing the ExecuteMsg::Enter message, expecting to receive x amount of shares. As their deposit is just 1 token below the amount required to get 2 shares, only 1 share will be rewarded. 3. As a result, total_deposit would be equal to 1 + 3x/2, and total_shares would be 2. Making each share worth 1/2 + 3x/4 tokens. 4. Mallory will then be able to return the share to get 1/2 + 3x/4 tokens after having spent just 1 + x/2 tokens, eectively proting x/4 - 1/2 tokens. Note that this issue is only exploitable at the beginning of the contracts lifecycle and only aects the rst user making the deposit. However, as the potential loss of funds can be substantial, we classify it as critical.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Incorrect total shares determination", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "In contracts/periphery/staking/src/contract.rs:104, the total shares of xtoken are determined via the contract balance. This is problematic because it should be determined by the total supply using the Supply bank query instead of the Balance query. Consequently, if the total supply is dierent from the contract balance, the minted amount will be incorrectly larger than intended, allowing users to withdraw more funds from the protocol and ultimately causing a loss of funds for legitimate stakers.", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Replaying Proliferate message inates total voting power", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "users voting In contracts/periphery/voting_power_inbound/src/contract.rs:307-311, the the FOREIGN_VOTING_POWER_TOTALS storage state is increased. However, here is no mechanism in place that prevents voters from replaying the Proliferate message to increase the total voting power. voting power updated, power total and the in is Consequently, malicious users can inate the total voting power such that it is impossible to reach the quorum during a governance proposal.", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Removal of channels automatically removes the associating port and connection identier", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "a channel When contracts/periphery/voting_power_inbound/src/contract.rs:122-140 and contracts/periphery/voting_power_outbound/src/contract.rs:226-244, it simultaneously removes the associated port ID and connection ID from their allow lists. removed from ID is Since one connection can have multiple channels, a malicious channel that got removed will automatically remove the associated connection ID, causing future channels to fail to establish a connection. Additionally, most of the time, port identiers are common across multiple chains due to the module name (e.g., transfer). If a malicious channel uses a common port name and is removed, any future channels that intend to use the same port identier will fail to be established. To recover from this situation, a governance proposal needs to be passed to congure and add new connections and port identiers, which is time-consuming and requires governance participation. We classify this issue as major because it aects the correct functioning of the system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. On-going proposals are rejected after removal of IBC channel", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "The governance contracts end_proposal function checks that the current power sources include the set of started in contracts/periphery/gov/src/contract.rs:530-536. that were present when the proposal sources is to purge potentially malicious channels from aecting Although this features goal governance, it has the consequence that the proposal is automatically rejected if any of the initial power sources have been removed, even if no votes from the removed channel have been submitted to the proposal.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Emergency governance proposal passes as long as quorum is reached", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "contracts/periphery/gov/src/contract.rs:436-439, In emergency governance proposal is counted as passed if the quorum is reached, irrespective of whether the votes are in favor of or against the proposal. the For example, assume a malicious voter submits a proposal that attempts to remove a legitimate IBC channel. The majority of voters disagree and submit against votes so the channel would not be removed. However, since the emergency proposal will pass, as long the quorum is reached, the legitimate IBC channel will be removed eventually.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Updating the last update timestamp when creating schedules might cause unissued rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "In contracts/periphery/vault_incentives_v1/src/contract.rs:170, last_update_timestamp is updated when the owner updates the schedule. This is problematic because the rewards distribution depends on the elapsed staking time, causing a loss of rewards for stakers. To illustrate, assume the start time is before the current timestamp when the owner creates the schedule. In line 377, the elapsed time will deduct the current timestamp with the last updated timestamp, not the schedules start time. Since the rewards are calculated in line 402 with the denominator as the whole schedules duration, the stakers will lose a portion of the rewards because the duration from the start date to the last updated timestamp is not included.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "11. remove_completed_proposal function incorrectly uses current conguration values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "In the contracts/periphery/gov/src/contract.rs:650-654, remove_completed_proposal function mutates the proposal status to expired if the proposal.end_block, current the config.proposal_effective_delay, and config.proposal_expiration_period. This implies that current conguration values are used, not the ones at the creation of the proposal. exceeds height block sum of Consequently, the proposal will expire earlier or later than intended depending on the proposal_effective_delay and proposal_expiration_period values updated in update_config through a successful governance proposal. The expiration block at proposal creation is stored in proposal.expiration_block, as seen in line 308.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "12. Possible division by zero error when no liquidity token is deposited", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "In contracts/periphery/vault_incentives_v1/src/contract.rs:449-451, the pt_lp_holders_index is increased for all staked liquidity token holders if the total it does not account for the scenario where the total yield token supply is zero. However, staked liquidity token in the contract is also zero. Consequently, the update_state function might fail due to a division by zero error when updating indexes.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "13. Users voting power remains after removing channels", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "In contracts/periphery/voting_power_inbound/src/contract.rs:122-143, the RemoveChannel message resets the FOREIGN_VOTING_POWER_TOTALS storage to zero to indicate there will be no voting power in this channel. However, individual voters still have their voting power stored in the VOTERS storage state. Consequently, both Voter and Voters query messages will still reect that voters still have outstanding voting power in the removed channel, which is incorrect. Additionally, if the channel is subsequently readded, Voters regain the voting power stored with the old channel since it has not been reset.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "14. StakePtLp message does not remove users deposit when updating the global index", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "In contracts/periphery/vault_incentives_v1/src/contract.rs:121-127, the StakePtLp message requires the caller to send config.pt_lp_token native denom, which will then call the update_state function. This function then queries the total tokens in the contract in line 425 without deducting the users deposit. This is problematic because the distributed rewards amount is for the stakers who staked during the elapsed time duration. Since the provided tokens were not staked before, they should not be entitled to a portion of the incentives earned. Consequently, denominator increase. the overall", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "15. Insucient input validations across contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "The smart contracts within scope lack sucient validation before saving conguration values. This could lead to issues that disrupt the correct behavior of the protocol and lead to failing transactions.  In contracts/periphery/builder_unlock/src/contract.rs:50:  token parameter not validated to be correct before saving upon instantiation.  proposed_receiver parameter should be None for new allocations.  In contracts/periphery/gov/src/contract.rs:74-88 and 679-764, the following parameters lack enough validation both upon instantiation and update:  xtoken may render the contract inoperable if set to an incorrect denom.  emergency_proposal_required_denom: to zero, emergency proposals could be auto-approved. If set to more than 1, it will never be met, and the proposal cannot pass. if set  In contracts/periphery/staking/src/contract.rs:53:  Lack of denom validation in the token parameter upon instantiation.  contracts/periphery/voting_power_inbound/src/contract.rs:50-5 lack of 8 and 102-120, upon instantiation and AllowVotingPowerSource, validation of the following parameters could lead to IBC features not working:  compatible_vp_outbound_versions  allowed_connection_ids  allowed_port_ids  contracts/periphery/voting_power_outbound/src/contract.rs:54- 63, 192-194, and 205-223, upon instantiation, AllowVotingPowerSource and UpdateConfig, lack of validation of the following parameters could lead to IBC features not working:  compatible_vp_outbound_versions  allowed_connection_ids  allowed_port_ids  contracts/periphery/vault_incentives_v1/src/contract.rs:33-57 and 469-538 lack validation upon instantiation and UpdateConfig could lead to protocol inoperability:  Missing denom validation of lp_token, yield_token, principal_token, and pt_lp_token.  pt_lp_pool_id pool is not validated.  yield_token_allocation_min yield_token_allocation_max.  yield_token_allocation_min, refracted_lp_ratio_delta_lower_bound, pt_lp_ratio_delta_lower_bound, should be validated to be less than 1. should be less than yield_token_allocation_max, and yield_token_allocation  yield_token_allocation should be validated to be less than than than the validation should be yield_token_allocation_max yield_token_allocation_min. Additionally, performed similarly to how the conguration update works. greater and", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Owner is allowed to execute arbitrary CosmosMsgs", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "The staking contract allows the owner to execute arbitrary CosmosMsgs through the ExecuteMsg::OwnerAction entry point. Among others, this message can be used to move contract funds to an arbitrary address through a BankMsg. In the event of compromised access keys or a malicious insider, this would allow the sweeping of all the contract funds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Executed proposals can be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "In the contracts/periphery/gov/src/contract.rs:641-660, remove_completed_proposal function allows removing an expired or rejected proposal from the general proposal list. This implies that it is also possible to remove an Executed proposal once it has expired, as seen in line 653.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. Coin denomination updates lead to locked tokens stuck in the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "voting-power-outbound The voting_power_denom contracts/periphery/voting_power_outbound/src/contract.rs:196-198. conguration UpdateConfig updated contract through allows the eld in be to If it gets updated, users who have locked tokens will receive, upon Unlock, tokens with the new denom instead of the ones they locked. This may lead to failures of the unlock operation or to other users tokens being spent, depending on the balance of the contract. The originally locked tokens will be stuck in the contract. the vault_incentives_v1 Similarly, incentive_denom contracts/periphery/vault_incentives_v1/src/contract.rs:493-495. this case, the update of the token denom causes the inability for users to get incentives. conguration UpdateConfig allows through updated contract the be to eld in In We classify this issue as minor since it can only be caused by the owner of the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Excessive control over funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "The builder-unlock contract allows the owner unallocated arbitrary execute_transfer_unallocated contracts/periphery/builder_unlock/src/contract.rs:517-562. to directly transfer any amount of the in address function through tokens an to This mechanism bypasses the expected behavior of the contract where the allocations are In case of a malicious insider or a expected to be made available depending on time. the compromised owner key, remaining funds by reducing allocations and then transferring the funds out. the attacker would be able to immediately cash out all", "labels": ["Oak Security", "Severity: Low"]}, {"title": "20. Single-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "21. Unused reply ID", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf", "body": "The staking contract denes an INSTANTIATE_TOKEN_REPLY_ID constant. However, the reply function in contracts/periphery/staking/src/contract.rs:268 does not check the ID. Although not a security issue, an unchecked reply ID may be error-prone if additional reply handling becomes necessary in a future implementation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Unbounded loops in the nitro package can lead to a DoS", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/nitro/keeper/msg_server.go:75 and x/nitro/keeper/prover.go:24, the user-provided elds msg.EndSlot and proof.Hash may lead to an unbounded loop or an arbitrarily computationally expensive transaction which can lead to a DoS. This is problematic since the Validate function in x/nitro/keeper/prover.go:24 does not charge gas to the sender of the transaction, making the attack free of charge. It is important to note that both these code paths are called by the SubmitFraudChallenge method in x/nitro/keeper/msg_server.go:56, which is currently not registered on the Router in x/nitro/module.go:107.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Not registered message types prevent users from sending transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "MsgContractDepositRent and MsgUnregisterContract are not registered in RegisterInterfaces and RegisterCodec in x/dex/types/codec.go. Hence, the module will not route the messages to an appropriate message server. Thus, users will not be able to send transactions with the aforementioned message types.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. MsgContractDepositRent should set a minimum amount to avoid potential spamming", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/keeper/msgserver/msg_server_contract_deposit_rent.go:12, there is no minimum limit to the amount that can be sent, and there is no gas charged for the operation, by default. This can be a cost-eective attack vector for the protocol, in which multiple transactions are sent with negligible amounts to consume CPU cycles with minimal cost. This may be used to slow down block production or even halt the chain.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Tick sizes are wrongly updated when a newly registered pair already exists", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/keeper/msgserver/msg_server_register_pairs.go:36, any errors returned from the k.AddRegisteredPair function are silently ignored. This implies that the execution will continue even if the creator of a contract is trying to register a pair that already exists. This unhandled error has the unintended consequence that SetPriceTickSizeForPair and SetQuantityTickSizeForPair are called in lines 37-38, updating the current tick sizes of an already existing pair. Since events for that pair are not emitted, this could break any integrations with o-chain components and third-party applications relying on those events.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Processing of MsgPlaceOrders and MsgSend messages in EndBlocker may be exploited to halt the chain if mispriced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "Due to the processing of MsgPlaceOrders and MsgSend messages in the EndBlocker, a user can send transactions with multiple MsgPlaceOrders and MsgSend messages that are successfully included in a block, but then fail during the EndBlocker execution. An attacker may exploit this feature if the computation needed in the EndBlocker is not properly priced in the transaction. If a network has zero or low fees, an attacker could send hundreds of thousands of MsgPlaceOrders and MsgSend messages at comparatively low cost for the computation required which can slow down block production up to the point where the blockchain halts.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Contract claiming is not possible due to a logic error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "if In the ContractDepositRent function, a new owner can claim a contract 0. However, contract.RentBalance x/dex/keeper/msgserver/ msg_server_contract_deposit_rent.go:28, the SendCoins operation is executed from the old creatorAddr, not from msg.Sender. Thus, this function will always fail when called by any address which is not the current owner, rendering the claim functionality unusable. == in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Past minting emissions would never happen if the chain is down on the required release date", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In validates if x/mint/types/minter.go:56, function the date of the block is equal to the scheduledReleaseDate, and gets GetScheduledTokenRelease the executed in the BeginBlock of the epoch module. If the date matches, new mint emissions of the chain token will be performed. However, the function does not consider if the date scheduledReleaseDate is in the past, but the emission of the given epoch has not happened yet. Therefore, in case the Sei chain is down for more than 24 hours, the release of tokens is skipped, altering the emission plan.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Amino codec must be registered to support end users with hardware devices like Ledger", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/types/codec.go:50, Amino should be used to register all interfaces and concrete types for the dex module. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Insucient validation of addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "The address of the creator, as well as the address of the contract in validateCancels the function in x/dex/keeper/msgserver/msg_server_cancel_orders.go are only checked against zero-length and not for validity of the address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. GetContract parse error not handled explicitly", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/keeper/contract.go:37, the method GetContract returns an error either when the contract is not present in the storage, or when the contract is found but cannot be parsed in x/dex/keeper/msgserver/msg_server_register_contract.go:95, 107, and 193 assume that the contract does not exist upon either error and does not handle parsing errors. However, properly. contexts calling the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Fund transfer in EndBlocker goes against best practices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "function sends a transaction using the MsgPlaceOrders message, the When a user in transferFunds x/dex/keeper/msgserver/msg_server_place_orders.go:15 is called to create a DepositInfoEntry with the users fund amount in MemState. The amount is not actually moved from the senders account until the GetDepositSudoMsg function is called in the If a user EndBlock function in x/dex/keeper/abci/end_block_deposit.go:33. sends a transaction with multiple messages of MsgPlaceOrders and MsgSend, the transaction would be successfully included in a block but the deposit might fail during the EndBlocker execution since insucient time. Such asynchronously failing messages can negatively impact the user experience. It is best practice to fail fast by directly transferring funds from a senders account during message execution. After that, the deposit can still be handled in the EndBlock function. funds may be available at that", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Events are not emitted consistently across the application, which may impact the ability of third-party applications to be integrated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "Cosmos events are emitted by applications to notify third-party applications such as block explorers about events that occur on the chain. Not emitting events consistently across the application may impact the ability of these applications to parse the activity that happens in Sei, impacting user and developer experience. The following instances of messages and functionality lack emission of events:  x/epoch/module.go:188  x/dex/keeper/msgserver/msg_server_unregister_contract.go:12", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. ChangeAdmin does not validate that the new admin is dierent from the current one, which may cause errors in contracts and applications relying on this logic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "function ChangeAdmin The in x/tokenfactory/keeper/ msg_server.go:135 permits the admin of a token denom to change its address to a new one. However, there is no check that NewAdmin is dierent from the current one. An event of a change of admin is emitted nonetheless, which may cause unexpected behavior in applications relying on this information. tokenfactory module the in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Ination rate is set to 0%, while the documentation indicates an intended default ination rate of 13%", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/mint/types/minter.go:26, it is stated that the intended default initial ination rate should be 13%. However, in line 21, the initial ination rate is set to sdk.NewDec(0).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. UnregisterContract should remove associated pairs after the contract is removed to avoid consuming unnecessary disk space on validators", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "is the contract removed in Once in x/dex/keeper/msgserver/msg_server_unregister_contract.go:12, its associated states are not deleted. An attacker can exploit storage by registering contracts, and then unregistering them multiple times. The cost of such an attack is comparatively low as rent is refunded to the contract owner after unregistration. UnregisterContract function the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Inecient implementation of UpdateQuantityTickSize and UpdatePriceTickSize", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "implementation The x/dex/keeper/msgserver/msg_server_update_quantity_tick_size.go:11 iterates through the tick size list, performing validation and then iteration through the same list happens again in SetQuantityTickSizeForPair. A similar implementation is performed to update price tick size. UpdateQuantityTickSize of in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Strict parsing of boolean CLI arguments may degrade user experience", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/client/cli/tx/tx_register_contract.go, the arguments [need the string true, which hook] and [need order matching] only check against degrades the user experience. For example, if a user capitalizes the word, the ag is going to be set to false.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Inecient implementation of CancelOrders", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "The implementation of CancelOrders in x/dex/exchange/cancel_order.go iterates through orderbook.Longs) and cancelOrder(cancel, cancelOrder(cancel, orderbook.Shorts) for each one. This is inecient, since an order is always just in either the long or short orderbook. orders, calling all", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Inecient implementation of PlaceOrders", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "The implementation of transferFunds within the PlaceOrders function is inecient. In x/dex/keeper/msgserver/msg_server_place_orders.go:25-29, there is a loop validating that the fund amounts are dierent from Nil. However, this iteration is redundant as the same validation is performed in line 38.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Lack of token whitelist validation when swapping and creating a position or executing a strategy may lead to loss of user funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In ethereum_hardhat/contracts/EthereumManager.sol:412 and 478, the swapTokenAndCreatePosition and swapTokenAndExecuteStrategy functions allow users to swap tokens and create or execute a strategy based on the provided strategy and chain identier. However, there is no validation that makes sure the swapped token toToken is whitelisted for that strategy identier strategyId and chain identier strategyChainId. and the createPosition function in line 391 veries that the assetInfos, In contrast, the strategyId, isTokenWhitelistedForStrategy mapping in line 277 to ensure the assets are whitelisted the and strategy validateAndTransferAssetFromSender function. strategyChainId arguments specied identier using chain valid are the via for The impact of this issue depends on how the contract on the other chain handles the non-whitelisted token. A possibility that might happen is that the recipient contract will reject the sent VAA message because the strategy does not support the asset token, causing a loss of funds for the sender.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Contracts are not compliant with CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "The smart contracts do not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Inability to update the admin address of the terra_manager prevents incidence response", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In contracts/terra_manager/src/contract.rs, the admin address is saved in the storage in the instantiate message. After that, the admin cant change its address. This may lead to severe implications if the private keys controlling the admin account are ever compromised, in which case an update of the admin address would help to prevent exploits.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Missing allowance check when executing a strategy with CW20 token causes meaningless error message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In packages/aperture_common/src/token_utils.rs:47, when creating the message to move assets from the sender to the current contract, the execution uses a cw20::Cw20ExecuteMsg::TransferFrom. This type of message requires that the sender provided an allowance for the spender contract. If no allowance is granted, message execution will fail without a meaningful error message.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing tax deductions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Cross-chain fee BPS value may be set to be larger than MAX_CROSS_CHAIN_FEE_BPS", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "the ethereum_hardhat/contracts/EthereumManager.sol:119, In the not _crossChainFeeBPS MAX_CROSS_CHAIN_FEE_BPS value as seen in line 131. As a result, an admin setting a _crossChainFeeBPS higher than MAX_CROSS_CHAIN_FEE_BPS will cause the calculated cross-chain fee in line 328 to be larger than intended. validated below value be to is", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Usage of deprecated safeApprove function opens up front-running possibilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In ethereum_hardhat/contracts/EthereumManager.sol:187 and 338, the safeApprove function is used to give approvals for other contracts to use the current contracts token balance. However, the safeApprove functionality is deprecated as it opens up possibilities for sandwich attacks similar to the classic ERC20 approve() function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Custom implementation of admin role increases code complexity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In contracts/terra_manager/src/contract.rs a custom implementation of an admin role is used. Using a battle-tested reference implementation reduces the complexity of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Removing a strategy from terra_manager may lead to unlinked data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "contracts/terra_manager/src/contract.rs:63, executing the selected strategy metadata is removed from when In ExecuteMsg::RemoveStrategy, STRATEGY_ID_TO_METADATA_MAP. As positions in POSITION_TO_STRATEGY_LOCATION_MAP are potentially pointing to a deleted strategy, this may lead to partial/unlinked data in the storage.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "contracts/terra_manager/Cargo.toml The overflow-checks for the release prole. package does not enable While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Re-entrancy guard TODO comment in Solidity codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "ethereum_hardhat/contracts/EthereumManager.sol:290, an In outstanding TODO comment indicating whether or not to implement a reentrancy guard in recordNewPositionInfo functionality. If the reentrancy guard is not applied, an attacker can keep reentering recordNewPositionInfo functionality, allowing the attacker to create fake positions under them. That said, there arent direct security risks since the rest of the code execution validates the attacker sent assets as specied in the assetInfos and fromToken argument. theres", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. The protocol can get permanently stuck in the StakingRewards state due to unhandled errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf", "body": "In the contracts/core/src/contract.rs:838-861, execute_tick_staking_rewards function within the core contract acts as the designated handler when the ContractState transitions to StakingRewards during routine procedures. However, if during this process the puppeteer contract callback to the PuppeteerHook stores a ResponseHookMsg::Error because of a timeout or an error in the ICA transaction, the execute_tick_staking_rewards function consistently returns a PreviousStakingWasFailed error in line 846. Consequently, lacking an alternative handler to progress the ContractState, the routine procedure becomes unable to proceed, resulting in the protocol becoming permanently stuck.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Accumulation of non-staked funds in the ICA account poses depegging risks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf", "body": "If the staking operations of the staker contract fail, user funds accumulate in the interchain account. This accumulation continues indenitely, regardless of the total balance or the frequency of failed staking operations. However, extended periods of failed operations could lead to the depegging of the liquid staking token, as non-bonded tokens would become unrecoverable or redeemable much later than the conventional bonding period suggests. This delay is due to the extended non-bonding time. Signicant accumulation of non-staked tokens or consecutively failing staking operations might be interpreted as a selling signal by users of liquid staking derivatives, potentially causing a depeg.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Missing validation in staker contract instantiation and update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf", "body": "In contracts/staker/src/contract.rs, during the execution of the instantiate and execute_update_config functions of the staker contract, data provided by the owner is stored in the contract without any validation. However, it should be validated to not allow for incorrect congurations.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Neutron governance updating IBC fees could temporarily hinder interchain transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf", "body": "The staker contract constructs the fee object required by the Neutrons feeRefunder and interchaintxs Cosmos SDK modules with fees dened by the owner. However, since Neutrons governance can update the required IBC fees, static fees could render contracts unable to execute transfers or interchain transactions if fees change. Consequently, interchain transactions. the aforementioned contracts may become stuck and unable to execute", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Additional funds sent for ICA registration are stuck in the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf", "body": "contracts/staker/src/contract.rs:179-198, In function execute_register_ica is utilized to register a new ICA account on a remote chain. This process mandates that the sender pays the registration_fee by transferring a dened amount of coins in the LOCAL_DENOM denomination. the However, additional funds sent by the user are not returned or processed further, eectively becoming stuck within the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Unbondings could fail due to asynchronous behavior of the staker contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf", "body": "The asynchronous nature of the staker contract can lead to situations where assets are requested for undelegation before they are fully staked. these scenarios, in In contracts/core/src/contract.rs:11291183 should ignore the undelegation request and continue processing, such that once the assets are staked, the undelegation request can be successfully processed at a later time. get_unbonding_msg function dened the This issue has been independently reported by a third party. Status: Externally Reported 7. Migrate only if newer pattern is not followed Severity: Informational The contract is currently migrated without regard to their version. This can be improved by adding validation to ensure that the migration is only performed if the supplied version is newer.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. First depositor can be front-run for unfair prot causing direct losses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The hub contract does not prevent the rst depositor from being front-run to eectively get fewer shares than planned from which the attacker will prot. In contracts/hub/src/math.rs:36-38, the number of shares that a user receives depends on ustake_supply, uluna_to_bond, and uluna_bonded. However, if a malicious depositor makes a large enough donation to the vault at the right time, increasing uluna_bonded, the next depositor will not receive their expected amount of shares. The below describes a potential exploit scenario that could be followed by an attacker Mallory to take advantage of a victim Alice: 1. Upon identifying that Alice is trying to make the rst deposit of X uluna into the hub contract, Malloryfront-runs their transaction with two calls: a. Making a minimal initial deposit, let's say 1 uluna, to obtain one unit of shares and setting ustake_supply to one. b. Donating a number of tokens to the contract equal to X/2 uluna, increasing the bonded_luna value without increasing ustake_supply", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Mallory will then be able to return the share to get 1/2 + 3x/4 uluna after having spent just 1 + X/2 uluna, eectively proting X/4 uluna. Note that this issue is only exploitable at the beginning of the contracts lifecycle and does only aect the rst user making the deposit. However, as the potential loss of funds can be substantial we classify it as critical. Recommendation We recommend performing the rst deposit atomically upon contract deployment. Their rst deposit should be large enough to limit the impact of the described exploit. Status: Resolved 2. Underow upon slope calculation may lead to unreliable voting power", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "4. Mallory will then be able to return the share to get 1/2 + 3x/4 uluna after having spent just 1 + X/2 uluna, eectively proting X/4 uluna. Note that this issue is only exploitable at the beginning of the contracts lifecycle and does only aect the rst user making the deposit. However, as the potential loss of funds can be substantial we classify it as critical. Recommendation We recommend performing the rst deposit atomically upon contract deployment. Their rst deposit should be large enough to limit the impact of the described exploit. Status: Resolved 2. Underow upon slope calculation may lead to unreliable voting power", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Unharvested rewards not accounted for in compute_mint_amount function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "compute_mint_amount at the The contracts/hub/src/execute.rs:144, does not take into account unharvested rewards when calculating the mint amount for a new user. As the protocol reinvests rewards, these belong to previous users, and new users are also given a share of these new rewards. contract, function located hub of Protocol users have a natural the harvest function to minimize any unharvested rewards getting distributed to other users. We classify this issue as minor, since the client states it is expected behaviour and that they will explain this in the user interface. incentive to call", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Period rounding can lead to undesired results", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The function create_lock converts a timestamp into a number of periods to get the current blocks period (variable block_period) and to calculate the number of periods for the lock rounding occurs which can lead to (variable periods). unexpected and potentially undesired results. these operations, In both of The rounding down of block_period means that the start of the lock could be set to the current period. Because of that, the minimum number of periods will not be strictly enforced. For instance, if a user creates a lock just before a period ends, the capital is locked up for one week less than if he creates a lock just after a period starts. On the other hand, the rounding down of periods may confuse a user. If a user species a time that corresponds to 3.99 weeks, the lock will only be created for three periods (three weeks).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Lack of validation of embedded logos", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The voting-escrow contract does not validate_marketing_info contracts/amp-governance/voting_escrow/src/marketing_validation.rs :52-69. validate embedded logos during its in function If an embedded logo is submitted on instantiation it will be saved without any further check. This is not the case for the execute_upload_logo function of CW20, which successfully validates all cases through validate_logo.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of validation upon instantiation of the Hub contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The hub contracts instantiation function in contracts/hub/src/execute.rs:33 lacks some validation steps of epoch_period and unbond_period. In addition, the list of validators stored in line 49 is checked for duplicates but it does not actually validate addresses to be those of active validators. The same situation is found in the add_validator function in lines 666-682. We classify this issue as minor since instantiation parameters are usually reviewed with care by a privileged user or development team before deployment.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Insucient validation in address blacklisting function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The voting-escrow contracts update_blacklist function checks that the two vectors provided as arguments, append_addrs and remove_addrs, do not clash with the current contents in the contracts/amp-governance/voting_escrow/src/contract.rs:707-714. However, it does not check if addresses are duplicated within each vector or if an address is part of both at the same time. blacklist of Duplicated addresses in append_addrs cause minor ineciencies as those will be saved into the storage, unnecessarily growing it with no purpose and opening a window for future inconsistencies. This limited impact in line 744, as processing the rst instance of any address causes the cur_power of duplicated iterations to be zero. is mitigated by the if statement On the other hand, duplicates in remove_addrs have a real impact as there are no checks in place to avoid repeated calls to the checkpoint function in line 778. This leads to additional accounting in voting power in line 347 linked to the blacklisting of the same address,  compromising the integrity of the scheduled slope changes and the stored Point. For addresses that are present in both vectors, the function rst appends addresses and then removes them. If, by mistake, the same address is part of both, that address will not be contained in the nal blacklist without the owner or guardian being aware of this situation. Although the impact of this issue can be considered major, the function is restricted to privileged addresses which are less prone to error in general. Therefore, this issue has been raised as minor.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Coecient calc implementation diers from documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "calc_coefficient The in packages/eris/src/helpers/slope.rs:6-10 is documented with the following line: Coefficient to 1 and [`MAX_LOCK_TIME`] is 9. However, the actual implementation does not adhere to this comment as when the interval is zero weeks, the returned value will be zero instead of one. calculation [`WEEK`] function equal where found is This issue has been raised as informational as every instance that calls the aected function checks the supplied interval to not be zero before or cant be zero given the contracs logic.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Widespread usage of generic errors in the Hub contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The error handling in the hub contract is based on StdError::generic_err instead of declaring custom errors, as opposed to the voting-escrow contract which mostly relies on custom errors. Although not a security issue, dening individual generic error messages decreases maintainability.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Lack of drop proposal function on owner transfer mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The hub contract implements a two-step transfer mechanism for updating the owner in order to remove a new_owner address address, submitted by mistake, the current owner would have to call transfer_ownership again and overwrite the address. following best practices. However, Although eective in practice, purpose of clearing this value.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Hardcoded denom and EPOCH_START", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The hub contract makes use of the CONTRACT_DENOM constant to set the denom in multiple instances, following best practices. However, the following instances have been found to use a hardcoded uluna string instead of the CONTRACT_DENOM constant:  contracts/hub/src/types/staking.rs:44, 67, 93  contracts/hub/src/queries.rs:80 Although not a security issue, it impacts maintainability and may lead to errors in the future, such as a partial change of denoms throughout the codebase. In addition, the code in packages/eris/src/governance_helper.rs:16 denes a variable EPOCH_START with a specic value assigned to it. It is important to make sure that this value is correct and intended for the specic use case before deploying the code to production, as it may need to be adjusted or replaced with a dynamic value that can change over time.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Optimization in compute_undelegations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "iterates over merge_with_validators in The hub contract uses a loop that if the variable uluna_to_undelegate contracts/hub/src/math.rs:86. However, is set to zero, the subsequent computations on lines 91 and beyond will have no eect, wasting computational resources.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Outdated documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "README type The ExecuteMsg::SubmitUnbond, which does not exist and was, presumably, replaced by ExecuteMsg::SubmitBatch. mentions message folder hub the le in a", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unnecessary conversion to lowercase in addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The contracts within scope used the addr_validate_to_lower helper function to sanitize addresses, found at packages/eris/src/helper.rs:25-31. Since CosmWasm 1.0.0, the addr_validate utility also validates address capitalization, hence making it redundant to perform this check manually.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Incorrect comments and typographical errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The following incorrect comments and typographical errors were found in the audited codebase. Although not security related, they decrease documentation quality and readability of the codebase:  contracts/amp-governance/voting_escrow/src/contract.rs:724 accumulator for old slopes instead of accumulator for old amount.  contracts/amp-governance/voting_escrow/src/state.rs:17 list of whitelisted logo urls prexes instead of list of contracts to receive updates on user's lock info, or something similar.  contracts/amp-governance/voting_escrow/src/state.rs:44 the timestamp when the lock position starts instead of the period when the lock position starts  contracts/hub/src/contract.rs:141 must be 1-2 instead of must be 1  contracts/hub/src/execute.rs:305 and 309 validatiors instead of validators", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Commented code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "A commented function was found in packages/eris/src/helpers/slope.rs:20-24. Although not a security issue, commented code decreases readability and may cause issues if re-introduced in the future without being properly re-architected.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Undelegations will fail when redelegating to a new validator", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "contracts/external/cw-vesting/src/stake_tracker.rs:71-74, In cardinality is not undelegations will fail in line 100 as the cardinality tries to decrement a zero-value. the increased when redelegating to a new validator. Consequently, Although the vesting recipient can prevent this issue by redelegating back to the source validator, it is irrecoverable if the vesting is canceled. In that case, the owner can no longer withdraw the delegated funds. Please see the test_redelegate_should_increase_cardinality test case to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Misconguring the total vested amount to be lower than the sent CW20 amount would cause a loss of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "In contracts/external/cw-vesting/src/contract.rs:38, the total amount of tokens to be vested depends on the PayrollInstantiateMsg.total amount (see the total contracts/external/cw-payroll-factory/src/contract.rs:87). amount to vest is lower than the sent CW20 amount, the excess tokens will be left in the cw-payroll-factory contract. If can Suppose a scenario where the cw-payroll-factory does not have any owner. An calling attacker higher ReceiveMsg::InstantiatePayrollContract PayrollInstantiateMsg.total amount, causing the cw-payroll-factory contract to send the excess funds to the newly instantiated cw-vesting contract. tokens with by a excess steal the Please see the test_inconsistent_cw20_amount test case to reproduce the issue.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Misconguring start time to be in the past might cause undesired payouts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "In contracts/external/cw-vesting/src/contract.rs:34, the start_time of the vesting can be set to a past value, which might lead to undesired payouts. We classify this issue as minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Vesting duration parameter is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "In cw-vesting/src/contract.rs:41, the duration_seconds parameter is initialized with a non-validated value. This results in the possibility of instant vesting, releasing funds immediately upon reaching start_time, which may not be intended. The value of duration_seconds is handled using the SaturatingLinear variant of the Schedule type. Using it with a start_time in the future and duration_seconds equal to 0 renders it equivalent to the PiecewiseLinear schedule consisting of a single step releasing the whole amount. We classify this issue as minor since only the contract instantiator can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Undelegation does not emit custom events", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "undelegation in During contracts/external/cw-vesting/src/contract.rs:366, no events or attributes are emitted upon successful execution. This is inconsistent with execute_delegate and execute_redelegate, where attributes are emitted in lines 259 and 324, respectively. execute_undelegate function the in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Values held in StakeTracker cannot be queried", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "There is a certain amount of code implementing tracking of delegations in the cw-vesting smart contract. The structure StakeTracker, dened in stake_tracker.rs, contains the elds total_staked, validators, and cardinality. They all reect the chronology of staked funds by the validator and account unbonding times. However, call graph analysis reveals that only total_staked aects the outcome of transaction processing. In contrast, validators and cardinality are never read outside tests in stake_tracker_tests.rs. StakeTracker does, however, update them, e.g. in the on_bonded_slash function in stake_tracker.rs:113 with a clever technique of reconstructing proper delegated amounts after slashing events. The concern is that elds validators and cardinality require computation and on-chain space while not being utilized in any way except testing.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Potential misleading error in ReceiveMsg::Fund", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "In cw-vesting/src/contract.rs:153, the error ContractError::Funded is thrown if the status of the vesting is not Unfunded. However, the contract also can be in the Canceled state.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Schedule cli shifts the unlock start date rather than leads to unlocked tokens that cannot be claimed yet", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "a and When dening an allocation of ASTRO for a user, the contract owner species a start date, a calculating the unlocked_amount in cli, duration. However, when time and cli are contracts/builder_unlock/src/contract.rs:939, the added, eectively just shifting the start date. The consequence of unlock_amount does not increase linearly from the start time, but from the sum of start date and cli instead. this is that the start contradicts in This packages/astroport-governance/src/builder_unlock.rs:35 which states Time after the cliff during which the remaining tokens linearly unlock. comment the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Recipient transfer does not transfer unlocked amount checkpoint", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "the in During execute_claim_receiver contracts/builder_unlock/src/contract.rs:650, only the astro_withdrawn eld of the allocation status STATUS is transferred to the new receiver, but not any amount that was previously unlocked in unlocked_amount_checkpoint. function This implies that the new receiver may have to wait longer for funds to unlock in the case where the previous recipient had an allocation decrease and the unlocked funds were stored in unlocked_amount_checkpoint.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Increasing the cli may result in unlocked tokens becoming locked again", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "In the increase_cliffs function, the contract owner can set a new cli for an allocation in in already contracts/builder_unlock/src/contract.rs:721. This may result unlocked tokens no longer being unlocked. Apart from this, an increasing cli in the current implementation may lead to an underow causing a panic in line 970 if a user already withdrew a bigger amount than the new unlocked amount. Note that this has no security implication, but a panic leads to a bad user experience.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Inconsistency in validation during recipient transfer may lead to a loss of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "the execute_propose_new_receiver returned in In contracts/builder_unlock/src/contract.rs:389 if the receiver has allocation parameters PARAMS with a non-zero amount. In the execute_claim_receiver function, however, an error is returned in contracts/builder_unlock/src/contract.rs:630 if a PARAMS entry exists for the receiver, even if the amount is zero. function, error an is This inconsistency allows a recipient with PARAMS but a zero amount to be proposed as the receiver, but that new recipient can never claim that allocation. This might lead to a loss of funds for the new receiver if the previous receiver of the allocation does not cooperate to resolve the issue. We classify this issue as minor since rstly, the creation of PARAMS allocations with a zero amount does not make much sense and may never exist, and secondly, the previous and new recipients are likely controlled by the same entity, in which case they can resolve the issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Maximum allocation amount can be set lower than total deposits", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "the update_config a In in new_max_allocations_amount contract/builder_unlock/src/contract.rs:689. There is currently no validation, however, that the new value is bigger than total_astro_deposited. contract function owner able the set to is This max_allocations_amount and implies that no new allocations can be created. total_astro_deposited assumption breaks that the <= We classify this issue as minor since only the owner can cause it, and since it can be resolved by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Transfer of unallocated tokens leads to wrong token accounting", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "During the execute_transfer_unallocated function, the total_astro_deposited the state the execute_increase_allocation in total_astro_deposited is which inconsistent decreased. increases function, variable amount This with not is contracts/builder_unlock/src/contract.rs:519. total_astro_deposited amount hence includes unallocated tokens. The Consequently, the total_astro_deposited state variable will be bigger than actual deposits after a transfer of unallocated funds. This implies that the condition checking total_astro_deposited against max_allocations_amount in line 523 will lead to an surpass the max_allocations_amount. deposited amount actual does even error not if We classify this issue as minor since it can be worked around by the owner by increasing max_allocations_amount.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Lack of validation when creating an allocation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "In the execute_create_allocations function, the passed AllocationParams are stored in contracts/builder_unlock/src/contract.rs:295. This implies that allocations can be created with a start_time in the past, a zero duration, zero amount or an invalid proposed_receiver address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Unnecessary lowercasing of addresses is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "the both codebase, Throughout custom addr_validate_to_lower function are used to convert String to Addr types and validate their correctness. As the version of cosmwasm-std dened in the Cargo.toml is it is no longer necessary to convert strings to lowercase. Using a custom function is 1.1, inecient and unnecessarily increases the codebase. deps.api.validate and the the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Unnecessary load of PARAMS during creation of an allocation is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "During the creation of an allocation, the contract veries that a user does not have an existing in allocation contracts/builder_unlock/src/contract.rs:287. Loading the value is inecient though, since it is not used. PARAMS loading value from the by", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Unnecessary validation of STATUS during creation of an allocation is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "by During the creation of an allocation, the contract veries that a user does not have an existing allocation in contracts/builder_unlock/src/contract.rs:299. However, there is already a check for PARAMS in line 287. Since both STATUS and PARAMS are created for new allocations, non-existence of an entry in PARAMS implies non-existence of that entry in STATUS, which makes the STATUS check unnecessary. checking STATUS the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Unnecessary loading of STATUS during claim of new receiver is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "In the execute_claim_receiver function, the STATUS of the new receiver is loaded in contracts/builder_unlock/src/contract.rs:649. However, an error is returned before in line 630 if that new receiver has stored PARAMS. Since PARAMS and STATUS for a receiver always exist both or neither, the code block in lines 649-653 has no eect.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Misleading function name compute_withdraw_amount may negatively impact maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "The compute_withdraw_amount function calculates the amount of Astro a user may withdraw in contracts/builder_unlock/src/contract.rs:956. the function also updates the users STATUS, which contradicts the function name, which only indicates a computation. This might mislead In addition,", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Inecient validation of prev_receiver", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "When a user accepts a claim of a token allocation, the function loads the PARAMS and in STATUS contracts/builder_unlock/src/contract.rs:625 and subsequently removes both the PARAMS and STATUS of said previous receiver. previous receiver the of During each of these four interactions, the function validates the prev_receiver address. This is unnecessary and wastes computational resources.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Lack of error message for query of non-existent allocation may confuse users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "When an allocation does not exist for a queried user through the QueryMsg::Allocation the query_allocation function returns an allocation with empty values in query, contracts/builder_unlock/src/contract.rs:760 and 763, rather than an error message that the allocation does not exist. This may be confusing to users.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. The exchange rate between milkTIA and osmoTIA cannot be adjusted in the event of a slashing incident", "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf", "body": "The liquid staking token milkTIA is supposed to be collateralized by at least 100% of staked TIA, specically, osmoTIA tokens. In the event of a slashing incident, the staked TIA tokens will be slashed, and thus, the amount of tokens collateralizing milkTIA will be reduced. Consequently, the exchange rate between milkTIA and osmoTIA must be adjusted to reect the new, lower collateralization ratio. However, contrary to the outlined procedure for the slashing incidence process in the MilkyWay architecture design documentation, there is currently no mechanism in place to adjust the exchange rate, only functionality to pause the contract via the circuit breaker. Moreover, a stale exchange rate may be problematic to external protocols that integrate milkTIA. As the slashing incidence process involves communication between two separate blockchains, Osmosis and Celestia, the introduced time delay allows malicious actors to exploit the outdated exchange rate in the meantime. However, due to the ability of an operator to pause the contract via the circuit breaker, we classify this issue as major.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Repeatedly failed ICS-20 token transfers cannot be recovered", "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf", "body": "The osmoTIA tokens are transferred from the staking contract on Osmosis to Celestia via ICS-20 token transfers. The in-ight packets are stored in INFLIGHT_PACKETS when implemented in handling the submessage reply in the handle_ibc_reply function, failed contracts/staking/src/execute.rs:818-855. This allows timed-out or transfers the ExecuteMsg::RecoverPendingIbcTransfers message. recovered retried and via be to However, if a recovered transfer fails again, the transfer cannot be recovered again. This is due to the MsgTransfer message not being added as a submessage and, thus, the handle_ibc_reply reply handler not being called. Consequently, the in-ight packet is not stored, and repeated attempts to recover the transfer will not work as the packet is not found in the INFLIGHT_PACKETS storage map. is issue same in in The contracts/staking/src/execute.rs:718, where the ibc_transfer_msg is not added as a submessage with the appropriate reply handler. As an actor can not purposefully force the IBC packet to fail, we classify this issue as major. receive_rewards function found also the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Users potentially withdraw incorrect token amounts if the received unstaked tokens are accounted for in the wrong batch", "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf", "body": "receive_unstaked_tokens in The contracts/staking/src/execute.rs:721-790 is called as part of the IBC hooks, made possible through the memo eld included in every ICS-20 token transfer packet. The MilkyWay o-chain coordinator initiates such a token transfer once the unbonding period of 21 days on Celestia has passed and the unstaked TIA tokens are ready to be transferred to the staking contract on Osmosis and received as osmoTIA tokens. function The corresponding batch, i.e., the oldest submitted batch, is determined in lines 757-760 by iterating over all batches stored in BATCHES and taking the rst batch that matches the status BatchStatus::Submitted. The batch's received_native_unstaked value is then set to the received amount of unstaked tokens in line 782. This value is expected to include the accumulated staking rewards or, tokens. if a slashing event occurred, the slashed amount of Subsequently, received_native_unstaked is used in the execute_withdraw function in lines 382-385 to calculate the amount of underlying osmoTIA tokens to withdraw. However, as ICS-20 token transfers use an unordered IBC channel, the order in which the unstaked osmoTIA tokens are received by the staking contract is not guaranteed. if the o-chain coordinator sends multiple unstaked token transfers to the Consequently, staking contract, batches could receive the incorrect token amount, resulting in users withdrawing incorrect amounts of osmoTIA tokens.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Collected protocol fees cannot be withdrawn", "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf", "body": "and processed Staking rewards are collected on Celestia, transferred to the MilkyWay staking contract on Osmosis, in contracts/staking/src/execute.rs:652-719. Protocol fees are calculated and deducted from the received staking rewards and accounted for in the total_fees storage variable in line 706. The remaining staking rewards are then transferred back to Celestia to be staked again. receive_rewards function within the However, due to missing functionality, the collected protocol fees cannot be claimed by the protocol and remain locked in the staking contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Inecient batch retrieval leads to increased gas costs and potential out-of-gas errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf", "body": "The receive_unstaked_tokens function determines the oldest submitted batch in contracts/staking/src/execute.rs:757-760 by iterating over all batches stored in the BATCHES storage map until the rst batch with the status BatchStatus::Submitted is found. Over time, as more and more batches are added, the number of batches to iterate over will increase, potentially leading to increased gas costs and, in the worst case, to an out-of-gas error. However, new batches are only created after some pre-congured time, initially set by the MilkyWay team to three days, has elapsed. Consequently, we classify this issue as minor as creation of new batches is limited. in Similarly, in contracts/staking/src/execute.rs:175-180, the pending batch can be retrieved from PENDING_BATCH_ID instead of iterating the BATCHES storage map. execute_liquid_unstake function the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Recovering a large number of timed-out or failed ICS-20 token transfers might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf", "body": "The recover function in contracts/staking/src/execute.rs:543-586 retrieves all timed-out and failed ICS-20 token transfer packets from the INFLIGHT_PACKETS storage map without the use of pagination. Consequently, if the number of in-ight packets grows very large, the function might run out of gas, and token transfers cannot be recovered anymore.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Proxy rewards not included in active pools will be lost upon claiming", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-10 Audit Report - Astroport Core Updates v1.0.pdf", "body": "In the contracts/tokenomics/generator/src/contract.rs:231, ClaimRewards message fetches accrued proxy rewards from all active pools instead of the specied liquidity pools (see lines 748-754). When the claim_rewards function in line 982 is executed during the callback, only the specied liquidity pools will have their proxy reward index updated. This is problematic because if the provided liquidity pools do not contain all the active pools, the proxy reward index for left-out pools will not be updated, causing a loss of rewards for depositors. This issue was discovered by the client independently during the audit, but it is still present in the commit hash used for the audit.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Protocol mint fees locked in factory contract for perpetuity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Edge/2022-04-23 Audit Report - Edge Protocol v1.0.pdf", "body": "The Edge pool contract mints eTokens to the factory contract when computing the interest accrued in contracts/edge-pool/src/borrow.rs:532. However, there is no function in the factory contract that allows the factory owner to redeem these eToken funds. The eTokens accrued during interest computations are thus locked in perpetuity.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Vault safeness incorrectly calculated due to the usage of wrong decimals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "The power contract checks if each user vault is solvent as a pre-condition to perform the mint, burn, deposit, withdraw, and liquidate operations. However, the calculations done in the get_status function in contracts/margined-power/src/vault.rs:319 could yield incorrect results. is turned into decimal type in line 344, power_decimals is used When the collateral instead of base_decimals, which represents the amount of decimals from the Power denomination instead of the one from the collateral. This error could cause insolvent vaults to be wrongly deemed safe, allowing further operations or safe vaults to be considered unsafe and liquidatable.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. The power contract no longer works if apply_funding_rate is not called for 48 hours", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "contracts/margined-power/src/handle.rs, In apply_funding_rate function calls calculate_normalisation_factor, which checks if the last funding update state.last_funding_update has occurred in the last MAX_TWAP_PERIOD, which is set to 48 hours. If not, it returns an error. the While it is assumed that the apply_funding_rate function is regularly called by the foundation or community, a potential exists that it is not called for extended periods, for example due to network outages. If it is not called for 48 hours, most core functions, such as handle_mint_power_perp, handle_burn_power_perp, handle_liquidation, handle_deposit, and handle_withdrawal will be unusable given the fact that they all invoke apply_funding_rate.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. User funds are lost when using Burn to withdraw collateral", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "The power contracts handle_burn_power_perp function requires the user to send both the power tokens to be withdrawn in contracts/margined-power/src/handle.rs:263 and 264. However, the additional collateral sent this way is never accounted for. tokens to be burned and the collateral Both amount_to_burn and amount_to_withdraw are supplied as arguments to VAULTS.burn, which deducts each amount from the corresponding eld in the storage. Finally, amount_to_withdraw is transferred to the user. The whole operation results in the user sending the requested amount of collateral tokens, getting that amount deducted from the vault but only receiving the amount reimbursed once instead of twice. This leads to lost the user losing funds.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Power contract can be used if not yet opened or if paused", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "For the power contract to be usable, it must be opened explicitly by executing SetOpen message. It can also be paused and unpaused by executing Pause and UnPause messages. These actions modify the variable state.is_open. However, the code does not contain a check if the value of this variable is true before user actions are performed. Hence it is possible to interact with the contract, even when it has not been opened yet or is paused.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. The staking contract does not handle transfers of staked coins properly", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "function The in decrements contracts/margined-staking/src/handle.rs:209 staked_amounts of a user whenever they unstake. Since staked_amounts is not updated when the staked coin (staked_denom) is transferred, this calculation can underow when transferred coins are later unstaked. For instance, when Alice transfers her staked coins to Bob (who does not have a staked position) and Bob tries to unstake, he will not be able to. handle_unstake", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Normalization factor could be manipulated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "the The power contracts apply_funding_rate function calculates the normalization factor in contracts/margined-power/src/funding.rs:20 only if it has not been already calculated at timestamp (and hence in the current block). The calculation_normalisation_factor function queries the oracle in TWAP mode using the dierence from the last update of normalisation_factor and the current timestamp as its period. This is the rst step in the ve major external functionalities: mint, burn, liquidate, deposit, and withdraw. current Given the mentioned restriction, performing consecutive calls in dierent blocks with just one second of dierence between their timestamps could be possible, forcing the oracle to return information of just a one-second period. This mostly defeats the benets of using the TWAP mechanism, as it is possible to briey manipulate the Oracle in favor of the user before interacting with the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Unpause delay too small to react", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "The power contracts pause mechanism allows anonymous users to unpause the contract 24 hours after it has been paused. Although this feature follows best practices to reduce centralization concerns, the period of one day may be too small in case of an incident response situation or after the discovery of a critical vulnerability in the code.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Missing fee_rate validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "contracts/margined-power/src/contract.rs:60, In is missing validation for the value to be between 0 to 1. Without validation, misconguration may go unnoticed and will eventually be dicult to correct. config.fee_rate Similarly, in contracts/margined-power/src/handle.rs:49 should have the same validation for the config.fee_rate. handle_update_config the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Lack of denomination and pool validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "In several validation: instances in the staking and power contracts, denomination and pools lack  deposit_denom and contracts/margined-staking/src/contract.rs:59 and 61 reward_denom  power_denom, base_denom, power_pool, and base_pool contracts/margined-power/src/state.rs:59-69  token in contracts/margined-collector/src/state.rs:8 in in For example, for the last instance, if an invalid denom is added to the list of allowed tokens, it will not be usable within the collector contract. Further, if a typo is made when removing a token the same token not added error will be raised as when a valid but non-existent token is to be removed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Contracts should implement a two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update. In addition, the staking contract does not have a mechanism to transfer ownership at all. This is problematic as in case of a suspected compromise, no action could be taken.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. get_index does not return a scaled index", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "The get_index function in contracts/margined-power/src/query.rs:78-95 does not scale the calculated index, as the naming suggests. Also, it does the same as the get_unscaled_index function, making one of these functions redundant. We classify this issue as minor given that the get_index function is used as part of a query entry point that third-party contracts may rely on.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Events/attributes are not always emitted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "Multiple functions within the scope of this audit do not emit event attributes. It is best practice to emit attributes to improve the contracts' usability and support o-chain event listeners and blockchain indexers. The following functions do not emit events or attributes:  In contracts/margined-collector/src/handle.rs:56, the send_token function is lacking attributes, such as amount and to_address.  In contracts/margined-staking/src/handle.rs:89, the handle_claim function is lacking attributes, such as amount.  In contracts/margined-staking/src/handle.rs:152, the handle_stake function is lacking attributes, such as staked_amounts.  In contracts/margined-staking/src/handle.rs:209, the handle_unstake function is lacking attributes, such as sent_funds.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Inecient execution could be improved", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "function update_rewards in The contracts/margined-staking/src/distributor.rs:36 lacks optimization of the execution path when block_rewards is zero: Although the result could be short-circuited if there are no block_rewards, the whole function is executed, consuming unnecessary resources and gas. staking contract the of", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. The power contract can be opened multiple times", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "contracts/margined-power/src/handle.rs:41 the In handle_open_contract function, it is not checked if the contract was already opened. An administrator can therefore open it multiple times successfully. While this has no negative security impact, it can confuse consumers because the event open_contract is emitted every time the function is executed. within", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Lack of role-based access controls for the pausing mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "The contracts within scope implement pausing mechanisms, which is in line with best practices. However, all of the administrative functions of the contract are centralized in the owner role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that may be a multi-sig or managed by a governance contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Widespread usage of generic errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "The contracts within scope of this audit make widespread use of generic errors. Although not a security issue, generic errors are discouraged as they may decrease the maintainability of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Token authority check can be bypassed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "The power contract implements the SetOpen entry point to unpause the contract for the rst time after checking that the contract is the authority of the power token. However, there is no mechanism to ensure that this entry point is used the rst time  the authority check can be bypassed by directly calling UnPause.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Unused code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf", "body": "Across the codebase, instances of unused errors, constants, elds within structs and functions exist in the following locations. Unused code should be removed as it can decrease the readability and maintainability of the codebase.  InsufficientFunds in contracts/margined-power/src/errors.rs:19.  UserStakeNotFound in contracts/margined-staking/src/errors.rs:13.  InvalidLiquidation in contracts/margined-staking/src/errors.rs:19.  InsufficientFunds in contracts/margined-staking/src/errors.rs:22.  VaultDoesNotExist in contracts/margined-staking/src/errors.rs:25.  Stakers constant in contracts/margined-staking/src/state.rs:9.  average_staked_amounts eld within the UserStake struct is never read and only assigned once in contracts/margined-staking/src/distributor.rs:85.  DECIMALS, DECIMAL_PLACES, and SCALE_FACTOR constants in contracts/margined-staking/src/contract.rs:25-28.  quote_decimals eld in the Config struct in contracts/margined-power/src/state.rs:31.  DECIMAL_TWO constant in contracts/margined-power/src/helpers.rs:15.  execute_transfer function in contracts/margined-collector/src/messages.rs:3-8.  update and mint functions in contracts/margined-power/src/vault.rs:122 and 149 are redundant and one of them is unused.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Missing denom validation when adding incentives could lead to insucient funds error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "contracts/incentives/src/helpers.rs:95-100, In validate_incentive_schedule function lacks validation to ensure that denomination matches the incentive denomination. the the sent This is problematic because it allows potential attackers to create an incentive schedule with a dierent denomination as long as the amount sent is correct. Consequently, due to an insucient funds error. legitimate users may encounter diculties in claiming their rightful rewards A test is reproducing test_incorrect_denom_deposit test case. issue case this provided in the Appendix in the", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Incorrect calculation when simulating with multiple routes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In contracts/oracle/wasm/src/helpers.rs:145-160, the add_route_prices function loads the price source for the denom and multiplies it with the current price. This is incorrect because the third route assets currency is not considered. To illustrate, assume a price source is created with three route assets (e. g. ATOM => MARS => OSMO) while the base denom is congured as USDC. The rst route asset will be simulated in Astroport, making the price currency MARS. After that, the function loads the MARS price from storage and multiplies it, resulting in the price currency becoming USDC. The problem arises when multiplying with the third route assets price, OSMO. When the price source is retrieved, the price currency is expected to be OSMO, not USDC. The function will calculate the price as follows:   =               This is incorrect, because the price currency after the second route asset multiplication (MARS) is not denominated as the third route assets currency (OSMO). Consequently, introduces a aw in the calculation process. this discrepancy in the expected currency versus the actual currency", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Utilization rate can be exploited to surpass 100% for new markets", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In contracts/red-bank/src/interest_rates.rs:290-294, the utilization rate of a market is determined by the ratio of total debt divided by total collateral. If a new market is instantiated with zero deposits, an attacker can inate the utilization rate to steal funds from the contract. An exemplary step-by-step attack follows: 1. ATOM market is instantiated. 2. The attacker becomes the rst depositor and deposits 1 uatom, increasing the markets total collateral. 3. The attacker donates 1000 ATOM to the contract directly", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. The attacker receives around 84000 ATOM after 10 seconds due to the inated utilization rate. For more information on this type of attack, please refer to the Silo Finance Vulnerability Disclosure. A test case reproducing this issue is provided in the Appendix in the zero_deposit_poc test case. Recommendation We recommend limiting the utilization rate to a maximum value of 100%. Status: Resolved 4. Removing whitelisted denoms causes leftover rewards to get stuck", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "7. The attacker receives around 84000 ATOM after 10 seconds due to the inated utilization rate. For more information on this type of attack, please refer to the Silo Finance Vulnerability Disclosure. A test case reproducing this issue is provided in the Appendix in the zero_deposit_poc test case. Recommendation We recommend limiting the utilization rate to a maximum value of 100%. Status: Resolved 4. Removing whitelisted denoms causes leftover rewards to get stuck", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Duplicated denoms might cause incorrect whitelist counts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "contracts/incentives/src/contract.rs:173 In the execute_update_whitelist function does not dedupe denoms in the add_denoms and remove_denoms vectors. 187, and This is problematic because providing duplicate denoms to be added or removed would inate the whitelist_count variable, causing an incorrect state stored in the contract. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Oracle centralization risks with Fixed price sources", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In the current design, the owner can post arbitrary prices to the oracle using a Fixed price and source contracts/oracle/osmosis/src/price_source.rs381-392. not validated, and every value is accepted. contracts/oracle/wasm/src/price_source.rs:184-195 Prices are in This can be problematic since an attacker that gets access to the private key of the owner can arbitrarily manipulate prices without any restrictions. For example, the attacker could set the price of all assets to 0, which would allow the attacker to liquidate all users at their loss. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Misconguring tolerance value to be higher than window size causes incorrect price reported", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "the contracts/oracle/wasm/src/price_source.rs:316-321, In query_astroport_twap_price function iterates over all snapshots to nd those whose period falls within a specied tolerable window. This window is dened as the period ranging from the window size minus tolerance to window size plus tolerance. This calculation implies that the window size exceeds the tolerance period. Suppose the owner miscongures either the tolerance to be higher than the window size or the window size to be lower than the tolerance. In such situations, the above assumption will not hold, and the tolerable window period will not be eectively enforced. Consequently, the valid tolerable window period could be a value smaller than window size minus tolerance or higher than window size plus tolerance, aecting the nal price reported. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Removing price sources in the oracle could stop reward collector operations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In contracts/oracle/base/contract.rs:106, RemovePriceSource messages in order to remove price sources from the oracle. the contract owner can execute However, the removal of asset prices could have a detrimental impact on the operations of the swapper and reward collector contracts. Specically, in contracts/swapper/astroport/src/route.rs:91-92, the swapper retrieves oracle prices during a swap process. If the owner proceeds to remove the price source associated with the fee_collector_denom or the safety_fund_denom, the swap operation will encounter an error. This would render it impossible to carry out asset swaps within the reward collector.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Missing prerequisites check when adding a Pyth price source", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In and contracts/oracle/wasm/src/price_source.rs:184 contracts/oracle/osmosis/src/price_source.rs:381, when validating a Pyth price source, no validation is performed to enforce prerequisites. In fact, since Pyth prices are denominated in USD, a price source from USD to base_denom is needed in order to compute prices correctly. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/address-provider/Cargo.toml  contracts/incentives/Cargo.toml  contracts/oracle/base/Cargo.toml  contracts/oracle/osmosis/Cargo.toml  contracts/oracle/wasm/Cargo.toml  contracts/red-bank/Cargo.toml  contracts/rewards-collector/Cargo.toml  contracts/swapper/base/Cargo.toml  contracts/swapper/astroport/Cargo.toml  contracts/swapper/osmosis/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Funds in the swapper contract can be stolen", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In contracts/swapper/base/src/contract.rs:155-182, the swap_exact_in function swaps Coins dened in coin_in input parameter without checking that they are provided by the user in info.funds. This vulnerability enables potential attackers to seize all the coins within the contract by sending swap messages with specically chosen coin_in parameters. We classify this issue as informational because the swapper contract is not intended to hold any funds, as the TransferResult message will distribute all the funds out.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Unvalidated veto time lock duration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-01-10 Audit Report - DAO DAO Veto v1.0.pdf", "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:67 and 634, the timelock_duration is not validated to be an actionable duration for humans, i.e., very short and even zero durations are allowed. Consequently, this could lead to falsely executed proposals because the veto time lock duration is so short that it is de facto skipped even if it was congured. We classify this issue as minor because only the DAO, which is a privileged address, can congure the veto timelock duration. to also This contracts/proposal/dao-proposal-single/src/contract.rs:68, 653, and 967. applies issue", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. State migration is not implemented in the dao-proposal-multiple contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-01-10 Audit Report - DAO DAO Veto v1.0.pdf", "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:1030, the migrate entry point does not implement any state migration to update existing proposals to in is support contracts/proposal/dao-proposal-multiple/src/msg.rs:235-239. conguration. comment indicated veto This the in Consequently, migrating old dao-proposal-multiple contracts to use the latest version will cause proposals to fail to serialize and deserialize properly, causing the contract to fail to work as expected. We classify this issue as minor because the contract migration admin can recover this by implementing the state migration and migrating the contract into a new code ID.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Vetoer can execute only_members_execute proposals even if they are not part of the DAO", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-01-10 Audit Report - DAO DAO Veto v1.0.pdf", "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:466-473, the execute_execute function allows to execute proposals when config.only_members_execute is enabled. This allows the vetoer to execute the proposal early if veto_config.early_execute is true, as seen in lines 492-504. the vetoer However, if veto_config.early_execute is false and the proposal passes, the vetoer can execute it even if they are not one of the DAO members. We classify this issue as informational because the vetoer can only be congured by the DAO, which is a privileged address. Please see the test_veto_execute_only_members_execute_proposal test case in the appendix to reproduce this issue.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Potential inability to veto proposals if chain halts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-01-10 Audit Report - DAO DAO Veto v1.0.pdf", "body": "the In contracts/proposal/dao-proposal-single/src/proposal.rs:82-88, current_status function determines the proposal status by checking whether the current timestamp exceeds the proposal expiration and veto timelock duration. If it exceeds, the proposal is evaluated as Status::Passed. This is problematic because if a chain halt occurs and the chain is restarted, the current timestamp might already exceed the proposal expiration and veto timelock duration. In that case, the vetoer would not have time to react (e.g., to veto and cancel the proposal), allowing the proposal to be executed even if rejecting the proposal was the intended decision. This contracts/proposal/dao-proposal-multiple/src/proposal.rs:82. exists issue also in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Manually unpausing the hub contract after migration might lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2021-11-23 Audit Report - Lido Finance stLuna v1.2.pdf", "body": "The migration process described below has been implemented after the frozen commit for this audit. A change to the migration logic of the hub contract was necessary since a migration within one transaction ran out of gas. An audit of the updated migration logic has been performed on commit e04eb1313c481bdeae084a1dab064afdab5ddbae. the hub contract, During migration of to true in contracts/anchor_basset_hub/src/contract.rs:755, which leads to a rejection of all messages except updates of params and the migration of old unbond waitlist entries in line 137. a paused param is set In the current implementation, the contract must be explicitly unpaused by the owner when the migration is done. There is no validation that the migration has actually been fully performed though. If unpaused before the migration has been nished, partially migrated unbonding waitlist entries might be processed, which could cause missed waitlist entries without a way to recover. Additionally, the paused ag can be used at any time by the owner to pause/unpause the hub contract. If the owner key is ever compromised, ownership could be transferred and the contract paused, leaving any funds inaccessible. We classify this issue as minor since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Total liquidity tokens are incorrectly increased, causing lower rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In the contracts/incentives/src/astro_incentives.rs:241-247, decrement_staked_lp function increases the ASTRO_TOTAL_LP_DEPOSITS state amount instead of decreasing it. This is incorrect because this function is called when users withdraw in contracts/incentives/src/astro_incentives.rs:91. liquidity tokens their Consequently, the computed rewards will be less than intended due to the inated number of liquidity tokens (see contracts/incentives/src/helpers.rs:226-243), causing a loss of rewards for stakers.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attackers can bind vault account ID to forcefully cause a loss for users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "the bind_credit_manager_account In contracts/vault/src/execute.rs:22, function can only be called by the credit manager contract to bind the vault account ID. After binding it, users can interact with the vault to deposit and redeem their tokens with the accrued reward. vault address The issue is that anyone can call the CreateCreditAccountV2 message while specifying the (see contracts/credit-manager/src/execute.rs:69-87), allowing them to manage the funds deposited in the vault. Suppose an attacker gets control of the vaults account ID, and users start depositing funds. In that case, attackers can steal funds by purposely borrowing a huge amount of tokens and using another address to liquidate the vault for prot. bind to to it", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Liquidatees staking rewards are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In the contracts/credit-manager/src/liquidate_astro_lp.rs:47, liquidate_astro_lp function sends the UnstakeAstroLp message to liquidate the borrowers collateral from the incentives contract. The incentives contract will compute the rewards in contracts/incentives/src/astro_incentives.rs:346-353. credit manager them to contract, transfer seen and the as The issue is that the credit manager contract ignores the accrued rewards, causing a loss of rewards for the borrower. Instead, the borrower should receive the accrued rewards for the staked period even though they are liquidated. For comparison, the stake_lp function in querying after accrues contracts/credit-manager/src/stake_astro_lp.rs:17-36. incentives contract rewards user the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Users cannot stake new liquidity tokens on Astroport", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In the contracts/incentives/src/query.rs:95, query_unclaimed_astro_lp_rewards function dispatches a PendingRewards query message to Astroport to retrieve the number of rewards accrued by the incentives contract. This function is called to accrue user rewards before increasing their liquidity token balance, which inuences the reward amount. The issue is that the PendingRewards query assumes the incentives contract has staked liquidity tokens previously before calling the function. Otherwise, an error will occur when retrieving the position (see the query_pending_rewards and load_position functions). This means that the StakeAstroLp message will always fail for new liquidity tokens as Astroport assumes the incentives contract to have an existing balance, which is not the case. Consequently, users cannot stake their liquidity tokens on Astroport, breaking the protocols intended functionality.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Potentially outdated congurations stored in the vault", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In contracts/vault/src/instantiate.rs:37-46, the vault contracts init function sets the ORACLE, HEALTH, and ACCOUNT_NFT addresses to the query response of the credit manager contract. This is problematic because if the credit managers contract owner updates in these contracts/credit-manager/src/update_config.rs:31-91, they will not be reected in the vault contract. addresses values new to For example, if the oracle contract is unmaintained and updated to a new address, the vault contract could potentially be exposed to stale and incorrect prices, causing incorrect accounting.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Incorrect liquidity tokens unstaked for ActionAmount::Exact", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In the contracts/credit-manager/src/unstake_astro_lp.rs:32-41, unstake_lp function computes the amount of liquidity tokens to unstake by deducting the the amount from ActionAmount::Exact from the users balance. This is incorrect because when the user species ActionAmount::Exact, the user wants to withdraw the exact amount of liquidity tokens. indicates that it For example, if the users balance is 1000 tokens and ActionAmount::Exact is specied as 100, the unstaked amount is incorrectly 900 instead of 100 tokens.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Using AstroportSpot can introduce price manipulation risk", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "contracts/oracle/wasm/src/price_source.rs:401, option In query_price function using price to WasmPriceSource::AstroportSpot. However, consuming spot prices into Mars protocol can introduce price manipulation risk and should therefore be avoided. includes fetch spot the an a", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Vault unlock may revert because of cooldown end timing of a position", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In contracts/vault/src/execute.rs:209, it is required that the user-provided vault tokens are equal to the sum of the unlocked vault tokens. This sum is calculated by iterating over all positions where the eld cooldown_end is less than or equal to the current block timestamp. This logic can make it very dicult for a user to send the correct amount of tokens when the transaction is initiated at a time close to the cooldown_end value of a position. Then, the sum will vary depending on whether the transaction was included in a block that was produced slightly earlier or slightly later than this timestamp. If the amounts do not match, the user has wasted gas and needs to try unlocking again.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Duplicate code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In contracts/oracle/wasm/src/lp_pricing.rs:26-42 the code to fetch the price of coin0 and coin1 is duplicated in lines 157-173. Duplicate code can negatively aect the maintainability of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Inconsistent use of u32::from and as u32 for type conversion", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "contracts/oracle/wasm/src/lp_pricing.rs:118, is In coin0_decimals converted to a u32 type using u32::from(coin0_decimals), however, in contracts/oracle/wasm/src/lp_pricing.rs:218 the coin0_decimals is cast to a u32 type using coin0_decimals as u32.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Redundant check for !rewards.is_empty() in claim_lp_rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In the contracts/credit-manager/src/claim_astro_lp_rewards.rs:33, claim_lp_rewards function includes a redundant check !rewards.is_empty() since that check was already performed in line 19 of the same function.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Incorrect token referenced in comment", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In contracts/vault/src/execute.rs:182, there is a comment stating \"// check that only the expected base token was sent\". However, it is the vault token that is being passed to the cw_utils::must_pay function below the comment.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Unnecessary address lookup", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In contracts/incentives/src/astro_incentives.rs:290, the ensure_eq! macro checks that the sender is the credit manager. However, the credit manager is passed in the as credit_manager_addr variable could be used since that has been set earlier in line 284. This unnecessary address lookup is inecient. &addresses[&MarsAddressType::CreditManager] when, fact, in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Missing validations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "There are several instances where validation is missing:  In contracts/oracle/wasm/src/price_source.rs:219, the validate function returns the price variable for WasmPriceSource::Fixed option without validating that the price is greater than zero.  In contracts/credit-manager/src/stake_astro_lp.rs:26, if the variable amt is greater than a users LP coin balance, there will be an underow error in decrement_coin_balance.  In contracts/credit-manager/src/stake_astro_lp.rs:27, zero, coin_balance decrement_coin_balance. is there will be an underow error if in  In contracts/vault/src/instantiate.rs:64, the cooldown_period is not validated to be greater than zero.  In contracts/vault/src/instantiate.rs:75, the base_token address is not checked to be a valid address.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Redundant code setting accumulated_pnl and accumulated_fee to zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf", "body": "In contracts/vault/src/performance_fee.rs:72, the accumulated_pnl and accumulated_fee are set to Uint128::zero(). However, this is redundant since these values will already be set to Uint128::zero() in the default function.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Disabled collateral can be re-enabled by depositing on behalf of the user", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/red-bank/src/execute.rs:471, the users collateral to market bit is automatically set if the user deposits a collateral asset. An attacker can re-enable a disabled asset as collateral by depositing a small number of funds on behalf of a victim. As a result, the re-enabled collateral will get liquidated if the borrower does not maintain the sucient liquidation threshold ratio. This might cause an unexpected loss to the victim since they disabled the asset as collateral. Please see the test_enable_asset_as_collateral_for_other_users test case in the appendix to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Swapping assets in the reward collector contract are vulnerable to sandwich attack", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/rewards-collector/osmosis/src/route.rs:121, the minimum amount of swap output is hardcoded to zero. Due to no slippage protection, an attacker can the normal price, calling the perform a sandwich attack by purchasing the asset at SwapAsset operation to buy the asset at an increased price, then immediately selling it for a prot. The attacker can repeatedly perform this attack to force the contract into buying assets at a higher price, resulting in a loss of funds.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Red banks markets with an id greater than 128 cannot be used", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "The red bank contract can handle an indenite amount of Markets that are created by the contract owner and stored in the MARKETS mapping. Each Market struct has a unique index attribute that is responsible for indicating its bit position in borrowed_assets and collateral_assets bitmaps dened in the User struct. Since those bitmaps are Uint128, they can handle a maximum of 128 Markets. This implies that any Market with an index greater than 128 cannot be used because of an overow in contracts/red-bank/src/helpers.rs:29.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Incorrect refund address during debt repayment", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "the caller The repay function allows repayment of a loan on behalf of other accounts. In a scenario where in account contracts/red-bank/src/execute.rs:843, refund the excess amount to the target address passed in the on_behalf_of parameter and not the caller. This implies that the party repaying the loan will lose funds to the debtor. behalf the function will overpays another debt on of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Computationally heavy unbounded loop during user position health calculation can lead to out-of-gas execution", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "contracts/red-bank/src/health.rs:121, In get_user_positions functionality attempts to loop over all markets initialized in the red bank contract. Since the is unbounded and markets cannot be removed, the execution gets more market count expensive with the number of markets and might eventually run out of gas if there are too many markets initialized. the This issue is also present in the UserDebts and UserCollaterals query messages in contracts/red-bank/src/query.rs:123-149 and 164-180. The queries attempt to loop through all markets without any pagination limit.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Address provider contract does not validate the newly set owner as valid address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/address-provider/src/contract.rs:77, the contract owner is set to the new_owner string provided by the caller. If the new owner is not a valid address, it will cause the address provider contract to have an invalid owner. As a result, it would prevent the SetAddress and TransferOwnership functionality from working correctly. We consider misconguration. this a minor", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Users will be unable to claim rewards if too many asset incentives are added", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In the incentives contract, users can call ClaimReward to retrieve their accrued Mars rewards. The message is handled by the compute_user_unclaimed_rewards function in line contracts/incentives/src/helpers.rs:84 which loops through all the asset incentives. On a long enough timeframe, if many assets get added to the protocol, this gets more expensive and could eventually run out of gas and hence block claiming of rewards for a given user.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Addresses are not validated if a wrong prefix is set in the address-provider contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "contracts/address-provider/src/helpers.rs:11, the In assert_valid_addr function is executed, all addresses that start with a prefix dierent from the stored one are assumed to be valid without executing api.addr_validate. when This implies that invalid addresses can be stored in the contract mapping and that the check on the given prefix can be bypassed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Setting price source for liquidity token aects Prices query message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/oracle/osmosis/src/price_source.rs:125-127, the liquidity token price source cannot be queried as it will return an Unimplemented error. However, the contract owner can add a liquidity token price source in lines 97-99. This means that the Prices query message would be aected since it includes the liquidity token price source when querying. Note that users can manually avoid querying the LiquidityToken price source by ltering out the aected entry with the start_after and limit arguments. Please see the  test_query_liquidity_token_prices test case in the appendix to reproduce this issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Markets reserve_factor attribute is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In packages/outpost/src/red_bank/market.rs:79, the validate method for the Market struct is not checking reserve_factor. Since this attribute represents the percentile of the borrow rate that is kept as protocol rewards, a value greater than one could cause the execution to distribute an incorrect amount of funds. We consider this issue to be minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Contracts are not compliant with CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "The following contracts do not adhere to the CW2 Migration specication standard:  address-provider  oracle  incentives  red-bank  rewards-collector This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Unversioned dependencies could lead to supply chain attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "oracle The contracts/oracle/osmosis/Cargo.toml:37. requires contract osmo-bindings as a dependency in Since it is fetching it directly from the GitHub repository without specifying the wanted commit hash or tag, any changes to that repositorys main branch may accidentally be included in the contract. This could lead to bugs as well as supply chain attacks.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. optimal_utilization_ratio value could cause a division by zero panic if not correctly validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In the packages/outposts/src/red_bank/interest_rate_model.rs:35, divide_decimal_by_decimal is dividing the current_utilization_rate by optimal_utilization_rate. Since optimal_utilization_rate is not validated to be greater than zero, this division could cause a panic.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Zero Mars token code identier will lead to InitAsset failures", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/red-bank/src/execute.rs:60, when conguring the Mars token code identier, it is not validated to not be zero. If the code identier is congured as zero, it will cause the InitAsset functionality to fail. This issue is also present in line 103 when updating the conguration.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Liquidator is unable to specify the receiver address which negatively impacts integrations and exibility", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/red-bank/src/contract.rs:72, there is no way for the liquidator to specify the recipient address for receiving underlying collateral. This will add overhead for periphery contracts to specify the logic for redirecting the liquidated assets transfers to rightful liquidators.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Avoid meaningless conguration update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/oracle/base/src/contract.rs:113, the contract owner can update the execution will be the conguration with the owner value as None. As a result, to the meaningless because the option_string_to_addr functionality will default original conguration owner. This would cause no changes to be modied in the end.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. InvalidDepositAmount validation during red bank deposit can be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/red-bank/src/execute.rs:459-464, the check ensures the deposit amount is not zero when depositing in the red bank. This check is unnecessary as the one_coin functionality from cw_utils already prevents zero amounts, as seen in contracts/red-bank/src/contract.rs:53.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/address-provider/Cargo.toml  contracts/oracle/base/Cargo.toml  contracts/oracle/osmosis/Cargo.toml  contracts/incentives/Cargo.toml  contracts/red-bank/Cargo.toml  contracts/rewards-collector/base/Cargo.toml  contracts/rewards-collector/osmosis/Cargo.toml While enabled implicitly through the workspace manifest, future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Contracts should implement a two step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "20. TWAPs are more sensitive to manipulation than median prices in \"one-block\" attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In a \"one-block\" attack, an attacker manipulates the price of an asset and then arbitrages it back in the next block. This type of attack is possible when the attacker knows in advance to be the creator for the next block (e.g. the attacker is a validator in PoS blockchains with deterministic slots) since the validators can order transactions to minimize the risk of the attack. Because TWAPs are calculated using the time-weighted average of prices, a \"one-block\" attack will have a greater impact on the TWAP calculation than on the median price. This is because the manipulated price will be included in the TWAP calculation, whereas it will not aect the median price. Therefore, TWAPs are more sensitive to manipulation than median prices in \"one-block\" attacks.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "21. Custom access control implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "Contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Bad debt state is not recorded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "In contracts/margined_engine/src/messages:185, the withdraw function called when executing the WithdrawMargin message is updating the bad_debt attribute of the state. As state is passed as a &mut, the withdraw function caller has in the state variable the updated bad_debt value. The state is not stored though, hence the new value is available only in the current execution scope and cannot be retrieved in a subsequent execution. Consequently, the bad_debt information is never saved in the contract store, and the information is lost. This implies that the margined_engine could be insolvent or with an insolvency risk without being aware. Additionally, the State query, which will be used to track the margined_engine status, would always report the bad_debt metric to be lower than the real accrued debt. See Appendix-1 for a test case that shows this issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Incorrect accounting during liquidation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "The margined engine contract incorrectly keeps track of the funds that should be requested or sent to the insurance funds contract upon liquidation. of the case liquidation_fee In in contracts/margined_engine/src/reply.rs:458, remain_margin.margin is not set to zero at the end of the if block, eectively being used rst in the calculation of bad_debt and later on the transfer of remaining margin at line 474. This results in the engine contract unexpectedly moving additional funds to the insurance fund contract. remain_margin.margin > if there is no previously recorded state.bad_debt and the engine contract In addition, doesnt have enough funds to pay a liquidator, the missing amount would be withdrawn twice from the insurance fund contract: The rst during realize_bad_debt in line 468 and a second time during withdraw in line 479. Given the Bad debt state is not recorded issue, this could cause the Insurance Fund contract to be drained faster than expected, potentially causing insolvency issues if not watched carefully. Additionally, these extra transfers incremented gas costs on every transaction related to the aected feature. See Appendix-3 for a test case that shows this issue.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Bad debt is wrongly reset upon realization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "the in When realize_bad_debt non-zero is contracts/margined_engine/src/utils.rs:81 state.bad_debt value, instead of updating it with any additional bad_debt and withdrawing funds from the insurance fund contract, it is reset to zero and no transfer from the insurance fund is requested. This implies losing track of any previous debt and not covering the new one given the lack of withdrawal from the insurance fund. function called with a Consequently, the contract could be at an insolvency risk without the team being aware as the bad_debt value being reported would be lower than the real accrued debt.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Possible inconsistencies when conguring decimal values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "values decimal In both margined engine and virtual AMM contracts, contract instantiators are required to in specify and contracts/margined_engine/src/contract.rs:62-66 contracts/margined_vamm/src/contract.rs:40. There is no validation that ensures both values are same and consistent with each other when conguring and updating the decimal values via contracts/margined_engine/src/handle.rs:83. If both it will yield incorrect results when executing contracts assume dierent decimal values, SwapInput and SwapOutput, potentially returning a higher or lower output amount than intended that directly aects trader's position size. seen as the MAX_ORACLE_SPREAD_RATIO in Moreover, contracts/margined_vamm/src/contract.rs:26 is represented as 10% with 8 decimal values, meaning that the intended decimal values should be 9 (100_000_000 / 0.1 = 1_000_000_000). Since the constant value cannot be modied, a misconguration of decimals in contracts/margined_vamm/src/query.rs:230 to return an incorrect spread limit exceeded result. query_is_over_spread_limit constant would cause being not that, native token decimals Besides seen in packages/margined_common/src/asset.rs:191. This collides with the virtual AMM satisfy intends decimals MAX_ORACLE_SPREAD_RATIO constant value. are assumed as 6 as requirement decimals accept values since to to it", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Margined engine cannot support native tokens as collateral during mainnet production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "In the packages/margined_common/src/validate.rs:28-33, validate_eligible_collateral functionality only recognizes ujunox and uwasm as supported native tokens when conguring and updating eligible collateral assets. Since ujunox prex only exists in Juno Testnet and uwasm prex originates from wasmd, the hardcoded native tokens will not be usable during production as they dont exist in the Juno mainnet. Also, as not all native tokens follow the utoken convention and could have a custom decimal digits in packages/margined_common/src/asset.rs:191 could lead to possible wrong calculations. representation, hardcoded value 6u8 the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Emergency ShutdownVamms messages are not able to execute SetOpen transactions due to lack of permissions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "In contracts/margined_insurance_fund/src/handle.rs:78, when handling ShutdownVamms messages, the execution is iterating through all the VAMMs registered in the insurance_fund in order to send VammExecuteMessage::SetOpen { open: false } messages to them. Those messages are wrapped in a SubMsg and have the purpose of pausing that specic VAMM. the SetOpen However line contracts/margined_vamm/src/handle.rs:98 that is only accepting transactions intended to be the insurance_fund contract. from its registered Owner that Consequently all the SetOpen SubMsg will fail due missing Owner role permissions. message handler is not guard has at a", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Updating eligible collateral causes state inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "the contract owner can In contracts/margined_engine/src/handle.rs:73-84, update the eligible collateral, which also updates the decimal values accordingly. This is problematic for the following reasons: Firstly, it would cause a state inconsistency issue. The actual balance held in the contract for the newly congured eligible collateral might be dierent than the recorded state. As a result, traders might be unable to withdraw excess margin due to insucient balance. Secondly, it causes a decimal collision issue as the virtual AMM that the margined engine contract interacts directly with is unable to have the decimal values updated. This causes inconsistencies between the two contracts and will be further elaborated on in the next section. is the than previous it would cause incorrect ratios and liquidation fees if the newly congured decimal Lastly, initial_margin_ratio, value. lower value maintenance_margin_ratio, and liquidation_fee values use decimal value as limit (i.e. 0% to 100%), a lower decimal congured will cause ratios and liquidation fees to exceed the 100% limit. For example, if the previous decimal value is 9 and the new eligible collateral uses 6 decimals, a congured 10% ratio or liquidation fee would become 10000%, which will likely cause all positions to be undercollateralized due to contracts/margined_engine/src/handle.rs:284. partial_liquidation_margin_ratio Since We classify this issue as minor, since only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Insurance fund beneciary can be updated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "The insurance fund contract allowed its owner to update the beneciary at any time as seen in contracts/margined_insurance_fund/src/handle.rs:36. A malicious insider or an attacker that compromised the keys of the legitimate administrator would be able to set themselves as the beneciary and then withdraw the contracts funds. We classify this issue as minor since only the owner can update the insurance fund beneciary and it is assumed that the owner is a trusted party.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Acknowledged 56. Hardcoded packet version for cross-chain requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Voyager Forwarder and CW Gateway v1.2.pdf", "body": "In asset-forwarder-middleware:contracts/asset-forwarder/src/execution .rs:198, 303, and 697, a hardcoded version is used when constructing the cross-chain call packet for dierent withdrawal scenarios, such as withdrawing blocked funds or refund requests. This may cause inconsistency and potential issues in the future when it is processed by the counterparty chain. For example, the counterparty chain might reject the request due to version mismatches if a dierent packet version is accepted instead.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Deactivated market assets would cause forced liquidation on borrowers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "In mars-red-bank/src/account.rs:61, the function get_user_position is used internally to calculate the borrowers debt, average liquidation threshold and most importantly the health factor which determines whether the borrower can be liquidated. The function iterates over all assets in that the borrower has a position, without accounting in the markets active state. If a market is deactivated, borrowers will be unable to perform any actions on it including repaying their loans. the market asset This would cause problems if the borrower is borrowing had been deactivated by the contract owner. The debt of the inactive market would still be included when calculating the overall health factor for the borrower. Although the deactivated market asset prevents liquidation attempts, a liquidator can still bypass it by liquidating other active collateral assets. Hence, the borrower would be subjected to forced liquidation due to the inability to repay their loans.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Staking xMars rewards can be sandwiched by an attacker, skimming its value before accruing to stakers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "Protocol rewards can be swapped and transferred by anyone to the Staking contract. A combination of public messages executed in one transaction can be leveraged by an attacker to skim the rewards of xMars stakers as shown below: 1. Withdraw Mars rewards (or ma_mars) using mars-protocol-rewards-collector/src/contract.rs:187. execute_withdraw_from_red_bank from the Red Bank to the Protocol Collector in 2. Sell assets if you have Mars/maMars inventory", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Sell MARS bought in step 4. This can be also exploited with rewards denominated in assets other than Mars, but the severity of this performed on Mars rewards is greater due to steps 6 and 7. Recommendation We recommend either rate-limiting/restricting the access of these public functions, or allowing the Protocol Rewards Collector to send rewards directly in the denomination they are withdrawn from the Red Bank, and swapping them back to Mars on the Staking contract without the intermediate swap to UST. Status: Acknowledged The Mars team is working on ideas to solve this on future versions of the protocol that the community could adopt. In the meantime, the community would have to evaluate the risk of adding Mars as a borrowable asset to the money market. At rst most fees will be collected in uusd which would only be swapped to Mars in the case of staking which would make the window for this attack small. 3. Malicious smart contracts can avoid liquidation attempts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "7. Sell MARS bought in step 4. This can be also exploited with rewards denominated in assets other than Mars, but the severity of this performed on Mars rewards is greater due to steps 6 and 7. Recommendation We recommend either rate-limiting/restricting the access of these public functions, or allowing the Protocol Rewards Collector to send rewards directly in the denomination they are withdrawn from the Red Bank, and swapping them back to Mars on the Staking contract without the intermediate swap to UST. Status: Acknowledged The Mars team is working on ideas to solve this on future versions of the protocol that the community could adopt. In the meantime, the community would have to evaluate the risk of adding Mars as a borrowable asset to the money market. At rst most fees will be collected in uusd which would only be swapped to Mars in the case of staking which would make the window for this attack small. 3. Malicious smart contracts can avoid liquidation attempts", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Initializing vesting contract wrongly would cause inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "In the Vesting contract, congurations such as unlock_start_time, unlock_cliff and unlock_duration are congured during contract initialization. There are no validations in place to verify submitted values are correct, eg. unlock_start_time must be a timestamp in the future instead of the past.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Duplicate accounts creation would cause inconsistent total supply", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "In the xMars token contract, accounts are created via create_accounts during contract initialization. As shown in contracts/mars-xmars-token/src/contract.rs:53-62, the function loops through a set of accounts without verifying possible duplications. If the accounts contain any repeated address, the previous balance would be overwritten but the total_supply would increase, creating a discrepancy between the two.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Sent tokens other than denoms are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "are then In the Red Bank contract, users can deposit native assets via DepositNative message. The coins called get_denom_amount_from_coins. The function does not limit user sent funds to exactly one type of funds. If the user sent two types of funds (eg. LUNA and UST), the other assets which are not denom would be lost in the contract. function internal parsed which from an is", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Expiration can be set to past timestamp and block height", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "In the Ma-token contract, IncreaseAllowance and DecreaseAllowance allow specifying an Expiration via block height or block timestamp. The specication does not verify whether the supplied Expiration value is higher than the current timestamp or block height. Users may set the expiration value to a past timestamp or block height, which causes the approval to fail.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Overow checks are not enabled for the release prole, which can lead to a loss of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "In contracts/cw20-blocklist/Cargo.toml, overflow-checks are not enabled for the release prole. Since there are arithmetic calculations that do not use checked increasing an calculations to prevent overow issues in the cw20-base contract accounts balance), an overow in production would be silently ignored. (e.g.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Users can evade having blocked funds destroyed by using uppercase addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "The cw20-blocklist contract does maintain the blocklist with lowercase addresses, and it performs lowercasing of an address before checking whether it is on the blocklist. The underlying cw20-base contract, on the other hand, does not lowercase addresses. This discrepancy allows users to evade having blocked funds destroyed, by having their balance sent to an uppercase address, rather than a lowercase one. If a user sends the the Transfer message to a previously unused and not blocked uppercase address, execute_transfer function of the cw20-base contract will update BALANCES with the uppercase address as the key. Blocklisting that address works as expected, since all blocklist see checks If the minter contracts/cw20-blocklist/src/contract.rs:195, 211, and 254. now wants the address DestroyBlockedFunds message, the destroy_blocked_funds function is trying to reduce BALANCES using the lowercased address as a key in lines 160-168. This will fail, since the balance was stored under an uppercase address as the key. associated with transforming lowercase, performed address funds using burn after that are the the to to", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Missing validations during contract instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "In contracts/cw20-blocklist/src/contract.rs:36-38, msg.name, msg.symbol, and msg.decimals are not validated. the passed arguments Without validation of name and symbol, the minter is able to pass invalid or non-printable characters that could aect front-end rendering, allow script injection, or passing strings very long strings which may inhibit usability of the token. Without validation of decimals, the minter is able to pass any supported u8 value (from 0 to 255). An uncommonly large decimal point might cause issues for protocols that build on top of this contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. One-step minter update increase risk of lost minter permissions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "The cw20-blocklist contract allows the current minter to update the minter address in one single step. While this is common practice, it presents a risk for the minting permission to become lost if the new address is incorrect. A two-step minter update will allow the current minter to propose a new minter address, and then the account that is proposed as the new minter may call a separate function that will allow them to claim the minting permission and actually execute the cong update.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Consider using time locks to automatically unblock addresses in the event of a lost/compromised minter private key", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "Throughout the codebase, the minter can perform various privileged actions such as adding and removing addresses to/from the blocklist. A blocked address will remain blacklisted until the minter decides to unblock them. In the event that the private key is lost or compromised and the minter updated, the blacklisted address may never be unblocked.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Blocked addresses can receive tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "In the codebase, there are no restrictions that prevent blocked addresses from receiving tokens. Since the minter can destroy funds held by a blocked address using the DestroyBlockedFunds message, we recommend disallowing funds to be sent to a blocked address.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Removal of Burn and BurnFrom may impact contract composability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "The cw20-blocklist contract does not include the Burn and BurnFrom messages that the cw20-base contract provides. This may impact composability of the cw20-blocklist contract with other smart contracts, In the current implementation, a Redeem message exists, that only allows the minter to burn tokens. that may rely on burning of funds.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Duplicate code impacts maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "Throughout the codebase, privileged execution messages such as AddToBlockedList, RemoveFromBlockedList, UpdateMinter, Redeem, and DestroyBlockedFunds messages are all restricted to minter access. The logic that veries whether info.sender is the minter is duplicated across the handlers for these functions, which negatively impacts the code's maintainability and readability and may lead to future errors.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. cw20-blocklist modies cw20-base interface, which negatively impacts composability and is not documented correctly", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "Compared with the cw20-base contract, following modications: the cw20-blocklist contract exhibits the Initial balances cannot be provided during instantiation 1. Minter is always set to the instantiator 2. Minting cap cannot be set 3. 4. Marketing info cannot be set or queried 5. Burn and BurnFrom messages have been removed 6. Minter, AllAllowances, AllAccounts, MarketingInfo, and DownloadLogo queries have been removed This reduces the composability of the cw20-blocklist contract, since it may not be possible for some projects to swap a cw20-base contract with a cw20-blocklist It also aects frontends and implementation without aggregation layers that may rely on some of the removed queries. Lastly, the documentation in contracts/cw20-blocklist/README.md:3 describes that the cw20-blocklist further modication of their code. contract extends the cw20-base to add blocklist functionality, which is misleading.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Testing wallet seed phrase and private keys are exposed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "In keys.terrain.js, the testing wallets mnemonic and private keys are hardcoded and visible to the public. Although these secrets are intended to be used purely for testing purposes, it is a violation of best practice to commit wallet seed phrases or private keys into a repository. These accounts may accidentally be used by developers on mainnet, in which case funds may be lost or permissions be exploited.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Outdated dependencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "The cw20-blocklist contract contains outdated dependencies, see Appendix 1.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. Inconsistency between evidence and staking parameters allows malicious validators to escape penalties", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-06-13 Audit Report - Dora Vota v1.0.pdf", "body": "In the staking module conguration of the mainnet genesis le, the unbonding_time is set to 1,814,400 seconds (21 days). in config/mainnet/genesis.json:12 the max_age_duration within the However, evidence module parameters is set to 172,800,000,000,000 nanoseconds (2 days), which is a magnitude shorter. in config/mainnet/genesis.json:11, the max_age_num_blocks is Additionally, congured to 100,000, which translates to 600,000 seconds (approximately 6.94 days), assuming a 6-second block time. This duration also falls short of the specied unbonding_time. These discrepancies mean evidence can only be reported during a fraction of the unbonding period, allowing validators who have committed oenses to escape penalties if the evidence expires before the end of the unbonding period.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Unhandled zero-amount transfers in marketplace contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "In several occurrences when performing BankMsg::Send, there is no validation to ensure the amount to transact is greater than zero. Consequently, the transaction will fail and revert. 1. 2. 3. 4. contracts/marketplace/src/execute.rs:1209-1216 the contracts/reserve-auction/src/helpers.rs:143-146, In settle_auction function will fail if the remaining amount is zero after deducting the protocol and royalty fees. In packages/common/src/lib.rs:78-82, the royalty_payout function will fail if the royaltys share is zero. In 1223-1230, deducting the royalty, network, and nder fees. lines In and 1074-1081, the value of execute_remove_stale_collection_bid functions will params.bid_removal_reward_percent is set to zero or to the maximum bps value. lines if the remaining amount is zero after execute_remove_stale_bid if contracts/marketplace/src/execute.rs:1023-1030 the payout function will fail and and the fail", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Validate that the amount is not zero before sending funds to the bidder and operator. Status: Resolved 2. Protocol does not enforce minimum reserve price to be in STARS denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "In contracts/reserve-auction/src/helpers.rs:131, the fair_burn function is called to burn a portion of the bid amounts, expecting the bid denom to be STARS. This is problematic because there is no validation ensuring that config.min_reserve_price is in the STARS denom. Additionally, when settling the auction in lines 143-146, the settle_auction function distributes the config.min_reserve_price is denominated in a dierent denom, incorrect funds will be distributed instead. Consequently, denom. STARS funds with the if", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. MAX_FIXED_PRICE_ASK_AMOUNT is not enforced during ask price update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "In the contracts/marketplace/src/execute.rs:412, execute_update_ask_price function does not validate the price.amount does not exceed MAX_FIXED_PRICE_ASK_AMOUNT. This invariant is enforced in line 308 during the execute_set_ask function, but it is not enforced when updating the asking price.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. TODO comment in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "In packages/common/src/lib.rs:65, a TODO comment is in the codebase. TODOs in production code are a deviation from best practices.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Duplicate nder fee validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "contracts/marketplace/src/execute.rs:474-478 In duplicate validations of finders_fee_bps are performed. and 484-488, In fact, the only dierence lines between these two checks are variable names (fee vs finders_fee_bps), but validations are identical. the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Reserve prices can be updated for expired auctions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "the contracts/reserve-auction/src/execute.rs:158, In execute_update_reserve_price function does not validate whether the auction is expired. An expired auction should not be modiable.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Static calculation of weights for the claim_reward extrinsic enables DoS attack vector", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "claim_reward The in pallets/lend-market/src/lib.rs:782-800, iterates over all the existing markets to collect rewards from each of them. function, dened However, since the number of registered markets is not bounded, the execution could exceed the computation limit if too many markets are registered. Since the calculation of the extrinsic weights does not take into account the cardinality of the markets, the fee charged to the origin will be uncorrelated with the actual computational resource usage. This leads to a situation where the execution of multiple claims within the claim_reward extrinsic will cost the same as a single claim done with the claim_reward_for_market extrinsic. Consequently, attackers could leverage this behavior to overload chain nodes by executing claim_reward on multiple markets paying a smaller fee, potentially allowing a denial-of-service attack.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Price feeder centralization risks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In the prices pallet, the FeederOrigin can set arbitrary emergency prices by executing the in reset_price pallets/prices/src/lib.rs:120-143. set_price extrinsics dened and However, prices are not validated before being stored and every value is accepted. As a consequence, this could lead to the following scenarios: 1. Privilege abuse: An attacker may get access to the private key of the FeederOrigin. He can then use the account to manipulate prices, for example by setting the price for all assets to a small value, which would allow the attacker to liquidate all users at their loss. 2. Input error: Since the provided Price is not validated, provided as input and stored in the contract. Even a Price equal to zero is allowed. incorrect values could be We classify this issue as minor since only a privileged account can perform the aforementioned operations.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Multiple foreign_asset_id can be mapped to the same asset_id", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "the set_foreign_asset extrinsic In pallets/prices/src/lib.rs:149-157, permits the UpdateOrigin origin to establish a mapping within the pallet, associating a foreign_asset_id with an asset_id. However, it lacks a verication mechanism to ensure that the given asset_id is not already linked to a dierent foreign_asset_id. As a result, an asset_id can be associated with multiple foreign assets which would lead to market miscongurations. We classify this issue with minor severity since only a privileged account can perform the aforementioned operation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Missing check that foreign_asset_id is specically of the ForeignAsset type", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In pallets/prices/src/lib.rs:149-157, the set_foreign_asset extrinsic enables the UpdateOrigin origin to establish a mapping within the pallet that associates a foreign_asset_id with an asset_id. However, ForeignAsset type; it is only identied as a CurrencyId. it does not verify that the provided foreign_asset_id is specically of the As a result, the UpdateOrigin can map any asset type, not just foreign assets. We classify this issue with minor severity since only a privileged account can perform the aforementioned operation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Default mantissa precision can lead to an incorrect price", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In pallets/prices/src/lib.rs:179-186, the get_asset_mantissa function is designed to calculate the mantissa for a given asset by attempting to retrieve the asset's decimal precision from multiple sources. However, if it fails to nd any decimal information for the specied asset_id, it automatically assumes a default precision of 12 decimals. As a result, this approach poses a risk, as the function plays a crucial role in asset valuation, and an incorrect mantissa calculation would lead to the determination of an erroneous price.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Missing validation for the lend_token_id", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "pallets/lend-market/src/lib.rs:656-680, In the force_update_market function enables the UpdateOrigin to assign a new lend_token_id to a specied market. However, it fails to verify whether the lend_token_id is not already a market, a validation that is performed in the ensure_lend_token method in line 1843. As a consequence, this oversight could lead to inconsistencies in market conguration since the lend token is not designed to be used in a market. We classify this issue with minor severity since only a privileged account can perform the aforementioned operation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. The force_update_market extrinsic could break existing markets", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In pallets/lend-market/src/lib.rs:659, the force_update_market function permits the UpdateOrigin to forcibly replace an existing market with another, without ensuring the coherence of the provided data. This poses a risk since UpdateOrigin is allowed to modify markets with any data, including malicious ones that could break invariants. As a consequence, the current approach could result in the acceptance of markets with a collateral_factor or liquidation_threshold outside of the [0,1] range, which could break market operations and potentially cause a loss of funds. We classify this issue as minor since only a privileged account can perform the aforementioned operation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Static calculation of weights for the update_liquidation_fee_collateral extrinsic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "the pallets/lend-market/src/interest.rs:1123-1130, In update_liquidation_fee_collateral extrinsic takes a collaterals vector as a parameter. However, the calculation of the extrinsic weights does not take into account the length of the collaterals vector. As a result, the update_liquidation_fee_collateral extrinsic will charge the same fee for vectors of dierent sizes leading to an uncorrelated relation between fees and computational resource usage. We classify this issue as minor since only a privileged account can perform the aforementioned operation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Missing validation of liquidate_incentive_reserved_factor during market update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In pallets/lend-market/src/lib.rs:381 the add_market function checks the correct including liquidate_incentive_reserved_factor. This value is forced to be in the (0,1) range. provided market parameters, allowed ranges the for However, pallets/lend-market/src/lib.rs:610, this validation is not performed. update_market function the in in a consequence, when As the updating the market, liquidate_incentive_reserved_factor value outside the (0,1) range, which will have implications in the form of incorrect calculations of incentives when liquidating positions in within liquidated_transfer pallets/lend-market/src/lib.rs:1757. is possible function to set the it We classify this as minor since only a privileged account can perform the aforementioned operation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Incorrect interest is calculated if requested before market initialization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In pallets/lend-market/src/interest.rs:58, the get_market_status function calculates and returns information about the queried market. However, in case the market has not been used yet, the last_accrued_interest_time variable, when retrieved in line 75 from the LastAccruedInterestTime on-chain storage, would default to zero. Consequently, when get_market_status is called without the market being previously initialized, the interest accrual period is inaccurately computed from January 1, 1970, despite the asset not being used yet leading to a wrong calculation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Inecient active markets search", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "ensure_active_market The in pallets/lend-market/src/lib.rs:1801-1806, searches for a market by comparing identiers one by one in a loop through all markets with an asymptotic complexity of O(n). function, dened However, the same operation could be performed in constant time by using the market method, dened in pallets/lend-market/src/lib.rs:1946. Consequently, this would cause the execution to incur higher costs due to unnecessary iteration.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Inecient market data aggregation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "get_lf_base_position The in pallets/lend-market/src/lib.rs:1145-1151 iterates through all active markets, aggregating collateral for underlying assets. function, dened However, current_collateral_balance function in line 1407. the markets queried are not retained, despite being re-queried later by the Consequently, this would cause the execution to incur higher costs due to unnecessary calculations.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Redundant storage queries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "The pallets/lend-market/src/lib.rs le exhibits redundant uses of on-chain storage. For instance, the AccountDeposits storage, introduced at line 315, undergoes redundant queries in lines 945-946, 1280-1283, 1312-1315, and 2105-2106. In each case, the storage is rst checked for the key's presence, followed by a separate query to fetch the key's value. Another example of redundant queries can be seen in line 1146, where the storage query the loop Self::liquidation_free_collaterals is called on every iteration of despite having the same value on each iteration. Minimizing the number of storage queries would enhance both performance and code clarity.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Code duplication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "The pallets/lend-market/src/lib.rs le contains multiple code duplicates: 1. The code fragments in lines 1144-1152 and 1158-1166 are nearly identical, with the only distinction being the function called on the iterated values: and collateral_asset_value liquidation_threshold_asset_value (line 1163) in the other. instance 1149) (line one in 2. The code fragments in lines 1312-1325 and 1280-1293 are nearly identical, with the only distinction being the type parameter: BalanceOf in one instance and FixedU128 in the other. Code duplication undermines maintainability, thereby expanding the potential for security vulnerabilities.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. The get_special_asset_price function consistently returns None", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In pallets/prices/src/lib.rs:188, the get_special_asset_price function is designed to return a TimeStampedPrice value, but it consistently returns None instead. As a consequence, this behavior is misleading and renders the function ineective.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Inecient reduce_reserves extrinsic execution in case of reduce_reserves parameter equal to zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In pallets/lend-market/src/lib.rs:1045, the reduce_reserves extrinsic takes reduce_amount as a parameter. However, if this amount is zero, the function will perform all operations unnecessarily, which is inecient and may be misleading to the function caller.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Use of magic numbers decreases maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  pallets/lend-market/src/farming.rs:28  pallets/lend-market/src/rate_model.rs:173", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. State change events are emitted even if no change has occurred", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "In and pallets/lend-market/src/lib.rs:778 pallets/lend-market/src/lib.rs:678, when updating market parameters, the event about success is emitted regardless of whether anything has been changed. If none of the optional values are specied, then the function will end without changing the state, but the MarketRewardSpeedUpdated or UpdatedMarket event will be emitted, which is inconsistent with the function's logic.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Miscellaneous comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf", "body": "Miscellaneous recommendations can be found below:  In pallets/lend-market/src/lib.rs:1894 there should be an Overflow error, not an Underflow one, causing exchange_rate to be between (0.02, 1) range, so the division of amount value and exchange_rate could cause overow only.  In pallets/lend-market/src/lib.rs:959, it should be used asset, instead of assert.  In pallets/leverage-staking/src/lib.rs:129, NotSupportTokenType should be reworded to NotSupportedTokenType.  In pallets/lend-market/src/interest.rs:141, the inequality should be greater than or equal to 0.02, not only greater, based on code implementation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Wallet fees can be circumvented", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "function The contracts/core/factory/src/service/create.rs:26 user-provided proxy_initial_funds as an argument. create_wallet calls ensure_enough_native_funds by passing in the Subsequently, the ensure_enough_native_funds function iterates through these funds and adds the wallet fee to the entry in proxy_initial_funds which has the same denom as the wallet fee. However, the code does not check that proxy_initial_funds contains such an entry. If it does not, the wallet fee is not added to the vector required_funds and no check is in place whether the user has sent the expected funds. logic This proxy_initial_funds that does not contain an entry with the fee denom. fee by dening a allows users the wallet to bypass vector of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Full-featured wallet creation may run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "create_wallet The in factory/src/service/contract.rs:22-30 within the factory contract has the potential to execute a substantial number of operations in case of full-featured walled creation, posing a risk of running out of gas during execution. function dened The following steps are executed within the create_wallet function: 1. Two messages are dispatched: One for instantiating the proxy contract and another one for sending the fee to the deployer. 2. The instantiate function of the proxy contract stores each element from the initial_data vector", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. For each element in plugins, a message is executed to the plugin registry contract and the plugin contract is created and instantiated. As a result, execution could potentially run out of gas not allowing users to create the wallet. if there are a sucient number of elements in the mentioned vectors, the Recommendation We recommend breaking down wallet creation into multiple transactions to allow users to create a basic wallet and then perform other transactions to add features. Status: Acknowledged 3. Malfunctioning or malicious plugins could make the proxy contract unusable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "5. For each element in plugins, a message is executed to the plugin registry contract and the plugin contract is created and instantiated. As a result, execution could potentially run out of gas not allowing users to create the wallet. if there are a sucient number of elements in the mentioned vectors, the Recommendation We recommend breaking down wallet creation into multiple transactions to allow users to create a basic wallet and then perform other transactions to add features. Status: Acknowledged 3. Malfunctioning or malicious plugins could make the proxy contract unusable", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Wallet nonce can be reset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In proxy/src/wallet/exec.rs:62-77, substitute the controller. the rotation function allows the user to A check is in place to not allow the user to substitute a controller with the same one in order to reset the nonce. However, by using a third controller, the user can perform a double rotation and still reset the nonce, allowing message replay. We classify this issue as minor since only the user itself can perform this operation to reset their nonce.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Code IDs unregistered before whitelisting could allow attackers to instantiate whitelisted malicious contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "and In factory/src/contract.rs:80-81 factory/src/management/contract.rs:47-53, before storing the provided proxy contract code ID, the execution does not check whether it has already been registered. Consequently, an attacker could attempt to upload a malicious service, whitelist, using the aforementioned code ID. included in the We classify this issue with minor severity because this misconguration is only possible from the admin during the instantiation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Providing multiple instances of the same AuthenticatorInstInfo type does not raise an error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In factory/src/contract.rs:100-103, if the user supplies multiple instances of the same AuthenticatorInstInfo type during the execution of the instantiate function, the process does not produce an error, but it proceeds with a continue instruction. As a result, the execution will store only the rst AuthenticatorInstInfo encountered and no error will be raised. It is best practice to inform the user in case the provided input is ignored or an error occurs.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. The ensure_enough_native_funds function fails if coins are not provided in the expected order", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "the factory/src/service/create.rs:105-137, In ensure_enough_native_funds function veries that the funds sent by the user cover both the fee and the proxy_initial_fund. However, if the order of the coins in the sent_fund and proxy_initial_fund vectors is not the same, the function will fail since there is a check that uses the equality operator.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. It is possible to create wallets with not whitelisted proxies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In factory/src/service/create.rs:35-37, the proxy_code_id provided by the user in create_wallet should be validated to exist within the whitelist of supported_proxies. Failure to enforce this check could allow the user to designate any contract as a proxy, including potentially malicious ones. We classify this issue as minor since this misconguration is only possible from the admin.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Missing address validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In proxy/src/contract.rs:111, during the execution of the instantiate function of the proxy contract, the controller address is stored in the contract. contain However, AuthenticatorProvider::Custom, it should be validated before being stored. address since can the an in it case of in plugin_registry/src/management/plugin_mgmt.rs:60, Similarly, the metadata_data.creator address should be validated before instantiating the Plugin struct.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. The update of the deployer address in the factory contract could disrupt the operations of the proxy contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In proxy/src/contract.rs:115-119, during the proxy contract deployer address is fetched from the factory contract and stored. instantiation, the However, since the deployer address can be updated in the factory contract, its update will not be reected in any previously instantiated proxy that will continue querying the old one. Consequently, it is advisable to not fetch the deployer address during the execution of the proxy contracts instantiate function, as any changes will not be reected here.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. It is possible to overwrite existing registered plugin contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In plugin_registry/src/management/plugin_mgmt.rs:68-70, the register function does not ensure that the provided plugin code_id is already registered in the plugin_code_ids map. Similarly, new_plugin_version function allows the deployer to store existing code_ids. in plugin_registry/src/management/plugin_mgmt.rs:160-161 the Consequently, it is possible to overwrite an existing plugin and assign to it a new code_id. We classify this issue as minor since it can be caused only by the reviewer, which is a privileged account.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Subscription tiers are not updatable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "the plugin_registry/src/management/config.rs:5-22, In add_subscription_tiers function does not allow the modication of existing subscription tiers. Attempting to update an existing tier in the add_subscription_tiers function will result in an error in line 12. it Consequently, subscription fee. is not possible for the deployer to modify elements such as the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Missing pagination for the plugin query", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In proxy/src/plugin/contract.rs, the plugins query returns a combined list of exec_plugins, pre_tx_plugins, and post_tx_hooks_plugins. However, since there is no pagination in place, performance issues might occur as the number of plugins grows, up to the point where the query could run out of gas.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Missing subscriber contract validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In plugin_registry/src/service.rs:120-166, plugin_registry contract enables proxy contracts to subscribe to the requested tier. the subscribe function in the However, since there is no check in place to conrm that the sender is a proxy contract, any address can subscribe and pay the subscription fee.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Lack of input vector deduplication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "In the following locations, vectors provided as input to the contract are not deduplicated:  In factory/src/contract.rs:82-86, during the instantiate function, Additionally, the vector should include, at a minimum, the default one. the supported_proxies vector execution the lacks deduplication. of  In factory/src/contract.rs:89-95, the supported_chains vector is not deduplicated.  In plugin_registry/src/contract.rs:87-91, the subscription_tiers vector lacks deduplication.  In factory/src/service/create.rs:105-137, the proxy_initial_fund vector is not deduplicated.  In proxy/src/contract.rs:129, the relayers vector lacks deduplication allowing the execution of duplicated MsgGrantAllowance messages.  In proxy/src/contract.rs:158-182, the required_chains vector deduplication allowing MsgRegisterInterchainAccount messages. the execution of lacks duplicated Consequently, the contract could store duplicated elements or in the case of mappings only the last duplicated element of the vector.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Contracts should implement a two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Missing input validation for wallet fees", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf", "body": "When the factory is instantiated in contracts/core/factory/src/contract.rs:81, the wallet fee is not validated. The specied denom may therefore be invalid. In such a scenario, creating wallets will not be possible and a redeployment of the factory will be necessary.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attacker can drain funds by refusing completed oers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "In contracts/nft-loans-non-custodial/src/execute.rs:336, a borrower can refuse an oer even if the oer had been accepted. Suppose a borrower calls RefuseOffer for an accepted loan  that allows the lender to call WithdrawRefusedOffer in order to withdraw the deposited funds. This is problematic because the lender already had their principal in back interest contracts/nft-loans-non-custodial/src/execute.rs:546-549, resulting in the contract losing funds. repaid and An attacker can exploit this issue by completing and refusing a loan to withdraw excess funds as the lender. This can be exploited repeatedly to drain all funds from the contract. Please see the test_steal_funds test case to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Borrowers are forced to default on loans with zero fees or interest", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "In the contracts/nft-loans-non-custodial/src/execute.rs:557-567, contract tries to send fees to the treasury without validating that the amount is greater than zero. Suppose a lender accepted a loan with the loan terms interest as 0. The calculated fee amount would be zero (see line 531), causing the contract to send 0 funds to the fee contract. Since Cosmos SDK does not allow 0 amount transfers, borrowers would not be able to repay in time, causing their loans to default. A lender can exploit this issue by providing zero-interest loans, forcing the borrower to default on their loans so the lender can have the NFT in return. Additionally, this issue will also occur if the admin sets the fee rate to the maximum value, preventing all borrowers from repaying their loans successfully.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Attackers can steal NFTs with approvals on contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "and In contracts/nft-loans-non-custodial/src/execute.rs:433-440 contracts/raffles/src/execute.rs:64-71, the CW721 NFT is transferred to the contract using the TransferNft message without verifying the caller is the owner of the NFT. Since the transferred NFT is stored under the callers rae or loan, the caller can withdraw the NFT after it ends, causing the real owner to lose their NFT. The possibility of this could happen when the user approves their NFT in the rst transaction but fails to create a successful rae or loan in the second transaction (e. g. due to invalid arguments). An attacker can then exploit the vulnerability If the approval is not revoked and does not expire in the next block. We classify this as a major issue because the attack requires pre-approval on the contract for successful exploitation.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Malicious rae owner can replay CancelRaffle message to steal NFTs in contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "In contracts/raffles/src/execute.rs:172, the get_raffle_owner_messages function is called to refund the owner their NFT when the owner cancels a rae. The execute_cancel_raffle function does not prevent replay attacks, allowing the owner to cancel a rae as long as there are no tickets bought. An attacker can exploit this issue by creating a rae and immediately canceling it, resulting in the contract storing a valid RAFFLE_INFO for the specic rae identier value. After that, the attacker sells the NFT in a marketplace to a victim. Once the victim creates a rae and deposits the NFT into the contract, the attacker executes CancelRaffle and steals the NFT. We classify this as a major issue due to the high exploit diculty.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Incorrect implementation of CW20 Receive message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "In contracts/raffles/src/contract.rs:113, users can deposit CW20 tokens into the contract through a receive callback function. However, the callback message does not follow the CW20 specication. Consequently, users are unable to deposit CW20 into the rae contract directly. We consider this a minor issue as users can still deposit CW20 tokens using the allowance functionality.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Consider validating fee distribution address and fee rate", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "contracts/nft-loans-non-custodial/src/contract.rs:45 and In contracts/nft-loans-non-custodial/src/admin.rs:40, the contract owner instantiates and updates the fee distributor address. However, in each case, the address is not validated, which could lead to the contract being unable to execute as transfers may be made to an invalid address. the owner contract in Similarly, and contracts/nft-loans-non-custodial/src/contract.rs:46 contracts/nft-loans-non-custodial/src/admin.rs:61. A miscongured fee rate would prevent users from repaying borrowed funds due to overows occurring in contracts/nft-loans-non-custodial/src/execute.rs:527. instantiates updates rate and the fee We classify this as a minor issue since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Withdrawal of IDO pre-fund contributions will fail in most cases due to funds being deposited in Anchor", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The function withdraw_prefund in contracts/ido-prefund/src/execute.rs will revert in most cases since most of the funds are not actually stored in the contract itself but are deposited into Anchor as soon as a certain threshold is reached. This means that withdrawal requests by end-users will fail until the funds are redeemed from Anchor into the contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Missing input validation on staking cong update might lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The function update_config in contracts/staking/src/contract.rs fails to validate the unbonding conguration provided as an argument by not calling the available assert_unbond_config function, which ensures that unbonding periods are specied in the right order to be processable by the unbonding logic. This could lead to inconsistent contract state and errors during unbonding attempts.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. The staking contract owner can withdraw all reward tokens from the contract but users can not unbond without penalty", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The staking contract owner can use the function emergency_withdraw to remove all funds from the smart contract. This seems to be intended for emergency use in case of a vulnerability being detected. However, this does leave the user in a position in which they cannot use unbond to get their own funds back without a penalty.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Staking contract can run out of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The staking contract relies on being funded since rewards are transferred from the contracts balance to the user. In the case of the contract running out of funds, users are left without rewards.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Multisig implementation does not follow CW3 specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The implementation of (https://github.com/CosmWasm/cw-plus/blob/main/packages/cw3/README.md). However, does not follow the naming convention for the interface, which might lead to confusion. the multisig contract is relatively close to the CW3 specication it In addition, the code implements basic functionality that is already implemented by the CW3 reference implementation (https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw3-ex-multisig).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Multisig proposals do not expire and cannot be closed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "Proposals submitted to the multisig remain in an executable state forever. This could lead to old proposals being executed by a signer after circumstances have changed, for example, when a transaction is not relevant anymore. Additionally, the lack of support for cancelling proposals means that a proposer cannot withdraw a past proposal even if the set of signers changes through a cong change. An example of this being a problem could be a proposal having been replaced by a newer version and then accidentally being executed when the signing threshold is lowered.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Staking contract sends UST fees to arbitrary burn address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The staking contract charges a UST fee on all operations. Collected fees can be withdrawn from the contract by sending them to a burn address that can be set by the owner to any address. This is inconsistent with the burn terminology.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Reward withdrawals in staking contract charge fees even if no rewards are distributable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "The withdraw function in contracts/staking/src/contract.rs does not fail when no rewards are distributable. This means that the user spends gas and fees without receiving any reward in return. Whilst this may be intentional, it is not what a user would expect as normal behaviour.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Missing tax deductions on UST transfers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf", "body": "In contracts/ido-prefund/src/execute.rs UST is sent out from the contract in the functions withdraw_prefund and withdraw_ido_funds. In both cases the code fails to account for Terra taxes on native tokens, meaning that these taxes are taken from the contracts balance. In addition, functions deposit_prefund and deposit_anchor_by_admin send UST to Anchor. However, the bookkeeping of user funds takes into account taxes on UST transfers. This is unlikely to lead to the contract ever running out of funds due to fees. However, operator benets may be slightly lower than expected in certain cases.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Potential locked funds in case the user-dened destinationFee does not cover the actual fee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "In contracts/src/Gateway.sol, the sendToken function accepts destinationFee as an input, allowing users to set any arbitrary fee value. This allows users to send a message with a destinationFee set to zero for executing the transaction as cheaply as possible, which does not cause errors on the Ethereum side. On the Polkadot side though, this may lead to errors: When receiving the message, the in the inbound-queue convert_send_token parachain/primitives/router/src/inbound/mod.rs:124-290. this the dest_para_fee is included in a conversion, DepositReserveAsset XCM instruction. in case dest_para_id is dened, function During executes pallet if dest_para_fee is zero or a value less than the required fee, the XCM However, instruction will fail because of the missing funds for the execution leading to funds being stuck in the agent.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Unveried registerToken function execution outcome could lead to funds being stuck in the agent contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "In contracts/src/Assets.sol:154-172, isRegistered ag to indicate the token registration status on the Asset Hub. the registerToken function sets the this ag is set regardless of However, the success or failure of the token registration command, which could fail for instance if the token is already registered and the Asset Hubs create extrinsic fails in https://crates.parity.io/src/pallet_assets/lib.rs.html#385. Consequently, if the token registration fails or is delayed, every subsequent sendToken function invocation will fail as well on the Polkadot side, leading to user tokens being stuck in the agent contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Inconsistent state in case agent contract instantiation fails on Ethereum", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "In parachain/pallets/system/src/lib.rs:373-394, the create_agent extrinsic updates the Agents map and then sends a message to Ethereum. However, since the message dispatch and execution is async, but the Agents map is already updated, the pallet will act as if the agent contract is instantiated already, even if the instantiation message has not yet been processed. in case the message fails in the Ethereum Gateway contract, the state on the Additionally, Polkadot side will not be reverted, leading to an inconsistent state between the two sides of the bridge.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Lack of cross-chain error handling could lead to inconsistent states, loss of funds, and frozen channels", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "In parachain/pallets/inbound-queue/src/lib.rs, potential errors may arise during the processing of inbound messages, specically on lines 262-263, 268, and 278. These errors can be related to issues in the inbound message structure, XCM conversion, insucient balance to cover processing fees, or problems with XCM delivery. Consequently, in case an error is raised on the Polkadot side, the Ethereum contract's state is already mutated. Failure to handle the error and rollback changes on the Ethereum side for a valid inbound message on the Polkadot side may lead to inconsistent states between the two sides of the bridges. Furthermore, since channels are ordered, a failure in message handling will revert the transaction and will not update the next nonce. As a result, only the erroring message can be proposed, the channel will be stuck and no other message will be able to be executed through it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. The throttling mechanism could delay critical governance operations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "In parachain/pallets/system/src/lib.rs, a throttling mechanism for the queue is implemented to limit the execution complexity of the on_finalize function. This throttling mechanism limits the number of messages retrieved per block from the outbound-queue pallet to a maximum of MaxMessagesPerBlock messages. Consequently, the processing of messages could be delayed depending on the number of messages in the queue of the outbound-queue pallet, but also depending on the number of other pallets interacting with their queues since the message-queue pallet selects autonomously each block which client pallet is served and there is no guarantee that the outbound-queue is selected. This could potentially cause delays in the execution of important commands like SetOperatingMode or Upgrade that should be dispatched promptly to address malfunctioning or exploits of the bridge. For instance, an attacker could exploit this by enqueuing a substantial number of commands to saturate the queue. The implemented segregation of governance channels does not prevent this issue since all the channels rely on the same queue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. The current DOT/ETH exchange rate implementation is not optimal in the context of price volatility", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "The current Snowbridge implementation introduces a parameter responsible for storing the exchange rate of the DOT/ETH pair to calculate a fair transaction fee. Its value is updated manually via set_pricing_parameters extrinsic. This is suboptimal and susceptible to irregularities in the form of large deviations from the actual ETH or DOT price and the stored exchange rate. comment in According parachain/pallets/outbound-queue/src/lib.rs:53, this rate will be updated once every few weeks. Given historical price uctuations in short periods of time between the to DOT and ETH, it is possible that forwarding transactions will be unprotable for relayers or for the protocol itself. Additionally, since the fees are collected but not directly swapped using the provided exchange rate, the value of fee reserves deposited by users is susceptible to market volatility.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. State updates for the primary governance channel are transmitted through the slower channel", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "the Primary Governance In parachain/pallets/system/src/lib.rs:489-490, the update of pricing parameters, contract upgrades, and the Channel handles pausing/resuming of is responsible for creating agents, creating channels, native forced transfers from agents, and forced pausing/resuming of the channel. the Gateway. The Secondary Governance Channel, instead, Forceful channel updates, which include actions such as pausing or resuming a channel and adjusting usage fees, should be directed to the Primary Governance Channel, but are currently managed through the Secondary Governance Channel. As a result, if the Secondary Governance Channel becomes more crowded, the governance's response to any issues could become slower.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Channel-specic outbound_fee is not fully implemented", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "parachain/pallets/system/src/lib.rs:441-465 In the update_channel and force_update_channel extrinsics permit to modify channels by specifying the mode and the outbound_fee. 479-495, and However, the outbound_fee is currently disregarded and not processed either in the pallet or within the Gateway contract  it is solely emitted in the event. Despite being dened in the comment as the Fee charged to users for sending outbound messages to Polkadot, this specic fee per channel is not currently implemented.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. The agent may not be able to reimburse the relayers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "In contracts/src/Gateway.sol:217-222, a mechanism is implemented to incentivize relayers to forward messages and receive a reward from the agent in return. However, since there is no automated mechanism to fund agents, such as an explicit requirement for agent creators to fund the agent contract or an enforced fee ratio favorable for is possible that due to market conditions, bridge usage, or after bootstrapping the contract, there are no funds left to reward relayers. the protocol, it Consequently, there would be no incentive for relayers to forward messages, which could cause delays and disruptions in the bridge operations.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Inecient overow protection for the nonce", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "In parachain/pallets/outbound-queue/src/lib.rs:313, the nonce is correctly incremented using saturated addition, safeguarding against overow. However, when the nonce reaches its maximum value, messages with that one can still be sent across the bridge. Only the initial message with the maximum nonce will succeed; subsequent ones will be rejected. The contract contracts/src/Gateway.sol:142-500 increments a channel's nonce without protection against overow. This results in sending a message which will be rejected on the Polkadot side. While there is no security implication, redundant message transmissions lead to ineciencies that could be avoided.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Events do not contain information about the channel in use", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "In parachain/pallets/system/src/lib.rs, control commands are dispatched over channels to Ethereum using the send function, with corresponding events emitted through deposit_event. For example, channel, and the corresponding event is emitted in line 647. in line 645, the TransferNativeFromAgent command is sent over a However, events do not provide information about the specic channel used for each command even if some commands, for instance, the TransferNativeFromAgent, could be sent via either a parachain channel or a governance one leading to possible issues in o-chain indexers that listen to those events.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Comments do not reect the implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf", "body": "It has been noticed that in some places comments do not match the implementation. This may lead to problems with understanding the logic by developers and negatively impact maintainability. Noticed irregularities:  In the system pallet, in parachain/pallets/outbound-queue/src/lib.rs:54 the exchange rate between DOT and ETH can be changed via In  The comment states that set_fee_parameters extrinsic. However, such a function does not exist. practice, the set_pricing_parameters extrinsic is responsible for this. requirements and information about fees are specied in the comments for most extrinsics while no fees are charged for governance and transfer_native_from_agent administrative functions, the so-called Partial fee is charged. However, the comments describing them indicate that no fee is included, which diers from the implementation. update_channel functional ones. For the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Unauthorized swap adjustments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "update_swap_adjustment_handler in The allows contracts/dca/src/handlers/update_swap_adjustment_handler.rs updating the swap adjustments for a specic strategy, eectively increasing or decreasing the number of tokens swapped. However, this function, which is supposed to be callable only by the contract admin, lacks authorization checks. An attacker can save arbitrary swap adjustments for any strategy, potentially grieng the protocol  for example, by setting it to a value of 0. function We would like to point out the described vulnerability was also detected by the Calculated Finance team during the audit. A x was prepared, which was then reviewed by the Oak Security team. that", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Destination address set to the DCA contract address allows disbursement of escrowed funds at any time", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "the DCA contracts In in contracts/dca/src/helpers/disbursement.rs, swapped and escrowed funds are disbursed to the provided destination addresses of a vault. Destination addresses can be used as arbitrary callbacks by specifying a custom message. get_disbursement_messages function However, the destination address is not checked to ensure it is not the DCA contract itself. This allows for the execution of messages in the context of the DCA contract as the caller of the message. For example, providing the DisburseEscrow message would lead to the disbursement of escrowed funds whenever funds are distributed, contradicting the intended behavior of disbursing escrowed funds only in specic situations, e.g., upon vault cancellation.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. PerformanceAssessmentStrategy::CompareToStandardD ca is incorrectly used for a vaults performance_assessment_strategy when choosing SwapAdjustmentStrategyParams::WeightedScale", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "a the with new vault create_vault_handler in Creating contracts/dca/src/handlers/create_vault.rs allows specifying a performance assessment and swap adjustment strategy. The swap adjustment strategy can be either set to or SwapAdjustmentStrategyParams::RiskWeightedAverage SwapAdjustmentStrategyParams::WeightedScale. The performance assessment strategy determines if a vault should continue to swap tokens based on the performance of the for SwapAdjustmentStrategyParams::RiskWeightedAverage. supposed function used vault only and be to is the However, to performance_assessment_strategy PerformanceAssessmentStrategy::CompareToStandardDca in line 120 for both swap adjustment strategies, regardless of the chosen strategy. set is As a result, the vault's escrow_level, supposed to be set to 0, is set to the escrow level in line 127. Additionally, cong value (risk_weighted_average_escrow_level) Instead of imposing swap and automation fees in the incorrect swap fees are charged. in disburse_funds_handler contracts/dca/src/handlers/disburse_funds.rs:43 and 48, performance fees are applied. As the performance fees are calculated based on the protability delta between the standard DCA and the DCA+ strategy and the vault not using the DCA+ strategy, performance fees will be inaccurately calculated. function", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Spot price usage may be exploited through oracle manipulation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "During trigger execution, the belief price is determined using the query_belief_price function in contracts/dca/src/helpers/price.rs:8-48. In line 38, the pools are queried for their spot price, which could be manipulated on low liquidity pools. This issue is exacerbated due to the lax limits on slippage described below in the issue Default slippage_tollerance is set to the maximum value and because ExecuteTrigger is permissionless. An attacker could monitor existing vaults to compile a list of targets and exploit them by executing triggers at the correct time after manipulating the oracles spot price.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. due_date of the disburse escrow task is not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "Canceling a vault through the cancel_vault_handler function stores a task in storage to disburse escrowed funds. The due_date is designed to limit the execution of the task to a specic time in contracts/dca/src/handlers/cancel_vault.rs:35. calculated based on the current block frame and is time However, when disbursing escrowed funds via the disburse_escrow_handler function in contracts/dca/src/handlers/disburse_escrow.rs, the previously stored task is not loaded, and its due_date is not checked. This means that escrowed funds can be disbursed at any time by the contract admin, even when the due_date has been surpassed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Default slippage_tollerance is set to the maximum value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "Slippage tolerance determines the maximum allowable deviation between the anticipated number of tokens a user expects to receive, such as in a token swap, and the actual number tokens received. A higher value implies a smaller amount of tokens being received, of increasing the loss of value for the user. Within the audited contracts, slippage tolerance is used in two functionalities:  Calling the trigger through the ExecuteTrigger message, which swaps tokens in accordingly the contracts/dca/src/handlers/execute_trigger.rs:207. selected strategy to  Providing the contracts/dca/src/handlers/z_provide_liquidity.rs:37. ZProvideLiquidity liquidity using message in In both instances, the user can optionally dene a custom slippage value. If none is provided, the default value will be used. the default value for slippage_tolerance (for ExecuteTrigger) and However, slippage_tollerance (for ZProvideLiquidity, please note the spelling mistake in the variable name) is Uint128::one(). Consequently, users may experience signicant losses when using these functionalities without dening a custom slippage tolerance value. In the case of pairs with low liquidity, such token swaps may be detected by MEV bots, which could sandwich the messages and thereby extract maximum value from the user. In addition, note that in both of the above-mentioned cases, the functions do not validate the optional user-provided slippage parameters. Consequently, if their value is greater than 1, there will be an underow in contracts/dca/src/helpers/swap.rs:23 and contracts/dca/src/handlers/z_provide_liquidity.rs:49, which will result in a panic.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Vault deposits can trigger recursive trigger executions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "a in via can vault deposit in Anyone deposit_handler contracts/dca/src/handlers/deposit.rs. the vault was inactive prior to the deposit, a new trigger is saved in line 96 with the target time set to the current block time, prompting an immediate execution. If the vault has destination addresses congured to deposit distributed funds directly into other vaults, this can possibly lead to recursive trigger executions. the If function the described vulnerability was also detected by the We would like to point out Calculated Finance team during the audit. A x was prepared, which was then reviewed by the Oak Security team. that", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of conguration parameter validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "Most of the conguration parameters are properly validated before saving them to storage. However, the following parameters are missing validation steps both upon instantiation in contracts/dca/src/handlers/instantiate.rs:23-33 and upon update in contracts/dca/src/handlers/update_config.rs:24-34 :  A maximum size is not enforced for the fee_collectors vector. This could lead to out-of-gas errors during iteration if a big enough list of collectors is supplied.  Empty allocations in the fee_collectors vector are not rejected.  A page_limit of zero is not rejected, even though it would render some of the contracts queries ineective, as no elements would be returned. In addition, the assert_page_limit_is_valid function implements a default value of 30, therefore if the limit is below that number, any query that makes use of the default value will return an error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Inconsistent pair identication in storage", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "When saving new pairs in contracts/dca/src/state/pairs.rs:7-9, the storage key is determined as format!(\"{}-{}\", denoms[0], denoms[1]). Therefore, both pairs A-B and B-A are saved as dierent pairs with potentially dierent routes. The find_pair function in lines 15-23 checks the existence of both options, however, it will always return the rst that matches the submitted ordering. Returning dierent unexpected inconsistencies in gas costs and swap fees. routes depending on the order of the assets in a pair will cause", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. minimum_received_amount not applied to swaps might give a false sense of security", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "through the execute_trigger_handler function in When executing a trigger contracts/dca/src/handlers/execute_trigger.rs, vault.minimum_received_amount is checked against belief_price. However, it is not instead, vault.slippage_tolerance is supplied. swap message 207-215, provided actual lines the to in Since no verication exists to guarantee that vault.slippage_tolerance aligns with the same the minimum_received_amount creates a false sense of security for users, as it is not eectively used in the nal swapping process. minimum_received_amount, usage level risk as of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Lack of validation upon swap adjustment", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "The update_swap_adjustment_handle function allows for arbitrary values to be submitted as the swap adjustment, aecting the number of tokens to be swapped by this factor. If a large value is assigned, the swap will fail, as the resulting amount designated for swapping will exceed the available funds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Lack of validation in liquidity provision cache", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "z_provide_liquidity_handler in The function not contracts/dca/src/handlers/z_provide_liquidity.rs:28-35 validate the saving provider_address PROVIDE_LIQUIDITY_CACHE storage. Providing an incorrect address will cause the subsequent reply handlers to fail, wasting computational resources, or rendering the locking useless if a duration of zero is provided. does to it user-submitted before the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Lack of validation of custom swap fee denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "create_custom_swap_fee_handler The function in not contracts/dca/src/handlers/create_custom_swap_fee.rs:9-23 validate that the supplied denom actually exists. In case of a typo, the admin might not be aware of the error, and since the expected denom will not be found, no fee will be applied to the desired operations. does", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Misleading lack of feedback upon fee removal", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "remove_custom_swap_fee_handler in function The not contracts/dca/src/handlers/remove_custom_swap_fee.rs:7-19 validate that the supplied denom is part of the current custom fees. Since no feedback is returned when removing a non-existing element from the storage, the admin would not be aware of the error, for example, in case of a typo. Therefore undesired fees will still be charged afterward. does", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. New vaults may be inactivated right after creation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "create_vault_handler in The contracts/dca/src/handlers/create_vault.rs does not assert the initial token deposit info.funds[0].amount is sucient to guarantee a successful swap of the desired number of tokens, i.e. swap_amount. As a consequence, such a vault would be inactive and unable to perform token swaps due to insucient funds. function that", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Lack of role-based access controls for the pausing mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "The codebase implements a pausing mechanism, which is in line with best practices. However, all of the administrative functions of the contract are centralized in the admin role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that might be managed by a multisig or a governance contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Swap pair route can have duplicate entries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "create_pair_handler The in contracts/dca/src/handlers/create_pair.rs allows the contract admin to create and update swap pairs. The pair.route eld is used to specify the route (i.e., pool ids) that should be used for swapping tokens. While there are various checks in place to ensure that the route is not empty and the route matches the base_denom and quote_denom, there is no check to ensure that the route does not contain duplicate entries. function A swap pair with duplicate route entries will increase the total swap fees and gas costs when swapping tokens.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Vault label length is not validated to be less than 100 characters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "Users can specify a label when creating a new vault via the create_vault_handler function in contracts/dca/src/handlers/create_vault.rs. The label is stored in the vault.label eld and is solely used for o-chain display purposes. While updating a vaults in contracts/dca/src/handlers/update_vault.rs is restricted to 100 characters, there is no such restriction when creating a new vault. update_vault_label_handler function label the via In addition, empty labels are allowed which do not serve the intended asset identication purpose.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Inability to update important vault conguration parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "A vault owner can currently update the vault label via the update_vault function in other contracts/dca/src/handlers/update_vault.rs. However, important vault conguration parameters that cannot be updated once the vault is created. This includes the swap slippage tolerance (slippage_tolerance), the minimum receive amount (minimum_receive_amount), and the destination addresses (destinations) for fund disbursement. there are The inability to update these parameters can be problematic in certain situations. For instance, if the vault owner wants to increase the slippage tolerance to ensure that the vault is able to swap tokens even when the market is volatile or liquidity is low, or if the initially provided slippage value was too conservative. In such cases, they would have to cancel the vault and create a new one.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Peer nodes could receive blocks that are not applied by the sequencer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "The produceBlock function, dened in block/produce.go:75-161, is responsible for producing and distributing new blocks to peers. However, since in block/produce.go:148, the gossipBlock function is optimistically invoked before the block is actually applied via the applyBlock function, there is a risk of gossiping blocks to peers even if applying the block errors or if the process stops for any reason after the execution of gossipBlock but before the execution of applyBlock. Such an error will lead to peers storing and applying a block that the proposer will not apply, leading to an inconsistent block and transaction execution.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. HTTP server misconguration allows Slowloris DoS attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "The serve function in rpc/server.go:177-184 instantiates an HTTP server and enables listening for incoming requests on the listener address. However, since there is no ReadHeaderTimeout to handle idle connections, the server is vulnerable to Slowloris Denial-of-Service (DoS) attacks. This attack method operates by transmitting large amounts of data slowly, which succeeds in keeping the connection alive in the event of a timeout, ultimately resulting in a DoS of the node.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. CONTINUATION frames ood vulnerability in x/net allows attackers to DoS the node", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "The golang.org/x/net package used in Dymint is vulnerable to CONTINUATION frames ood, as reported in https://pkg.go.dev/vuln/GO-2024-2687. An attacker may cause an HTTP/2 endpoint to read arbitrary amounts of header data by sending an excessive number of CONTINUATION frames. Maintaining HPACK state requires parsing and processing all HEADERS and CONTINUATION frames on a connection. When a request's headers exceed MaxHeaderBytes, no memory is allocated to store the excess headers, but they are still parsed. This permits an attacker to cause an HTTP/2 endpoint to read arbitrary amounts of header data, all associated with a request which is going to be rejected. These headers can include Human-encoded data which is signicantly more expensive for the receiver to decode than for an attacker to send. Consequently, attackers can leverage this vulnerability to perform a DoS attack against the RPC server.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Incorrect mempool initialization height leads to discarded transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In node/node.go:177, during the execution of the NewNode function, the NewTxMempool function is called to instantiate a new mempool. However, since the mempool height is set to zero, incoming transactions would get incorrectly assigned a height of zero. As a consequence, the mempool would incorrectly and prematurely purge valid transactions in the purgeExpiredTxs function dened in mempool/v1/mempool.go:762.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Submitting blocks to the data availability and settlement layer can result in a deadlock", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In block/submit.go:13-57, the SubmitLoop function, running in a goroutine, submits blocks (SL). A mutex, batchInProcess, is used to ensure that only a single batch is processed at a time. to the data availability (DA) and settlement layer layer However, preventing the next batch from being processed and resulting in a deadlock. if the submitNextBatch function in line 46 errors, the mutex is not released,", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Invalid blocks can be received via p2p gossip, potentially preventing block syncing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In block/manager.go:256-278, the applyBlockCallback callback function is called whenever a new block is received via libp2p gossip. If the received block height is equal to the next expected height, the block is applied via the applyBlock function in line 269. Otherwise, if the block height is for a future height, the block and the corresponding commit are stored in prevBlock and prevCommit, respectively. However, at this point, the block is not yet validated by verifying the signature to ensure the sequencer has produced it. This stateful check is only performed later in the executeBlock function in block/block.go:180-182 via the Validate function. As a result, issues such as: invalid blocks can be received and processed by nodes, leading to potential 1. 2. If the block height is equal to the next expected height, it is attempted to be applied. Before any stateful validations, the block is saved via the SaveBlock function in block/block.go:38. While the block is ultimately dismissed and not applied due to not passing the signature verication check, it remains stored, wasting disk space of the node. An attacker could exploit this behavior by spamming invalid blocks to nodes. If the received block is for a future height, the block and commit are stored in prevBlock and prevCommit, potentially overwriting a valid block and commit. As a result, nodes can be prevented from syncing via this mechanism. Please note that nodes also synchronize via the settlement layer (Dymension Hub), which mitigates this issue to some extent. Additionally, it should be noted that the sequencer does not receive blocks via libp2p gossip, only regular nodes do.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Non-atomic batch submission to data availability and settlement layers causes repayment for the same data and potential indenite failure", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In block/submit.go:89-103, in the submitNextBatch function, a batch is submitted to the data availability (DA) layer by calling SubmitBatch, followed by an attempt to submit the same batch to the settlement layer (SL) using m.settlementclient.submitbatch. the SL submission fails due to reasons such as insucient gas or censorship at the If settlement layer, the transaction remains in the mempool awaiting inclusion. The system then the same batch to both layers after the waiting period ends. Since retries to submit leading to syncTarget remains unchanged, the DA layer accepts the redundant batch, unnecessary payments for already existing data. If the original transaction eventually gets included in the SL before the new transaction, the SL rejects the resubmitted transaction due to a height check requirement. Consequently, this cycle of failing settlement attempts and redundant payments perpetuates indenitely and incurs unnecessary costs for the system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Applying blocks concurrently can lead to unexpected errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "The applyBlock function executes the current block by calling the executeBlock function in block/block.go:44. As part of the execution, the application's BeginBlock, EndBlock, and DeliverTx are called for every included transaction. However, applying the block to the store and the ABCI application is not atomic, shared state is not locked between processes, such as the goroutine that processes libp2p gossiped blocks and the sync goroutine that syncs the node with blocks from the settlement layer. In the rare case that a block for the same height is simultaneously processed by both goroutines, both processes will attempt to execute the block, leading to unexpected errors such as a panic in the ABCI application when checking the header's validity.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Stopped block production is immediately resumed after receiving a health status event from the data availability or settlement layer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In block/produce.go:17-73, the ProduceBlockLoop function produces new blocks unless the shouldProduceBlocksCh channel receives a false value. In this case, block production is stopped, and the channel waits for a true value again. There are three causes that may stop the block production: the data availability (DA) layer is unhealthy, the settlement layer (SL) is unhealthy, or 1. 2. 3. block production encounters an error. SL's current The DA and the in healthStatusEventCallback block/manager.go:250-254. This function sends the received health boolean value into the shouldProduceBlocksCh channel. is listener continuously reported function, dened health health status to However, if block production was previously stopped due to erroneous block production, the health listener will enable block production again as soon as the DA or SL health status is reported as true, even if the error that caused the block production to stop has not been resolved.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Pending blocks are repeatedly gossiped", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In block/produce.go:148, the produceBlock function gossips a newly produced block to its peers. However, if the sequencer picks up a pending block that has already been gossiped, it will be gossiped again, which is unnecessary. We classify this issue as minor, as repeatedly gossiped blocks do not harm the network besides causing networking ineciencies.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Validating gossiped transactions may block the libp2p validator queue", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In p2p/validator.go:43-69, the TxValidator libp2p validator function calls the mempool's CheckTx function to validate the gossiped transaction prior to adding it to the mempool. However, if the CheckTx function returns an error that does not match any of the switch cases, i.e., the default case, the function will attempt to read from the checkTxResCh channel to receive the ABCI response. As CheckTx may have errored before initiating an ABCI CheckTx request, the channel will not receive any response, causing the goroutine to block and clog the libp2p validator queue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Mempool is initialized at genesis without the preCheck and postCheck functions, leading to not validating the transactions size and wanted gas until the rst block is committed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In state/executor.go:301, the commit function calls the mempool's Update function to update the preCheck and postCheck functions with the new maxBytes and maxGas consensus parameters received from the underlying application. Those functions are used to additionally validate that the transactions size (in bytes) is less than the maximum and that the transactions wanted gas does not exceed the block gas limit. This validation occurs before and after a transaction is added to the mempool. However, at genesis, the mempool is not initialized with those preCheck and postCheck functions, even though both consensus parameters, maxBytes, and maxGas, are made available after executing InitChain in block/initchain.go:45. As a result, transactions will not be validated until the rst block is committed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Maximum number of peer IDs can potentially be reached, preventing gossiped transactions from being added to the mempool", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "the nextPeerID function returns the next In node/mempool/mempool.go:35-48, unused peer ID to use and panic if the number of active IDs exceeds the maximum threshold, maxActiveIDs = math.MaxUint16. However, over time, as more and more peer IDs are utilized, and unused IDs are not reclaimed via the Reclaim function, the maximum threshold can potentially be reached at some point. As a result, the libp2p transaction validator function, TxValidator, will be unable to claim an ID for a new peer and panics, preventing incoming transactions from being added to the mempool. We classify this issue as minor as it requires a total number of 65,535 unique peers to have been connected to the node at some point.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Incomplete validation of conguration parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In config/config.go:137-144, GetViperConfig function execution to validate the NodeConfig. the Validate function is executed by the However, SettlementLayer are currently checked. the validation process is incomplete, as only BlockManagerConfig and Consequently, the node may use an invalid conguration, possibly leading to unintended behaviors and node halt.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Node can be started without providing the genesis", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In cmd/dymint/commands/start.go:128-135, the checkGenesisHash function is executed during the node initialization to verify that the provided genesisHash and the SHA-256 hash of the genesis le are equal. However, if the Genesis le or the genesisHash is not provided, it does not generate an error, thus permitting the node to start even without providing the genesis.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Suboptimal data retrieval due to static congurations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "The fetchBatch function in block/retriever.go:106 retrieves data batches using a retriever instance (m.retriever) initialized at node startup. However, this approach leads to if sequencer 1 uses suboptimal data retrieval due to static congurations. For instance, Celestia as the DA layer and sequencer 2 uses Avail, parsing data would fail for one another. This static conguration presents a signicant issue, as nodes submitting to Celestia or Avail may face diculties syncing data. Since m.retriever is statically congured based on the daregsitry settings, the syncing node might encounter situations where it's unable to parse both sets of data. When data is submitted to the settlement layer, it includes a DASubmitMetaData.client eld to validate the data availability from the client. Retrievers are congured to use only one DA client. If the settlement has data from mixed clients, the retriever can only parse data for its congured client. If the data is only on another client, this static conguration would prevent processing the data. We classify this issue as minor because, at the time of the audit, only one sequencer node is used. Once further sequencer nodes are introduced, it becomes a serious issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Occurrence of \"Tendermint\" instead of \"Dymint\"", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In rpc/client/client.go:168, the BroadcastTxCommit function uses the error reason \"Tendermint exited\". This error message might be misleading as the client is called \"Dymint\".", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Non-sequencer nodes unnecessarily register health status event listener", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "to the In block/manager.go:243, corresponding EventQueryHealthStatus healthStatusEventCallback callback function. Whenever this event is emitted, the event's Healthy value is sent to the shouldProduceBlocksCh channel, potentially enabling or disabling block production. the EventListener function subscribes event registers and the However, this mechanism is only relevant for the sequencer node, as it is currently the only node that is producing blocks. For other regular nodes, the shouldProduceBlocksCh channel is not relevant, rendering the event listener and callback function unnecessary.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Use of magic numbers decreases maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf", "body": "In rpc/json/service.go:107-108 and rpc/client/client.go:315, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to understand their use easily and may make inconsistent changes across the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. MsgInstantiateOracle is not registered", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/types/codec.go:18, MsgInstantiateOracle is not registered as a concrete implementation of the sdk.Msg interface. While there are no issues when executing a MsgInstantiate transaction message without the registration, an error will occur if a transaction message contains code that involves marshaling or unmarshalling an unregistered message.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Amino codec must be registered to support end users with hardware devices like Ledger", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/types/codec.go:33, Amino should be used to register all interfaces and concrete types for the icaoracle module. This is necessary for legacy binary and JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Missing GenesisState validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/keeper/genesis.go:11, InitGenesis is missing genesis state validation. Without validation, miscongurations may go unnoticed and might eventually be dicult to correct.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Governance can activate invalid oracles", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/keeper/gov/gov.go:11-13, the ToggleOracle function can be called by governance to enable or disable any oracles. However, no validation ensures that the oracle already has a contract instantiated on the host chain and the channel is still active. Enabling such invalid oracles is inecient.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Removing oracles does not remove associated metrics", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/keeper/gov/gov.go:16-24, the RemoveOracle function can be called by governance to remove any oracle as long as it exists in the storage. However, no validation ensures that the metrics associated with the oracles are removed too. If a channel times out and governance removes the oracle, the pending metrics will remain forever in the storage in an IN_PROGRESS state.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Oracles cannot be added again if they have an active channel and are removed through governance", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/keeper/gov/gov.go:16-24, the RemoveOracle function can be called by governance to remove any oracle as long as it exists in storage. However, if governance removed OracleChainId while the channel is still active, the chain identier cannot be added back through the AddOracle function. This is due the error occurring in stride:x/icaoracle/keeper/msg_server.go:85 because the channel would still be active. Since interchain account channels cannot be closed manually by users, the oracle for the specic chain id cannot be added back anymore.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. RestoreOracleICA does not ensure that channel is closed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "RestoreOracleICA The in stride:x/icaoracle/keeper/msg_server.go:150 does not explicitly check to ensure that the channel for the requested oracle is closed. If the channel is closed an error should be returned. this function is called for an open channel RegisterInterchainAccount will fail later in the functions execution, but will not return an error that clearly communicates its cause. In the case that function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Duplicated ValidateBasic invocation in CLI", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "CLI commands transaction All stride:x/icaoracle/client/cli/tx.go:19 stride:x/icaoracle/client/cli/gov.go:55 function before calling GenerateOrBroadcastTxCLI. registered in the GetTxCmd function in and msg.ValidateBasic call the As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI function this is a duplicated invocation, which is inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Incorrect usage message for GetCmdQueryOracle command", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "usage message in The stride:x/icaoracle/client/cli/query.go:47 is incorrect. The command expects to receive exactly one argument holding the chain id, but the usage message is not describing this. GetCmdQueryOracle command for", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Unused code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "Across the codebase, locations. Unused code decreases the maintainability of the codebase. instances of unused errors and functions exist in the following  ErrMarshalFailure in stride:x/icaoracle/types/error.rs:18  ErrUnmarshalFailure in stride:x/icaoracle/types/error.rs:19  CWTemplateContract in cw-ica-oracle:src/helpers.rs:10-27", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Events are not always emitted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "There are multiple functions within the scope of this audit that do not emit events or attributes. It is best practice to emit events and attributes to improve the usability of the contracts and to support o-chain event listeners and blockchain indexers. The following functions do not emit events or attributes:  In cw-ica-oracle:src/contract.rs:15, the instantiate function should emit an event containing the admin_address value.  In cw-ica-oracle:src/execute.rs:19, the post_metric function should emit events containing the new_metric and new_price values.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Misleading comments in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In cw-ica-oracle:src/state.rs:127, the add function for the History storage state mentions that Old items are removed from the back of the deque when capacity is reached. However, this is incorrect because the old items are actually removed from the front of the deque when the capability is reached, as seen in line 137. in cw-ica-oracle:src/execute.rs:46, Additionally, the comment species that duplicated metrics will not be added to the store while in the current implementation duplicate new metrics silently overwrite existing metrics.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. Inconsistent admin duplicate validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-07-13 Audit Report - Astroport Concentrated Liquidity Pool with Injective Orderbook Integration v1.0.pdf", "body": "The free-granter contract performs validation of the submitted admin addresses in contracts/periphery/fee_granter/src/state.rs:15-23. However, no checks on address duplication are performed in this function. While the update function performs its own separated checks, this is not the case with the instantiation function. As there is a maximum of two admins, duplicate addresses would limit operations. tWe classify this issue as minor since admin addresses can be updated to remove duplicated addresses.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. try_list poses centralization risk", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "in function try_list sellable/src/execute.rs:212 the The ownable.owner to list any token. While this is a privileged account, it allows anyone controlling this account to list tokens that belong to other accounts. If the ownable.owner account is compromised, it can create a situation where a users tokens may be listed without the owners consent at lower than market value prices, eectively allowing them to be stolen. This also introduces a discrepancy where the ownable.owner can list tokens, but the listed_token.owner is the only address that can delist tokens. allows", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. MaxCoins function could potentially return an unexpected set of fees", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "The globalfee module implements a combination of global and local minimum gas prices, similar to Gaias implementation. The list of localFees is expected to initiate and enforce a higher transaction fee requirement, if the amounts are all greater than the globalFees amounts, as a spam prevention measure. The function GetTxFeeRequired in xion:x/globalfee/ante/fee.go:70 retrieves the global and local fees and returns the combined fee requirement using the MaxCoins function in line 88. However, the function implementation can return unexpected results in the following scenarios:  If the local fees include denoms not present in the global fees, the transaction fee fees, potentially including unwanted fee to the local requirement will be set denominations.  If the local fees include denoms not present in the global fees, the transaction fee requirement will be set to the local fees, potentially including lower fee amounts for denominations present in the global fees.  If the local fees include at least one fee amount that is equal to or greater than the equivalent global fee, the transaction fee requirement will be set to the local fees, potentially including lower fee amounts for other denominations present in the global fees.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. buy_item does not properly validate sent funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "The buy_item function in cw-std:sales/src/execute.rs:136 contains a logic error that does not properly validate that the funds provided in the message are greater than or equal to the price of the item being bought. While this issue has the potential to have a severe impact on the balance of the contract, it is not directly exploitable under normal conditions due to the fact that the contract is not intended to hold a balance. Since the contract does not hold a balance, the bank message that performs the funds transfer to the item owner will error due to insucient funds. If the contract was extended in the future though to hold funds, or if funds are accidentally sent to the contract, an attacker could use the buy_item function to steal these funds by listing their own item for a large sum and supplying a very small amount of funds so that they will receive the excess balance.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Incorrect gas limit used in PostHandle function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "the in In abstract-account:x/abstractaccount/ante.go:180, the sudoWithGasLimit function is called with params.MaxGasBefore as the maximum gas parameter. Instead, the in the after_tx maximum amount of gas that can be consumed by the contract call decorator should be set to MaxGasAfter. PostHandle function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing Genesis validation in the InitGenesis function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "In abstract-account:x/abstractaccount/module.go:98-103, the genesis state is created from the supplied input data during genesis initialization. However, the Validate function is not called for the created type. Consequently, the message is not validated, potentially leading to an invalid genesis state.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Unused code relating to the Redeemable functionality", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "While the Redeemable functionality has been removed, messages relating to the in the codebase in instantiation and querying of and redeemable::InstantiateMsg redeemable::QueryMsg in cw-hubs:seat/src/msg.rs:41. cw-hubs:seat/src/msg.rs:14 redemption of in tokens still exist", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Missing check for sig_bytes length in verify function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "In account-contract:account/src/eth_crypto.rs:37, there is no validation that the length of sig_bytes equals 65 bytes. If the verify function is called with sig_bytes having a length of less than 65 bytes, it will cause the function to panic. Panics go against best practices since they do not provide error messages to the caller which can help to understand and resolve the cause of the error.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Improve credentials processing in before_tx", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "In account-contract:account/src/execute.rs:38-54, the credential processing is implemented as follows: Check the length of the credential bytes, if the length is less than 1, return an error. The implementation then checks the cred_byte (the rst byte) and derives the signature algorithm. All other bytes form sig_bytes and are interpreted as signature bytes. As a result, the current implementation accepts cred_bytes of arbitrary length. It is a widespread implementation practice to read the exact number of signature bytes because the length of the signature is known prior.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Duplicate validations are inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "Across the codebase, instances of duplicate validation have been found, which decrease the eciency of the code.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Usage of the deprecated function EmitEvents", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "deprecated in The used abstract-account:x/abstractaccount/keeper/msg_server.go:102. Using deprecated functions is generally discouraged as they may be removed in future versions of the library, leading to potential compatibility issues. EmitEvents function is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Missing validation of parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "Validate The in abstract-account:x/abstractaccount/types/params.go:22 validates only the maxGasBefore and maxGasAfter parameters, but no validation is performed for allowAllCodeIDs and allowedCodeIDs parameters. This can allow for a situation where these parameters introduce potential miscongurations. function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Missing params validation in SetParams", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "SetParams The in not abstract-account:x/abstractaccount/keeper/keeper.go:67-78 implement validation of the params input. SetParams is used in the UpdateParams function in abstract-account:x/abstractaccount/keeper/msg_server.go:36 function does and abstract-account:x/abstractaccount/keeper/genesis.go:12. InitGenesis the function in in While the UpdateParams function validates input params before passing it to the SetParams function, the InitGenesis function does not do that. By validating params in the SetParams function it will improve the overall consistency of input validation and help with future maintainability.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Outdated dependencies in abstractaccount module", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "Many packages (e.g., cometbft, cosmos-sdk, net, runtime) are outdated and have known vulnerabilities xed in the newest versions. Examples of known vulnerabilities: 1. GO-2023-1861. Cosmos \"Barberry\" vulnerability in github.com/cosmos/cosmos-sdk. Found in: github.com/cosmos/cosmos-sdk@v0.47.2. Fixed in: github.com/cosmos/cosmos-sdk@v0.47.3. 2. GO-2023-1883. Denial of service via OOM in github.com/cometbft/cometbft. Found in: github.com/cometbft/cometbft@v0.37.1. Fixed in: github.com/cometbft/cometbft@v0.37.2. 3. GO-2023-1878. Insucient sanitization of Host header in net/http. Found in: net/http@go1.19.7. Fixed in: net/http@go1.20.6. 4. GO-2023-1840. Unsafe behavior in setuid/setgid binaries in runtime. Found in: runtime@go1.19.7. Fixed in: runtime@go1.20.5. 5. GO-2023-1705. Excessive resource consumption in net/http, net/textproto, and mime/multipart. Found in: net/textproto@go1.19.7. Fixed in: net/textproto@go1.20.3.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Contracts should implement a two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Misspelled error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "abstract-account:x/abstractaccount/types/errors.go:8, In ErrNotSingleSignautre is misspelled. the error", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unused errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "The codebase contains several errors that are unused. These errors should be removed if they are not intended to be used.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Unused functions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "The codebase contains several removed if they are not intended to be used. functions that are unused. These functions should be", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Execute messages of allowable contract do not emit any attributes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "The allowable contracts execute messages in cw-std:allowable/src/lib.rs:95 do not emit any attributes. It is best practice to emit attributes whenever execute messages are handled to allow o-chain listeners such as indexing service observe state changes.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Outstanding TODO comments in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf", "body": "Across the codebase, instances of TODO comments have been found. These markers often signal areas where additional work or improvements are needed:  xion:x/globalfee/queirer.go:34  abstract-account:x/abstractaccount/ante.go:77", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Gzipped wasm binaries with invalid CRC could be used to DOS the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "In the create function in x/wasm/keeper/keeper.go:181, the passed wasmCode is uncompressed. Gas is not charged during uncompression, but rather further down in line 185 after the error check in line 183. Consequently, if an error occurs during uncompression, the function returns an error without charging gas for uncompressing the code. An attacker can consume a high amount of computation and I/O operations without paying for that resource usage by sending a big le to uncompress and causing an error at the last moment. This can be achieved by triggering the uncompression of a valid gzipped le but with an invalid CRC, so the function will read the entire buer before failing during the CRC check, which happens after uncompressing the whole le. For the attack, it is important to create a valid gzipped le with a maximum size of 800 kB. An invalid/bigger le would fail due to the byte prex check and the LimitReader in place. Since the gasMeter charges gas proportional to the transaction message size, it is desirable to use a very small gzipped le with an uncompressed size of 800 kB. A test case demonstrating the above scenario can be found in appendix 1. The cost of this attack could further be decreased by sending a MsgStoreCode with the code constructed as described above from within a CosmWasm smart contract. Even though MsgStoreCode is not directly supported by the default Wasm message encoder EncodeWasmMsg, it can be sent using a StargateMsg.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Contract admins can bypass code ID instantiation permission when migrating contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "The migrate functionality in x/wasm/keeper/keeper.go:380 does not check whether the caller is authorized to perform a contract migration towards the specied code ID. As a result, contract admins can bypass any code ID instantiate permission by specifying the restricted code ID when migrating their contract. A test case demonstrating the above scenario can be found in appendix 2.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. IBC Querier plugins unbounded loop could lead to DoS", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "The IBC Query plugin is dened in x/wasm/keeper/query_plugins.go:200, allowing queries of smart contracts IBC metadata. In line 209, while executing the ListChannels query, specic logic is executed to search open channels associated with a given PortID. This is achieved by iterating through existing channels using the IterateChannels function from channelKeeper. Notably, if PortID remains unspecied, all open channels are retrieved. Consequently, attacker could exploit this unbounded iteration, leading to a chain-wide DoS. in scenarios where a substantial number of channels are registered, an", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Governance permissioned chains are not supporting CosmWasm contracts that dynamically instantiate other contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "The authz implementation in x/wasm/keeper/authz_policy.go does not propagate i. e. a message sent from a CosmWasm smart contract will be governance permissions, executed in the runtime with an authz object of type DefaultAuthorizationPolicy and not GovAuthorizationPolicy. This implies, for example, that contracts cannot instantiate other contracts, which is a common pattern used by teams building CosmWasm smart contracts. Scenario:  Governance permissioned chain that allows only governance to load code and instantiate a contract: code_upload_access = ACCESS_TYPE_NOBODY instantiate_default_permission = ACCESS_TYPE_NOBODY  Code is uploaded and a contract is instantiated through governance.  The contract itself cannot dynamically instantiate other contract instances.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. When updating a contracts AccessConfig subset conditions are not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "In the setAccessConfig function in x/wasm/keeper/keeper.go:882, when updating the AccessConfig for a specic contract code, no check is performed on whether the new cong is a subset of the global access cong as is done in other parts of the codebase. This could lead to inconsistency of the local AccessConfig with the global one,", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Attribute keys starting with underscores lead to errors, causing smart contract runtime errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "The contractSDKEventAttributes function in x/wasm/keeper/events.go:62, returns an error if an attribute key starts with an underscore _. This will lead to runtime errors for smart contracts that have code paths that were not extensively tested. An example could be a DeFi protocol that adds an attribute with an underscore under certain conditions, for example, an emergency withdrawal. The runtime error would prevent the emergency withdrawal, putting user funds at risk.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Updating access congurations can render existing contracts non-compliant", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "During instantiation, the access cong specic to the contract is veried, but the global one is not considered. In fact, the contracts access cong is only validated as a subset of the global one during the code creation process in x/wasm/keeper/keeper.go:176. Consequently, existing contracts may no longer comply with the updated congurations. if either the upload access cong or instantiate access cong are modied, For instance, changing the instantiation access cong from AccessTypeEverybody to AccessTypeOnlyAddress will not impact previously created codes, which anyone can still instantiate.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Possible key collision in appendToContractHistory function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "x/wasm/keeper/keeper.go:565, the In appendToContractHistory function may cause a key collision when contract addresses end with zeroes. If contract addresses are not guaranteed to have the same length, the prex of a zero-ending address may collide with a contact that has a non-zero-ending address. iteration reverse the in Additionally, since the store code for ContractHistory does not prevent an address collusion in a mixed 20/32 byte address chain, it might cause the transaction to fail when the position counter is not initialized correctly or overows for a 20-byte address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. autoIncrementID is a misleading variable name that may impact future maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "The autoIncrementID function in x/wasm/keeper/keeper.go:956 contains a misleading variable name called lastIDKey that may impact future maintainability. The variable name does not accurately reect its usage  rather than storing the last identier key, and it is actually used as the next identier key.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Input label validation can be bypassed using white space, label supports non-printable characters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "In x/wasm/types/validation.go:26-28, the validateLabel function veries the label is not an empty string without trimming white space from user input. As a result, one can simply provide white space as the contract label, which the validation function does not reject. Additionally, control characters and non-printable characters can be used in the label. This defeats the purpose of the validation and may confuse users.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Proposal validations can be improved", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "x/wasm/types/proposal.go:485-487, In for PinCodesProposal only checks that the provided CodeIDs slice is not empty. Ideally, it should also check that it does not contain duplicated code IDs and that the provided code IDs are not 0. There is also currently no upper bound on the number of CodeIDs in the validation. ValidateBasic function the This issue is also present in the ValidateBasic functions for UnpinCodesProposal and UpdateInstantiateConfigProposal.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. handleMigrateProposal contains unreachable error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "In x/wasm/keeper/proposal_handler.go:107-112, there are two if statements that return an error if the err value is not nil. The second if statement in line 110 cannot be executed because the rst one would always return before it.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Typographic and grammar errors found in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "During the audit, several typographical and grammar errors were found that negatively impact readability:  proto/cosmwasm/wasm/v1/tx.proto:30: \"Sender is the actor that signed the messages\".  x/wasm/keeper/api.go:10, 12: \"much\"  x/wasm/keeper/gas_register.go:59: \"create\"  x/wasm/keeper/keeper.go:266: \"contract\"  x/wasm/types/wasmer_engine.go:214: \"probably\"  x/wasm/types/wasmer_engine.go:143, 157: \"phase\"", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Lack of event emission when storing code, updating, or clearing an admin through a proposal", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "In the following cases, events are emitted when actions are performed through messages, but not when they are performed through proposals. This inconsistency might be confusing for users and may lead to issues for o-chain services such as block explorers.  When storing in x/wasm/keeper/proposal_handler.go:58, no event is emitted. This diers from the handler for StoreCode messages, which emits an event. proposal through code a  When updating in x/wasm/keeper/proposal_handler.go:172, no event is emitted. This diers from the handler for UpdateAdmin messages, which emits an event. proposal through admin an a  When clearing in x/wasm/keeper/proposal_handler.go:188, no event is emitted. This diers from the handler for ClearAdmin messages, which emits an event. proposal through admin an a", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Sudo contract interactions do not consume gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf", "body": "The sudo contract interactions do not consume gas throughout the codebase. Although gas is charged through the tx.GasMeter().ConsumeGas(sudoSetupCosts, \"Loading CosmWasm module: sudo\") call in x/wasm/keeper/keeper.go:461, sudo proposals eventually go into the BeginBlocker or Endblocker, where gas is not actually accounted for. We classify this issue as informational since sudo calls are trusted.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Saving an invalid LastResultsHash and AppHash when performing a hard rollback", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "Hard rollback deletes the block and the app states to recover an incorrect application state In internal/state/rollback.go:117, when removeBlock is true, the transition. in the block latest internal/state/rollback.go:110-111, latestBlock is used to store both LastResultsHash and AppHash in rolledBackState where it should use rollbackBlock when performing a hard rollback. However, removed store. block from is", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Missing error handling for setProposal might cause unwanted state to be ushed to disk and invalid proposals to be included in a block", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "In internal/consensus/state.go:1037.go, there is a call to method setProposal which returns an error. However, this error is not immediately handled, which might cause the proposal to be ushed to disk and created even when an error occurred. One of the reasons why setProposal may return a non-nil error upon an invalid proposal signature as depicted in internal/consensus/state.go:2333. In that case, a proposal that has been signed by a wrong signature gets added to a block, even though it should have been discarded.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Remove unused les and code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "Across the codebase, various instances of unused les and code have been found.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Use of deprecated function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "The abci/client/grpc_client.go:60. deprecated function grpc.WithInsecure is used in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Redundant use of span closing statements is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "In the finalizeCommit method in internal/consensus/state.go:2148, the storeBlockSpan is closed. However, this operation is redundant as in line 2141 there is a deferred statement already closing the same span. Redundant code can make the code more complex or inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Missing validation might lead to dangling pointer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "In the OnStart method in internal/mempool/reactor.go:98, the channel eld from the Reactor type is not checked against the nil value. This can cause a dangling pointer, and the main thread to crash. This is not a security concern in the current implementation, since upon node creation in node/node.go:274 the mempool reactor is initialized and the channel is created by passing a callback SetChannel to method AddChDescToBeAdded. Nevertheless, the fact that the mempool constructor initializes the channel as nil, and there is no further validation could potentially cause an issue in the future.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Delays in the execution of UpdateExecutor transactions could temporarily inhibit the capability of the protocol to execute requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "the The guard in contracts/registry-stake/src/contract.rs:338 checks if current epochs executor is set or not, ensuring that update_executor is called before execute_request for the new epoch. Since transaction order from the mempool is not deterministic, the capability of the protocol to execute requests will be temporarily inhibited until an UpdateExecutor transaction is executed.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. stakes vector could exceed the CosmWasm VM memory limit when loaded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "In contracts/registry-stake/src/state.rs:68, the stakes attribute is dened in the State struct as a vector of strings. This implies that every time the read_state function is invoked, all the State data, including the stakes vector, is loaded into memory. Since the stakes vector has no maximum length, the CosmWasm VM memory could not have enough space available to load it resulting in an execution panic. A bad actor could intentionally use this issue to cause any interaction with the protocol to be very gas intensive, up to the point where any interaction will run out of gas. With current parameters on Osmosis, the cost of this attack would be in the millions of US dollars. While this might still be economically viable, we classify this issue as major, since it can be resolved with a contract upgrade.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Unstake transactions are likely to fail if more than one of them is processed in the same block", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "Unstake in The contracts/registry-stake/src/contract.rs:635-698, takes as input parameter a vector of numeric indexes that represent the users stake slots in the stakes vector. transaction handler, dened In order to process the deletion of the vector data at the provided indexes within an O(1) asymptotic cost, the swap_remove function is used. This method performs a delete substituting data in the selected index slot with the data stored in the latest element of the vector. Consequently, a removal of one element aects also the ordering of the elements stored in the latest positions of the vector. If we have more than one Unstake transaction in the same block, the indexes for any subsequent positions might be wrong, leading to an error, or, if the same sender controls the position, to the deletion of the wrong position. This implies that the likelihood of an Unstake transaction to succeed depends on dierent unpredictable factors like:  The order of transactions in a block  The cardinality of Unstake transactions in a block  The distance of the index to the end of the stakes vector The likelihood of having a transaction error increases drastically on particular events, for example a market crash where users may want to exit funds from the protocol quickly. Additionally, bad actors can grieve users by staking many small amounts, and then front-running others to cause unstake failures. This could be used together with a short of the tokens to attack the whole protocol and prot from a panic in users.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Protocol is prone to censorship", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "The guard dened in contracts/registry-stake/src/contract.rs:342-347 ensures that only the currently elected executor can submit the ExecuteRequest message. This implies that the currently elected executor is not participating, the protocol will be stuck for the entire epoch with no executed requests. responsive and actively if Since every AUTO token holder can stake its tokens and participate in the election, there is a possibility that the executor could be an inactive protocol participant. Also, a malicious actor could stake a large amount of tokens in order to intentionally stop the requests execution, causing all or targeted executions to get delayed. This is particularly impactful for users and attractive for attackers if requests contain trading transactions that require to be executed in a timely manner. Usually, in proof of stake (PoS) systems, such actors would bear an economic cost such as infrastructure maintenance, cost of staked capital, and third-party delegation loss. Also, in this case, it is required to deposit the stake in the contract only for one block since there is no unbonding period, reducing the attackers capital cost and making the attack cheaper with respect to other PoS systems. In fact, in contracts/registry-stake/src/contract.rs:635-698, the Unstake message handler allows the currently elected executor to unstake all of its stake slots without losing its role. Consequently the executor can be in charge of its role without having its stake deposited in the protocol. This would allow an attacker to get an AUTO loan, stake and be elected, unstake, repay the loan and act as an inactive executor in order to stop requests execution without having to hold or loan tokens for long. Also, it is worth to note that in contracts/registry-stake/src/contract.rs:645, during the handling of the Unstake transaction, the executor election is done before removing the unstaking users address from the stakes vector. This implies that an unstaking user could be elected as the current epoch executor without having capital at risk stored in protocol. We classify this issue as minor since the client intends to set the epoch length to 100 blocks, which corresponds to 10 minutes on Osmosis and is low enough to reduce the impact of an attack. Still, market manipulation even over a short time window may be exploited.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Partially implemented tax deductions may lead to failures if tax rates are updated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "In packages/autonomy/src/asset.rs:44-46, used to calculate taxes to be paid when transferring native coins, always returns zero. the compute_tax function that is Consequently it is not eective and future changes in the Osmosis (or another) chain could inhibit the execution of requests submitted in the registry.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Contracts are not compliant with CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "The following contracts do not adhere to the CW2 Migration specication standard: a) registry-stake b) wrapper-osmosis This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. AssetInfo struct is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "In contracts/registry-stake/src/contract.rs:61, representing the AUTO token provided during the instantiation is stored without validation. the AssetInfo struct Since this struct contains an address, it should be checked to ensure that it is a valid one.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Pools allow attackers to extract free value with minimal cost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "The compute_swap function in contracts/pair/src/contract.rs:733 uses unsigned integers for its calculations without rounding, which opens up a way for an attacker to extract value from a pool with a very small cost. As an example, imagine a pool with 5_000_000_000_000 A tokens, and a pool with 1_000_000_000 B tokens. If a user now sends 1 B token, we expect the user to get 5_000 A tokens back. When a user sends 1 A token, we expect the user to get 0 B tokens back (actually 0.0002, but since we are dealing with integers here, the remainder will be dropped). The current implementation incorrectly returns 1 B token though. Imagine further that the value of 1 B token is 5_000 USD, and the value of 1 A token is 1 USD, an attacker can now get a risk free return of around 4_999 USD (minus transaction fees) per transaction. If the attacker repeats this attack, they will be able to drain the pool. Even worse, whenever the attacker shifts the balance enough, other arbitrageurs will be able to extract value by bringing the pool back to the 5_000 to 1 ratio, allowing the attacker to repeat the attack from where they started. Here is a failing test case demonstrating the example: #[test] fn compute_swap_rounding() { let offer_pool = Uint128::from(5_000_000_000_000_u128); let ask_pool = Uint128::from(1_000_000_000_u128); let offer_amount = Uint128::from(1_u128); let commission_rate = Decimal::from_ratio(0_u128, 1_u128); let return_amount = Uint128::from(0_u128); let spread_amount = Uint128::from(0_u128); let commission_amount = Uint128::from(0_u128); assert_eq!( compute_swap(offer_pool, ask_pool, offer_amount, commission_rate), Ok((return_amount, spread_amount, commission_amount)) ); }", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attacker can cause the generators send orphan proxy rewards function to run out of gas, locking orphan rewards in the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "the send_orphan_proxy_rewards in In contracts/tokenomics/generator/src/contract.rs:721, USER_INFO storage map is iterated over with the LP token prex. That iteration is unbounded. An attacker can deposit many the send_orphan_proxy_rewards function to run out of gas. There is currently no way to recover from such an attack, any orphan rewards would be locked forever in the contract. to make the iteration long enough for function the small amounts The query_orphan_proxy_rewards query handler exhibits the same issue in line 880, which could potentially cause calling contracts to run out of gas.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Lack of access control on maker contracts set cong function allows anyone to set themselves as the fund receiver", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "is no access in There contracts/tokenomics/maker/src/contract.rs:225, implying that anyone can change the maker contracts cong. An attacker can for example set themselves as the fund receiver, or change the percentage of funds that goes to governance. set_config restriction function the on", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Lack of access control on generator contracts set tokens per block function allows anyone to set number of tokens per block and extract value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "is no access restriction on the set_tokens_per_block function in There contracts/tokenomics/generator/src/contract.rs:756, implying that anyone can change the tokens_per_block. An attacker can for example set a high number of tokens per block and extract value.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Lack of mass updating pools before changing alloc points leads to incorrect allocation of pending rewards and causes orphan rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "In the add function in contracts/tokenomics/generator/src/contract.rs:154, total_alloc_point gets updated, which implicitly changes the allocation for all other pools. Currently, no mass update is performed before that change. That implies that any pending rewards will be distributed according to the updated allocation, causing some rewards to stay unclaimed in the contracts. imagine there is only one pool A, which has 100 alloc_point out of a For example, total_alloc_point of also 100. Also suppose that a total of 10 tokens have been accrued so far in rewards, but they have not yet been assigned to pool A. According to these numbers, the LP holders of pool A are entitled to a total of 10 reward tokens. Imagine now that pool B gets added with an alloc_point of 300, and immediately afterwards, the rewards for pool A are calculated and allocated. At that point, pool A will only have 100 alloc_point out of 400 total_alloc_point, and LP holders will now only receive 2.5 of the reward tokens. The remaining 7.5 rewards will stay unallocated in the contract. Those tokens may be withdrawn using the SendOrphanProxyReward message. The same issue exists in the set function in 197.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Vested but not yet claimed tokens will be lost when replacing a vesting schedule for an account", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "from When updating a vesting account in the register_vesting_accounts function, previous vesting schedules may be replaced with updated ones. During that logic, any unclaimed amounts in contracts/tokenomics/vesting/src/contract.rs:136. to_receive is then used to reduce the amount that will be transferred from the owner in line 155 (or is refunded to the owner in line 168). Any vested, but not yet claimed amounts are also part of to_receive, and will hence be lost from a users point of view. to_receive schedule vesting added are the to", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Missing spread calculation of stable pair contract is misleading to users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "is not In the pair stable contracts compute_swap and compute_offer_amount functions, the spread in contracts/pair_stable/src/contract.rs:832 and 872. Without the actual spread, the max spread assertion, as well as the returned spread amount, are useless, which is misleading to users. hardcoded computed, rather but yet to A TODO exists in the code that mentions the need for spread calculation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of access control on the generator contracts set allowed reward proxies function allows anyone to set proxies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "There is no access restriction on the set_allowed_reward_proxies function in contracts/tokenomics/generator/src/contract.rs:655, implying that anyone can set proxies that can be used when adding an LP token to the pool. We consider this only a minor issue since only an owner can add LP tokens to a pool. Still, an attacker can grief the owner by removing reward proxies from the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Duplicate storage in two contracts could lead to inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "i. e. asset_infos, contract_addr, liquidity_token, and pair_type, Both factory and pair contracts store the PairInfo struct which contains information about in pairs, in contracts/factory/src/state.rs:19 and contracts/pair/src/state.rs:16 contracts/pair_stable/src/state.rs:17. This duplicate storage might lead to inconsistencies between the two contract states. and", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Borrowers can prevent liquidation leading to bad debt accumulating", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "liquidating When in contracts/credit-manager/src/vault/liquidate_vault.rs:154-166, all the borrowers unlocking positions are processed in a loop. A borrower can create many tiny unlocking positions using the RequestVaultUnlock message, causing the total unlocking positions cardinality to grow to the point where the liquidate_unlocking function runs out of gas. collateral This is highly problematic, since borrowers can prevent being liquidated, which can result in bad debt accumulating.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Liquidators can extract a higher value by looping small amounts of liquidations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In the contracts/credit-manager/src/liquidate_coin.rs:119-127, request_amount is rounded up using the ceil function. This allows a liquidator to extract a higher value by liquidating small amounts of collateral within a loop. Additionally, the maximum close factor can be bypassed as long as a single liquidation message does not exceed the limit, allowing the total liquidated amount to be higher than the congured limit. We consider liquidations consumes a lot of gas, which decreases the protability of the attack. instead of critical this a major issue because performing multiple small Please see the test_repeated_single_liquidation test case to reproduce the issue.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Contract version and name are overwritten during instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "the In contracts/account-nft/src/contract.rs:23-36, during instantiation of account-nft contract, in contract/account-nft/src/contract.rs:29-33 and then again during the call of the parent contract instantiation in contract/account-nft/src/contract.rs:35. the version and name of the contract are set twice. First This implies that the stored CW2 metadata would be the one from the cw721-base contract and not the intended one, potentially causing problems in future migrations.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Duplicate keys should be removed to prevent miscongurations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "contracts/credit-manager/src/instantiate.rs:19-25 and In contracts/oracle-adapter/src/contract.rs:47-49, the msg.allowed_vaults, msg.vault_pricing and msg.allowed_coins are not deduplicated before storing them. If any allowed vault addresses or coin denominations are duplicates, earlier congurations would be overwritten, and only the last key would be saved successfully. We classify this issue as minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Update of the account-nft address can lead to state inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In contracts/credit-manager/src/execute.rs:65-80, the contract owner is able to update the address of the account-nft contract. This can cause state inconsistencies as account ids associated with the previous NFT contract are removed. Also, owners of NFTs from the old contract will lose access to their funds managed in the credit-manager that will be virtually transferred to the owners of the NFTs from the new contract. We classify this issue as minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Funds held by swapper contract may be unintendedly withdrawn", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "When performing a swap in the swapper contract, the output is transferred to the recipient using in message contract/swapper/base/src/contract.rs:187-194. TransferResult created a Then any amount of contract/swapper/base/src/contract.rs:234. the denom_in and denom_out is transferred to the recipient in However, in the case that the swapper contract holds additional funds of either denomination those would be automatically sent to the recipient in addition to the input and output amounts. We classify this issue as minor despite the fact that no funds should be present in the swapper contract there may be situations where funds are sent to the contract, e.g. an airdrop or inadvertent usage.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Update of the red bank address in the credit-manager could lead to state inconsistency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In contracts/credit-manager/src/execute.rs:65-80, the contract owner is able to update the address of the red bank in the credit-manager. This would cause state inconsistencies since all the data stored in TOTAL_DEBT_SHARES and DEBT_SHARES will not be updated accordingly.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. The execution of the AssertBelowMaxLTV callback at the end of the UpdateCreditAccount transaction could run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf", "body": "In the contracts/credit-manager/src/execute.rs:285-288, AssertBelowMaxLTV is always added to the list of callbacks to execute after the other Actions provided as an input in the UpdateCreditAccount message. This callback is executing two times an unbounded loop through the COIN_BALANCES, DEBT_SHARES and VAULT_POSITIONS vectors that have not a capped length. Also, it is executed after all the other Actions and Callbacks so it has only a fraction of the initially provided gas. This implies that if the cardinality of the vectors is signicant, the remaining gas could not be enough to pay the computation leading to out of gas errors. While this scenario is not likely to happen at the launch of the protocol, the risk of running out of gas will increase with more assets supported and wider adoption.", "labels": ["Oak Security", "Severity: Low"]}]