[{"title": "7.1   Automated Security Tools", "body": "  While performing the audit we found a simple but severe issue which would have been flagged by basic smart contract security tools. Using linters, static analyzers and other tools could prevent these mistakes and increase the overall code quality.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "7.2   Compiler Version", "body": "  The used compiler version 0.8.3 is six version behind the current version 0.8.9 (including bug fixes).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "7.3   Events Emit Complete Channel Struct", "body": "  HOPRNet might evaluate if it is necessary to emit the whole channel struct in events. We are not aware of the needs but if not the whole struct it needed, it would be more efficient to only include the relevant parts in the event.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "7.4   Pre- and Post Condition Checks", "body": "  If gas efficiency is not a priority, checking pre- and post conditions after important operations might be valuable. Consider for example that the contract balance could be queried before and after a transfer and it could be checked if the balance reduced or increased exactly to the expected amount.  HOPRNet - Payment Channel -   13  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hopr-payment-channels/"}, {"title": "5.1   Incorrect Liquidity Decrease", "body": "  PoolCollection._calcTargetTradingLiquidity  decreases  the  BNT  trading  liquidity  if  the current funding of a certain pool is greater than its funding limit. This is done in a way that could possibly reset the pool:  uint256 excessFunding = currentFunding - fundingLimit; targetBNTTradingLiquidity = MathEx.subMax0(liquidity.bntTradingLiquidity, excessFunding);  Consider the following example:   The funding limit is 40,000 BNT.   The current funding of the pool is 40,000 BNT.   bntTradingLiquidity is 20,000 BNT (for example after the value of BNT to the corresponding  token has quadrupled).   The funding limit is now lowered to 20,000 BNT by governance.   bntTradingLiquidity is now set to 0 and the pool is reset on the next deposit.  Bancor - Bancor v3 -   13  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedRiskAcceptedLowAcknowledgedRiskAcceptedCodePartiallyCorrectedCodePartiallyCorrectedRiskAcceptedRiskAcceptedDesignMediumVersion2RiskAccepted             \fRisk accepted  Bancor plans to fix this issue in a future version and accepts the risk for now.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "5.2   Missing Slippage Protection", "body": "  The following functions do not guarantee any slippage protection for users and are thus susceptible for front-running attacks:   BancorPortal._uniV2RemoveLiquidity   functions  removeLiqudity  and removeLiquidityETH  of  UniswapV2Router02  with  1  wei  slippage  protection  at  all circumstances.  calls   the    BancorV1Migration.migratePoolTokens   calls  removeLiquidity  StandardPoolConverter with 1 wei slippage protection at all circumstances.  in  Bancor   v1's  Risk accepted:  The client accepts the risk, stating the following:  Similar to how liquidity removal is processed on these 3rd party protocols, it is assumed that users will migrate their liquidity immediately and will be prompted with its results.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "5.3   Missing Getter for Average Rates", "body": "  The function PoolCoollection.poolData is commented as follows:  there  is  no  guarantee  that  this  function  will  remain  forward  compatible,  so  relying  on  it  should  be avoided and instead, rely on specific getters from the IPoolCollection interface  This  indicates  that  all  data  from  the  struct  that  is  returned  by  this  function  is  also  available  via independent getters. There is, however, no getter function available that returns the AverageRates.  Acknowledged  Bancor acknowledged the issue and plans to fix it in a future version.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "5.4   Fake Pool Token Migration", "body": "  BancorV1Migration.migratePoolTokens does not check if the given pool token is registered in the ContractRegistry. For this reason, an attacker could call the function with a fake pool token contract that returns a fake StandardPoolConverter:  IBancorConverterV1 converter = IBancorConverterV1(payable(poolToken.owner()));  Bancor - Bancor v3 -   14  SecurityMediumVersion1RiskAcceptedDesignLowVersion2AcknowledgedSecurityLowVersion1RiskAccepted                        \fThis converter can then in turn return reserve amounts of tokens that do not exist:  uint256[] memory reserveAmounts = converter.removeLiquidity(amount, reserveTokens, minReturnAmounts);  If the BancorV1Migration contract holds only tokens for some reason, these tokens can then be sent to  token  balances  before  calling converter.removeLiquidity.  the  contract  does  not  check   the  attacker  as   its   Risk accepted:  The client accepts the risk noting that the contract is not supposed to receive any tokens.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "5.5   Gas Savings", "body": "  The following list contains suggestions on how the gas consumption of Bancor v3 can be improved:   The fields of MigrationResult in BancorPortal can be rearranged to achieve tighter packing.   BancorNetwork.addPoolCollection  loads  the  latest  pool  collection  from  storage  then  calls  _setLatestPoolCollection which loads the same pool collection from storage again.   BancorNetwork.createPools loads the same pool collection on each iteration from storage.   BancorNetwork._depositBNTFor  transfers  BNT  to  the  BNTPool  which  then  burns  them.  The  tokens could be burned by BancorNetwork instead.   BancorNetwork.withdraw   to BancorNetwork. _withdrawBNT then approves BNTPool for the tokens and transfers the tokens to BNTPool. The tokens could be directly transferred from PendingWithdrawals to BNTPool.  PendingWithdrawal   transfers   tokens   from   pool    BancorNetwork._withdrawBNT transfers vBNT from the provider to BNTPool which then burns  them. The tokens could be burned directly from the provider's address.   BancorNetwork.withdraw   to BancorNetwork. _withdrawBaseToken then approves PoolCollection for the tokens which burns them. The tokens could be directly burned from PendingWithdrawals.  PendingWithdrawal   transfers   tokens   from   pool    Some  or  all  fields  in  NetworkSettings  could  be  immutable  and  updated  via  proxy  upgrade,  depending on how frequently they are updated and loaded.   Many  call  chains  unnecessarily  validate   than  once.  For  example, BancorNetwork.initWithdrawal  validates  the  pool  token  address  and  amount,  then  calls PendingWithdrawals.initWithdrawal  which  performs  the  same  validations  again  even though it can only be called by the BancorNetwork contract.  input  data  more    PoolCollection.depositFor  loads  data.liquidity.stakedBalance  from  storage  and then loads the whole data.liquidity struct from storage with no change of the data in-between.   PoolCollection.depositFor  reads  data.liquidity  from  storage,  updates  the  fields  on  storage and then loads the struct again two times from storage.   PoolMigrator.migratePool  retrieves  the  target  pool  collection  of  a  given  pool  by  calling BancorNetwork.latestPoolCollection.  It  then  calls  PoolCollection.migratePoolOut which performs the same call to check if the given target pool collection is valid.   PoolCollection._poolWithdrawalAmounts takes the Pool struct as memory copy. Since not all  words  are  accessed  and  the  function  is  only  called  with  storage  pointers,  the  data  argument could be a storage pointer and the necessary fields could be cached inside the function.  Bancor - Bancor v3 -   15  DesignLowVersion1CodePartiallyCorrected        \f PoolCollection._executeWithdrawal loads stakedBalance from storage even though it is  already cached in prevLiquidity   PoolCollection._updateTradingLiquidity calls _resetTradingLiquidity which loads liquidity.bntTradingLiquidity  from  storage  even  though  an  overloaded  version  of  the function  exists  which  takes  that  variable  as  an  argument  and  there  is  a  cached  version  of liquidity available.   PoolCollection._performTrade  loads  the  liquidity  struct  from  storage  even  though  the  values are already present in the TradeIntermediateResult argument.   PoolMigrator._migrateFromV1  translates  the  Pool  struct  from  the  old  version  to  the  new  version. Since the structs are identical, this is not necessary.   PoolToken._decimals can be immutable.  pools    Because   address, PoolTokenFactory.createPoolToken could take the override variables as arguments instead of using storage variables.  added   admin   only   can   the   be   by    AutoCompoundingRewards.terminateProgram loads ProgramData from storage to check if the given program exists. As the pool is later removed from _pools, the call would revert anyways if the the pool program did not exist.  In  AutoCompoundingRewards  some  ProgramData struct from storage even though not all words are required.  (e.g.  enableProgram)   functions   load   the  whole  In StandardRewards some functions (e.g. createProgram) load the whole ProgramData struct from storage even though not all words are required.   The fields _bntPool, _pendingWithdrawals and __poolMigrator in BancorNetwork could be  immutable  if  they  are  set  up  either  directly  in  the  constructor  of  BancorNetwork  or  with pre-known addresses.  In BancorNetwork.flashloan, the user could pay the loaned amount directly back to the master vault.   During  a  withdrawal  of  base   in PendingWithdrawals instead of burning a part of them, sending the rest to BancorNetwork and finally burning them in PoolCollection.  tokens  (not  BNT),  all  pool   tokens  could  be  burned   Code partially corrected:  The client has addressed some of the suggestions. Additionally, some are no longer relevant due to other code changes.   Corrected: The fields of MigrationResult in BancorPortal are now tightly packed.   Corrected: latestPoolCollection has been completely removed from the code.   Corrected: BancorNetwork.createPools takes the respective pool collection as argument.   Not corrected: BancorNetwork._depositBNTFor still transfers BNT to the BNTPool which then  burns them.   Corrected:   BancorNetwork._withdrawBNT   directly   transfers   pool   tokens   from  PendingWithdrawal to BNTPool.   Not  corrected:  BancorNetwork._withdrawBNT  still  transfers  vBNT  from  the  provider  to  BNTPool which then burns them.   Partially corrected: BancorNetwork._withdrawBaseToken directly transfers pool tokens from  PendingWithdrawal to PoolCollection.   Not corrected: All fields in NetworkSettings are still storage variables.  Bancor - Bancor v3 -   16     \f Not corrected: There are still many call chains that validate input multiple times.   Not   corrected:   PoolCollection.depositFor   still   redundantly   loads  data.liquidity.stakedBalance from storage.   Not  corrected:  PoolCollection.depositFor  still  redundantly   loads  data.liquidity  multiple times from storage.   Corrected: latestPoolCollection has been completely removed from the code.   Corrected: PoolCollection._poolWithdrawalAmounts takes only relevant and cached data  as input.   Not  corrected:  PoolCollection._executeWithdrawal  still  loads  stakedBalance  from  storage.   Corrected:  PoolCollection._updateTradingLiquidity  uses  the  overloaded  version  of  _resetTradingLiquidity.   Not  corrected:  PoolCollection._performTrade  still  loads  the  liquidity  struct  from  storage.   Not   corrected:   PoolMigrator._migrateFromV1   has   been   renamed   to  PoolMigrator._migrateFromV5 but still unnecessarily translates equal structs.   Not corrected: PoolToken._decimals is still a storage variable.   Not corrected: PoolTokenFactory.createPoolToken still uses storage for override variables.   Not  corrected:  AutoCompoundingRewards.terminateProgram  still  redundantly  checks  for  pool existance.   Not  corrected:  In  AutoCompoundingRewards  some  functions  (e.g.  pauseProgram)  still  load  more data from storage than required.   Not corrected: In StandardRewards some functions (e.g. _programExists) still load more data  from storage than required.   Not  corrected:  The  fields  _bntPool,  _pendingWithdrawals  and  __poolMigrator  are  still  stored in storage.   Not  corrected:  In  BancorNetwork.flashloan,  the  loaned  amount  is  still  paid  back  to  the  contract and then sent to the master vault.   Corrected: PendingWithdrawals.completeWithdrawal does not burn tokens anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "5.6   Inconsistent Reentrancy Protection", "body": "   AutoCompoundingRewards.createProgram  has  a  reentrancy  protection,  while  the  functions  terminateProgram and enableProgram do not.   BancorNetwork.withdrawNetworkFees  does  not  have  reentrancy  protection,  while  other  functions that are restricted to callers with certain roles have.  Code partially corrected  function Although  all  mentioned  AutoCompoundingRewards.setAutoProcessRewardsCount  lacks  reentrancy  protection  while  all other functions restricted to the admin are protected.  functions  are  now  protected  against  reentrancy,   the  new   Bancor - Bancor v3 -   17  DesignLowVersion1CodePartiallyCorrected          \f5.7   Rounding Error Can Lock Tokens  When  creating  a  StandardRewards  program,  both  the  reward  rate  and  the  remaining  rewards  are computed as follows:  uint256 rewardRate = totalRewards / (endTime - startTime); _programs[id] = ProgramData({     ...     rewardRate: rewardRate,     remainingRewards: rewardRate * (endTime - startTime) });  Depending  on  the  token's  number  of  decimals  and  the  duration  of  the  program,  remainingRewards can be smaller than totalRewards due to the divide-then-multiply scheme. In practice, this means that in  such  cases,  totalRewards  -  remainingRewards  tokens  won't  be  distributed  and  will  never  be deduced  from  _unclaimedRewards.  This  results  in  the  tokens  being  locked  in  the  contract  and  not being able to be used for future programs.  Risk accepted:  The client accepts the risk, stating the following:  The  amount  of  tokens  which  can  be  locked  due  to  a  rounding  error  is  negligible.  We  are  also considering revamping the whole mechanism, which will also affect this code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "5.8   BNTPool.renounceFunding Division by 0", "body": "  In  PoolCollection._executeWithdrawal,  if  the  protocol  has  to  renounce  BNT  funding  and  this results  in  the  BNT  staked  balance  being  reset  to  0,  but  the  BNT  trading  liquidity  is  still  greater  than  0, _resetTradingLiquidity  is  called  which  tries  to  renounce  BNT  funding  again.  As  the  staked balance has already been set to 0, this second call to BNTPool.renounceFunding will now revert due to a division by 0.  Consider the following case:   User A deposits TKN liquidity into an empty pool.   Trading is enabled.   User B trades a certain amount of TKN for BNT.   User A now withdraws all his supplied TKN.   The withdrawal fails due to the mentioned problem.  Risk accepted:  The client accepts the risk, stating the following:  This  is  a  rare  case  that  we  don\u2019t  expect  to  happen  in  practice,  since  trading  can\u2019t  be  enabled immediately and usually involves many depositors. In any case, we will consider addressing this in the future as well.  Bancor - Bancor v3 -   18  DesignLowVersion1RiskAcceptedCorrectnessLowVersion1RiskAccepted                \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Oracle Manipulation   -Severity Findings   BNT Burned Twice    Locked vBNT    Pool Denial of Service   -Severity Findings  0  1  3  18   BNT Deposit Allows msg.value > 0    Consistency Issues Between Implementation, Excel Demonstration and Documentation Regarding  the Withdrawal    Different Programs Can Share the Same Reward    Emission of Events With Arbitrary Amounts   Impossible to Migrate ETH Position   Inconsistent Naming   Inconsistent Use of ERC20.transfer    Misleading Comment    Misleading Comment in PoolCollection.enableTrading    Problematic Loop Continuation During Pool Migration    Undocumented Behavior    Unused Imports / Variables    Wrong Function Name in BancorPortal    Wrong Interface    AutoCompoundingRewards Can Burn More Pool Tokens Than Expected    BNTPool.renounceFunding Fails on Insufficient BNT Pool Token Balance    ERC20Permit Handling    MathEx.reducedFraction Can Turn Denominator to 0   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.1   Oracle Manipulation", "body": "  To  prevent  manipulation,  Bancor  v3  calculates  a  moving  average  of  each  pool's  spot  price  that  is adjusted  once  per  block.  Critical  actions  like  the  increase  of  trading  liquidity  or  withdrawal  of  funds  Bancor - Bancor v3 -   19  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityHighVersion1CodeCorrected           \frequires  the  spot  rate  of  a  pool  to  not  diverge  from  this  moving  average  by  more  than  a  certain percentage.  Since the moving average is calculated as an arithmetic mean, it is subject to manipulation. Consider the following scenario:   An attacker funds a pool with some tokens with a spot rate of 1 BNT : 1 token.   They perform a trade from BNT to the token by providing an amount of BNT that changes the spot  rate to 10 BNT : 1 token. The average rate is now 2.8 BNT : 1 token.  In the next block, they perform another trade from token to BNT to bring the spot rate back to 2.8 BNT : 1 token.   Since the spot rate now equals the average rate, the attacker can withdraw his supplied tokens.   The  pool  does  not  contain  enough  tokens  to  satisfy  the  withdrawal,  so  the  attacker  gets  compensated in BNT for the outstanding amount.   This compensation is calculated with the average rate of the pool which now is 2.8 BNT to 1 token  instead of the real 1 : 1 rate.   The attacker will receive 2.8 times the amount of BNT he is actually eligible to receive.  The  attacker  is  required  to  split  both  trades  in  2  consecutive  blocks.  In  the  first  block,  they  create  an arbitrage opportunity that can be utilized by an arbitrageur. To make sure, their initial investment will not be lost, they must selfishly mine 2 blocks in a row. This is possible with around 1.5% of the total hashrate of Ethereum. Renting this amount of hashrate is in the realm of possibilities and we estimate that the cost of renting the hashrate and losing out on the reward of the additional mined blocks results in a total cost of ~150.000 USD.  Alternatively, an attacker could try to spam transactions to the Ethereum network in order for their second transaction to be executed before the transactions of any arbitrage bot.  Furthermore, after Ethereum's transition to Proof-of-Stake, the attack becomes simpler: As the attacker now knows when it is their turn for validation, they could submit their first transaction right to the block before. Using Flashbots, the transaction could actually be hidden so that no arbitrage bots would see it before it is included in the block. The next block is then in the hand of the attacker.  While this attack is hard to carry out and requires a lot of capital, it can also create immense losses.    A second moving average for the inverse rate has been introduced. Averages for the rate and the inverse rate are calculated independently which prevents the aforementioned attack. The resulting inverse rate in the example would diverge from the inverse spot rate by ~100%.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.2   BNT Burned Twice", "body": "  Withdrawals  from  PoolCollection  can  result  in  the  burning  of  double  the  amount  of  BNT  than intended. This happens any time a withdrawal occurs that results in the protocol removing BNT from the this  case,  both  amounts.bntProtocolHoldingsDelta.value  and protocol  equity.  amounts.bntTradingLiquidityDelta.value are set to the same value greater than 0, resulting in a  call  to BNTPool.burnFromVault which burns the same amount of BNT again.  to  BNTPool.renounceFunding  which  burns   the  amount  of  BNT  and  a  call   In     Bancor - Bancor v3 -   20  CorrectnessMediumVersion1CodeCorrected         \fboth   If  and amounts.bntTradingLiquidityDelta.value  are  greater  than  0,  only  the  former  value  triggers token burning (via BNTPool.renounceFunding).  amounts.bntTradingLiquidityDelta.value   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.3   Locked vBNT", "body": "  the   StandardRewards   In  or depositAndJoinPermitted to deposit underlying tokens and stake the obtained pool tokens in one single transaction. To perform such aggregation, the protocol transfers the tokens from the user to itself and calls BancorNetwork.depositFor to get the pool tokens that will then be used for staking.  depositAndJoin   contracts,   users   can   call   If the token being deposited is BNT, BancorNetwork will send both bnBNT and vBNT to the contract. As there is no handling for vBNT, it will stay locked into the contract, preventing the user to ever withdraw his BNT from the network.    depositAndJoin  now  keeps  the  pool  tokens,  but  sends  vBNT  back  to  the  provider  if  BNT  are deposited.  Additionally,  a  temporary  function  transferProviderVBNT  has  been  added  to  allow distribution of already accumulated vBNT to their owners by the contract admin.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.4   Pool Denial of Service", "body": "  The  first  user  to  deposit  into  a  newly  created  pool  can  immediately  burn  his  pool  tokens.  In  this  case, depositing into the pool no longer works, because the following check will revert:  if (poolTokenSupply == 0) {     if (stakedBalance > 0) {         revert InvalidStakedBalance();     } }  A malicious user could create a bot that performs this attack cheaply by instantly depositing 1 wei base tokens into any newly created pool.    New deposits now reset the pool when pool token supply is 0 and staked balance is greater than 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.5   BNT Deposit Allows msg.value > 0", "body": "  BancorNetwork.depositFor is payable. While the _depositBaseTokenFor function makes sure that it reverts if the sent token is not equal to ETH and msg.value is greater than 0, the same check is not applied in _depositBNTFor.  Bancor - Bancor v3 -   21  DesignMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f  _depositBNTFor now reverts if msg.value is greater than 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.6   Consistency Issues Between Implementation,", "body": " Excel Demonstration and Documentation Regarding the Withdrawal  1. Deviating Calculation of BNT Burned  The  formula  for  BNT  trading  liquidity  to  be  burned  from  the  pool  defined  in  the  excel  spreadsheet renounce nothing method.A11 is deviating from the white paper and the implementation. It seems like the sign in front of B10*E10 needs to be removed.  The documented and implemented formula is:  P =  ax(b + c + e(2 \u2212 n)) (1 \u2212 m)(be + x(b + c \u2212 e(1 \u2212 n)))  The formula used in excel is:  2. Incorrect Denominator  P =  ax(b + c + e(2 \u2212 n)) (1 \u2212 m)(\u2212be + x(b + c \u2212 e(1 \u2212 n)))  The documentation on page 39 has the following formula documented for hmax  supr  hmaxsurp = be(en + m(b + c \u2212 e)) (1 \u2212 m)(b + c \u2212 e(1 \u2212 n))  The formula's denominator is missing the additional term (b+c-e)  Specification changed  Bancor replied the following:  Both issues outlined here were actually typing errors in the spec, while the implementation is correct. The spec was updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.7   Different Programs Can Share the Same", "body": " Reward  AutoCompoundingRewards ensures that only one program exists for a specific pool at a given time. In practice, this means that the pool tokens allocated for such programs cannot be used by another one.  Bancor - Bancor v3 -   22  CorrectnessLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1CodeCorrected                          \fSimilarly, using _unclaimedRewards, StandardRewards makes sure that if multiple programs have the same reward token, the external reward vault must contain enough tokens to cover all of them.  However,  if  StandardRewards  and  AutoCompoundingRewards  contain  programs  for  the  same reward token and the address for the _externalRewardsVault is the same in both contracts, correct funding cannot be ensured because both programs only check that there are enough funds in the vault.    StandardRewards  now  only  distributes  BNT  via  minting.  _externalRewardsVault anymore.  It  does  not  access   the  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.8   Emission of Events With Arbitrary Amounts", "body": "  BancorNetwork._initWithdrawal does not check if the supplied pool token address belongs to a pool. An attacker could call the function with a fake pool token that returns a valid pool address:  Token pool = poolToken.reserveToken(); if (!_network.isPoolValid(pool)) {     revert InvalidPool(); }  The contract would then transfer the fake pool tokens from the attacker while the attacker keeps the real pool tokens and emit a WithdrawalInitiated event with arbitrary pool token amounts. While this is not  a  problem  for  the  protocol  itself  and  is  also  not  exploitable  in  the  final  withdrawal,  third  party applications relying on the emitted events could be affected.    _initWithdrawal now correctly checks if the supplied pool token is valid.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.9   Impossible to Migrate ETH Position", "body": "  When  trying  to  migrate  a  Uniswap  or  SushiSwap  position,  if  one  of  the  tokens  is  the  protocol  defined native token address 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, the call to the factory to obtain  transaction  will  revert  with the  NoPairForTokens as this custom address is not used in these protocols.  the  pair's  address  will  return   the  address  zero  and   Code corrected  Bancor now interacts with Uniswap and SushiSwap using the WETH address instead of 0xEee...EEeE.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.10   Inconsistent Naming", "body": "  Bancor - Bancor v3 -   23  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fBancorPortal.migrateSushiSwapV1Position returns a struct with \"Uniswap\" in one of its field's names.    migrateUniswapV2Position and migrateSushiSwapPosition now both return a struct with the name PositionMigration.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.11   Inconsistent Use of ERC20.transfer", "body": "  In some cases a normal transfer is used. Some of these occurrences have the comment:  // transfer the tokens to the provider (we aren't using safeTransfer, since the PoolToken is a fully // compliant ERC20 token contract) p.poolToken.transfer(provider, poolTokenAmount)  But the pool token is also transferred with a safe transfer in another case  poolToken.safeTransferFrom(provider, address(_pendingWithdrawals), poolTokenAmount)  The assumption that all tokens behave as expected should be carefully evaluated against gas savings between a normal transfer and a safe transfer.    BancorNetwork._initWithdrawal  now  transfers  the  pool  tokens  using  a  regular  transferFrom call.  Since  all  pool  tokens  are  PoolToken  contracts,  they  revert  on  failure  making  it  safe  to  use  the regular transferFrom function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.12   Misleading Comment", "body": "  _latestPoolCollections in BancorNetwork has the following comment:  a mapping between the last pool collection that was added to the pool collections set and its type  Since the function setLatestPoolCollection allows the governance to set to latest pool collection to any pool collection, the comment is incorrect.  Furthermore, when the the \"latest\" pool collection is set to an older version, multiple pool collections with the same version can be added through addPoolCollection.    The latestPoolCollections mechanism has been completely removed.  Bancor - Bancor v3 -   24  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.13   Misleading Comment in  PoolCollection.enableTrading  A comment of PoolCollection.enableTrading states:  if  the  price  of  one  (10**18  wei)  BNT  is  $X  and  the  price  of  one  (10**6  wei)  USDC  is  $Y,  then  the virtual balances should represent a ratio of X to Y*10**12  The explanation is ambiguous and could be misunderstood in a way that both virtual balances must be represented with the same number of decimals.    The addressed documentation has been improved to clarify possible misunderstandings.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.14   Problematic Loop Continuation During Pool", "body": " Migration  BancorNetwork.migratePools  checks  if  newPoolCollection  is  equal  to  the  0-address.  In  the current setup this can never happen.  Furthermore,  if  the  PoolMigrator  implementation  changes  for  future  PoolCollection  versions  so that  the  migratePool  function  could  indeed  return  the  0-address,  the  mentioned  check  leads  to  a continuation of the migration loop:  if (newPoolCollection == IPoolCollection(address(0))) {     continue; }  In this case, the pool data of the old pool would be lost and _collectionByPool would point to a pool collection that does not contain the migrated pool anymore.    The  lastPoolCollection  mechanism  has  been  completely  removed  and  migrations  to  new  pools now require the caller to pass an explicit pool collection to the migratePool function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.15   Undocumented Behavior", "body": "  The  trade  functions  in  BancorNetwork  allow  the  user  to  declare  a  beneficiary.  If  the  user  sets  this beneficiary  to  the  0-address,  the  beneficiary  is  replaced  with  the  user's  address.  This  behavior  is  not documented.    Bancor - Bancor v3 -   25  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \fAll trade functions now explain the mentioned special behavior.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.16   Unused Imports / Variables", "body": "  The following types have been imported but not used inside the respective contracts:   BancorNetwork:   WithdrawalRequest   BancorV1Migration:   Upgradeable   BNTPool:   Utils   Fraction   IPoolCollection   Pool   PoolToken   PoolMigrator:   Fraction   AutoCompoundingRewards:   AccessDenied   StandardRewards   AccessDenied  Additionally,  BNTPool  twice,  PoolMigrator  defines  a  private  constant INVALID_POOL_COLLECTION  that  is  not  used  and  StandardRewards  defines  an  unused  error PoolMismatch.  imports  Token     All unused imports and variables have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.17   Wrong Function Name in BancorPortal", "body": "  BancorPortal contains a function migrateSushiSwapV1Position indicating calls to SushiSwap v1 even though the referenced contracts belong to SushiSwap v2.    V1 and V2 strings have been removed from all function, event and variable names related to SushiSwap.  Bancor - Bancor v3 -   26  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.18   Wrong Interface  BancorV1Migration.migratePoolTokens  v3's types  IPoolToken interface. While this is not a problem right now, future changes in the interface might create problems here.  legacy  DSToken  addresses  with     BancorV1Migration now uses a separate interface for legacy pool tokens.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.19   AutoCompoundingRewards Can Burn More", "body": " Pool Tokens Than Expected  On creation of a program in AutoCompoundingRewards, the caller provides the amount of tokens that should  be  distributed  during  the  lifetime  of  the  program.  Depending  on  the  token  to  be  distributed, createProgram  and PoolCollection.poolTokenAmountToBurn.  Both  functions  use  the  same  formula  to  calculate  the amount of pool tokens that have to be burned in order to distribute the given token amount:  BNTPool.poolTokenAmountToBurn   either   calls   function poolTokenAmountToBurn(uint256 bntAmountToDistribute) external view returns (uint256) {     if (bntAmountToDistribute == 0) {          return 0;      }       uint256 poolTokenSupply = _poolToken.totalSupply();      uint256 val = bntAmountToDistribute * poolTokenSupply;       return          MathEx.mulDivF(              val,              poolTokenSupply,              val + _stakedBalance * (poolTokenSupply - _poolToken.balanceOf(address(this)))          ); }  The formula allows for the burning of high amounts of pool tokens (up to the total), which can become problematic for new deposits as the value of the pool tokens now far exceeds the value of the underlying tokens, potentially leading to large rounding errors for token suppliers. To highlight this problem, consider the following example:   bnBNT total supply is 20000   The protocol holds all bnBNT (i.e. no user has supplied any BNT)  In this case  _stakedBalance * (poolTokenSupply - _poolToken.balanceOf(address(this))  is now 0. The formula is therefore reduced to:  bntAmountToDistribute * poolTokenSupply * poolTokenSupply     / bntAmountToDistribute * poolTokenSupply  Bancor - Bancor v3 -   27  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected              \fThe amount of tokens to be distributed is now completely factored out of the equation. It will therefore always return poolTokenSupply to be burned, no matter the amount of tokens to distribute.    If the amount of pool tokens to be burnt in a single program exceeds 50% of the total supply, the program is  now  terminated.  This  ensures  that  the  value  of  pool  tokens  does  not  appreciate  too  much  in comparison to the underlying.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.20   BNTPool.renounceFunding Fails on", "body": " Insufficient BNT Pool Token Balance  BNTPool.renounceFunding  removes  a  given  amount  of  BNT  and  burns  the  corresponding  pool tokens. Because the pool tokens will be distributed to BNT liquidity providers, there can be circumstances where the protocol does not hold enough pool tokens for a given amount BNT that has to be burned. This will result in reverting transactions.  Consider the following example:  Liquidity  provider  withdrawals  that  exceed  the  amount  of  excess  tokens  in  a  given  pool  require  the protocol  to  decrease  the  liquidity  of  the  pool.  If  the  amount  of  BNT  liquidity  that  must  be  removed  is greater than the amount of BNT pool tokens the protocol holds (because enough users have provided BNT liquidity in exchange for BNT pool tokens), the call will revert.    renounceFunding  now  burns  at  most  the  amount  of  pool  tokens  available  and  updates  the  staked balance accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.21   ERC20Permit Handling", "body": "  The permit function of ERC20Permit tokens is called expecting them to revert if the given signature is incorrect.  While  this  is  the  correct  behavior  according  to  the  EIP  2612  specification,  numerous  token projects  have  shown  that  specifications  are  not  always  adhered  to  completely  (e.g.  the  transfer function in USDT). Therefore, it might be possible that some token project exists that does not revert but rather returns a boolean value on calls to permit.    ``ERC20Permit` support has been completely removed from the project.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "6.22   MathEx.reducedFraction Can Turn", "body": " Denominator to 0  Bancor - Bancor v3 -   28  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \fMathEx.reducedFraction  equally  scales  down  two  uint256  values  so  that  the  higher  value  does not exceed a defined maximum. It computes the factor by which the values have to be divided with the following code:  uint256 scale = Math.ceilDiv(Math.max(fraction.n, fraction.d), max);  In the case that fraction.d is smaller than scale, the fraction's denominator will be set to 0 causing undefined behavior. Since the function is always used with a max value of type(uint112).max, this can  only  happen  in  edge  cases  where  the  numerator  of  the  fraction  is  type(uint112).max  times greater than the denominator.  Code Corrected:  reducedFraction now reverts if the denominator is set to 0.  Bancor - Bancor v3 -   29  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.1   32 Bit Timestamps in Storage", "body": "  Some contracts (e.g. AutoCompoundingRewards) keep timestamps with the type uint32 in storage. This will render the contracts unusable and make them hard to upgrade after the year 2106.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.2   Impermanent Loss Protection Can Be", "body": " Disabled  PoolCollection.enableProtection  can  be  called  by  Bancor  v3's  governance  to  disable Impermanent  Loss  protection.  This  can  result  in  liquidity  providers  not  being  able  to  withdraw  the  full amount of tokens they are owed. In fact, LPs can end up with less tokens than originally provided and without any compensation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.3   Implementations Not Initialized", "body": "  Bancor deploys some if its contracts using a proxy pattern. However, the deployed implementations are not initialized by default. This is also evident on the current live version of the protocol. While this is not a problem  currently,  later  changes  might  introduce  DELEGATECALL  op-codes.  In  this  case,  a  malicious user  could  claim  ownership  of  the  contract  and  generate  a  DELEGATECALL  to  a  contract  containing  a SELFDESTRUCT op-code, causing a denial of service.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.4   Inconsistent Interface", "body": "  PoolCollection  defines  a  function  enableDepositing  with  a  boolean  argument  to  determine  if depositing  should  be  enabled  or  disabled.  On  the  contrary,  it  defines  the  distinct  functions enableTrading and disableTrading.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.5   Liquidity Growth Not Restricted", "body": "  When a pool gets enabled for trading, the starting liquidity is set to a pre-determined amount of BNT and not  set  to  the  full  amount  possible.  On  certain  actions,  the  trading  liquidity  is  allowed  to  grow  by  the LIQUIDITY_GROWTH_FACTOR  liquidity  by  calling  factor.  However,  anyone  can  grow   the   Bancor - Bancor v3 -   30  NoteVersion1NoteVersion2NoteVersion1NoteVersion1NoteVersion1                  \fBancorNetwork.depositFor  with  the  minimum  amount  of  1  wei  token.  Thus,  this  mechanism  only protects against accidents and not against deliberate manipulation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.6   Missing Access Control in postUpgrade", "body": "  postUpgrade  has  no  access  restrictions.  Using  it  in  an  upgrade  needs  to  happen  in  one  transaction  if frontrunning should be mitigated. Bancor has a deploy script that will automatically call this function in the upgrade transaction. But this is not guaranteed and might fail. We cannot see a case that it should be callable by everyone.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.7   More vBNt Than bnBNT Obtainable", "body": "  If the protocol does not have any bnBNT, it should be impossible to deposit BNT and hence obtain vBNT. However, in this case, a user can first send some bnBNT to the BNTPool and then deposit some BNT to obtain both the pre-owned bnBNT and newly minted vBNT. Although the BNT the user just deposited is not  withdrawable  anymore  as  he  does  no  longer  own  the  corresponding  bnBNT,  he  is  able  to  obtain additional vBNT at this cost.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.8   No Recovery of Accidental Token Transfers", "body": " Possible  In  case  an  ERC20  token  other  than  the  BNT  or  one  of  the  base  tokens  is  sent  to  the  contract,  then  it cannot  be  recovered.  Among  other  reasons,  this  might  happen  due  to  airdrops  based  on  the  base tokens.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.9   Potential External Contract Manipulation", "body": "  functions   The  and BancorNetworkInfo.withdrawalAmounts  are  subject  to  manipulation  by  reentrancy.  If  the mentioned  functions  are  used  in  any  way  to  alter  the  state  of  an  external  contract  (for  example  an investment protocol that supplies liquidity to Bancor v3), the values they return can be manipulated by calling the external contract in the onFlashLoan callback of BancorNetwork.flashloan.  PoolCollection.withdrawalAmounts   This is possible because of the following call in PoolCollection._poolWithdrawalAmounts:  int256 baseTokenExcessAmount = pool.balanceOf(address(_masterVault)) -     data.liquidity.baseTokenTradingLiquidity;  onFlashLoan  will  be  called  after  the  balance  of  _masterVault  has  already  been  reduced  by  the flashloan amount.  Bancor - Bancor v3 -   31  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \f7.10   Redundant Role Management  Most  contracts  are  upgradable.  Hence,  they  have  their  own  admin  account.  There  is  no  central management checking these roles are set accordingly. An admin change needs to be done individually and redundantly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.11   Unequal Token Burning", "body": "  Withdrawal  of  supplied  tokens  is  subject  to  a  7-day  waiting  period.  In  this  period,  newly  generated interest is not accrued to the withdrawing user. This means, that after 7-days, the pool tokens sent to the PendingWithdrawals  contract  are  worth  slightly  more  than  the  amount  of  tokens  the  user  actually receives. Because PoolCollection completely burns all of these pool tokens, while BNTPool keeps them, the outcome of a withdrawal of BNT differs to withdrawals of other tokens. Consider the following 2 examples:  BNT:   totalSupply of bnBNT is 100.   _stakedBalance in the BNTPool is 100.   A user initiates a withdrawal with 50 bnBNT, allowing them to withdraw 50 BNT after 7 days.   After 7 days, 100% interest has accrued and the new _stakedBalance is now 200.   The  user  withdraws  their  50  BNT  (which  get  minted)  and  the  50  bnBNT  are  repossessed  by  BNTPool.   _stakedBalance is now 200.   totalSupply is now 100.  TKN:   totalSupply of bnTKN is 100.   _stakedBalance in the PoolCollection is 100.   A user initiates a withdrawal with 50 bnTKN, allowing them to withdraw 50 TKN after 7 days.   After 7 days, 100% interest has accrued and the new _stakedBalance is now 200.   The user withdraws their 50 TKN and the 50 bnTKN are burned.   _stakedBalance is now 150.   totalSupply is now 50.  Both examples illustrate the same scenario but in the BNT case, a pool token is worth 2 BNT in the end, while in the TKN case, a pool token is now worth 3 TKN.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "7.12   Unsupported Tokens", "body": "  Not all ERC20 tokens can act as base tokens for Bancor v3 contracts. In particular, the following tokens are not supported:  Bancor - Bancor v3 -   32  NoteVersion1NoteVersion2NoteVersion1          \f Tokens that return metadata fields like name and symbol encoded as bytes32 instead of string (e.g.  MKR).  PoolTokenFactory.createPoolToken  will  fail  to  create  a  pool  token  for  these tokens.   Tokens  that  take  a  fee  on  transfer  (e.g.  PAXG  and  possibly  USDT).  A  deposit  will  use  the  full  amount to mint pool tokens while the contract has received a lower amount.   Tokens that have a rebasing mechanism (e.g. AAVE's aToken). User's staked balances will not be  updated accordingly.  Additionally, the following tokens could break the protocol in the future:   Tokens with blacklists (e.g. USDT, USDC).   Upgradeable tokens that add one of the mentioned mechanisms in the future.   Pausable tokens (e.g. BNB).  Bancor - Bancor v3 -   33  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/bancor-v3/"}, {"title": "5.1   Obsolete Storage Writes During Pool", "body": " Deployment  0  0  2  0  After the intermediate report, the following functions have been added to DMMPool:  function name() public override view returns (string memory) {     IERC20Metadata _token0 = IERC20Metadata(address(token0));     IERC20Metadata _token1 = IERC20Metadata(address(token1));     return string(abi.encodePacked(\"KyberDMM LP \", _token0.symbol(), \"-\", _token1.symbol())); }  function symbol() public override view returns (string memory) {     IERC20Metadata _token0 = IERC20Metadata(address(token0));     IERC20Metadata _token1 = IERC20Metadata(address(token1));     return string(abi.encodePacked(\"DMM-LP \", _token0.symbol(), \"-\", _token1.symbol())); }  The pool storage still contains the old name and symbol variables which are set during execution of the constructor.  Due  to  the  new  functions,  the  new  name  and  symbol  will  be  returned  while  the  storage variables are now obsolete.  constructor() public ERC20Permit(\"KyberDMM LP\", \"DMM-LP\", \"1\") VolumeTrendRecorder(0) {  These unnessesary storage writes makes the deployment of new pools more expensive than necessary. In  particular  100,000  gas  (roughly  20  USD  at  the  time  of  writing)  could  be  saved  during  each  pool deployment.  Kyber.Network - KyberSwap Classic - ChainSecurity  11  SecurityDesignCorrectnessCriticalHighMediumAcknowledgedLowDesignMediumVersion2           \f5.2   Actual Amplification Reduces After Unblanced Contribution  Users may add liquidity to a pool by directly invoking DmmPool.mint().  Normally,  liquidity  is  added  in  balanced  amounts  of  token0  and  token1  according  to  the  pool's inventory  as  the  amount  of  liquidity  tokens  minted  in  return  is  based  on  the  lower  contribution.  The surplus amount of the other token is kept by the pool.  After minting, the values of the virtual reserves are updated as follows:  liquidity = Math.min(     amount0.mul(_totalSupply) / data.reserve0,     amount1.mul(_totalSupply) / data.reserve1 ); uint256 b = liquidity.add(_totalSupply); _data.vReserve0 = Math.max(data.vReserve0.mul(b) / _totalSupply, _data.reserve0); _data.vReserve1 = Math.max(data.vReserve1.mul(b) / _totalSupply, _data.reserve1);  Unbalanced  contributions  reduce  the  factor  between  the  value  of  the  actual  reserve  and  the virtualReserve, hence the pool \"looses amplification\" figuratively speaking. In an extreme scenario of an unbalance contribution, which is rather costly for an attacker and has no clear benefit, the following scenario may arise:  Assume a pool has following state: reserve0 = 1000, reserve1 = 1000, vReserve0 = 2000 and vReserve1 = 2000.  1. A  user  adds  2000  token0  and  1  token1  to  the  pool.  The  values  for  vReserve0  and vReserve1 should now be 2002. However, as the pool received an additional amount of token0 the  value  of  reserve0  (3000)  is  now  higher  than  the  result  of  the  calculation  for  the  new vReserve0 amount, hence the value for vReserve0 is set to _data.reserve0.  2. This  step  may  be  repeated  for  the  other  token:  A  user  adds  3  tokens  to  reserve0  and  2998 tokens to reserve1. Then again the vReserve1 will get the value of reserve1.  3. Now it holds that reserve0 = vReserve0 and reserve1 = vReserve1.  After such a scenario an amplified pool is no longer amplified.  Note  that  a  similar  attack  vector  can  be  implemented  using  burn  for  tokens  that  accrue  rewards  on transfer.  unbalanced   The documentation provided does not describe the expected behavior when liquidity is added in case of an  section paper  Adding  liquidity  in  Ampfliciation  model  on  page  7  the  only  case  described  is  when  the contributions match the expected ratio.  Amplification   contribution.   Model,   the   In   in   Acknowledged:  Kyber is aware of this scenario and states:  Note that liquidity providers get benefits if this scenario happens and the attacker has no economic incentives to do this.  Kyber.Network - KyberSwap Classic - ChainSecurity  12  DesignMediumVersion1Acknowledged        \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Conflicting Statements About Contribution Ratio    Sandwich Attack on New Liquidity Providers   -Severity Findings   Outdated Compiler Version    Redundant Modulo Operation    Unused Library    Unused blockTimestampLast    Wrong Inequality    vReserve Wrong Naming   0  0  2  6  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "6.1   Conflicting Statements About Contribution", "body": " Ratio  The document Dynamic AMM model design and rationals in section 2.3.3 Add Liquidity reads:  When users add liquidity to existing pools, they must add liquidity with the current ratio of token in the pool. The amount of mint token will be the min increase proportion of 2 tokens, the virtual balances will scale out with the mint token to assure that the price range of the pools is only bigger. Special case: the pool has reserve0=1000 and reserve1=1000 and vReserve0=2000 and vReserve1=2000. An user adds 2000 token0 and 1 token1 to the pool. The vReserve0 and vReserve1 should be 2002. But the reserve0 (3000) is higher than vReserve0. Therefore, we must vReserve0 = max(reserve0, vReserve0) to assure the assumption that vReserve0 >= reserve0  The first statement clearly states:  must add liquidity with the current ratio of token in the pool  while the next statement handles a special case where this does not hold - hence the two statements are contradicting.  The actual implementation does not enforce that adding liquidity must be done with the current ratio of the tokens in the pool.  Finally  the  rational  behind  setting  vReserve  to  reserve  in  case  the  new  value  for  vReserve  is  less than  reserve  is  not  clear.  It's  understood  that  vReserve  cannot  be  smaller  than  reserve  as  the  Kyber.Network - KyberSwap Classic - ChainSecurity  13  CriticalHighMediumSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged        \famplification factor must be >= 1, however it's questionable and not documented why setting the value equal to reserve is the correct action in this case.  Specification changed:  The specification has been updated and now describes the scenario of an unbalanced contribution more detailed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "6.2   Sandwich Attack on New Liquidity Providers", "body": "  This attack works against new liquidity providers when they are adding liquidity. The overall idea of the attack  is  that  the  virtual  reserve  values  are  out  of  sync  with  the  reserve  values.  Hence,  the  slippage protection  of  addLiquidity()  can  be  circumvented.  The  reserve  values  are  brought  out  of  sync  by adding unbalanced liquidity. Adding unbalanced liquidity by itself is good for liquidity providers, but in this combination it can be used for an attack.  Prerequisites:   A pool with little liquidity, e.g. new pool   The pool is amplified   The attacker has the ability to perform a sandwich attack  Setup:   The pool has two token T0, T1   T0 is worth 100 USD   T1 is worth 1 USD   The pool is balanced, e.g. 1 T0 and 100 T1  Attacks Steps:  1. Attacker  adds  liquidity  regularly  through  the  router.  Hence,  the  pool  is  still  correctly  balanced.  In  particular the reserves and virtual reserves have the ratio 1:100.  2. The victim looks at the pool and decides to add liquidity   The  victim  uses  the  router  and  allows  for  no  slippage  or  a  tiny  amount  of  slippage  (hence,  following best practices)   The victim sets up amountADesired and amountBDesired in 1:100 ratio, also amountAMin and  amountBMin have 1:100 ratio  4. The attacker detect the victim transaction in the mempool and starts a sandwich attack  5. First attacker transaction:   The attacker swaps all of T0 out of the pool   The attacker adds unbalanced liquidity (as described in our report)   These two steps can be repeated   As a result the reserves are in a 1:100 ratio but the virtual reserves are in a different ratio, e.g.  1:210 in our example  6. The victim transaction is executed, all checks pass, the transaction is successfully completed  Kyber.Network - KyberSwap Classic - ChainSecurity  14  SecurityMediumVersion1CodeCorrected        \f7. Second attacker transaction:   Attacker removes all its liquidity from the pool, now only the victim's liquidity is in the pool   Attacker uses the incorrect ratio of the virtual reserves to execute a swap that is bad for the  victim  Effect and Analysis:   The  \"gifted\"  liquidity  through  unbalanced  minting  here  goes  back  to  the  attacker  as  they  are  the  only/primary liquidity provider  In  our  example  with  an  amplification  factor  of  100,  the  attacker  can  steal  12.69%  of  the  victim's funds. Hence, the more the victim deposits, the more can be stolen.   The attacker's funds can be smaller than the victim's funds. The percentage of stolen funds remains  the same.   This is independent of the price ratios between T0 and T1 (1:100 in this example). Different ratios  lead to the same outcome.   Other amplification factors lead to different results, but there are probably ways to make this attack  more effective  Example Numbers:  Pool after liquidity has been added:  [++] T0: 1.0 [++] T1: 100.0 [++] Value: 200.0 USD [+] Value of 1 LP Share: 20.00 USD [+] Virtual Reserves: 10.00, 1000.00  At this point all seems fine and the victim decides to add liqudity.  Pool after pre-manipulation:  [++] T0: 5.5249 [++] T1: 552.49 [++] Value: 1104.97 USD [+] Value of 1 LP Share: 110.50 USD [+] Virtual Reserves: 6.89, 1452.49  At this point the reserves are still in a 1:100 ratio, but the virtual reserves are not. There ratio is 1:210.  Pool before final swap to exploit incorrect ratios:  [++] T0: 100.0 [++] T1: 10000.0 [++] Value: 20000.0 USD [+] Value of 1 LP Share: 110.50 USD [+] Virtual Reserves: 124.68, 26290.01  At this point only the victim's liquidity is left. The ratio of the virtual reserves is still 1:210.    The router now features a slippage protection on the ratio of the virtual reserves. The function takes two new  arguments  where  users  can  specify  the  lower  and  upper  bound  for  the  ratio  between  the  virtual  Kyber.Network - KyberSwap Classic - ChainSecurity  15   \freserves. This mitigates the attack described above as the attacker can no longer arbitrarily unbalance the  virtual  reserves.  Note  that  the  protection  is  in  the  Router,  hence,  users  interacting  with  the  pool contract directly are not protected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "6.3   Outdated Compiler Version", "body": "  The project uses an outdated version of the Solidity compiler.  pragma solidity 0.6.6;  in  Known  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1378  version   bugs   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "0.6.6 ", "body": "  are:  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At  the  time  of  writing  the  most  recent  Solidity  release  is  version  0.6.12.  For  version  0.6.x  the  most recent release is 0.6.12 which contains some bugfixes but no breaking changes.    After the intermediate report the compiler version has been updated to 0.6.12.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "6.4   Redundant Modulo Operation", "body": "  DMMPool._update   In  operation uint32 blockTimestamp = uint32(block.timestamp % 2**32);. With optimizations enabled, for the  uint32(uint256(block.timestamp)) and uint32(uint256(block.timestamp)%2**32);.  redundant   generates   bytecode   compiler   identical   modulo   version   solidity   almost   there   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "0.6.6 ", "body": "  are:  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At  the  time  of  writing  the  most  recent  Solidity  release  is  version  0.6.12.  For  version  0.6.x  the  most recent release is 0.6.12 which contains some bugfixes but no breaking changes.    After the intermediate report the compiler version has been updated to 0.6.12.  6.4   Redundant Modulo Operation  DMMPool._update   In  operation uint32 blockTimestamp = uint32(block.timestamp % 2**32);. With optimizations enabled, for the  uint32(uint256(block.timestamp)) and uint32(uint256(block.timestamp)%2**32);.  redundant   generates   bytecode   compiler   identical   modulo   version   solidity   almost   there   0.6.6   use   of   is   a   This code no longer exists in the updated implementation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "6.5   Unused Library", "body": "  Library UQ112x112 is present in the repository but never used.    The unused library has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "6.6   Unused blockTimestampLast", "body": "  Kyber.Network - KyberSwap Classic - ChainSecurity  16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                                \fVariable blockTimestampLast in DMMPool is regularly updated but never used. The purpose of the variable is not documented.    The unused variable has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "6.7   Wrong Inequality", "body": "  DMMLibrary.getAmount  ensures  reserveOut  >=  amountOut.  However,  if  the  equality  holds  the transaction  requires amount0Out < data.reserve0 && amount1Out < data.reserve1.  swap   since   later   later   call   will   fail   in   a     The equality check has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "6.8   vReserve Wrong Naming", "body": "  In  DMMLibrary.getReserves(),  the  return  values  of  DMMPool.getReserves  are  assigned  to vReserve variables while the values returned by the function correspond to the unamplified reserves.  (uint256 vReserve0, uint256 vReserve1, ) = IDMMPool(pool).getReserves();  IDMMPool(pool).getReserves() :  function getReserves()         external         override         view         returns (         uint112 _reserve0,         uint112 _reserve1,         uint32 _blockTimestampLast         ) {         _reserve0 = reserve0;         _reserve1 = reserve1;         _blockTimestampLast = blockTimestampLast; }    The naming of the variables in the code has been corrected.  Kyber.Network - KyberSwap Classic - ChainSecurity  17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "7.1   Amplification Increases Risk for Liquidity", "body": " Providers  A higher amplification coefficient increases the risk for the liquidity providers. Due to a large amplification factor,  larger  trade  volumes  are  required  in  order  for  the  current  price  to  be  reached.  Moreover,  the smaller spread may be exploited by arbitrage bots balancing liquidity accross markets.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "7.2   Tokens With Multiple Entrypoints", "body": "  This is more a theoretical issue but has applied to tokens in the past. Nowadays this is a less common issue.  Some  (very  few)  tokens  have  multiple  addresses  as  entry  points,  e.g.  a  proxy  not  using delegatecall and the actual implementation contract. TrueUSD is such an example.  In the DMM system, this may has following consequences.   The check in DMMFactory.create() to prevent the creation of a pool where tokenA and tokenB  are equal can be bypassed.   A second unamplified pool may exist for the same token pair.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "7.3   Volume Increase", "body": "  By swapping large amounts of funds of a pool with the receiver being the pool itself anyone may execute a trade with a large volume. The requirement is that some additional tokens are transferred to the pool during the callback in order to cover the fees so that the transaction can succeed.  As any swap, such a trade gets recorded in the VolumeTrendRecorder. The volume observed by the VolumeTrendRecorder may be increased by anyone willing to spend the fee in order to do so.  Kyber.Network - KyberSwap Classic - ChainSecurity  18  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/kyberswap-classic/"}, {"title": "5.1   Administrators Can Make Non-Native Tokens", "body": " Native and Native Tokens Non-Native  When the function setCustomTokenAddressPair is called, the following checks are being performed:  require(!isTokenRegistered(_bridgedToken)); require(nativeTokenAddress(_bridgedToken) == address(0)); require(bridgedTokenAddress(_nativeToken) == address(0));  However, there is no check that the _nativeToken is not bridged token, i.e.:  require(nativeTokenAddress(_nativeToken) == address(0));  This can create a weird condition where the bridged token is again a native token. Once this occurs, the bridge fails to function correctly, as the bridged tokens are now handled as native tokens.  Similarly, administrators can also register an existing native token, as a non-native token. Consider the following example:  1. A native token T exists, which has already been bridged and where tokens of type T are locked up  inside the mediator contract.  2. An  administrator  call  setCustomTokenAddressPair  with  T  as  the  _bridgedToken  and  some  other fake token F as the supposedly native token on the other side.  POA Network - OmniBridge - ChainSecurity  9  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedRiskAcceptedLowAcknowledgedRiskAcceptedRiskAcceptedCorrectnessMediumVersion1RiskAccepted            \f3. The  attacker  transfers  a  lot  of  F  token  (which  can  be  freely  minted)  over  the  brige  and  thereby  unlocks the T tokens.  This allows administrators to steal all native tokens held by the bridge.  However, the overall risk is rather low as only administrators can call setCustomTokenAddressPair.  Risk accepted:  To address this problem, POA Network added a comment saying that the function arguments should be manually validated by the administrator, as no easy solution is available.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "5.2   Tokens With More Than One Token Address", "body": " Can Be Stolen by Admins  Tokens that have more than one address, through which they can be called, can be stolen when they are bridged. An example for such a token is TUSD. The attack would work as follows:  1. The token is already bridged using the first token address. An amount X has been transferred across  the bridge.  2. An attacker bridges the token using another token address. The attacker also bridges X tokens. Now the mediator balance on the native side is X for both token addresses. However, the actual balance, when queried from balanceOf is 2*X for both of them.  3. The attacker colludes with the administrators, which trigger a call to fixMediatorBalance on the  native side and withdraw X amount of tokens.  4. Then, the attacker can withdraw X tokens, by sending back the bridged tokens.  Overall, turned X tokens into 2*X tokens, when ignoring fees. The attacker managed to withdraw the full amount  of  bridged  tokens.  At  the  time  of  writing  118,000  TUSD  have  been  bridged  which  are  at  risk under such an attack.  Risk accepted:  No  code  changes  were  done.  POA  Network  added  a  warning  comment  to  fixMediatorBalance method.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "5.3   Documentation Mismatches", "body": "  The following mismatches with the documentation or within the documentation were found:  1. The  definition  of  native   is  different   in   the   code  and   in   the  documentation:  https://docs.tokenbridge.net/about-tokenbridge/features#chain-and-network-definitions  In the code, native refers to the origin of the token contract, in the documentation to the home side of the network.  2. Some documentation items mention a requiredBlockConfirmations of 8 while others mention  12.  POA Network - OmniBridge - ChainSecurity  10  SecurityMediumVersion1RiskAcceptedCorrectnessLowVersion1Acknowledged                \fAcknowledged:  Documentation will be re-worked with help of a technical writer.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "5.4   Function onTokenTransfer Reentrancy Case", "body": "  The  main  contracts  have  a  lock()  function  with  a  corresponding  variable  that  aims  as  a  reentrancy guard. In case when lock() is true, the onTokenTransfer function will silently accept the funds. This can lead to a reentrancy that can break some invariants of the contract. In case, the callback happens during the safeTransferFrom in the _relayTokens function, the from address can perform a token transfer  to  the  Bridge  contract.  Note  that  the  same  or  a  different  token  can  be  used.  Such  callbacks during  safeTransferFrom  can  occur  with  tokens  that  implement  the  ERC777  or  similar  standards. Because  the  received  tokens  are  silently  accepted  and  _setMediatorBalance  is  not  called,  the mediatorBalance won't track the balance correctly.  Risk accepted:  The described behaviour is acceptable, as ERC-777 tokens are not supported by the OmniBridge.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "5.5   Incompatible Tokens", "body": "  The following token types are incompatible with Omnibridge:   Rebasing tokens: If the balance of a token can change while it is stored inside the mediator contract, then basic assumptions no longer hold. Hence, such tokens as Ampleforth should not be bridged as the bridging might not be reversible.   Special  transfer  fees:  This  report  already  contains  issues  regarding  \"regular  transfer  fees\",  where upon transfer of X tokens, X-F tokens are transferred, while F tokens are paid to the fee receiver. In case of transfer fees, where upon transfer of X tokens, X+F tokens are subtracted from the senders balance and X tokens arrive at the receiver, the Omnibridge contracts will fail as they do not account for such fees.   Malicious tokens: Obviously, any malicious token contracts that do not follow sensible guidelines so that  for  example,  balances  can  be  arbitrarily  can  freely  manipulated,  cannot  be  bridged  in  a meaningful manner.  Users should be warned not to bridge such tokens.  Risk accepted:  POA Network manually reviewed the most important tokens to ensure their compatibility and will monitor the bridge and the bridged tokens. Furthermore, appropriate warnings will be added inside the UI.  POA Network - OmniBridge - ChainSecurity  11  SecurityLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Decimals in bridgeSpecificActionsOnTokenTransfer Are Not Used    ERC20 Function Calls Ignore Return Values    No Canonical Definition of Calldata for onTokenTransfer    Safe Transfers Are Not Used for All Token Transfers    Transferred Values in Case of Relaying Tokens With Fees   0  0  6   OmnibridgeFeeManager  Fee  Distribution  Reverts  in  Case  of  Tokens  With  Transfer  Fees  -Severity Findings   Code Simplification Possible    Name Collision Among Bridged Tokens With Different Origins   5   Reentrancy Into AMB    Restriction to Static Call    Superfluous Loads From Storage   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.1   Decimals in ", "body": " bridgeSpecificActionsOnTokenTransfer Are Not Used  In  both  Home  and  Foreign  OmniBridge  contracts  the bridgeSpecificActionsOnTokenTransfer function during the token relaying. But this data is used only in few cases within this function:  the  decimals  are  queried   in    Token is not registered and limits need to be initialised.   Token is native to the current side of the bridge and its deployment is not yet acknowledged.  In case of non-native, acknowledged or initialised Tokens the queried decimals won't be used. Because such  cases  are  the  most  common  ones,  the  unused  data  introduces  extra  gas  costs  that  could  be avoided.    POA Network - OmniBridge - ChainSecurity  12  CriticalHighMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrected        \fThe  use  of  TokenReader.readDecimals()  was  refactored  as  so  it  is  being  called  only  when deployAndHandleTokens messages are sent.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.2   ERC20 Function Calls Ignore Return Values", "body": "  The ERC20 specification states:  Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!  In some calls to the ERC20 tokens those return values are ignored:   IBurnableMintableERC677Token(_token).mint(address(manager),   fee)   in  _distributeFee function.   IBurnableMintableERC677Token(_token).transfer(address(manager),   fee)   in  _distributeFee function.   IBurnableMintableERC677Token(_bridgedToken).mint(address(this),   1)   in  setCustomTokenAddressPair function.   _getMinterFor(_token).mint(_recipient, _value) in _releaseTokens function.  In most cases that happens during the calls to non-native Tokens that were deployed via the factory. But due  to  the  setCustomTokenAddressPair  function  the  non-native  contracts  can  have  any  behavior and the return values need to be checked explicitly.    All calls to transfer and mint function now check the return values.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.3   No Canonical Definition of Calldata for ", "body": " onTokenTransfer  The function onTokenTransfer uses inline assembly to read the receiver and calldata from the calldata arguments.  The  assembly  strongly  relies  on  some  assumptions  about  the  argument  encoding  of  the Solidity.  One  of  them  is  that  there  are  no  \"garbage  bits\"  between  the  byte  offset  of  the bytes  calldata  _data  variable  and  the  length  field  of  the  bytes  calldata  _data  argument. This  assumption  will  hold  true  in  most  cases,  but  is  not  guaranteed  to  hold.  This  assumption  can  be eliminated  letting  the  compiler  copy  the  _data  into  the  memory  and  dealing  with  it  there.  Full expectations  about  the  expected  information  in  the  _data  argument  must  be  properly  documented,  to avoid the misinterpretation of the interface.  function onTokenTransfer(     address _from,     uint256 _value,     bytes calldata _data ) external returns (bool) {  POA Network - OmniBridge - ChainSecurity  13  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f  For  the  relevant  onTokenTransfer  function,  the  calldata  location  of  the  _data  variable  was replaced  with  the  memory  location.  Hence,  the  ABI  parsing  is  performed  by  the  compiler  and  only afterwards data is being parsed in inline assembly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.4   Safe Transfers Are Not Used for All Token", "body": " Transfers  For some transfers of ERC20 Tokens the SafeERC20 functions are not used. This includes:   The function _distributeFee in OmnibridgeFeeManagerConnector contract.   The function distributeFee in OmnibridgeFeeManager contract.  The first case only appears for non-native tokens at the Home side of the bridge, which in most cases should be ERC677 deployed by Factory. But due to the setCustomTokenAddressPair function, there are possible conditions when any other token can be called with this transfer.    All calls to the transfer function were replaced by a safe wrapper.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.5   Transferred Values in Case of Relaying", "body": " Tokens With Fees  In a scenario with token relaying, the _relayTokens function is executed. A user provided _value is then transferred to the bridge contract via safeTransferFrom. If the token has fees on transfer (e.g. USDT-not currently charged, PAXG), the actual transferred value will be smaller than the bridged value. invariant This  Balance of bridge == total supply of bridged token.  effectively   break   the   will     This has been corrected by measuring the actually transferred token amount.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.6   OmnibridgeFeeManager Fee Distribution", "body": " Reverts in Case of Tokens With Transfer Fees  As part of the internal function _distributeFee of the OmnibridgeFeeManagerConnector contract calls  the  token  contract  to  transfer  or  mint  the  fee  amount  to  the  manager.  In  case  the  relevant  token contract  is  native  to  Home  side  it  might  have  transfer  fees.  Then,  a  value  less  than  fee  will  be  moved during  the  transfer  to  the  OmnibridgeFeeManager.  Later  the  OmnibridgeFeeManager  tries  to distribute this fee amount using distributeFee function. Because the actually transferred value will be  POA Network - OmniBridge - ChainSecurity  14  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                        \fsmaller in case of Tokens with transfer fees, the OmnibridgeFeeManager will not have enough assets to perform the reward distribution with the required values.  Hence, the whole transaction will fail and such tokens cannot be moved across the bridge.    The code has been rewritten so that  1. The  OmnibridgeFeeManager  determines   the  amount  of   fees   to  distribute  by  calling  token.balanceOf(address(this)).  2. Failure  of  the  transfer/mint  operation  during  the  fee  distribution  will  not  fail  the  Omnibridge  message processing.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.7   Code Simplification Possible", "body": "  The following code can be simplified:  if (_token == address(0xb7D311E2Eb55F2f68a9440da38e7989210b9A05e)) {     // hardcoded address of the TokenMinter address     return IBurnableMintableERC677Token(0xb7D311E2Eb55F2f68a9440da38e7989210b9A05e); } return IBurnableMintableERC677Token(_token);  The if clause can be entirely omitted.  Specfication changed:  Before the OmniBridge is deployed for the ETH-xDAI instance the contract address in this check can be replaced  with  the  actual  minter  0x857DD07866C1e19eb2CDFceF7aE655cE7f9E560d  of  the  STAKE token  on  the  xDai  chain.  For  other  bridges  this  check  is  either  removed  at  all  or  did  not  have  any significant impact. A comment was added into the code to bring more clarity why this check is needed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.8   Name Collision Among Bridged Tokens With", "body": " Different Origins  When  the  bridge  creates  token  contracts  on  the  Home  chain,  the  \"  on  xDai\"  string  is  appended  to  the Foreign token name. In case of multiple bridges to different Foreign chains, different tokens that have the same  name  on  different  Foreign  chains,  will  have  same  names  on  the  Home  chain.  As  an  example, \"1INCH Token\" from Ethereum Mainnet and Binance Smart Chain will both have the \"1INCH Token on xDai\"  name  on  the  Home  chain.  While  that  has  no  direct  code-related  problems,  this  increases  the human error chance during the user interactions.    POA Network - OmniBridge - ChainSecurity  15  DesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                \fNewly deployed Omnibridge contracts are using \"from X\" names where X is the respective blockchain. The Blockscout interface also renames such tokens in the UI. Unfortunately, it is not possible to change token names for already existing tokens. However such collisions are being mitigated in the UI.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.9   Reentrancy Into AMB", "body": "  When  the  Arbitrary  Message  Bridge  contract  receives  a  message  from  the  other  side,  the  following  is performed code is used to execute the message call:  setMessageSender(_sender); setMessageId(_messageId); setMessageSourceChainId(_sourceChainId);  ...  bool status = _contract.call.gas(_gas)(_data); setMessageSender(address(0)); setMessageId(bytes32(0)); setMessageSourceChainId(0);  The  called  contracts  can  query  the  information  such  as  messageId  and  messageSender.  These information provide important authorization for the called contracts. As there is no reentrancy guard on this function, this code can be reentered in the following way:  1. Call A is made, correct information for A is available  2. A triggers the reentrancy and call B is made, now B is executing and the correct information for B is  available  3. The call B completes and the information are reset to 0  4. The execution of A continues, but now the queried information will be 0  Hence,  it  is  possible  that  during  the  execution  of  a  passed  message  the  wrong  context,  namely  0  is returned  when  queried  from  the  AMB  contract.  Furthermore,  events  are  emitted  in  an  interlaced  order which might confuse connected systems.  Please note the AMB contracts were outside of the scope of this review, however, we still note this as it can affect the OmniBridge.    The  issue  was  fixed  in  https://github.com/poanetwork/tokenbridge-contracts/pull/577.  It  ensures  that  no other message relay is currently being processed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.10   Restriction to Static Call", "body": "  The contract contains the following code to determine the upgradabilityOwner:  address(this).call(abi.encodeWithSelector(UPGRADEABILITY_OWNER))  However, this function is defined as a view function:  POA Network - OmniBridge - ChainSecurity  16  SecurityLowVersion1CodeCorrectedSecurityLowVersion1CodeCorrected                \ffunction upgradeabilityOwner() external view returns (address);  Hence, a staticcall can be used to avoid unexpected state modifications.    The call was replaced with a staticcall.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.11   Superfluous Loads From Storage", "body": "  The Omnibridge contracts sometimes contain code like this:  require(!bridgeContract().messageCallStatus(_messageId)); require(bridgeContract().failedMessageReceiver(_messageId) == address(this)); require(bridgeContract().failedMessageSender(_messageId) == mediatorContractOnOtherSide());  As  there  is  a  storage  load  (SLOAD)  inside  the  bridgeContract()  function,  this  SLOAD  will  be executed  three  times  in  this  case.  Due  to  the  about-to-be  introduced  EIP-2929  the  additional  costs  of extra SLOADs from the same location are significantly lowered, but it could still be avoided to do it.    The return value of bridgeContract() was saved in a local variable to avoid repeated calls.  POA Network - OmniBridge - ChainSecurity  17  DesignLowVersion1CodeCorrected        \f7   Notes  We leverage this section to highlight potential pitfalls which are fairly common when working Distributed Ledger Technologies. As such technologies are still rather novel not all developers might yet be aware of these  pitfalls.  Hence,  the  mentioned  topics  serve  to  clarify  or  support  the  report,  but  do  not  require  a modification  inside  the  project.  Instead,  they  should  raise  awareness  in  order  to  improve  the  overall understanding for users and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.1   Differing Token Values", "body": "  The OmniBridge has limits on transfers per token. This means that only a certain amount of tokens can be  transferred  per  transaction  and  per  day.  Generally,  this  limits  are  initialized  as  a  number  of  tokens. Obviously, a certain number of tokens of one type can have a very different value than the same number of tokens from another type. Hence, these limits need to be carefully monitored.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.2   Function requestFailedMessageFix", "body": " Performs Multiple Calls to bridgeContract  When a user detects a failed, bridged message, the function requestFailedMessageFix can be used to  fix  the  failed  call.  Therefore,  three  pieces  of  information  are  needed  which  are  currently  loaded  like this:     require(!bridgeContract().messageCallStatus(_messageId));    require(bridgeContract().failedMessageReceiver(_messageId) == address(this));    require(bridgeContract().failedMessageSender(_messageId) == mediatorContractOnOtherSide());  This code is execute both on Home and Foreign bridges.  Note that there are two levels of inefficiency here. First of all three separate calls are made, even though these information are generally always queried together. Second, this information is spread amount three storage  slots,  and  hence  requires  three  costly  SLOADs,  even  though  two  storage  slots  would  easily suffice, as only 321 bit of data are stored.  However,  as  this  needs  to  be  resolved  within  the  AMB  contracts,  it  is  outside  the  scope  of  this  code review.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.3   Limits Can Be Compressed in Storage", "body": "  There are three storage slots being consumed on both sides of the bridge for the following information:  uintStorage[keccak256(abi.encodePacked(\"dailyLimit\", _token))] = _limits[0]; uintStorage[keccak256(abi.encodePacked(\"maxPerTx\", _token))] = _limits[1]; uintStorage[keccak256(abi.encodePacked(\"minPerTx\", _token))] = _limits[2];  These  information  are  often  accessed  together.  Given  the  value  ranges  they  could  probably  be compressed into two storage slots. This would also provide gas savings on the foreign side as it would avoid a costly SLOAD.  POA Network - OmniBridge - ChainSecurity  18  NoteVersion1NoteVersion1NoteVersion1          \f7.4   Proxy Fallback Redundant Operations  The Proxy contract does some redundant operations, such as:   let ptr := mload(0x40)   mstore(0x40, add(ptr, returndatasize()))  Preserving the free memory slot pointer at 0x40 is important when the assembly code is used together with Solidity code. But in case of the Proxy contract, this can be skipped, as no solidity code is executed after the assembly block.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.5   Redundant Work Performed as Part of ", "body": " totalSpentPerDay  The  function  bridgeSpecificActionsOnTokenTransfer  has  the  following  code,  that  checks  and adjusts the totalSpentPerDay limit for a particular token.  require(withinLimit(_token, _value)); addTotalSpentPerDay(_token, getCurrentDay(), _value);  The code of those 2 functions are quite similar.  function withinLimit(address _token, uint256 _amount) public view returns (bool) {     uint256 nextLimit = totalSpentPerDay(_token, getCurrentDay()).add(_amount);     return         dailyLimit(address(0)) > 0 &&         dailyLimit(_token) >= nextLimit &&         _amount <= maxPerTx(_token) &&         _amount >= minPerTx(_token); }  function addTotalSpentPerDay(     address _token,     uint256 _day,     uint256 _value ) internal {     uintStorage[keccak256(abi.encodePacked(\"totalSpentPerDay\", _token, _day))] = totalSpentPerDay(_token, _day).add(         _value     ); }  The  function  withinLimit,  that  is  executed  first,  reads,  increases  and  checks  limits.  The  function addTotalSpentPerDay  reads,  increases  and  writes  the  increased  value  for  the  limit.  This  is  a  small redundancy that can potentially be eliminated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.6   Reentrancy Lock Is Gas Inefficient", "body": "  The  main  contracts  have  a  reentrancy  guard.  Setting  and  releasing  this  guard  inside  OmniBridge contracts is done via storage of a boolean true/false.  Please note that using locks which switch between the values 0 and 1 is more expensive than switching between the values 1 and 2 in case of a reverting transaction. However, the correct choice of this values  POA Network - OmniBridge - ChainSecurity  19  NoteVersion1NoteVersion1NoteVersion1            \fin  the  future  will  also  be  affected  by  the  currently  discussed  EIP-3298  which  is  concerned  about  the removals of refunds.  Based on EIP-2929 it would also be beneficial if the reentracy lock value would be packed into the same storage slot with another variable, but that is hard due to the chosen storage layout.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.7   State of Implementation Contract", "body": "  With  proxied  contracts,  the  state  generally  resides  in  the  proxy  while  the  code  resides  inside  the implementation contract. In principle, the state of the implementation contract is meaningless, unless the code  contains  selfdestruct,  callcode  or  delegatecall  opcodes.  Neither  of  these  opcodes  can  be  found inside the current Omnibridge contracts. However, we would still recommend to make the initialization of the state of the implementation contract part of the deployment scripts, as a best practice to avoid future issues.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.8   Token Creators Can Avoid Fee Payments", "body": "  Token  contracts  that  are  native  to  the  xDai  side  could  be  programmed  such  that  they  avoid  a  fee payment  to  the  bridge  validators,  e.g.  by  simply  ignoring  transfer  calls  to  and  from  the  fee  manager. Furthermore, existing tokens could be wrapped to avoid fees. However, as the fees are fairly low and as such tokens could be blocked on the bridge, the risk appears to be very low.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.9   Token With Transfer Restrictions", "body": "  Certain Tokens, especially regulated stable coins, have transfer restrictions, blacklists or even the power to seize funds. If some tainted funds would be bridged, the entire bridge balance of that particular token might become frozen or could get seized. As with any other contract where funds are deposited, users need to be aware of these potential risks.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "7.10   Weak Randomness", "body": "  The following function is used to pick a random number:  function random(uint256 _count) internal view returns (uint256) {     return uint256(blockhash(block.number.sub(1))) % _count; }  This is generally a bad way to sample randomness as, especially in the case of xDai, different attacks exist.  Furthermore,  there  randomness  is  extremely  slightly  skewed.  In  this  context,  however,  the randomness only serves to pick the account the receives the fee dust. As the corresponding monetary value is generally tiny, it seems acceptable.  POA Network - OmniBridge - ChainSecurity  20  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \f7.11   onlyMediator Modifier  There is an onlyMediator modifier inside the BasicAMBMediator contract. It performs two checks:   Check that the call comes from AMB bridge contracts.   Check that the forwarded by AMB bridge the message sender is a mediator on the other side.  There are multiple concerns about this modifier.  Firstly, the MediatorOwnableModule has a modifier with the same name that performs only one check -  that  the  message  comes  from  OmniBridge  extension  contract.  That  can  potentially  cause misunderstandings and human errors.  Secondly,  it  seems  that  the  virtual  message  sender  is  always  needed.  This  is  currently  being  queried through  a  call  to  bridge.messageSender().  Here,  for  future  versions  of  the  AMB  protocol  a  more efficient design would be possible where this information is passed along.  /**  * @dev Throws if caller on the other side is not an associated mediator.  */ modifier onlyMediator {     _onlyMediator();     _; }  /**  * @dev Internal function for reducing onlyMediator modifier bytecode overhead.  */ function _onlyMediator() internal view {     IAMB bridge = bridgeContract();     require(msg.sender == address(bridge));     require(bridge.messageSender() == mediatorContractOnOtherSide()); }  POA Network - OmniBridge - ChainSecurity  21  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-omnibridge/"}, {"title": "6.1   Expired Domains Look Valid for the", "body": " Subdomains  The  desired  invariant  that  fuses  can  be  inspected  individually  and  care  only  needs  to  be  taken  when domains expire, can be broken. This is because an expired domain can be rewrapped with new fuses and  wrapped  subdomains  are  not  aware  of  the  expiry  of  higher-level  domains.  Please  consider  the following scenario:  1. User U controls example.eth, wraps it and burns the CANNOT_REPLACE_SUBDOMAIN fuse.  2. The domain expires and user V takes control of it and makes sure it will not expire any time soon.  3. User V assigns control to W over sub.example.org.  4. User W wraps sub.example.org:  1. W also decides to burn the CANNOT_UNWRAP fuse.  2. During   the  execution   the  parent  node   (example.eth)   is  checked  where   the  CANNOT_REPLACE_SUBDOMAIN fuse has been burnt.  3. Hence, the wrapping succeeds.  5. Now  third  parties  check  the  wrapped  state  of  sub.example.org:  According  to  the  invariant  it cannot be unwrapped as it will not expire any time soon and as the CANNOT_UNWRAP fuse has been burnt.  6. User  V  can  freely  reassign  sub.example.org  (independently  of  the  NameWrapper).  Hence,  the permission  system  has  been  bypassed  as  a  non-wrapped  and  a  wrapped  version  exists  for sub.example.org.  ENS - NameWrapper -   10  CriticalHighMediumCodeCorrectedSpeci\ufb01cationChangedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected         \fHence,  fuses  are  indifferent  to  the  expiry  of  domains  and  they  enforce  the  corresponding  permissions only for never-expired domains.    The code was rewritten so that it checks the hierarchy of a name for safety.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ethereum-name-service-ens-namewrapper/"}, {"title": "6.2   Old State From Expired Domains Can Block", "body": " Legitimate Actions  In case a domain is wrapped, then expires and is later controlled by another user and wrapped again, the following problem can arise, which blocks the new legitimate owner from performing an action they would have been allowed to.  Please consider the following sequence:  1. User U controls example.eth and wraps it.  2. User U creates a subnode sub.example.org and sets themselves as owner.  3. The domain expires and user V takes control of it.  4. User V wraps example.eth again and burns the CANNOT_REPLACE_SUBDOMAIN fuse.  5. Now, user V tries to create sub.example.org:  1. The function canCallSetSubnodeOwner is evaluated, it should return true as V has the  permission to create new subdomains.  2. The owner of sub.example.org is queried and it returns U.  3. As the owner is non-zero, the CANNOT_REPLACE_SUBDOMAIN fuse is checked.  4. Finally,  canCallSetSubnodeOwner  returns  false  and  hence  the  legitimate  creation  of  the subnode fails.  Specification corrected:  The specification has been made more explicit so that it covers the case above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ethereum-name-service-ens-namewrapper/"}, {"title": "6.3   Variable node Assigned but Never Used in", "body": " wrapETH2LD  the   In  _makeNode(ETH_NODE, labelhash). However, this value is never used.  wrapETH2LD   functions,   node   new   the   is   calculated   using    The redundant variable was removed.  ENS - NameWrapper -   11  CorrectnessMediumVersion1Speci\ufb01cationChangedDesignLowVersion2CodeCorrected                \f6.4   Incorrect Specification for Unwrapping Functions  The README says about unwrapping:  Wrapped  names  can  be  unwrapped  by  calling  either  unwrapETH2LD(label,  newRegistrant, newController)  or  unwrap(parentNode,  label,  newController)  as  appropriate.  label  and  parentNode have meanings as described under \"Wrapping a name\"  Furthermore, the docstring says:   @param label label as a string of the .eth domain to wrap e.g. vitalik.xyz would be 'vitalik'  However, the implementation works differently. Instead of passing a label, a labelhash should be passed to the unwrapping functions, as seen for unwrapETH2LD below:  function unwrapETH2LD(     bytes32 label,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, label)) {     _unwrap(_makeNode(ETH_NODE, label), newController);  Specification changed:  The documentation has been updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ethereum-name-service-ens-namewrapper/"}, {"title": "6.5   Repetitive Code", "body": "  There are multiple instances of repetitive code that could be avoided. These instances include:   Within the function wrapETH2LD, two calls are made to registrar.ownerOf(tokenId).   Within  the  functions  unwrapETH2LD,  unwrap,  and  burnFuses,  two  calls  are  made  to  _makeNode(parentNode, labelhash).   Within the function burnFuses, getData is called multiple times in different spots.  The cost impact of these repetitions has been lowered by the recently introduced EIP-2929, however gas optimizations remain possible.    The  superfluous  call  to  registrar.ownerOf(tokenId)  has  been  removed  as  well  as  the  duplicate calle to getData in burnFuses.  ENS - NameWrapper -   12  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                  \f6.6   Specification Unclear for setSubnode* Functions  The docstring for the setSubnodeRecord function says:   @notice Sets records for the subdomain in the ENS Registry   @param node namehash of the name  However, the node parameter should contain the namehash for the parent node. This is not entirely clear from the description. Especially, in comparison with the setSubnodeRecordAndWrap function, where the docstring says:   @notice Sets the subdomain owner in the registry with records and then wraps the subdomain   @param parentNode parent namehash of the subdomain  A consistent naming of node versus parentNode for these very similar functions would be beneficial to avoid  confusion.  This  also  extends  to  the  setSubnodeOwner  and  setSubnodeOwnerAndWrap functions. Furthermore, the label parameter is missing from the setSubnodeRecord description.    The parameter names were changed to reflect their status.  ENS - NameWrapper -   13  CorrectnessLowVersion1CodeCorrected      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ethereum-name-service-ens-namewrapper/"}, {"title": "7.1   Dirty Bits in Return Value of getData", "body": "  The  getData  function  is  one  of  the  most  important  functions  of  the  NameWrapper  as  it  retrieves information about the different nodes.  function getData(uint256 tokenId)     public     view     returns (address owner, uint96 fuses) {     uint256 t = _tokens[tokenId];     owner = address(uint160(t));     fuses = uint96(t >> 160); }  Functions calling getData need to be aware that the owner return value will contain \"dirty bits\". This is dangerous  if  assembly  is  being  used,  because  assembly  will  access  the  raw  data.  Writing  normal solidity code should be fine.  Hence, we recommend to avoid assembly in connection with getData. We have attached an example file for this behaviour.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ethereum-name-service-ens-namewrapper/"}, {"title": "7.2   Note to Integrators: onERC1155Received", "body": " Hook  This  note  is  meant  for  any  developers  wanting  to  build  upon  the  NameWrapper.  Similarly  to  ERC223, ERC721, ERC777, and others the implementation of ERC1155 invokes the onERC1155Received hook at the end of safeTransferFrom. Developers building services which interact with the NameWrapper should  be  aware  of  that  and  implement  the  hook,  as  these  hooks  have  historically  led  to  reentrancy attacks.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ethereum-name-service-ens-namewrapper/"}, {"title": "7.3   Restrictions on Custom Permissions", "body": "  The README documents that additional fuses might be designated to additional permissions. While this generally can be implemented with the current contract, not all types of permissions will be feasible this way.  Any permissions, requiring checks \"up the chain\" of custody would not work without modifications to the contract  or  without  breaking  the  invariant  that  fuses  can  be  inspected  individually.  As  a  somewhat  ENS - NameWrapper -   14  NoteVersion1NoteVersion1NoteVersion1          \fcontrived example, a permission enforcing that TTL values of subnodes must be strictly larger than TTL values of parent nodes, currently could not be enforced.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ethereum-name-service-ens-namewrapper/"}, {"title": "7.4   The Transitive Permission Structure", "body": "  Users  should  be  aware  of  the  transitive  permission  structure  of  the  system.  This  permission  structure involves the NameWrapper, Registry and Registrar. Given a typical user setup, setting an operator O using NameWrapper.setApprovalForAll does not only pass control over all wrapped domains but O also controls all non-wrapped domains. Furthermore, domains that are acquired in the future, can be controlled by O.  In  short  becoming  an  operator  for  a  particular  account  on  the  NameWrapper  is  more  powerful  than becoming  an  operator  for  the  same  account  on  the  Registrar  or  the  Registry.  Hence,  operator permissions should be given out with great care.  ENS - NameWrapper -   15  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/ethereum-name-service-ens-namewrapper/"}, {"title": "6.1   Locked Refunded Provision", "body": "  When  a  maker  submits  an  order  to  the  Mangrove  orderbook,  they  need  to  provide  some  ETH,  also known as the provision, to compensate the takers in case the makerExecute hook reverts. A maker can update their offer by calling Forwarder.updateOffer. Note that at this point a maker can update most of the parameters of the order including gasreq, i.e. the gas required for the makerExecute hook to execute. A maker could reduce the gas requirements meaning that some provision will be refunded to them. Forwarder.updateOffer does not handle this refunding (the ownerData.weiBalance is not updated) and Mangrove system only sees MangroveOrder as a maker. This means that the refunded amount is essentially lost for the end-user of the MangroveOrder. Note that if the provision needs to be increased again, the end-user must provide extra ETH.  Code Corrected:  In the current implementation, the provision can only be increased therefore no funds are locked.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "6.2   Wrong Calculation of Locked Provision", "body": "  Giry SAS - MangroveOrder -   11  CriticalHighCodeCorrectedCodeCorrectedMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                 \fWhen a user updates their offer through Forwarder.updateOffer, MangroveOrder tries to calculate the new gas price by calling deriveGasprice. The gas price depends on the total provision available for  this  order.  That  is  the  sum  of  the  extra  provision  attached  which  is  stored  in  args.fund  and  the already locked provision. Currently, the locked amount is calculated with the following snippet:  vars.offerDetail.gasprice() * 10 ** 9 * args.gasreq + vars.local.offer_gasbase()  This formula is wrong for two reasons:  1. It depends on args.gasreq which is the updated gas requirement of the order as passed by  the user.  2. There are parentheses missing around args.gasreq + vars.local.offer_gasbase(),  as this entire term should be multiplied by the gas price.  This miscalculation can have multiple consequences:  1. Can allow users to steal funds (see relevant issue).  2. An  order  can  be  submitted  with  smaller  gasprice  since  the  calculated  total  provision  is  too  small.  Code Corrected:  Forwarder.updateOffer has been updated. Currently, users can only increase the provision for an order.  Users  cannot  determine  args.gasreq  as  it  is  set  to  be  equal  to  the  offerGasreq().  It  is important  to  notice  that  offerGasreq()  is  not  constant  but  depends  on  the  configuration  of  the MangroveOrder and in particular the gas requirements of the router.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "6.3   Expiration Date Cannot Be Updated", "body": "  A  user  can  update  most  of  the  offer  details  by  calling  Forwarder.updateOffer.  However,  the expiration date cannot be changed. In order to change the expiration date of an order, one must retract it and submit a new one.  Code Corrected:  MangroveOrder.setExpiry has been added to allow users to update the expiration date of the order.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "6.4   Underflow in postRestingOrder", "body": "  Once the market order part of GTC order has been filled as much as possible, the remaining amount the user  wants  to  trade  is  put  into  a  resting  order.  Note  that  if  fillWants  ==  true,  then  the  Mangrove engine will have stopped matching the order either when it is fully filled, there are no more orders on the books, or when the total average price of the order would fall below the threshold of the ratio between the order's initial wants and gives. Hence, if the matching stops before the order's wants are fully filled, we are  guaranteed  not  to  have  given  away  more  than  the  order  initially  had  (else  the  total  average  price would be below what we initially wanted).  Giry SAS - MangroveOrder -   12  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged                \fHowever,  if  fillWants  ==  false,  this  condition  no  longer  holds.  The  order  can  receive  arbitrarily many tokens before giving away all the tokens it has to give away. As the price of a trade is defined by the  maker,  there  could  be  orders  on  the  books  which  give  away  arbitrarily  many  tokens  for  a  very  low price.  Hence,  the  user  can  receive  more  tokens  in  the  market  order  part  of  the  trade  than  they  were expecting to. As such, res.takerGot + res.fee can exceed tko.takerWants despite only having partially filled the order.  When we go to post a resting order, the following code is executed:  res.offerId = _newOffer(   OfferArgs({     outbound_tkn: outbound_tkn,     inbound_tkn: inbound_tkn,     wants: tko.makerWants - (res.takerGot + res.fee), // tko.makerWants is before slippage     gives: tko.makerGives - res.takerGave,     gasreq: offerGasreq() + additionalGasreq, // using default gasreq of the strat + potential admin defined increase     gasprice: 0, // ignored     pivotId: tko.pivotId,     fund: fund,     noRevert: true, // returns 0 when MGV reverts     owner: msg.sender   }) );  When  the  wants  for  the  resting  order  are  calculated,  an  underflow  can  occur  in  the  case  described above, as the market order part of the GTC order could have received arbitrarily many tokens. As Solidity ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "0.8.10  is  used,  this  will  simply  revert  the  transaction,  but  will  unnecessarily  prevent  the  user  from", "body": " completing their trade.  Specification Changed:  Currently,  the  order  is  posted  with  the  same  price  as  the  taker  originally  wanted.  Thus,  the  issue  has been mitigated.  Giry SAS replied:  this  problem  made  use  reevaluate  our  specification:  requiring  the  (instant)  market  order  and  the (asynchronous) maker order to respect a limit average price is not well defined. In some cases this would lead the maker order to be posted for a 0 price. We decided to change the specification and post the maker order at the price initially set by the taker for the market order (irrespectively of the obtained price).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "6.5   Users Can Steal Funds From MangroveOrder", "body": "  The core Mangrove system maintains the balanceOf mapping which stores how much ETH is available for each maker to be used as a provision for their orders. Importantly, the MangroveOrder contract is seen  as  one  single  maker  by  the  system,  even  though  there  might  be  many  end  users  creating  their orders through it. Let us assume that at some point the balance of MangroveOrder is positive and an attacker has already submitted an order. It is possible as we show in another issue that there might be some non-claimable balance since updateOrder does not handle refunds. An attacker can steal money from mangrove by employing any of the following two vectors:  1. Updating an order without sending funds:   The attacker calls Forwarder.updateOrder for their order with msg.value == 0 and  they increase the gas requirement of their order.   This means that args.fund == 0 so gas price will remain the same, however, the total  provision needed has been increased as the gas requirements have been increased!   At this point MGV.updateOffer is called with msg.value == 0.  Giry SAS - MangroveOrder -   13  SecurityMediumVersion1CodeCorrected        \f Mangrove core does not perform any check if there are enough funds attached to the call  since it relies on the balanceOf mapping by calling debitWei.   Mangrove core uses the amount stored in balanceOf for the extra provision.   The  attacker  now  retracts  the  order  and  withdraws  the  provision  of  the  order  which  includes the stolen amount.  2. Updating an order by attaching funds:   The attacker calls Forwarder.updateOrder for their order with msg.value != 0 and  they increase the gas requirement of their order.   Since funds have been attached to the transaction, the gas price will be recalculated.   The  new  provision  at  this  point  is  calculated  wrongly  since  the  provision  parameter passed  to  derivePrice  depends  on  args.gasreq  which  represents  the  updated  gas requirements  of  that args.gasreq can be freely set by the users so arbitrarily large value could be passed. As a result, the new gas price is greater than it should be but the extra funds passed are not enough to cover for the extra provision needed by the offer.  the  offer  and  not  vars.offerDetail.gasreq().  Note    Mangrove core uses the amount stored in balanceOf for the extra provision.   The  attacker  now  retracts  the  order  and  withdraws  the  provision  of  the  order  which  includes the stolen amount.  A  similar  attack  can  be  performed  when  some  of  the  global  parameters  change,  which  could  result  in inaccurate accounting of provisions. If the gasbase of the token pair related to an order changes in the core  mangrove  system,  calling  updateOffer  can  result  in  an  increased  (or  decreased)  provision without  providing  any  additional  funds.  This  will  credit  (or  debit)  funds  to  the  MangroveOrder  contract which  aren't  attributed  to  any  user.  In  particular,  if  the  global  gas  price  is  increased,  calling updateOffer  of  Mangrove  core  with  an  unchanged  gasprice  which  is  lower  than  the  new  global  gas price,  the  mangrove  core  system  will  set  the  gas  price  higher  without  receiving  any  funds.  This  again changes the balance of the MangroveOrder contract, without attributing it to any individual user. While _newOffer and _updateOffer in Forwarder have checks to make sure the offer's gas price is higher than the global gas price, __posthookSuccess__ in MangroveOffer does not. Hence, if the global gas price changes, then an order is partially filled and attempts to repost, its provision will be increased with no additional submitted funds. While the amounts of funds are small, it is conceivable that a malicious user could be able to exploit a change in the global gas price or the gasbase in order to steal funds.  It  is  important  to  note  that  this  issue  cannot  result  in  users  losing  funds  since  the  excessive  provision which can be stolen cannot be claimed by any specific user. In the normal case, no excessive provision should  be  available.  Therefore,  it  is  expected  the  amount  that  can  be  stolen  to  be  low.  Hence,  we consider the issue as medium severity.  Code partially corrected:  The issue has been addressed in multiple different ways:  1. In the current implementation there shouldn't be unallocated users' funds in Mangrove core.  2. Users can only increase the provision of an order using MangroveOrder.updateOrder, not decrease  it.  Hence,  they  must  provide  additional  provision  and  can  not  submit  orders  which could make use of funds that are already stored in the Mangrove core.  3. The __posthookSuccess__ uses Forwarder._updateOffer.  Giry SAS - MangroveOrder -   14    \f6.6   Inaccurate Comment  In MangroveOrder.checkCompleteness, the following is mentioned:  // when fillWants is true, the market order stops when takerWants units of outbound_tkn have been obtained;  However, this comment is inaccurate since part of the takerWants goes to cover the fees, so not the full takerWants amount can be obtained.  In AbstractRouter.push, the return value is described as follows:  ///@return pushed fraction of amount that was successfully pushed to reserve.  However,  for  tokens  with  fees,  provided  the  TransferLib  is  used,  the  whole  amount  will  always  be reported.  Code Corrected:  The comments have been updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "6.7   Missing Natspec", "body": "  The Natspec is missing in the following cases:   For AbstractRouter.bind, the maker parameter.   For AbstractRouter.unbind, the maker parameter.   For SimpleRouter.__pull__, the strict parameter.   For IOfferLogic.OfferArgs, the gasprice field.  Code Corrected:  The Natspec has been added to the respective functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "6.8   Redundant pragma abicoder v2", "body": "  Many contracts include the pragma abicoder v2 directive. However, for solidity 0.8 the abicode v2 is the default one, so the pragma is redundant.  Code Corrected:  The pragma has been removed from most of the contracts.  Giry SAS - MangroveOrder -   15  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f6.9   Setting Expiration Date  A user can define the time-to-live of a resting order submitted through MangroveOrder by specifying the TakeOrder.timeToLiveForRestingOrder.  It  is  important  to  note  that  an  order  can  remain  in  the mempool  for  a  long  time  before  it's  executed.  Specifying  an  explicit  expiration  date  instead  of  the time-to-live might be more convenient for users since it's independent of the time it takes for a transaction to be included in a block.  Code Corrected:  The  expiration  date  is  now  absolute  and  no  longer  relative  to  the  time  the  transaction  is  added  to  the blockchain.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "6.10   Forwarder.provisionOf Calculation Is", "body": " Wrong  As its natspec suggests Forwarder.provisionOf computes the amount of native tokens that can be redeemed  when  In MgvOfferMaking.retractOffer, the provision is calculated as follows:  offer.  However,   deprovisioning   given   true.   this   not   is   a   provision = 10 ** 9 * offerDetail.gasprice() //gasprice is 0 if offer was deprovisioned   * (offerDetail.gasreq() + offerDetail.offer_gasbase());  The important part to notice is that provision depends on offerDetail.offer_gasbase().  This is not the same for Forwarder.provisionOf where the provision is calculated as follows:  provision = offerDetail.gasprice() * 10 ** 9 * (local.offer_gasbase() + offerDetail.gasreq());  Here,  offerDetail.offer_gasbase().  provision   the   depends   on   local.offer_gasbase()   instead   of  Code Corrected:  The provision is now calculated using the offerDetail.offer_gasbase().  Giry SAS - MangroveOrder -   16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "7.1   Updating Approvals on Order Update", "body": "  A  user  can  update  their  orders  by  using  Forwarder.updateOffer.  It  is  important  for  users  to remember  that,  in  case  the  makerExecute  hook  to  their  order  fails,  they  will  have  to  reimburse  the taker. A reason for an order to fail is that there is not enough allowance given to the router to transfer funds from the maker's reserve to MangroveOrder contract. This is highly likely to happen after a user updates their offer by having it give more funds to the taker.  Giry SAS - MangroveOrder -   17  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-order/"}, {"title": "5.1   ZkBobPool Withdrawal Sandwich Attack", "body": "  When the withdrawal with native_amount is submitted to the ZkBobPool, the sale of tokens for ETH happens using the UniswapV3Seller contract. However, the amountOutMinimum parameter of this swap is 0. A potential attacker can place orders that would manipulate the price, forcing the sellForETH trade  to  be  executed  with  a  bad  price.  Thus,  due  to  the  lack  of  spread  control,  any  use  of UniswapV3Seller can result in a bad trade, allowing price manipulators to pocket the profit from this trade.  Risk accepted:  BOB Protocol responded:  This  feature  is  only  intended  to  swap  small  amounts  of  tokens,  purely  for  funding  wallets  with  gas tokens. UI will strongly dissuade users for doing swaps that are larger than e.g. 100$ in value. Added a warning comment to the sellForETH function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "5.2   BaseERC20 Overflow", "body": "  BOB Protocol - zkBob -   10  SecurityDesignCorrectnessTrustCriticalHighMediumRiskAcceptedLowRiskAcceptedRiskAcceptedRiskAcceptedDesignMediumVersion1RiskAcceptedCorrectnessLowVersion1RiskAccepted                    \fThe _increaseBalance function of the BaseERC20 contract can overflow. While it is checked that the account  is  not  frozen  (i.e.  the  first  bit  of  the  balance  is  zero),  it  is  not  guaranteed  that  the  addition  will result in a number smaller than 2^255. Hence, an account could become frozen by increasing its balance above this value.  Risk accepted:  Assuming  a  reasonable  total  supply  of  the  token  (less  than  2^255),  it  is  impossible  for  any  individual account  to  have  a  balance  large  enough  to  cause  this  overflow  to  happen.  Thus,  the  overflow  cannot occur under normal circumstances.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "5.3   Daily Limits Can Be Avoided", "body": "  If the MutableOperatorManager is used and the operator variable is set to 0, then effectively every user becomes an operator / relayer. This means that any user could spread funds between multiple addresses and easily avoid the daily limits imposed by the ZkBobAccounting contract.  Risk accepted:  BOB Protocol accepts the risk regarding users avoiding daily limits and states:  Allowing  users  to  submit  transactions  themselves  introduces  multiple  potential  problems,  including the one described with the limits. For now, it can be assumed that deposit transactions might only go through  the  chosen  relayer,  which  is  also  responsible  for  detecting  abnormal  limit  usage.  Even though we cannot assume that one address is equal to one user, we think that making per-address limits in the contract can still be useful in certain use-cases.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "5.4   ERC20Permit.receiveWithPermit Signature", "body": " Can Be Front-Run  Similar  to  issue  ERC20Permit.receiveWithSaltedPermit  signature  can  be  front-run,  the  signatures between  ERC20Permit.permit  and  ERC20Permit.receiveWithPermit  are  interchangeable  as well.  Thus, the attacker can front-run the signatures and use them in unintended functions to cause a user's transactions  to  fail.  However,  this  does  not  render  the  ZkBob  system  unsecure  itself  but  might  cause problems for 3rd party integrations. Thus, the severity of this issue is low.  Risk accepted:  BOB Protocol accepted the risk and stated:  Third  party  integrations  relying  on  permit/receiveWithPermit  are  advised  to  implement  necessary fallbacks for failing permit/receiveWithPermit calls, avoiding entire transaction failures.  BOB Protocol - zkBob -   11  TrustLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   ZkBobPool Fees Can Drain the Deposits of the User   -Severity Findings   ERC20Permit.receiveWithSaltedPermit Signature Can Be Front-Run   -Severity Findings   Admin Reentrancy in ERC20Recovery    Avoiding Recovery by Admin    BobVault Uint Conversions    Missing Sanity Checks    No Events on State Changes   0  1  1  5  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "6.1   ZkBobPool Fees Can Drain the Deposits of the", "body": " User  When depositing using the transact function, the caller can specify a negative token amount. Normally, this would revert as it is checked that the deposit amount is positive. However, if the user also specifies the  fee  to  be  greater  than  the  absolute  value  of  the  deposit  amount,  the  total  token_amount  will  be positive, hence passing the check. Thus, the deposit will go through. This can be exploited by a malicious operator in the following scenario:  1. Operator (msg.sender) specifies txType = 0 (deposit), _transfer_token_amount = -400,  fee = 500.  2. Computed token_amount will be 100.  3. 100 * TOKEN_DENOMINATOR will be transferred to the ZkBobPool from the user address.  4. accumulatedFee[msg.sender] will be increased by 500.  5. Operator withdraws 500 * TOKEN_DENOMINATOR of fees.  Thus, by depositing only 100 tokens malicious operator was able to withdraw 500 tokens as fees. The malicious operator can drain the contract via the fees.  Note  that  the  transact  function  is  only  callable  by  the  privileged  Operator  role.  However,  the OperatorManager contracts can be configured such that every user would be an operator.    BOB Protocol - zkBob -   12  CriticalHighCodeCorrectedMediumCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedSecurityHighVersion1CodeCorrected        \fBOB Protocol confirmed that the case of asset drain was prevented by the verifier and the snark circuits which  are  out  of  scope  for  this  engagement.  However,  the  deposit  of  a  negative  value  still  could  have been  used  as  an  undesired  withdrawal.  Stronger  checks  were  introduced,  namely  a  requirement  that _transfer_token_amount  must  be  positive  for  deposits.  The  check  during  the  withdrawal  correctly constrains  the  token_amount,  since  otherwise  the  same  issue  would  occur  in  the  other  direction  -  a small negative _transfer_token_amount + big positive fee can be positive, causing a withdrawal to count as a deposit.  The full response of BOB Protocol team:  This confusing case is handled correctly by the verifier and snark circuits.  During usual deposit, the following happens:  1. User deposit amount is 400 (_transfer_token_amount is 400)  2. Relayer adds a 100 fee on top  3. Pool contract executes transferFrom for 500 (400 + 100) tokens  4. User shielded balance is increased by _transfer_token_amount (400), which is verified by the  circuit verifier  5. Relayer receives a 100 fee  6. So 500 transferred tokens were divided between user (+400) and relayer (+100)  During the suggested negative deposit, the following happens:  1. User deposit amount is -400 (_transfer_token_amount is -400, better to think of it as a balance  delta, rather than deposit amount)  2. Relayer adds a 500 fee on top  3. Pool contract executes transferFrom for 100 (-400 + 500) tokens  4. User shielded balance is increased by _transfer_token_amount (-400), which is verified by the circuit verifier. As the balance delta is negative, the balance is actually being decreased by 400.  5. Relayer receives a 500 fee.  6. In  the  end,  relayer  receives  500  tokens,  comprised  of  user  shielded  balance  decrease  (400)  and external token transfer (100)  7. Essentially, this turned a deposit into a very strange version of withdrawal  Although balance accounting works correctly here, this situation is indeed very confusing. It cannot be triggered via the UI or SDK, as it just does not make sense for users to do something like that. To get  rid  of  this  unnecessary  source  of  confusion,  we  will  introduce  a  bit  stricter  validation  on  the deposit amounts, so that negative _transfer_token_amount are not allowed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "6.2   ERC20Permit.receiveWithSaltedPermit", "body": " Signature Can Be Front-Run  The  ZkBobPool  permittable  deposit  relies  on  the  ERC20Permit.receiveWithSaltedPermit function.  However,  the in  ERC20Permit.saltedPermit  function  as  well.  An  attacker  can  intercept  the  deposit  transaction, extract the signature and use it in the call to saltedPermit. As a result of this action, the permittable deposit  will  fail  due  to  the  nonce  already  having  been  used.  Thus,  the  attacker  can  front-run  the signatures and use them in unintended functions to cause a user's transactions to fail.  signature   function   used   used   can   this   the   be   in   BOB Protocol - zkBob -   13  DesignMediumVersion1CodeCorrected        \f  The  saltedPermit  function  was  removed.  Hence,  a  permittable  transaction  can't  be  front-run  with  a call that uses the same signature for another function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "6.3   Admin Reentrancy in ERC20Recovery", "body": "  The  executeRecovery  function  in  ERC20Recovery  can  only  be  called  by  the  owner  or  the  recovery admin. When recovering the tokens, they are transferred to the recoveredFundsReceiver address. If this address is a contract, the onTokenTransfer function is called. This call could be used to reenter the  executeRecovery  function  in  order  to  double-claim  the  funds  to  recover.  This  would  allow  the recovery admin or the owner to exceed the intended recoveryLimit.  As  the  recoveredFundsReceiver  can  only  be  set  by  the  owner,  and  both  the  owner  and  recovery admin are trusted addresses, the impact of this issue is limited.    The recoveryRequestExecutionTimestamp and recoveryRequestHash are now deleted before any external calls are made. Hence, if a reentrant call later calls executeRecovery again, there will be no stored timestamp or hash, so the funds can't be double-claimed anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "6.4   Avoiding Recovery by Admin", "body": "  a   that   user   sees   (using account  If  ERC20Recovery.requestRecovery()),  they  can  simply  transfer  funds  to  another  account  to  stop them from being recovered. It may also make sense from the perspective of trustworthiness to only allow recovery  of  funds  e.g.  if  the  account  is  already  frozen,  or  at  least  enforcing  that  an  account  must  be frozen in order to recover its funds.  recovery   marked   their   for   is   Specification corrected:  BOB Protocol responded:  Recovery  functionality  is  intended  to  be  used  only  on  dormant  or  non-existing  users,  if  the  user  is able  to  move  his  funds  to  a  different  address,  his  token  should  not  be  allowed  for  recovery. Recovering  frozen  is  a  different  use-case,  although  it  can  be  also  executed  through  the  same functionality.  With  the  assumption,  that  the  proper  checks  will  be  performed  before  account  recovery,  this  issue  is resolved.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "6.5   BobVault Uint Conversions", "body": "  BOB Protocol - zkBob -   14  SecurityLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \fTo track the token.balance the BobVault contract uses uint128 values. Theoretically, it is possible to provide a value that is great than type(uint128).max. This case will not be handled correctly by the code due to the unsafe conversion to uint128, which truncates the value. As a result, internal accounting will be broken. This happens in multiple functions such as: buy, sell, swap, give.  token.balance += uint128(sellAmount);  The amount before conversion in most cases is used as an argument for token transfer. However, the practical safety of this conversion depends on the external contract, which is not optimal.    BOB Protocol responded:  Although  such  extremely  high  amounts  won\u2019t  be  seen  in  practice,  we  added  additional  overflow checks where necessary.  The checks were introduced in buy, swap, give. Check performed in sell is sufficient to prevent the overflow.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "6.6   Missing Sanity Checks", "body": "  Many  state-changing  operations  do  not  include  sanity  checks  to  ensure  incorrect  values  are  not  set. Consider adding checks to ensure these values aren't accidentally set incorrectly. This can happen e.g. due to a bug in a front-end application resulting in empty values in calldata.  These operations include:  ERC20Blocklist:   updateBlocklister() does not check that _newBlocklister is not address(0).  ERC20Recovery:   setRecoveryAdmin() does not check that _recoveryAdmin is not address(0).   setRecoveredFundsReceiver()  does  not  check  that  _recoveredFundsReceiver  is  not  address(0).  Claimable:   setClaimingAdmin does not check that _claimingAdmin is not address(0).  ZkBobPool:   constructor() does not check any of the provided addresses.   initialize() does not check that _root is not 0.   setTokenSeller() does not check that _seller is not address(0).   setOperatorManager() does not check that _operatorManager is not address(0).  BobVault:   constructor() does not check that _bobToken is not address(0).   setYieldAdmin() does not check that _yieldAdmin is not address(0).   setInvestAdmin() does not check that _investAdmin is not address(0).  BOB Protocol - zkBob -   15  DesignLowVersion1CodeCorrected        \f  Checks  were  added  where  necessary.  Explanation  was  added  why  certain  cases  do  not  need  sanity checks.  BOB Protocol responded:  We added a few sanity checks in places there we think they might be important:   ZkBobPool: constructor(), initialize(), setOperatorManager()   BobVault: constructor()  In other places, zero addresses are used for unsetting the specific privileges and rights:   ERC20Blocklist:  updateBlocklister()  \u2013  zero  address  is  used  to  limit  the  ability  to  block/unblock  accounts only by the governance.   ERC20Recovery: setRecoveryAdmin() \u2013 zero address is used to limit the ability to recover funds only  by  that recoveredFundsReceiver  is  not  zero  in  _remainingRecoveryLimit  (link)  so  it  is  safe  to  not introduce additional checks  the  governance.  setRecoveredFundsReceiver()  \u2013   is  a  check   there    Claimable: setClaimingAdmin() \u2013 zero address is used to limit the ability to claim tokens only by  the governance.   ZkBobPool: setTokenSeller() \u2013 zero address is used to disable the ability for users to swap small  amount of BOB tokens to MATIC during the withdrawal process.   BobVault: setYieldAdmin() - zero address is used to limit the ability to collect generated yield by the governance; setInvestAdmin() \u2013 zero address is used to limit the ability invests tokens into the yield provider only by the governance.  Moreover,  these  functions  should  only  be  called  by  the  admin  via  governance  process  (e.g.  from Safe UI), making real UI typos very unlikely to happen.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "6.7   No Events on State Changes", "body": "  Many  state-changing  operations  do  not  emit  events.  Consider  emitting  events  for  important  state changes.  These operations include:  ZkBobPool:   initialize()   setTokenSeller()   setOperatorManager()  ZkBobAccounting:   _setLimits()   _resetDailyLimits()   _setUsersTier()  BobVault:   setYieldAdmin()  BOB Protocol - zkBob -   16  DesignLowVersion1CodeCorrected        \f setInvestAdmin()  MutableOperatorManager:   _setOperator()  ERC20Recovery:   setRecoveryAdmin()   setRecoveredFundsReceiver()   setRecoveryLimitPercent()   setRecoveryRequestTimelockPeriod()  Claimable:   setClaimingAdmin()    Events were added to the following functions:  ZkBobPool:   setTokenSeller()   setOperatorManager()   withdrawFee()  ZkBobAccounting:   _setLimits()  MutableOperatorManager:   _setOperator()  The remaining functions are either not expected to be called regularly, or it was deemed unimportant for the functions to emit events.  BOB Protocol - zkBob -   17  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "7.1   BobVault.disableCollateralYield Potential", "body": " Reentrancy  The  token  buffer,  dust  and  yield  fields  are  updated  after  the  external  call.  If  the  yield  contract  has  a reentrancy point, where BobVault can be called again - this update can happen in an invalid state. The external calls should happen after all the state variable updates.    Statements were reordered to make the reentrancy impossible.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "7.2   ERC20Permit Deletes Existing Approvals", "body": "  Using any of the public functions in ERC20Permit will zero out any pre-existing approval a user may have had  from  the  signer.  Hence,  a  user  should  use  any  existing  approval  from  the  signer  before  calling permit or its variations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "7.3   Incorrect Comment", "body": "  In the CustomABIDecoder contract, the _memo_fixed_size function features the following comment:  else if (t == 2) {     // fee + recipient + native amount     // 8 + 20 + 8     r = 36; }  in   However,  is  actually ... | fee | native_amount | receiver | .... The given sizes for the fields are correct (but also in the wrong order).  the  case  of  a  Withdraw  operation   in  calldata   the  order     The comment was fixed.  BOB Protocol - zkBob -   18  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Reentrant Tokens  The BobVault contract should not use any tokens with reentrant transfers, such as an ERC777 token, as collateral.  This  could  lead  to  inconsistent  event  orderings  or  potentially  more  severe  issues.  This  audit was performed with the assumption that any tokens used as collateral do not have reentrant functionality.  Similarly,  the  ZkBobPool  contract  should  not  use  an  underlying  token  with  reentrant  calls,  as  it  would open  up  critical  vulnerabilities  such  as  draining  the  contract's  balance  through  the  withdrawFee function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "7.5   Unused Constant", "body": "  In CustomABIDecoder.sol, the sign_r_vs_size constant is defined but never used.  BOB Protocol responded:  We  won\u2019t  delete  the  constant,  as  keeping  it  does  not  impact  the  size/gas  cost  of  the  produced bytecode (most likely it is being pruned by the optimizer), but it might become useful in the future, for adding more extra fields.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "7.6   Unused Return Data in YieldConnector", "body": "  The  YieldConnector's  _delegateFarmExtra  function  does  not  return  anything,  even  though  the farmExtra function of the IYieldImplementation interface returns a bytes type.  Similarly,  the  claimTokens  function  of  the  Claimable  contract  does  not  check  the  return  value  of IERC20(_token).transfer(_to,  balance).  Hence,  false  could  be  returned  (meaning  the transfer did not actually take place).    BOB Protocol responded:  Acknowledged  and  added  missing  function.  The _delegateFarmExtra()  function  is  unused  in  the  context  of  existing  AAVE  deployments,  however,  it to might  be  used  IERC20(_token).transfer(_to,  balance)  in  the  Claimable  contract  are  only  intended  to  be  executed within the manual governance process, thus actual transfer result does not imply any considerable impact on the system.  (e.g.  Compound).  Calls   return  statement   lending  markets   integrations   farmExtra()   for  other   from   BOB Protocol - zkBob -   19  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/zkbob-smart-contracts/"}, {"title": "5.1   Compound Rate normalizeAmount", "body": "  The normalizeAmount returns values that are greater or equal to target * decimals / rate, but still denormalizes to the same target value. For example, target 3, rate 123 and decimals 1000 yields 25. The true value, if computed in the domain of real numbers, would be 24.39. Thus, it can be expressed, for  some  cases.  Also, that  normalizeAmount(300)  deposits  of normalizeAmount(3)  ==  25.  This  has  that  depend  on CoumpoundRateKeeper.  is  few  effects  on   the  normalizeAmount  performs   than  the  systems,   rounding  up  of   the  smaller   2440  which   result   100   ==    Saving  _checkBalance  function  calls  can  fail  and  system  will  be  rendered  unusable.  This  can happen during the normal operation of the system. Saving contract users won't be able to deposit and withdraw funds from the contract. The rounding can effectively cause Denial of Service failure on this contract.   QVault _checkBalanceInvariant can fail for the same reason and render contract DoSed.   Saving contract can have not enough tokens to cover the deposits. Since all deposits are stored as normalized values and rounded up, all users get more tokens than they can claim from the system.   Saving contract rewards users with smaller deposits   BorrowingCore penalized the users, by rounding up their debt.   The BorrowingCore will collect more fees but users also will get less liquidation coins if fee is high  enough to cover both.  In addition, the update is done via a loop, that is not executed more than once, while according to fuzzing tests it never runs more than once for the domain of numbers that contract should work with.  Code partially corrected:  Q Blockchain - System contracts -   10  SecurityDesignCorrectnessTrustCriticalHighMediumLowCodePartiallyCorrectedDesignLowVersion1CodePartiallyCorrected            \fThe  ineffective  loop  was  removed  in  favor  of  simple  if  condition.  On  repetitive  deposit  to  the  same address  on  the  QVault  the  user  balance  loses  some  small  values  due  to  division  with  truncation  in denormalization  function.  This  loss  should  in  most  cases  compensate  the  gain  from  the  rounding  up. Overall all mentioned problems can be mitigated by some extra funds deposits. BorrowingCore behavior also while penalizing certain parties by tiny amounts, rewards the system health.  Q Blockchain - System contracts -   11    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  3  6  16  -Severity Findings  -Severity Findings  Inconsistent extendLocking Allows Multiple Votes    Multiple Votes by Delegation    Owner Not Initialized   -Severity Findings   Expired Slashing Proposals Are Not Purged    FxPriceFeed setExchangeRate Timestamp    Gas Heavy Operation on Foreign Chain   Inconsistent Liquidation Full Debt Due to Payback    Price Decimals and Token Decimals May Differ    ValidationRewardPools _updateCompoundRate   -Severity Findings   ASlashingEscrow Decision Reordering    Compiler Version Not Fixed and Outdated    ContractRegistry Erasing Key    Corruptible AddressStorageStakesSorted    FxPriceFeed Can Have No Maintainers    GSN Version String   Inconsistent Liquidation Full Debt Due to Outdated Debt   Inconsistent System Debt Auction Start Condition   Inefficient Code    Long pendingSlashingProposals Attack    QVault updateCompoundRate Precision Loss    Solc Pragma    Specification Mismatch    SystemSurplusAuction Bid Reentrancy    ValidationRewardProxy Allocate Potential Overflow    Validators Can Alter Delegator Share   Q Blockchain - System contracts -   12  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected       \f6.1   Inconsistent extendLocking Allows Multiple Votes  VotingWeightProxy.extendLocking only assigns _lockNeededUntil to lockedUntil[_who]. To  be  consistent,  it  should  be  the  max  between  the  new  and  the  old  value.  Otherwise  the  user  can manipulate the unlock times by voting on a proposal with smaller end time. In addition, the manipulation with unlock times enables user to transfer out the funds earlier and perform the attacks similar to on in Multiple Votes by Delegation, where users tokens can be reused to contribute to the same vote multiple times.    VotingWeightProxy.extendLocking now yields the max value between _lockNeededUntil and lockedUntil[_who].  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.2   Multiple Votes by Delegation", "body": "  Upon  VotingWeightproxy.announceUnlock  and  VotingWeightproxy.unlock,  no  check  is done to verify that the voting agent is not currently locking the delegated amount. This enables an attack where it is possible to vote multiple times with the same Q.  Here is the attack scenario: A    and V   i  i   are accounts controlled by attacker.   : QVault.lock(X)  1. A  i 2. A   3. V  i 4. A   (no lock)    :  VWP.announceNewVotingAgent(V1)  and  VWP.setNewVotingAgent,  can  do  it  in  one  go i  because getLockeduntil will return 0 since A    did not vote  i   : vote on proposal, gets a lock on its own lockInfo   : QVault.announceUnlock(X) and QVault.unlock(X), can do it in one go since A  i   did not vote  i  5. A  i   : Qvault.transfer(A   , X)  i+1  6. goto 1. with i = i+1  Code corrected :  Lock time is now tracked only once per user, previously it was once per locking contract and per user. Now both announceUnlock and unlock now take into account the max time between user's own time lock and its voting agent's time lock, this mitigates the attack described above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.3   Owner Not Initialized", "body": "  Some  contracts  inherit  Ownable  and  Initializable,  but  do  not  assign  the  owner  in  the  initialize function. If such contracts are deployed as a proxy, the owner field will be uninitialized (stays address 0) and owner functionality would be unusable.  Q Blockchain - System contracts -   13  CorrectnessHighVersion2CodeCorrectedDesignHighVersion1CodeCorrectedDesignHighVersion1CodeCorrected                      \f GSNPaymaster  inherits  Initializable  and  BasePaymaster.  BasePaymaster  inherits  Ownable. Function initialize of the GSNPaymaster only assigns value to stc field. The relayHub field can only be set by owner.   ForeignChainTokenBridgeAdminProxy does not set owner in initialize.   TokenBridgeAdminProxy  is  Initializable  and  Ownable.  Owner  is  not  initialized.  Also,  the  Ownable  functionality is not used anywhere.   ExpertsMembership does not initialize owner. Also, the Ownable functionality is not used anywhere.    Q Blockchain has done following fixes for the issues:   Function  initialize  was  removed  from  GSNPaymaster.  The  logic  from  it  was  moved  to  the  constructor.   Now the contract extends OwnableUpgradeable contract of openzeppelin library. The initialize  functions calls _Ownable_init, that sets the owner.   Now the contract extends OwnableUpgradeable contract of openzeppelin library. The initialize  functions calls _Ownable_init, that sets the owner.   Now the contract extends OwnableUpgradeable contract of openzeppelin library. The initialize  functions calls _Ownable_init, that sets the owner.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.4   Expired Slashing Proposals Are Not Purged", "body": "  When  purgePendingSlashings  is  called  (Validators  and  Roots),  only  proposals  with  state REJECTED  or  EXECUTED  are  deleted.  The  proposals  with  state  EXPIRED  are  kept  the pendingSlashingProposals  list  and  their  slashing  amount  is  always  kept  into  account  when calculating the pending slashing amount. Thus, preventing the Roots and Validators to withdraw this amount that they should be able to withdraw, locking it forever.  in   Code corrected :  RootNodesSlashingVoting  and  ValidatorsSlashingVoting  now  define  slashingAffectsWithdrawal functions. The slashingAffectsWithdrawal function includes a check that slashing proposal is not in EXPIRED state.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.5   FxPriceFeed setExchangeRate Timestamp", "body": "  The  exchange  rate  on  FxPriceFeed  is  set  by  setExchangeRate  function  and  recorded  timestamp  is taken from the block. Since the transactions can be delayed and reordered or put to the chain earlier than needed,  the  rate  can  be  outdated  by  the  time  the  block  is  mined.  The  recorded  timestamp  can  give unreliable information about the rate status. Some approaches, like Maker price oracles, ensure that new price  values  propagated  from  the  Oracles  are  not  taken  up  by  the  system  until  a  specified  delay  has passed.  Q Blockchain - System contracts -   14  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f  Field pricingTime was added to the FxPriceFeed contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.6   Gas Heavy Operation on Foreign Chain", "body": "  ForeignChainTokenBridgeAdminProxy is supposed to be deployed on the Ethereum mainnet, thus its  gas  consumption  is  critical.  The  current  complexity  of  the  updateTokenbridgeValidators  is actually O(m*n), where m is length of old list and n is length of new list. Complexity can be reduced to O(m+n)  if  all  old  values  in  list  were  replaced  by  new  list  values.  Also,  the  number  of  calls  to  other contracts should be minimized. Currently, a lot of calls to bridgeValidators contract are done.  Specification corrected:  Q  Blockchain  wants  to  use  IBridgeValidators  interface  implementation  as  it  is  without  any modifications,  since  it  allows  them  easier  integration  with  existing  tokenbridge  code.  With  this requirement, current solution is sufficient. In addition, the O(m*n) complexity loop is done to lower the number  of  calls  between  ForeignChainTokenBridgeAdminProxy  and  IBridgeValidators contracts. According to Q Blockchain tests, this lowers the overall gas consumption.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.7   Inconsistent Liquidation Full Debt Due to", "body": " Payback  Owner  of  the  Vault  that  is  being  liquidated  can  call  payBackStc  and  repay  STC  after  the  liquidation process has started. This can lead to potential problematic scenario:  Collateralization ratio = 150% Liquidation ratio = 125% Liquidation fee = 2%  1. Vault owner has for 150 worth of collateral and 100 worth of STC.  2. Collateral value drops to 120, liquidation is opened with liquidationFullDebt = 100. At that  point the fee should be 2. Highest bid is 105.  3. Vault  owner  pays  back  some  its  debt  over  liquidation  ratio,  so  now  the  vault  has  for  120  worth  of collateral  and  88  worth  of  STC.  Vault  owner  cannot  call  liquidate  because  the  liquidation  ratio does not allow this.  4. Liquidation  is  executed,  liquidationFullDebt  is  still  100  but  should  be  88  by  now.  After liquidation, liquidator got his 120 worth of collateral token, system had its fee of 2 and user only got 105 - (100 + 2) = 3. So, in the end vault owner has lost more STC than what he should have with the liquidation.  System  would  also  burn  more  STC  the liquidationFullDebt that should have changed due to payback.  than  needed,  compensating   token   Code corrected :  A modifier has been added to prohibit debt payback when vault is being liquidated.  Q Blockchain - System contracts -   15  DesignMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrected                  \f6.8   Price Decimals and Token Decimals May Differ  When computing the collateralization ratio in BorrowingCore the formula uses the price from the oracle along with the decimals of the collateral. It is an issue because there is no guarantee that the oracle price will  have  the  same  decimals  as  the  associated  collateral.  The  decimalPlaces  of  the  FxPriceFeed should be used instead.    Instead  of  using  getDecimals,  Q  Blockchain  uses  decimalPlaces  in  BorrowingCore  in  functions _getColRatio and getVaultStats.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.9   ValidationRewardPools ", "body": " _updateCompoundRate  In attempt to improve the precision, the _updateCompoundRate tries to update the compound rate of rate  keeper  with  balance  -  reservedForClaim  -  1  tokens.  Then, the  validator  denormalize(newRate,  stake)  -  denormalize(oldRate,  stake)  +  1  tokens  are  be  used to increase the reservedForClaim variable.  Assume  following  starting  point  of  the  system:  oldRate  ==  1  stake  ==  200  balance  ==  400 reservedForClaim == 0  to   integer  division   The  _updateCompoundRate  will  update  the  compound  rate  keeper  with  400-0-1  ==  399  amount. Due  for reservedForClaim will be 400-200+1==201. But the stakers would be able to get only 200 tokens out from this update. This 1 token difference will not be claimable by anyone and such discrepancies will be slowly accumulating the ValidationRewardPools system.  the  newRate  will  be  2.  New  value   truncation  of   the  result,   If compound rate was updated with balance - reservedForClaim == 400 tokens, newRate would be  3  and  denormalize(newRate,  stake)  -  denormalize(oldRate,  stake)==400  could have been distributed. reservedForClaim would have become 400 too.  If balance where == 200, the balance - reservedForClaim - 1 would be 199, that is not enough to increase the rate. Meanwhile the solution without the -1 would have increased the rate by 1.  To  conclude,  the  balance  -  reservedForClaim  -  1  _updateCompoundRate  algorithm  slowly accumulates  the  errors  and  delays  in  some  cases  the  distribution  of  the  tokens.  With  time  the accumulated errors can drive the denormalized stake and reservedForClaim values more apart and can prevent the payout of the rewards, since the reservedForClaim values will be greater than they should have been, if computation were done in the domain of real numbers.    sub(1)   add(1)   method The  reserveAdditionalFunds(address  _validator)  that  increases  the  validators  balance  and reservedForClaims  fields  by  the  transferred  value  was  added.  It  allows  to  compensate  for  rounding  up errors if they occur. Since the accumulation error speed is not higher then number of delegators * number of updates 1 extra Q token with 18 decimals should compensate error for quite awhile.  approach   dropped.   Payable   was   Q Blockchain - System contracts -   16  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected              \f6.10   ASlashingEscrow Decision Reordering  The  proposeDecision  and  recallProposedDecision  can  be  called  numerous  times  on ASlashingEscrow.  Roots  that  want  to  confirmDecision  cannot  be  sure  what  decision  they  are confirming  and condition  recallProposedDecision/proposeDecision.  Since  the  order  of  those  transactions  can  vary, pending decision might be changed by the time confirmation arrives.  confirmDecision   between   race   due   the   to     The  confirmDecision  function  takes  extra  decision  hash  argument,  that  solves  the  problem  with reordering.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.11   Compiler Version Not Fixed and Outdated", "body": "  The  solidity  compiler  truffle-config.js to be 0.7.6.  is  not   fixed   in   the  code.  The  version,  however,   is  defined   in   the  In the code the following pragma directives are used:  pragma solidity ^0.7.0;  Known bugs in version 0.7.6 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1509  More information about these bugs can be found here:  https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.7 which contains some bugfixes.  Code correct :  Solidity compiler version has been fixed to 0.7.6 in every file, this this the last version before breaking changes of version 0.8.0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.12   ContractRegistry Erasing Key", "body": "  Any given string key for address cannot be purged from ContractRegistry. Function contains always checks that address != 0. But _setAddress function does not allow address to be 0. Thus, unused key address  will  always  be  contained  by  this  contract.  There  is  no  dedicated  function  for  purging  the addresses. In addition, keys are pushed to the storage keys array, but never can be deleted.    Q Blockchain - System contracts -   17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fFunctions removeKey and removeKeys were added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.13   Corruptible AddressStorageStakesSorted", "body": "  AddressStorageStakesSorted contract uses linked list to manage the sorted stakes of addresses. Linked list implementation relies on HEAD==address(0) and TAIL==address(1) constants It is possible to inject  HEAD  or  TAIL  wherever  in  the  linked  list,  allowing  the  owner  to  manipulate  the  order  of  the elements.  The  issue  severity  is  limited,  because  only  the  Validators.sol  contract  is  using  the AddressStorageStakesSorted and only message senders can add themselves to this list. However, if the contract is used in another way than the Validators.sol contract does, the corruption of the sorted linked list could lead to severe issues.  Code correct :  A check that prohibits HEAD or TAIL to be added in the list has been added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.14   FxPriceFeed Can Have No Maintainers", "body": "  Function  leaveMaintainers  in  FxPriceFeed  contract  does  not  check  that  there  are  left  maintainers after the execution of this function. ContractRegistry performs such check in the same function.    Check was added similar to ContractRegistry, that prevents the last maintainer from leaving.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.15   GSN Version String", "body": "  Versions  of  contracts  that  enable  the  GSN  functionality  should  reference  the  GSN  version  used  2.2.2. Currently  the  returned  version  strings  are  not  correct.  While  there  are  no  consequences  on  smart contract level (versions are not checked), the font end libs can have problems with compatibility.   StableCoin.versionRecipient returns \"0.0.1\"   GSNPaymaster.versionPaymaster returns \"0.0.1\"  Code corrected :  The  GSNPaymaster.versionPaymaster is 2.2.0 now.  returned   version   by   StableCoin.versionRecipient   and  Q Blockchain - System contracts -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                          \f6.16   Inconsistent Liquidation Full Debt Due to Outdated Debt  BorrowingCore vault liquidationFullDebt value is updated every time the liquidated function is called.  This  function  can  be  called  by  anyone  and  LiquidationAuction  calls  is  once  during  the startAuction. Nothing prevents the liquidated, as long as the vault is still undercollateralized. But there  is  no  incentive  to  do  so  for  anyone.  In  addition,  the  liquidationFullDebt  saved  in  the beginning of the liquidation will be smaller than the up-to-date value of debt. The collateral interest rate grows  constantly  and  actual  debt  at  than liquidationFullDebt. The difference depends on duration of liquidation auction and interest rate on collateral. All values that depend on liquidationFullDebt will be affected by this discrepancy. For example, the liquidation fee that is defined as a percent of liquidationFullDebt will be smaller than needed and thus, the generated surplus of the system will be smaller than defined %.  the  end  of  Auction  execution  will  be  higher     The liquidate function cannot be called when liquidated. Thus, the liquidationFullDebt cannot be  updated,  once  it  is  set.  The  collateral  interest  rate  growth  won't  affect  the  debt  and  according  to  Q Blockchain, it is intended behavior.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.17   Inconsistent System Debt Auction Start", "body": " Condition  From SystemBalance.getBalanceDetails, auction can begin if  systemBalance.getDebt() >= _params.getUint(stc.debtThreshold())  In SystemDebtAuction.startAuction, auction can begin if  _systemBalance.getDebt() > _params.getUint(stc.debtThreshold())  Note >= vs > difference.  Code corrected :  Both conditions are now strict inequality >.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.18   Inefficient Code", "body": "  Some code has no effect, is redundant, or simply inefficient. Removing or changing it can increase code readability and save some gas as well.  Examples  Q Blockchain - System contracts -   19  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f AddressStorage.mustRemove/mustAdd  :AddressStorage.remove/add  already  has  the  onlyOwner modifier   AddressStorage.size()  :  array.length  has  already  type  uint256,  further  casting  to  uint256 has no effect   AddressStorageStakesStore.updateStake(): addrStake[_addr] = _stake; should be moved after the if(_stake==0){} block, otherwise on a 0 stake contract will write 0 in the slot, then delete the entry.   EmergencyUpdateVoting._vote() : the first two require statements check the same property  and have different error messages   QVault.withdrawTo() : the check for user balance is already done in _subFromBalance   QVault._subFromBalance() : upon _targetBalance computation, the SafeMath library not  needed, the check for _amount <= balanceOf(_owner) has already been done   QVault._subFromBalance() : balanceOf is called 3 times, while the result can be queried only  once and later stored in memory variable.   ValidationRewardProxy.PayInformation : this struct contains bool ok, which is assigned  once but never used or returned   ASlashingEscrow.Decision,   SystemSurplusAuction.AuctionInfo,  SystemBalance.SystemBalanceDetails : those structs can be optimized for tight packing   Validators   if   currentWithdrawal.amount   is   0,   the   entry  validatorsInfos[msg.sender].withdrawal is first deleted and then reinitialized again.   RootsVoting._equals() : function is never used   SystemSurplus.bid()   :   _auction   is   already   in   storage,   rewriting   it   to  auctions[_auctionId] is not needed and gas heavy   SystemBalance.getBalanceDetails()  :  a  condition  evaluation  can  be  saved  on  average  by  writing this block in a if - else if - else style, with the most validated condition first   SystemDebtAuction.execute() : call to _checkBalances has no effect since auction status is  now CLOSED   TokenBridgeAdminProxy : is Ownable but the functionality is never used   VotingWeightProxy.extendLocking()  :  the  loop  may  update  lockInfo.lockedUntil  for each  tokenLockSource  every  time  it  is  called.  So,  every  source  will  have  the  same  value  for  their lockInfo.lockedUntil, a unique lockedUntil per user would be more gas efficient   FxPriceFeed can have fields defined as immutable.   CompoundRateKeeperFactory and AddressStorageFactory can deploy minimal proxies for  implementations and not the complete contract.     The redundant check is removed from AddressStorage.mustRemove/mustAdd   Redundant casting removed   The _stake == 0 is handled properly now.   The redundant check was removed.   The redundant check was removed.   The redundant calls were removed.   The ok field was removed from struct.  Q Blockchain - System contracts -   20  \f The field definitions were rearranged, to profit from tight packing.   The deletion was removed.   RootsVoting._equals() is removed.   The redundant rewrite was removed.   The conditions were rewritten in more optimal way.   _checkBalances was moved to the beginning of SystemDebtAuction.execute() function.   _checkBalances was moved to the beginning of SystemDebtAuction.execute() function.   fallback function is onlyOwner now.   The loop was removed.   State variables that could be immutable are now immutable   Proxies are used for the implementations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.19   Long pendingSlashingProposals Attack", "body": "  Malicious root can create numerous proposals on ValidatorsSlashingVoting or RootNodesSlashingVoting and  make  pendingSlashingProposals  entries  on  Validators  or  Roots  too  long  for  gas  limit  to  be executed. This will brake withdrawal functionality on those contracts for a given Root/Validator. Since the root is trusted role, the chance of such attack is considered low.  Code corrected :  Check  RootNodesSlashingVoting and ValidatorsSlashingVoting upon createProposal.  for  already  pending  slashing  proposal  pair   (victim,  proposer)  has  been  added   in  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.20   QVault updateCompoundRate Precision", "body": " Loss  Following computations are performed in the updateCompoundRate function of the QVault:  uint256 _accruedReward = aggregatedNormalizedBalance.mul(_newRate.sub(_oldRate)).div(getDecimal()); IQHolderRewardPool(registry.mustGetAddress(\"tokeneconomics.qHolderRewardPool\")).requestRewardTransfer(     _accruedReward );  The resulted _accruedReward variable will have more error, then the difference of two denormalized values, calculated with different rates. The requested reward will be smaller due to the integer division truncation  error.  With  time,  the  error  can  accumulate  and  break  invariant  of  the  contract.  In  addition, _checkBalanceInvariant is not performed after the updateCompoundRate.  Code corrected :  The Q Blockchain provided following fixes:   call _checkBalanceInvariant at the end of updateCompoundRate  Q Blockchain - System contracts -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f change calculation of _accruedReward to our standard pattern:   denormalize aggregated balance with old rate   update compound rate   denormalize aggregated balance with new rate   _accruedReward must be the diff between the two  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.21   Solc Pragma", "body": "  pragma   contract   Current  compiler: pragma solidity ^0.7.0; Contracts should be deployed with the same compiler version and flags that  they  have  been  tested  the  most  with.  Locking  the  pragma  helps  ensure  that  contracts  do  not accidentally  get  deployed  using,  for  example,  the  latest  compiler  which  may  have  higher  risks  of undiscovered bugs.  quite  many   directive   versions   permits   the   of     Solidity  pragma  is  set  to  fixed  0.7.6  for  all  Smart  Contracts.  This  is  the  latest  version  of  Solidity  0.7 major version compiler.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.22   Specification Mismatch", "body": "  Code does not match with the specification.  Examples:  1. AddressStorageStakes.add()  address  _addr   :  stake   spec  be   @param  @param _stake amount of decreasing but it should be increase instead of decrease  decreased   whose   will   says and  2. AddressStorageStakes.sub()  :  data.stake  >=  _stake  check  does  not  match  with  the  error message  3. FxPriceFeed : @title Root nodes voting is wrong  4. BorrowingCore.withdrawCol()   : userVaults[msg.sender][_vaultId].colAsset > _amount check does not match with the error message  5. QHolderRewardPool.requestRewardTransfer() : return specs to not match with code, there is no _unsatisfyableClaims and if the amount is too big, call just reverts and does not return 0.  6. SystemBalance.increaseDebt() : PDF documentation says only liquidation auction and saving should  be  allowed  to  increase  debt.  Eligible  contracts  are  not  fixed,  could  be  more  contracts  than those two  7. ConstitutionVoting.shouldExist()   says @dev  Internally  counts  the  vetos  percentage  but  modifier  only  checks  for  proposal existence  spec   :   8. VotingWeightProxy.announceUnlock()  :  spec  says  function  should  throw  error  028002  if  _amount = 0 but no check is done  Q Blockchain - System contracts -   22  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f9. VotingWeightProxy.unlock()  :  spec  says  we  can  only  unlock  previously  announced  amount  via announceUnlock, but it is possible to unlock more than announced  Code corrected :  1. specs updated  2. error message updated  3. specs updated  4. error message updated  5. specs updated  6. new modifier has been added to check for LiquidationAuction and Saving  7. specs updated  8. specs updated  9. specs updated  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.23   SystemSurplusAuction Bid Reentrancy", "body": "  Function  bid  in  SystemSurplusAuction  calls  PushPaymaster.safeTransferTo  to  bidder  address. After  the  call  some  _auction  storage  variable  is  reassigned.  While  PushPaymaster  call  has  a  limited 30000 gas, this can be still enough for reentrancy. Reordering of call and storage assignments can close this potential vulnerability.    The  order  of  operations  was  PushPaymaster.safeTransferTo call.  changed.  No   storage   reads/writes  happen  after   the  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.24   ValidationRewardProxy Allocate Potential", "body": " Overflow  The allocate function has following computations:  p.delegatorReward = p.balance.mul(shortList[i].amount).mul(p.qsv).div(p.totalStake).div(decimal); p.validatorReward = p.balance.mul(shortList[i].amount).mul(decimal.sub(p.qsv)).div(p.totalStake).div(decimal);  The max value for uint256 is close to 10^77. Balance has 18 decimals, amount 18 decimals as well. The qsv or decimal-qsv is a value of 10^27 magnitude. Overall it makes 10^63 just for decimals calculations. Keeping in mind the potential big values for shortList amounts and distributed p.balance, the overflow can occur and block all Validator reward payouts from execution.  Code corrected :  Q Blockchain - System contracts -   23  SecurityLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fComputation that are prone to intermediate overflows are now done using the function mulDiv of library FullMath from Uniswap V3.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.25   Validators Can Alter Delegator Share", "body": "  The setDelegatorsShare function of ValidationRewardPools allows validators to set a percent, that will go to delegators from the rewards that validator can get. This action can be done without any time constraints and prior announcement. Validator can even sandwich the call to rewards distribution function between  two  setDelegatorsShare  calls  that  will  result  in  harder  to  notice  of  lowering  the  profits  of delegators.  Code corrected :  Q Blockchain added event DelegatorsShareChanged that allows users to easily identify misbehaving validators. The own stake of validator is much higher than the potential profit from reward distribution and since the own stake can be slashed for misbehavior, the issue is considered as resolved.  Q Blockchain - System contracts -   24  TrustLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "7.1   Constructor and Initializer", "body": "  Some  contracts,  e.g.  AddressStorage  defines  both  constructor  and  function  initialize.  Quite  often developers  duplicate  the  logics  of  initialize  inside  constructor  and  define  constructor  itself  with initializer  modifier.  In  your  case  you  don't  do  it,  but  the  creation  and  initialization  of  such  contracts  is consistent and done in a safe way. We wanted to let you know that the current pattern can easily lead to issues, if contract will be used directly without proxy and without proper initialization. The contracts that will serve as implementations for Factories also should be properly initialized, to prevent the undesired state modifications on it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "7.2   DefaultAllocationProxy Allocate", "body": "  The design of allocate function in DefaultAllocationProxy contract has aspect that is worth mentioning: The  failure  of  any  beneficiary  fallback  logic  will  force  the  entire  allocation  procedure  to  fail.  In  current implementation version only the QHolderRewardProxy has any logic in its receive function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "7.3   Plain Strings as Keys", "body": "  The use of plain strings as access keys for the registry across the code base is error prone. It could lead to mistyping one of the keys, can make a contract unusable. A less error prone solution would be to store those string keys as globally available constants.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "7.4   Proxy Tests", "body": "  The  truffle  tests  concerning  proxies  should  be  extended.  In  the  current  state,  the  proxies  are  just deployed,  but  never  used.  Tests  should  be  done  with  real  proxies,  issues  like  the  one  concerning  the ownership could have been detected then.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "7.5   Roots Function _addStake Check", "body": "  The check needs to check the _amount value. In current implementation this causes no problems, but can lead to bug if functionality changes.  require(msg.value > 0, \"[QEC-002012]-Additional stake must not be zero.\");  Q Blockchain - System contracts -   25  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \f7.6   SlashingEscrow PENDING After appealEndTime  The  ASlashingEscrow's  state  machine  can  stays  PENDING  on  an  arbitration  decision  if  not  enough RootNodes  confirm  the  decision.  If  a  decision  on  a  casted  objection  does  not  receive  enough confirmations,  it  stays  on  PENDING  state,  event  after  the  appealEndTime.  So  as  long  as  not  enough RootNodes have confirmed the decision, the slashed amount is kept in the slashing escrow, that could mean pure loss for the validator, the slashing proposer and the system reserve if the arbitration is never decided.  The  Q  Blockchain  team  confirmed,  that  root  nodes  are  incentivized  to  vote.  Thus  every  vote  on SlashingEscrow should eventually be decided.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "7.7   System Compatibility With External Tokens", "body": "  While  systems  contracts  operate  properly  with  good  behaving  ERC20  tokens,  some  odd  tokens  can cause  potential  problems  in  the  system.  For  example,  the  BorrowingCore  getting  collateral  with collateral.transferFrom(msg.sender,  address(this),  _amount)  and  _amount  is retained  for  accounting.  This  behavior  does  not  tolerate  tokens  with  fees.  If  a  collateral  is  a  token  that allows fees upon transfer, the real amount received by the BorrowingCore will be less than _amount and the system could end up undercollateralized without noticing it. Similarly, the rounding errors in QVault transfers can lead to smaller received values on the BorrowingCore side. Thus, QVault cannot be used as  a  collateral  inside  BorrowingCore  without  code  adjustments.  In  addition,  on  Ethereum  some  tokens don't always return values on transfer/transferFrom or approvals. Some tokens have unusual number of decimals  (too  big  or  too  small).  Allowing  the  system  to  manipulate  any  external  token  should  be  done with a great care.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "7.8   Total Q Supply Assumption Source", "body": "  the   amount, Upon  (block.number.mul(15)).add(10000000000).mul(1  ether)  is  copy-pasted  as-is  four  times. Having  system  parameters  defined  in  different  sources  is  error  prone  and  can  complicate  the upgradability of the system contracts.  computation   circulating   total   of   Q   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "7.9   Unchecked Function Return Values", "body": "  Some of the calls to known functions are not checked, mainly calls to AddressStorage.  Examples :   QVault.delegateStake : return value of _newDelegations.add(_delegationAddr); is not  checked  Q Blockchain - System contracts -   26  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f AExertsMembership.add/remove/swapMember : return values of the interactions with the list  of experts are not checked   QVault _addToBalance and _subFromBalance functions return bool that are never used  While this might be intended, this uses more gas.  Q Blockchain - System contracts -   27  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain/"}, {"title": "6.1   Balancer Flashloan Can Break Proxy Access", "body": " Rights  The OperationExecutor supports Flashloans. For this, a callback interface for the FlashloanProvider must be  provided.  As  the  UserProxy  does  not  have  the  required  interface,  this  callback  is  made  to  the OperationExecutor, which then calls execute() to switch back into the Proxy's account/storage context  CS-DMAV2-005  The transaction flow for Flashloans is as shown below:  Context: UserProxy  UserProxy delegatecall -> OperationExecutor -> TakeFlashloan Action -> FlashloanProvider  Context: OperationExecutor  FlashLoan Callback -> UserProxy.execute()  Context: UserProxy  OperationExecutor.callbackAggregate()  To facilitate this flow, the OperationExecutor is given the permission to call execute() on the UserProxy for the duration of the Flashloan.  In the case of using Maker's Flashloan, this callback is correctly restricted to only call execute() on the initiator (msg.sender) of the Flashloan.  For the Balancer integration however, the initiator is given in calldata of the Balancer call instead of Balancer returning the msg.sender. This means there can be a callback into any proxy for which the OperationExecutor  has  execution  rights,  even  if  Balancer  was  called  from  an  address  other  than  the Proxy.  This is an issue if there is an unsafe external call in any action nested in the FlashLoan. Any address can reenter the receiveFlashloan function of OperationExecutor by taking a Flashloan on Balancer, and use its execute() privileges to execute any actions from within the context of the proxy.  Summer.fi - DeFi Modular Actions v2 -   12  CriticalHighCodeCorrectedMediumLowCodeCorrectedCodeCorrectedCodeCorrectedSecurityHighVersion1CodeCorrected         \fWe illustrate what an attack could look like using the following set of actions performed by a user:  1. TakeFlashloan  2. SwapAction  3. TransferAction  First, the user will take a Flashloan. This will give the OperationExecutor permission to call execute() on  the  proxy.  Second,  the  user  swaps  tokens.  Assume  that  this  makes  an  unsafe  external  call  to  an attacker's contract, for example through a transfer hook in the traded token.  Now, the attacker has control flow and can execute the reentrancy attack. They take another Flashloan, setting  the  FlashloanRecipient  to  the  OperationExecutor  and  the  initiator  to  the  UserProxy. receiveFlashloan()  will  be  called,  which  calls  execute()  in  the  UserProxy.  The  functionSelector will  always  be  callbackAggregate,  but  the  flData.calls  is  provided  by  the  attacker  when  they take  their  Flashloan.  Now,  those  actions  chosen  by  the  attacker  will  be  executed  in  the  context  of  the UserProxy. For example, the attacker can call the SendToken, SetApproval or Withdraw action and drain all funds in the proxy.  The actions taken by the attacker will be recorded in the txStorage and it will be checked if they belong to an operation that exists at the end of the execution. This means the attack only works if there exists an action that is the same as the one the user called, but with additional actions added.  For example, for the set of actions above to be attackable there would have to be another legal operation that has those steps and additional ones at the location of the reentrancy.  Such as:  1. TakeFlashloan  2. SetApproval  3. SwapAction  4. TransferAction  The same issue is also present in OperationExecutor v1, when taking a Balancer Flashloan and making an unsafe external call. However, here the limitation of the actions needing to form a legal operation is not present, as the operations are only checked in the beginning, not at the end. So an attacker can add any operations they want using reentrancy.  In summary, if there is an unsafe external call (reentrancy) in any nested action taken by a user during a Balancer Flashloan, their entire Proxy's balance can be drained.    Nested  OperationExecutorV2 at a time when it has execution rights on the Proxy of the original caller.  flashloans  are  now  prevented,   the  main  concern  of   this  solves   reentering   the  Technically this works as follows: OperationExecutorV2 now features a flag isFlashloanInProgress. Upon  a  callback  through  one  of  the  flashloan  interfaces  (the  callback  by  the  flashloan  provider  is executed in the context of the OperationExecutorV2) checkIfFlashloanIsInProgress ensures no flashloan is in progress already by ensuring the flag is equal to 1. processFlashloan() sets the flag to 2 before dispatching the callback to the Proxy context and resets the flag to 1 after it returned.  Note that outisde of flashloan actions, the following still applies:  For the Balancer integration however, the ``initiator`` is given in calldata of the Balancer call instead of Balancer returning the ``msg.sender``.  It is important that outside of flashloan actions the OperationExecutorV2 does not have any priviledges on any proxy.  Summer.fi - DeFi Modular Actions v2 -   13  \f6.2   Inefficient txStorage  In OperationExecutor's aggregate(), actions are written into txStorage as follows:  txStorage.actions = abi.encodePacked(txStorage.actions, targetHash);  CS-DMAV2-006  This  unnecessarily  reads  all  past  actions  out  of  storage  and  then  rewrites  the  same  data  into  storage again, which costs gas each time. To reduce gas consumption, just the new data could be added at the end.  Writing  to  (multiple)  storage  slots  is  expensive.  It  would  also  be  possible  to  hash  actions  one  by  one instead of at the end, allowing only a single storage slot to be used instead of one for each action.    aggregate() now pushes the executed action to the storage without reading the previous actions every time:  txStorage.actions.push(targetHash);  executeOp()  retrieves  the  stored  actions  once  after  the  execution  of  aggregate()  completed  and encodes them, the result is the same as the previous txStorage.actions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-defi-modular-actions-v2/"}, {"title": "6.3   SafeMath Is Not Needed", "body": "  An outdated version of the SafeMath library is used.  Since  Solidity  0.8,  the  overflow  checks  that  were  previously  done  in  SafeMath  are  now  enforced  by default. As a result, the library is no longer needed.  If SafeMath is used for the custom revert strings, the new version of SafeMath should be used.  CS-DMAV2-003    SafeMath has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-defi-modular-actions-v2/"}, {"title": "6.4   SendToken Functionality Differs for Native", "body": " Tokens  The SendToken action has the following NatSpec:  CS-DMAV2-004  Summer.fi - DeFi Modular Actions v2 -   14  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f//@title SendToken Action contract //@notice Transfer token from the calling contract to the destination address  For ERC-20 tokens, the implementation sends tokens that are held by the delegatecalling contract.  However, for native ETH, the implementation only forwards ETH that was sent as msg.value along with the originating function call. In this case send.amount is ignored. It cannot send ETH that was already held by the delegatecalling contract.  After  the  intermediate  report  the  description  was  updated  and  now  explains  the  different  behavior  for ERC-20 tokens and Ether.  The description for Ether is inaccurate however:  The amount of ETH that can be transferred is either the whole or partial (whether some amount has been used in other actions) amount from the amount that the transaction has been called with ( msg.value ). If the proxy contract contains any prior ETH balance, it CANNOT be transferred.  The delegatecalls into the code of the actions during the loop in aggregate() preserve msg.value. payable(address).transfer(msg.value) attempts to transfer this amount which succeeds only if sufficient  Ether  is  available.  Either  the  Ether  sent  along  the  original  call  has  not  yet  been  spent  and  is available for the onward transfer or the Proxy has additional Ether balance which can be used.    SendToken  has  been  changed,  the  behavior  for  the  native  token  now  matches  the  functionality  for ERC-20 tokens. The new description now describes the actual behavior of the action.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-defi-modular-actions-v2/"}, {"title": "6.5   ERC-1967", "body": "  The description of library StorageSlot reads:  CS-DMAV2-002  This library is a small implementation of EIP-1967. Unlike that EIP which usage is to store an address to an implementation under specific slot, it is used to storage all kind of information that is going to be used during a transaction life time.  While  the  library  is  suitable  for  the  intended  use,  mentioning  EIP-1967  can  be  confusing  and  strictly speaking  is  incorrect:  This  EIP  standardises  the  storage  slots  for  the  the  following  addresses: implementation, beacon and admin only. The EIP states:  More slots for additional information can be added in subsequent ERCs as needed.  The StorageSlot library borrows the idea how the storage slot is chosen to avoid any collision with high probability  from  the  EIP-1967  but  is  otherwise  not  connected  to  and  does  not  implement  or  adhere  to EIP-1967.  Summer.fi - DeFi Modular Actions v2 -   15  InformationalVersion1Speci\ufb01cationChanged      \fSpecification changed:  Summer.fi removed the misleading reference to ERC-1967 from the description.  Summer.fi - DeFi Modular Actions v2 -   16  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-defi-modular-actions-v2/"}, {"title": "7.1   Missing Event", "body": "  In OperationsRegistry, the transferOwnership function does not emit an event.  CS-DMAV2-001  Acknowledged:  Summer.fi states they do not emit events on ownership change in any contract.  Summer.fi - DeFi Modular Actions v2 -   17  InformationalVersion1Acknowledged    \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-defi-modular-actions-v2/"}, {"title": "8.1   DsProxy With Unsupported Authority", "body": "  A user is free to set the authority contract of his own DSProxy. Depending on the authority contract set, which may be arbitrary, ProxyPermission.givePermission() may not be successful.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-defi-modular-actions-v2/"}, {"title": "8.2   Reentrancy Could Delete Transient Storage", "body": "  The executeOp function in OperationExecutor could be reentered, which deletes the txStorage.  However, this is only possible if the msg.sender has execute() privileges for the executeOp function on the UserProxy and can reenter.  This should only be the case for the user, meaning they could only circumvent the legal operations check for themselves by deleting txStorage.  Summer.fi - DeFi Modular Actions v2 -   18  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-defi-modular-actions-v2/"}, {"title": "5.1   Cancel Order Authorization Differs From", "body": " Match  Function validate of OrderValidator contract permits matches in cases when the message sender is not the order maker. This can be done when the order maker is an ERC1271 implementation or when the sender provides a valid signature. During the cancellation the only check that is done is:  require(_msgSender() == order.maker, \"not a maker\");  This  check  is  more  strict  than  the  matchOrders  authorization  rules  and  limits  the  possible  pool  of parties that can use this entry-point, for example, ERC1271 contracts cannot cancel their orders.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "5.2   Dependency on EIP712Upgradeable", "body": "  Contract  OrderValidator  uses  EIP712Upgradeable  contract  from  openzeppelin  library,  which  is currently  in  a  draft  stage.  That  increases  the  risk  of  bugs  and  errors  in  all  contracts  that  use  this dependency. In addition draft library contracts tend to be inefficient. For example in current version, every call  (_EIP712NameHash(), two  _EIP712VersionHash()) which together cost 4200. That is fairly unnecessary.  _hashTypedDataV4   lookups   storage   triggers   to   import \"@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol\";  Rarible Inc. - Exchange V2 -   8  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedLowRiskAcceptedRiskAcceptedDesignMediumVersion1RiskAcceptedSecurityLowVersion1RiskAccepted                   \f5.3   Missing Indexes In Events  In ExchangeV2Core the events Cancel and Match contain no indexed fields. Indexing order hashes will help to avoid performance issues on node clients.  Rarible Inc. - Exchange V2 -   9  DesignLowVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   doTransfers Does Not Hanlde LibFeeSide.FeeSide.NONE   -Severity Findings   Function safeGetPartialAmountFloor Precision Problems    Order Salt Problems    Orders With Salt 0 Can Be Canceled   -Severity Findings   Compiler Version Not Fixed    Contracts Can Be Order Makers    Precision Check in calculateRemaining Problem   0  1  3  3  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "6.1   doTransfers Does Not Hanlde", "body": " LibFeeSide.FeeSide.NONE  doTransfers  performs  the  transfer  of  assets  after  choosing  which  is  the  feeable  side.  However, getFeeSide can return the value LibFeeSide.FeeSide.NONE in the case none of the assets are ETH or  ERC20  or  ERC1155.  This  value  is  not  handled  by  the  function  doTransfers  which  results  to  the transfer not being performed.    doTransfers was changed to handle LibFeeSide.FeeSide.NONE.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "6.2   Function safeGetPartialAmountFloor", "body": " Precision Problems  target)   The function safeGetPartialAmountFloor( uint256 numerator, uint256 denominator,  uint256  LibMath  the numerator * target / denominator and reverts on too much divergence from the correct value. Due to the different nature of tokens ( ETH, ERC20, ERC721, etc.) and different decimals on them, the actual values sent to this function can be of different orders. In cases when the denominator is greater  effectively   computes   contract   defined   in   Rarible Inc. - Exchange V2 -   10  CriticalHighCodeCorrectedMediumSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedDesignHighVersion1CodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged                \fthan  the  numerator  *  target  the  0  will  be  returned.  This  can  lead  to  situations  when  the  orders cannot be matched. For example order \"Buy 30 for 600X\" cannot be matched with order \"Sell X for 10\", because  the  fillRight  function  that  relies  on  safeGetPartialAmountFloor  will  return  (10,  0) value that later will fail the check in matchAndTransfer function.  The safeGetPartialAmountFloor function is used in following places:   Function fillLeft in LibFill contract.   Function fillRight in LibFill contract.   Function calculateRemaining in LibOrder contract. In this case, big, close to filling values may  fail.  Specification corrected:  Now the specification correctly communicates the behavior of the contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "6.3   Order Salt Problems", "body": "  The  salt  is  effectively  a  field  of  an  order  that  allows  different  orders  of  the  same  asset  types  from  the same maker to be distinguishable from each other. This field is also part of the hashKey of the order that is  used  to  track  the  filling  of  the  order.  However,  due  to  the  lack  of  Asset  values  in  the  hashKey,  the same value for salt can be resubmitted with higher-order take value, and thus lead to multiple full filling of the  same  order.  For  example,  an  order  that  makes  20  take  X  after  filling  can  be  resubmitted  with  the same salt and higher take limit: make 30 take 2X. Note that after cancellation the salt becomes unusable for the maker. From a specification point of view, it the order with same hashKey shouldn't be fully filled multiple times.  function hashKey(Order memory order) internal pure returns (bytes32) {     return keccak256(abi.encode(             order.maker,             LibAsset.hash(order.makeAsset.assetType),             LibAsset.hash(order.takeAsset.assetType),             order.salt         )); }  Specification corrected:  The behavior was documented and properly described in exchange-v2/readme.md.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "6.4   Orders With Salt 0 Can Be Canceled", "body": "  The  filling  degree  of  orders  with  salt  0  is  not  tracked  in  the  matchOrders  function.  But  the calculateRemaining function will use the value from fills map to compute the remaining value that needs  to  be  filled.  The  cancel  function  effectively  sets  the  fills  map  value  to  the  UINT256_MAX value. Users can also cancel orders with salt 0, effectively making the asset pair not longer usable with salt 0.  Rarible Inc. - Exchange V2 -   11  DesignMediumVersion1Speci\ufb01cationChangedDesignMediumVersion1CodeCorrected                \f  A check that prevents 0 salt order cancellation was added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "6.5   Compiler Version Not Fixed", "body": "  The  solidity  compiler  is  not  fixed  in  the  code.  In  addition,  different  files  define  different  pragmas.  The version, however, is defined in the truffle-config.js to be 0.7.6. In the code the following pragma directives are used:  pragma solidity >=0.6.2 <0.8.0; pragma solidity >=0.6.9 <0.8.0;    The pragma was fixed to 0.7.6 for all contracts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "6.6   Contracts Can Be Order Makers", "body": "  Maker  and  Taker  of  orders  can  be  contracts  with  the  help  of  the  ERC1271  standard.  In  addition,  fee receiving parties can be contracts too. If native ether is used as an asset during the match, the transfers can  fail  if  the  contracts  do  not  implement  a  payable  fallback  function.  The  system  specification  should clearly communicate this requirement to the users.  Specification corrected:  The expectations from contracts were documented and described in exchange-v2/readme.md.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "6.7   Precision Check in calculateRemaining", "body": " Problem  Due  to  a  precision  check  in  function  calculateRemaining  orders  with  different  magnitudes  of  take and make values can become unfillable even with a small filling degree. For example, Order with make 10 take 100 cannot be filled if fill amount of take is 15. In calculateRemaining the remaining make value for that order will be approximated with value 8. Because the true value of 8.5 cannot be expressed with integer numbers, the error of 0.5 will exceed 0.1% limit that is built-in in calculateRemaining due to utilization of LibMath.safeGetPartialAmountFloor function.    precision   The  commit 839710b1bd7ed11fc22fa2093f408934b92ccf35.  This  fix  prevents  premature  order  freeze.  With  the  fix,  in  calculateRemaining   function  was   removed   check   in   Rarible Inc. - Exchange V2 -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \fonly  the  last  make  item  of  the  order  can  be  unsellable.  For  example,  an  order  with  make  10  take  100 cannot  be  fully  filled  if  the  fill  amount  of  take  is  95,  as  the  0.5  make  value  will  be  estimated  by calculateRemaining  function  as  0.  With  help  of  order  extension  functionality,  such  orders  can  be fixed  via  signature  resubmission  with  greater  values.  The  precision  check  for  price  computation  is  still used.  Rarible Inc. - Exchange V2 -   13  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "7.1   Accumulation of Rounding Errors", "body": "  The  fullfilment  of  an  order  is  tracked  by  the  fills  mapping.  The  remaining  part  comes  from  the subtraction of the value the fills mapping holds for a particular order from the total take value of the order.  if (orderLeft.salt != 0) {      fills[leftOrderKeyHash] = leftOrderFill.add(newFill.takeValue); } if (orderRight.salt != 0) {     fills[rightOrderKeyHash] = rightOrderFill.add(newFill.makeValue); }  the  value  added   However,  in LibOrder.calculateRemaining.  Division  might  introduce  some  rounding  erros  which  gradually accumulate  if  an  order  is  partially  filled  multiple  times.  Notice  that  the  implemenation  tolerates  a  0.1% rounding error.  is  a  result  of  a  division  occuring   the  fills  mapping   to   function calculateRemaining(Order memory order, uint fill) internal pure returns (uint makeValue, uint takeValue) {     takeValue = order.takeAsset.value.sub(fill);     makeValue = LibMath.safeGetPartialAmountFloor(order.makeAsset.value, order.takeAsset.value, takeValue); }  function safeGetPartialAmountFloor(     uint256 numerator,     uint256 denominator,     uint256 target ) internal pure returns (uint256 partialAmount) {     if (isRoundingErrorFloor(numerator, denominator, target)) {         revert(\"rounding error\");     }     partialAmount = numerator.mul(target).div(denominator); }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "7.2   AssetMatcher Gas Efficiency", "body": "  The matchAssetOneSide function in AssetMatcher contract effectively decides if two assets types can be matched. It also contains logic for matching assets that are not yet known to the systems:  if (classLeft == classRight) {     bytes32 leftHash = keccak256(leftAssetType.data);     bytes32 rightHash = keccak256(rightAssetType.data);     if (leftHash == rightHash) {         return leftAssetType;     } }  Rarible Inc. - Exchange V2 -   14  NoteVersion1NoteVersion1      \fThis piece of code works for all known asset types as well. In addition, it is more efficient than the current matchAssetOneSide for most of the known asset types.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "7.3   Incentives for Front-Running", "body": "  In  case  when  2  assets  that  can  pay  fees  are  exchanged,  the  order  of  arguments  in  matchOrders function might matter. Moreover it determines the price and thus the amounts exchanged between the two  parties.  There  might  be  third  parties  that  are  incentivised  to  front-run  the  transactions  in  order  to determine the position of the orders for their own interest. The users should be aware of such events. In addition,  once  the  transactions  are  visible  in  the  mining  pool,  any  other  parties  can  try  to  frontrun  the match, to profit from matching with lower fees or good price.  Illustration of order importance:  Let  A  and  B  be  an  ERC20  and  ERC1157  token  respectively.  Accoring  to  the  contract  logic  currently implemented,  the  feeable  token  is  A.  Assume  two  orders  O1:(10A,  20B)  and  O2:(50B,11A)  Executing matchOrder(O1, O2) yields fillResult(10A, 20B) (fillLeft will be called). On the other hand, executing  matchOrder(O2,  O1)  yields  fillResult(20B,  220/50A)  (fillRight  will  be  called). Assuming a fee of 10% then in the first case we have 0.1 * 10A and the second 0.1* 220/50 A  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "7.4   Orders Can Pay No Fees", "body": "  Before transfering the assets to the corresponding parties the fee side is chosen. The side is chosen to be the one that offers ETH or ERC20 or ERC1155. If there is no such types in make and take assets of the order, the fees won't be deducted.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "7.5   Reentrancy Risk", "body": "  In  the  matchOrders  can  occur  calls  to  other  contacts  and  addresses.  For  example,  during  the  native ether transfer or during the transfer of tokens that allow user hooks e.g. ERC777 (extension of ERC20). While we haven't identified a direct way, how this can be abused. But risk of reentrancy is nullified when a non-reentrant lock is used, for a price of small gas cost increase.  In addition, following transfers of ether will send all the gas to the callee, allowing it to execute any other contract with no restrains.  (bool success,) = to.call{ value: value }(\"\");  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "7.6   The Order of Orders Determines The Price", "body": "  In centralized order book-based exchanges, the price of matchable orders with different prices is usually determined  by  the  order  with  the  earliest  submission  time.  In  the  current  implementation,  the  price  is determined by the left order. While the centralized method is not applicable to this system, the current behavior should be documented in specification, as the users should be aware of the price formation.  Rarible Inc. - Exchange V2 -   15  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f7.7   Use of SafeMath  There are many instance where the SafeMath is not used. Such calculations can lead to overflows and, thus, unexpected behavior. No dangerous overflows have been found during the overflow, however, the use  of  SafeMath  is  recommended.  For  example  such  calculations  happen  in  transferPayouts function on sumBps accumulator.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "7.8   Validate Gas Efficiency", "body": "  Function  validate  in  OrderValidator  contract  can  be  restructured  for  a  lower  gas  cost.  The isContract check is performed in all cases when the message sender is not the maker. Assuming that the most popular cases are when the maker is not a contract, the signature check can be performed first, before the isContract check.  Rarible Inc. - Exchange V2 -   16  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/rarible-exchange-v2-smart-contracts/"}, {"title": "6.1   NstToDai Can Be Paused if DaiJoin Is Paused", "body": "  The  DaiNst  converter  itself  is  permissionless.  However,  if  DaiJoin  is  paused,  NstToDai()  will  be indirectly paused as exit() will revert on DaiJoin.  Note that this theoretically possible situation does not apply to the existing Maker's DaiJoin deployed at 0x9759A6Ac90977b93B58547b4A71c78317f391A28.  The only ward of this contract is its deployer contract DaiJoinFab, which is immutable and does not have the functionality to pause the daiJoin by calling cage() nor to add more wards.  MakerDAO - NST -   10  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-nst/"}, {"title": "5.1   Constitution and Experts Keys", "body": "  0  0  0  3  All  the  registry  keys  for  common,  governance,  and  tokeneconomics  have  been  grouped  in Globals.sol  as  constant.  However,  it  is  not  the  case  with  other  keys  like  the  constitution  and governed  parameters  keys.  An  accidental  typo  in  the  string  constant  can  lead  to  potential  system misconfiguration.  Risk accepted:  Q Blockchain accepts the risk and decides to leave the code as it is.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "5.2   FxPriceFeedMedianizer Price Feed", "body": " Manipulation  Since  all  the  data  submitted  by  the  subfeeds  is  immediately  visible  on-chain,  malicious  subfeed  can decide what data to submit and manipulate the outcome of the computed round. By submitting a value above or below the current median the subfeed provider has limited control over the outcome. Assuming that subfeeds are trusted, this has a limited likelihood of happening.  Risk accepted:  Q Blockchain accepted the risk and states:  Q Blockchain - System contracts v1.2 -   11  DesignTrustCriticalHighMediumLowRiskAcceptedRiskAcceptedRiskAcceptedDesignLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                  \fThe subfeeds are considered trustworthy, also the price manipulation is quite limited in range since the resulting price is a median and by definition insensitive to extreme values. Therefore the impact of a malicious subfeed would be minimal.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "5.3   FxPriceFeedMedianizer Subfeeds", "body": " Consistency  Multiple subFeed parties need to provide the rate in a given round to compute the exchangeRate.  The following problems can potentially arise during the lifetime of this contract:  1. Due to the concurrent nature of the blockchain, subfeeds cannot control when their submit() call will  be  included  in  the  chain  history.  In  addition,  the  submit  reverts  if  the  same  subfeed msg.sender tries to republish the rate in the same round. The submit transaction submitted at the  very  start  of  the  new  round  may  be  counted  in  the  previous  round,  due  to  random  delays between transaction creation and block confirmation.  2. The  subfeeds  rates  provided  to  the  FxPriceFeedMedianizer  contract  are  not  sanitized.  It  is possible to provide subfeeds that do not match the pair, decimals, or base token address. The only sanity  check  performed  on  the  submitted  rate  is  the  rate  >=minRateValue  check.  A misconfiguration on the subfeed side can lead to a wrong exchangeRate as a result.  Risk accepted:  Q Blockchain accepts the risk and states:  1. We don't see a downside of their submission just going an earlier or later round.  2. If a subfeed reports the price for a wrong asset it will probably always be far   from the median. So, it does not immediately affect the price but the owner can   detect this and remove the subfeed. We consider this also low severity and would   accept the risk.  Q Blockchain - System contracts v1.2 -   12  DesignLowVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   FullMath Operation Correctness Issue   -Severity Findings  -Severity Findings   Reward Allocation Can Be Blocked    Code Duplication    Floating Dependencies Versions    Reentrancy Possibility on Root Node Approval Voting    Unused Functionality and Libraries    FxPriceFeedMedianizer Missing Events    FxPriceFeedMedianizer Rate and Update Time   0  1  0  7  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "6.1   FullMath Operation Correctness Issue", "body": "  The  FullMath.mulDiv(uint  a,  uint  b,  uint  denominator)  the floor(a\u00d7b\u00f7denominator)  operation.  A  similar  function  exists  in  the  UniswapV3  core  codebase. However due to the change of the solidity compiler version from 0.7.6 to 0.8.9, some modifications were  made  to  account  for  the  default  SafeMath  arithmetic  operations  behavior.  This  computation happens in FullMath.mulDiv code:  function  performs   prod0 := add(prod0, mul(prod1, twos))  While Uniswap library performs this operation:  prod0 |= prod1 * twos;  Please note that this operation occurs in the unchecked block.  As a result, the FullMath.mulDiv computation yields undesired results.  For example, this assignment of arguments causes overflow and panic in the FullMath.mulDiv.  a = 2**255 b = 2**255 denominator = 57896044618658100000000000000000000000000000000000000000000000000000000000001  The correct computation should yield 5789604461865809542357098500868799828994258986484 4074485766219939100404438900.  Q Blockchain - System contracts v1.2 -   13  CriticalHighCodeCorrectedMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignHighVersion1CodeCorrected        \f  The FullMath.mulDiv function has been replaced by the OpenZeppelin v4.8.0 implementation. It uses Solidity compiler above 0.8.0 version.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "6.2   Reward Allocation Can Be Blocked", "body": "  In  event was added:    of  the  code  in  ValidationRewardProxy  and  RootNodeRewardProxy  the  Allocated  emit Allocated(beforeAllocation - address(this).balance);  The allocation happens with the help of the PushPayments contract that performs a call with 30000 gas. Malicious  Validator  or  Root  in  their  fallback  function  can  transfer  an  amount  that  is  greater  than beforeAllocation  back  to  the  reward  proxy.  This  way  the  computation  of  the  event  argument  will overflow.  As  a  result,  the  allocation  of  rewards  will  be  blocked.  The  severity  of  this  issue  is  low  since Roots are trusted and Validators can be slashed.    A variable has been added to aggregate the allocated amounts instead of computing a difference.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "6.3   Code Duplication", "body": "  1. In   the   Validators   to registry.mustGetAddress(RKEY__VOTING_WEIGHT_PROXY) is inlined multiple times, while to  registry.mustGetAddress(RKEY__VALIDATORS_SLASHING_VOTING)  are the  calls  grouped  under  the  _getSlashingVotingAddress()  view  function.  Having  a  single  getter function for the voting weight proxy registry key would be consistent with the rest of the codebase.  contract,   call   the   2. In   function clearVault(address,  _vaultId,  _amountToClear,  _beneficiary)  basically duplicates the functionality of transferCol, followed by _clearVault.  BorrowingCore,   the     1. The   inlined   calls  _getConstitutionParametersAddress() and _getVotingWeightProxyAddress().  by  more   consistent   replaced   been   have   calls   to  2. Functions  clearVault  and  transferCol  have  been  marked  as  deprecated  and  are  kept  for  backward compatibility.  Q Blockchain - System contracts v1.2 -   14  TrustLowVersion3CodeCorrectedVersion3DesignLowVersion1CodeCorrected                  \f6.4   Floating Dependencies Versions  The versions of @opengsn and @openzeppelin in package.json is not fixed. This could break the codebase if a new version has breaking changes. Upgradeable contracts that rely on proxy pattern can be  rendered  broken  if  the  new  version  of  the  dependency  contract  introduces  or  changes  the  order  of defined storage fields.    The versions of @opengsn and @openzeppelin have been fixed to 2.2.4 and 4.3.3.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "6.5   Reentrancy Possibility on Root Node", "body": " Approval Voting  In  ARootNodeApprovalVoting.approve, there is a call to onExecute.  ARootNodeApprovalVoting._execute,   function   the   called   by  Since the ARootNodeApprovalVoting is abstract, contracts that inherit from it may execute arbitrary external  code  and  re-enter  during  this  call.  The  function  ARootNodeApprovalVoting.approve  can be  called  again  the  because  _proposal.executed  is  set  to  true  only  after  the  call  to  onExecute. However,  relying  on  the  trust  model,  should  not  be  an  issue  since  the  function  can  only  be  called  by trusted root nodes when the majority is reached. Nevertheless, the Checks-Effects-Interactions pattern is violated.    The flag _proposal.executed is set to true before the call to onExecute. The function adheres to the check effect interaction pattern now.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "6.6   Unused Functionality and Libraries", "body": "  The following list contains problems due to imports, inheritance and usage of the libraries and contracts that are not needed. The redundant code can be removed.   The SafeMath library is not used anymore in the code since the compiler version is now 0.8.9. However,  some  SafeMath  library  imports  are  left  in  the  source  code,  as  well  as  some using SafeMath for uint256.   The  PushPayments  contract  is  Initializable  but  the  functionality  is  never  used  and  can  be  removed.  Code partially corrected:   The SafeMath library has been completely removed.  Q Blockchain - System contracts v1.2 -   15  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f The PushPayments contracts Initializable functionality while not used in the current version might be needed in the future. To prevent problems with storage layout it is necessary to keep the Initializable functionality of the PushPayments.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "6.7   FxPriceFeedMedianizer Missing Events", "body": "  The  FxPriceFeedMedianizer  contract  does  not  emit  events  when  certain  state  changes  occur.  For example:   addSubFeed   removeSubFeed   setMinSubmissionsCount   setMinRateValue   _closeRound  The  lack  of  such  events  complicates  the  reproduction  of  the  contract  state  off-chain.  Thus,  SubFeed providers  might  need  custom  solutions  for  monitoring  the  chain  to  know  when  a  new  rate  must  be submitted.    The  events  MinSubmissionsCountSet,  FxPriceFeedMedianizer.  ExchangeRateUpdated,   SubFeedAdded,   and   MinRateValueSet   have   SubFeedRemoved, in added   been   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "6.8   FxPriceFeedMedianizer Rate and Update", "body": " Time  New exchangeRate is computed only after a round where minSubmissionsCount limit of submissions was reached.  External  protocols  and  systems  can  mistakenly  use  stale  exchangeRate  if  updateTime  is  not properly inspected. There is no default way to get both the rate and update time in a single call    A getter returning both the rate and the time has been added.  Q Blockchain - System contracts v1.2 -   16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "7.1   Finalized Withdraw Address", "body": "  For  an  address  to  be  finalized  in  WithdrawAddresses,  a  root/validator  node  must  provide  proof  of ownership to Q Development AG. One of the limitations set by Q Blockchain is to disallow withdrawals to the main account.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "7.2   Gas Optimization", "body": "  1. The  majority  of  the  updates  of  the  form  x  =  x  +/-  y  have  been  optimized  to  x  +/-=  y,  but  there remains some unoptimized variable updates. An unexhaustive list is:   BorrowingCore.depositCol   :  userVaults[msg.sender][_vaultId].colAsset = userVaults[msg.sender][_vaultId].colAsset + _amount;   BorrowingCore.getAggregatedTotals:  _totalsInfo.outstandingDebt = _totalsInfo.outstandingDebt + _colOutstandingDebt;   Saving.deposit:  aggregatedNormalizedCapital = aggregatedNormalizedCapital + (_newNormalizedCapital - normalizedCapitals[msg.sender]);   Saving.withdraw:  aggregatedNormalizedCapital = aggregatedNormalizedCapital - (normalizedCapitals[msg.sender] - _newNormalizedCapital);  2. The modifier ARootNodeApprovalVoting.onlyRoot takes an address as an argument, but is only  used  with  msg.sender.  Removing  the  argument  and  using  directly  msg.sender  will  save gas.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "7.3   Storage Variables Visibility", "body": "  Some  variables  that  are  currently  internal  in  contracts  that  are  not  inherited  can  be  made  private. Saving.registry, AExpertsMembershipVoting.registry,  Examples  ValidationrewardPool.registry, FxPriceFeedMedianizer.pair, or Saving.stc.  are:   Q Blockchain - System contracts v1.2 -   17  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/q-blockchain-system-contracts-v1-2/"}, {"title": "6.1   Call to Vow.flap() Can Be Sandwiched", "body": "  The parameters for the FlapperUniV2 deployed at time of the audit are a lot of 5000 DAI, a cooldown period of 1577 seconds between calls to Vow.flap(), and 98% slippage tolerance through want.  An MEV searcher can therefore sandwich the Vow.flap() call and extract up to 2% of the 5000 DAI every  26  minutes.  The  gas  cost  of  calling  flap()  is  around  20$  at  the  current  gas  price  of  30  Gwei. Assuming  the  sandwich  attack  gas  cost  is  within  the  same  order  of  magnitude  (one  frontrunning transaction  and  one  backrunning  transaction,  on  warm  token  addresses,  and  warm  Uniswap  pool),  we expect a MEV searcher to extract a profit of around $50 per call. This amounts to a possible loss for the protocol of around $2800 daily.  MakerDAO - FlapperUniV2SwapOnly -   10  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-flapperuniv2swaponly/"}, {"title": "6.1   Advance to Wrong Stage", "body": "  When all deposits are done and meet the minimum requirements but no trades happen, consequently, the  stage  is  not  advanced  and  the  stage  FAIR_TRADING  would  never  be  active.  If  claimLP  is  called after fairTradingEnd it will not be possible to claim because the stage is still in ETH_DEPOSIT instead of FAIR_TRADING . advanceStage needs to be called first to allow claiming the LP tokens in this case to put the stage into FAIR_TRADING and allow the stage progression to be finished in the next iteration.    If fairTradingEnd is reached in the ETH_DEPOSIT stage, the next call will automatically advance the stage to FINISHED.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-auction/"}, {"title": "6.2   ETH Transfer", "body": "  The contract uses the native transfer function to transfer ETH to users. As this function can only use up to 2,300 gas, users using contracts (e.g., Gnosis Safe) to transfer ETH to the contract might be in for a surprise  when  the  FAILED  stage  is  reached  and  they  want  to  call  retrieveETH:  The  transfer  won't succeed.  In  this  case,  the  ETH  of  these  users  has  to  be  transferred  manually  by  the  owner  using execute.    ETH are now transferred using low level calls.  GEARBOX - Gearbox Auction -   10  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.3   Gas Optimizations  The following parts of the contracts could be optimized for gas efficiency:   _advanceStage redundantly checks for the condition if the block.timestamp has exceeded the  fairTradingStart.   _advanceStage performs multiple, redundant storage loads of stage.   _advanceStage sets the stage to ETH_DEPOSIT and then immediately sets it to FAILED.   GEAR token transfers are conducted using safeTransferFrom. This overhead is not needed as  the GEAR token's transfer functions are reverting by default.   _getCurrentMinMaxAmounts   redundantly  totalEthCommitted from storage multiple times.  loads   totalGearCommitted   and   getPendingLPAmount redundantly loads totalLPTokens from storage multiple times.   _commitETH redundantly loads totalEthCommitted from storage multiple times.   commitGEAR redundantly loads totalGearCommitted from storage multiple times.   _depositToPool   redundantly   loads   curvePool,   totalGearCommitted   and  totalEthCommitted from storage multiple times.   foundry.toml does not contain settings for the optimizer.    All listed gas optimizations have been integrated, except for the following (minor) points:   foundry.toml has not been updated with optimizer settings.   _depositToPool still loads curvePool two times from storage.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-auction/"}, {"title": "6.4   Shearing Percent Getter Wrong Before Fair", "body": " Trading Stage  If  getCurrentShearingPct  is  called  before  the  fairTradingStart  timestamp  is  reached,  it  will display more than the maximum shearing percentage.    getCurrentShearingPct now returns shearingPctStart before fairTradingStart.  GEARBOX - Gearbox Auction -   11  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-auction/"}, {"title": "7.1   Almighty Owner Function", "body": "  The  owner  of  the  Bootstrap  contract  is  \"almighty\".  The  function  execute  allows  non-restricted  calls  to any  contract.  This  setup  seems  fine  as  the  owner  is  planned  to  be  the  GEARBOX_TREASURY  address. The thread model assumes this address fully trusted. Still, it should be checked after deployment that all addresses were set correctly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-auction/"}, {"title": "7.2   Fail at FAIR_TRADING Stage", "body": "  The  function  fail  can  be  called  by  the  owner  of  the  contract  at  any  stage.  If  it  is  called  in FAIR_TRADING  stage,  LP  tokens  have  already  been  transferred  to  the  contract  and  cannot  be distributed  through  the  claimLP  function.  Instead,  they  have  to  be  sent  to  another  contract  (with execute) on which a distribution can take place.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-auction/"}, {"title": "7.3   Inconsistent and Floating Pragma", "body": "  Gearbox Auction uses the floating pragma ^0.8.10. Additionally, the compiler version is not set in the Foundry  settings.  Contracts  should  be  deployed  with  consistent  compiler  versions  and  flags  that  were used during testing and auditing. Locking the pragma helps to ensure that contracts are not accidentally deployed using a different compiler version and helps to ensure a reproducible deployment.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-auction/"}, {"title": "7.4   Rounding Errors", "body": "  Due to rounding errors, the following can happen:   A call to sellGear with 3 wei of GEAR tokens (or slightly more depending on the current shearing  percentage) can be sold without the shearing fee.   Some LP tokens might not get distributed. If, for example, 25 wei LP tokens are distributed to a user that committed all of the GEAR liquidity and all of the ETH liquidity, the user only receives 24 wei LP tokens.  GEARBOX - Gearbox Auction -   12  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox-auction/"}, {"title": "6.1   Outdated Interfaces", "body": "  The  zkSync  interfaces  for  L2Log  and  L2Message  have  been  updated  and  the  ones  used  in  the  DAI bridge current codebase are deprecated. The malformed L2 logs or messages would block any attempt of withdrawal or claim of a failed deposit.    The structs used correspond now to the most recent version of the zkSync 2.0 structs.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-zksync-dai-bridge/"}, {"title": "6.2   Refund Recipient Is Not Aliased", "body": "  On ZkSync the contract addresses are aliased using the AddressAliasHelper.applyL1ToL2Alias function,  to  distinguish  between  L1  and  L2  initiated  transactions.  However,  the  refund  recipient  in  the Mailbox.requestL2Transaction  call  in  the  L1DAITokenBridge  contract  doesn't  alias  the msg.sender address, even if it is a contract address.    Refund recipient address is aliased if the msg.sender is a contract.  MakerDAO - zkSync DAI Bridge -   12  CriticalCodeCorrectedHighMediumCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCorrectnessCriticalVersion1CodeCorrectedDesignMediumVersion5CodeCorrected                 \f6.3   Critical Tests Missing  Some critical tests are missing in the test suite, for example, the e2e test for claiming a failed deposit is incomplete.    After  Matter  Labs  provided  the  necessary  sdk  functions  to  generate  the  proof  required  by claimFailedDeposit a test case was added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-zksync-dai-bridge/"}, {"title": "6.4   Inconsistent Use of Interfaces", "body": "  When L1DAITokenBridge calls finalizeDeposit, it uses the L2DAITokenBridgeLike interface. The L2DAITokenBridge implements IL2Bridge, but IL2Bridge and L2DAITokenBridgeLike are not connected.    MakerDAO  uses  the  IL2Bridge  interface  now  and  has  removed  the  L2DAITokenBridgeLike interface.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-zksync-dai-bridge/"}, {"title": "6.5   Lack of Documentation", "body": "  The  main  functionality  is  sufficiently  documented.  However,  the  interaction  with  zkSync  2.0  remains undocumented.  This  is  of  high  importance  as  zkSync  2.0's  documentation  is  incomplete.  Furthermore, the emergency shutdown process remains undocumented.  Specification changed:  Natspec documentation was added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-zksync-dai-bridge/"}, {"title": "6.6   Remaining TODO in the Source Code", "body": "  There is a leftover TODO comment in the code of L1DAITokenBridge.    The TODO was removed.  MakerDAO - zkSync DAI Bridge -   13  DesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                                \f6.7   Unused enum  There is an unused QueueType enum in the file L1GovernanceRelay.sol.    MakerDAO has removed the unused enum.  MakerDAO - zkSync DAI Bridge -   14  DesignLowVersion1CodeCorrected        \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-zksync-dai-bridge/"}, {"title": "7.1   zksolc Not Up-To-Date", "body": "  The version of the compiler that currently used is 1.3.3, at the time of writing the latest compiler version is 1.3.5.  MakerDAO - zkSync DAI Bridge -   15  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-zksync-dai-bridge/"}, {"title": "8.1   Contract Address Aliasing Maps to", "body": " Non-Operational Addresses  The contract deployment processes are different on zkSync and Ethereum mainnet, this discrepancy has as an effect that two similar contracts deployed by the account will not have the same address on L1 and L2, even considering address aliasing.  The  L1DAITokenBridge  specifies  the  msg.sender  (or  it's  alias  for  smart  contracts)  as  the  refund recipient.  The contracts that plan to use the L1DAITokenBridge need to be able to access the refunded funds. While the refunded funds will be credited on L2, the L1 contracts should be able to call zkSync bridges to spend those funds.  MakerDAO - zkSync DAI Bridge -   16  NoteVersion6  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-zksync-dai-bridge/"}, {"title": "5.1   Redemption Blocked When No Rate Entry at", "body": " Maturity Exists  After  the  shutdown  of  the  ClaimFee  contract,  users  may  exchange  their  claim  balance  for  DAI  using cashClaim(),  if  it  has  a  maturity  after  the  closure  timestamp.  However,  this  requires  a  valid  entry  in ratio[ilk][maturity] which must be set manually for each ilk and maturity by the governance.  Since the function slice allows users to split their claim fee, many arbitrary maturity timestamps may exist.  If  the  user  still  holds  all  segments  up  to  the  maturity,  they  may  be  able  to  merge  them  using function merge(). However, these segments may not be available anymore: Individual segments may have  been  redeemed  already,  or  be  unavailable  to  the  user  as  they  have  been  transferred  using  the function moveClaim.  Overall, users may be blocked and unable to redeem their claim fee.  Risk accepted:  Deco accepts the risk that rate entries might be missing for maturity timestamps. They pledge to provide appropriate support to ensure all maturities have a valid ratio set in case of emergency shutdown.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "5.2   Gate1 Withdraw Timestamp", "body": "  MakerDAO - Claim Fee Maker -   10  DesignCorrectnessCriticalHighMediumRiskAcceptedLowAcknowledgedRiskAcceptedRiskAcceptedDesignMediumVersion1RiskAcceptedDesignLowVersion1Acknowledged                  \fIn the Gate1 constructor, the withdrawAfter timestamp is set. The only check made using this value is to see if it is in the past. Thus, not setting the value at all would save gas and yield the same results.  Acknowledged:  The additional storage write is a one-time cost during deployment.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "5.3   Leftover Claims", "body": "  ClaimFee.collect()  reimburses  the  stability  fee  accrued  between  the  issuance  and  collect timestamp. If the collect timestamp is not equal to the maturity, a new claim fee is issued from the collect timestamp to the maturity.  In  general,  it's  very  unlikely  that  a  valid  rate  is  stored  for  the  maturity  timestamp:  Apart  from  values manually inserted by the governance, rates stored through function snapshot() can only exist for valid block timestamps. The maturity of a claim fee could have been set months in advance upon issuance or the claim fee could have been sliced in various ways. Hence, most of the time, it's not possible to collect up to the maturity timestamp. This design will result in minting many small \"leftover\" claims.  Risk accepted:  There  will  be  standardized  maturity  timestamps,  e.g.the  first  day  of  the  month  at  12:00:00  UTC. Additionally, it is planned to run bots that regularly take snapshots to ensure that any leftover claims are sufficiently small to be negligible. Lastly, users will be warned against using functionality which creates non-standard maturity timestamps.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "5.4   Slice at Timestamp With No Rate", "body": "  The function slice allows users to split their claim at a certain timestamp. However, it is possible that the  timestamp  at  which  they  split  their  claim  does  not  have  a  valid  rate.  Unless  they  later  merge  their claims again, or the governance adds a valid rate for the split timestamp, it may not be possible for the user to redeem the full value of the claims.  Risk accepted:  As stated previously, it is intended to have standardized maturity timestamps so that users can know in advance  which  timestamps  will  have  valid  rates.  Using  such  timestamps,  users  are  able  to  split  their claims  without  incurring  any  losses.  Should  the  need  arise  there  are  two  pathways  to  mitigate  the situation: Governance may insert snapshots at timestamp or users can use activate() to activate a claim  fee  balance  at  a  timestamp  with  a  rate  set.  Note  that  yield  earned  between  issuance  and  the activation timestamp becomes uncollectable and is permanently lost.  MakerDAO - Claim Fee Maker -   11  DesignLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  Increasing VAT Debt After Shutdown, After thaw()   -Severity Findings   Comments Regarding vow.heal()    Governance Can Burn From Users    Gate1.heal()   totalSupply Mapping Not Updated   -Severity Findings   Address of VOW    Duplicate Check    Maturity in the Past    Unused Constants and Function    Various Event Issues   this Keyword in initializeIlk   0  1  4  6  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.1   Increasing VAT Debt After Shutdown, After ", "body": " thaw()  ClaimFee generates the required DAI by calling vat.suck() through the Gate1 contract which acts as a safeguard to enforce a limit on the maximum amount of DAI that can be generated by adding bad debt to the system.  vat.suck() is independent of the system status, notably whether the VAT is live or not. Hence, the call to  vat.suck()  will  add  more  bad  debt  and  generate  DAI  when  the  VAT  is  in  shutdown.  This  occurs even  after  end.thaw()  has  been  called  in  step  6  of  the  shutdown,  which  fixes  the  total  outstanding supply of DAI.  The Gate1 contract's purpose is to limit access of the ClaimFee contract in the core maker system: In order to draw bad debt using vat.suck() one needs to be a ward in the VAT to be able to pass the auth modifier. To avoid giving full privileges to the external ClaimFee contract, an intermediary contract Gate1 is introduced, which will be given the privileged role in the VAT. The code of the Gate1 contract enforces limitations in order to limit the risk for the core system. In its current state, the Gate1 contract is missing restrictions to prevent drawing more debt when the VAT is in shutdown.  For further reference:  MakerDAO - Claim Fee Maker -   12  CriticalHighCodeCorrectedMediumSpeci\ufb01cationChangedSpeci\ufb01cationChangedRiskAcceptedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedAcknowledgedCodeCorrectedDesignHighVersion1CodeCorrected               \fhttps://github.com/makerdao/dss/blob/master/src/end.sol#L410 https://docs.makerdao.com/smart-contract-modules/shutdown/end-detailed-documentation#6.-thaw https://github.com/makerdao/dss/blob/master/src/vat.sol#L230    A check for the condition VatAbstract(vat).live() == 1 was added to the accessSuck function in the ClaimFee contract. This prevents the debt from increasing after the VAT is in shutdown.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.2   Comments Regarding vow.heal()", "body": "  One of the annotations of the Gate1 contract reads:   does  not  execute  vow.heal  to  ensure  the  dai  draw  amount  from  vat.suck  is  lower  than  the  surplus buffer currently held in vow  There is the following comment in Gate1.accessSuck():  // call suck to transfer dai from vat to this gate contract try VatAbstract(vat).suck(address(vow), address(this), amount_) {     // optional: can call vow.heal(amount_) here to ensure     // surplus buffer has sufficient dai balance      // accessSuck success- successful vat.suck execution for requested amount     return true; } catch {   vow.heal() uses surplus DAI of the VOW (= surplus buffer) to repay bad debt of the VOW at the  VAT   vat.suck() generates DAI by creating bad debt assigned to the VOW  Vat.suck() simply adds bad debt, there is nothing ensuring the amount of DAI drawn is lower than the surplus buffer.  Specification changed:  The annotation and comments were removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.3   Governance Can Burn From Users", "body": "  The function ClaimFee.withdraw() allows the privileged ward role (the governance) to burn a claim of any user. However, the function's annotation contradicts this as it states the following:  /// Withdraws claim balance held by governance before maturity /// @dev Governance is allowed to burn the balance it owns  MakerDAO - Claim Fee Maker -   13  CorrectnessMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1Speci\ufb01cationChangedRiskAccepted                  \fFurthermore, this function can also withdraw/burn a claim balance upon/after maturity.  Risk accepted:  The annotation was changed to reflect the functionality. The risk of allowing the governance to burn any user's  balance  is  accepted,  as  they  plan  to  add  additional  contracts  with  functionalities  that  require burning claim fee balances.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.4   Gate1.heal()", "body": "  Gate1.heal() is annotated with:  // Access to vat.heal() can be used appropriately by an integration  It simply calls vat.heal():  function heal(uint rad) external {     VatAbstract(vat).heal(rad); }  Vat.heal() heals bad debt of msg.sender()  function heal(uint rad) external {     address u = msg.sender;     sin[u] = sub(sin[u], rad);     dai[u] = sub(dai[u], rad);     vice   = sub(vice,   rad);     debt   = sub(debt,   rad); }   The Gate1 contract however doesn't accrue bad debt when generating DAI: Gate1 only draws bad debt using vat.suck(address(vow), address(this), amount_). The bad debt is assigned to the VOW, only the generated DAI is assigned to the Gate1 contract:  function suck(address u, address v, uint rad) external auth {     sin[u] = add(sin[u], rad);     dai[v] = add(dai[v], rad);     vice   = add(vice,   rad);     debt   = add(debt,   rad); }  If  the  Gate1  contract  doesn't  accrue  bad  debt  outside  of  its  own  functionality,  the  function  has  no purpose.  Furthermore,  if  Gate1  does  indeed  accrue  bad  debt,  the  intended  backup  DAI  balance  may  be compromised by the fact that anyone could call heal() and use some of this DAI balance to heal the bad debt.  MakerDAO - Claim Fee Maker -   14  DesignMediumVersion1CodeCorrected        \f  The heal() function of the Gate1 contract was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.5   totalSupply Mapping Not Updated", "body": "  The ClaimFee contract has a totalSupply mapping which should track the total supply of claims per ilk. However, neither the mintClaim nor burnClaim functions update the mapping.    The totalSupply mapping is now updated accordingly in the mintClaim and burnClaim functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.6   Address of VOW", "body": "  In the Gate1 Contract, both the VOW and the VAT addresses are stored as immutables. In contrast, the ClaimFee  contract  stores  both  addresses  in  storage  without  implementing  functionality  to  update  the address.  As  reading  from  storage  is  expensive,  variables  set  only  during  deployment  may  be  changed  to immutables. During the deployment, all immutable values are inserted into the bytecode of the deployed contract code. Hence, they can be accessed during execution without the need for an expensive SLOAD operation.  that   there  are  ongoing  discussions   Note  to  use  a  proxy: https://github.com/makerdao/dss/pull/241  As  such,  it  may  be  necessary  to  have  a  mutable  storage variable for its address.  to  change   the  VOW     The VAT address was made immutable in the ClaimFee contract, and the VOW address was removed. Instead, the VOW address is dynamically queried from the Gate1 contract when necessary.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.7   Duplicate Check", "body": "  The function issue checks the following condition:  require(initializedIlks[ilk] == true, \"ilk/not-initialized\");  However,  the  mintClaim  function  checks  the  very  same  condition  and  hence  the  check  in  issue  is unnecessary.    The duplicate check was removed.  MakerDAO - Claim Fee Maker -   15  CorrectnessMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f6.8   Maturity in the Past  The function issue places the following requirement on the maturity timestamp:  require(         issuance <= latestRateTimestamp[ilk] && latestRateTimestamp[ilk] <= maturity,         \"timestamp/invalid\"     );  However,  there  is  no  guarantee  that  the  value  latestRateTimestamp[ilk]  is  recent.  As  it  makes little  sense  to  issue  a  claim  with  a  maturity  in  the  past,  one  could  instead  check  that  the  maturity  is later than the current block timestamp.    The issue function now ensures the condition block.timestamp <= maturity.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.9   Unused Constants and Function", "body": "  There are a few constants and a function that are unused or could otherwise be omitted.  1. The  MAX_UINT   constant   could  be   replaced  with   the  built-in  Solidity   constant:  type(uint256).max.  2. The constant RAD is never used.  3. The function wmul is never used.    The MAX_UINT constant was replaced as suggested; RAD and wmul were removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.10   Various Event Issues", "body": "  There are a few functions in which events should be emitted or the event parameters should be indexed.  1. In  the  ClaimFee  constructor,  no  Rely  event  is  emitted  when  the  message  sender  is  added  as  a  ward.  2. No event is emitted by the close function. This is an important change regarding the functionality  of the contract and hence should emit an event.  3. No event is emitted by the calculate function. Again, this is an important storage change which allows  users  to  cash  out.  Indexing  the  events  would  allow  users  to  search  for  specific  ilks  and maturities.  4. The Kiss and Diss events in the Gate1 contract are not indexed.  5. The NewApprovedTotal and Draw events in the Gate1 contract could have indexed amounts.  MakerDAO - Claim Fee Maker -   16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedAcknowledged                          \f  1. A Rely event emission was added to the ClaimFee constructor.  2. A Closed event was added and is now emitted by the close function.  3. A NewRatio event was added and is now emitted by the calculate function.  4. The address parameter in the Kiss and Diss events in the Gate1 contract are now indexed.  Acknowledged:  5. The  NewApprovedTotal  event  was   indexed accessSuckStatus parameter, but the amount parameter is not indexed as Deco did not see the need for it.  removed.  The  Draw  event  now  has  an   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.11   this Keyword in initializeIlk", "body": "  The initializeIlk function makes the following call to the snapshot function:  function initializeIlk(bytes32 ilk) public auth {     // ...     this.snapshot(ilk); // take a snapshot }  Calling  a  function  in  this  way  incurs  an  extra  cross-contract  call.  In  order  to  make  an  internal  call,  the snapshot  function  would  have  to  be  declared  public  instead  of  external  and  the  this  keyword removed.    In  initializeIlk() has been updated accordingly.  the  snapshot   functions  visibility  has  been  changed   to  public,   the  call   in  MakerDAO - Claim Fee Maker -   17  DesignLowVersion1CodeCorrectedVersion3          \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "7.1   Circumvent withdrawAfter Restriction", "body": "  Gate1  features  a  restriction  for  function  withdrawDai().  The  privileged  role  able  to  pass  the  auth modifier can only call withdrawDai() successfully when the withdrawal condition is satisfied:  bool withdrawalAllowed = (block.timestamp >= withdrawAfter);  The  privileged  role  able  to  pass  the  auth  modifier  can  always  add  any  address  as  a  bud  using  the function  kiss().  Such  an  account  can  then  pass  the  toll  modifier  and  successfully  call  suck()  / draw()  and  draw  DAI.  If  the  call  to  vat.suck()  is  unsuccessful  (e.g.  if  the  limit  has  already  been reached) this allows to withdraw the backup DAI balance of the contract.  Code partially corrected:  While  it  is  no  longer  possible  to  add  a  bud  when  the  withdrawal  condition  is  not  satisfied,  an  already existing bud would still be able to circumvent the restriction. For example, after the contract is created, a bud  could  be  added,  and  only  then  withdrawAfter  would  be  set  to  a  timestamp  in  the  future. Alternatively,  one  could  wait  for  withdrawAfter  to  be  in  the  past,  then  add  a  bud  and  set withdrawAfter  to  a  future  timestamp.  Therefore,  a  ward  is  still  able  to  withdraw  the  backup  DAI balance of the contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "7.2   Discrepancy Between Reimbursed Amount", "body": " and Actual Stability Fee  The  stability  fee  paid  in  in  the  Maker  system  is  based  on  the  rate  increase  between  when  taking  and repaying the debt.  ClaimFee reimburses the stability fee based on stored snapshots of the rate.  There are corner cases where the rate stored may not match the actual rate debt was taken/repaid for at this  timestamp  and  hence  the  reimbursed  amount  of  DAI  is  not  the  amount  of  stability  fee  paid  by  the user.  Storing  the  current  rate  in  ClaimFee  does  not  trigger  the  update  of  the  rate  in  the  Maker  system (jug.drip()).  A  later  transaction  in  the  very  same  block  may  trigger  jug.drip()  and  further transactions modifiying a debt position of this ilk use the new rate.  Consider the following scenarios which must happen within the same block:  1.   ClaimFee.snapshot() is executed and rate A is stored   Jug.drip() is executed -> The rate is udpated to A+x   The user repays debt in the Maker system at rate A+x  MakerDAO - Claim Fee Maker -   18  NoteVersion1CodePartiallyCorrectedNoteVersion1RiskAccepted          \fWhen the user calls collect() on his claim fee balance he is reimbursed based on the \"old\" rate stored and receives less DAI than actual stability fee paid.  2.   User takes debt in the Maker system at rate A   Jug.drip() is executed -> rate is udpated to A+x   ClaimFee.snapshot() is executed and rate A+x is stored  Similarly,  the  user  may  not  be  compensated  for  the  full  stability  fee  in  this  scenario.  Note  that normally, with the stability fee based on the rate/time, the user has an incentive to increase the rate first using jug.drip() before taking on debt. However, unaware users with the impression that claim fee covers their stability fee may not do this.  We assume that jug.drip() is executed frequently and the resulting rate increase is small enough so the discrepancies arising in scenarios as described above can be neglected.  Risk accepted:  The risk is accepted based on the assumption that the rate increases are small enough to be negligible.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "7.3   No Connection Between ClaimFee and Actual", "body": " Debt  There  is  no  connection  between  an  issued  claim  fee  and  debt  in  the  VAT.  ClaimFee  reimburses  the stability fee its amount (art) would have accrued.  Note that the amount of claim fees issued per ilk should not exceed the amount of actual debt per ilk otherwise more stability fee is reimbursed than is actually accrued by the system.  Deco responded:  \u2013 Our goal is to help the Maker protocol find users who want to hold a vault open for the entire term of the claim fee so that the protocol can derive the benefits of a sticky user and collect the fixed-rate revenue upfront without having to make any re-imbursements later to these users from the revenue generated by variable-rate vaults held by others. We want to ensure claim fee supply stays matched to the vaults who signed up for fixed-rate debt at the issuance date.  \u2013 ClaimFee has a transfer function which already allows a vault owner who has claim fee balance and no longer wants to use it to transfer it to another regular vault owner. This would keep claim fee balance less than ilk debt and not trigger the excess reimbursement issue.  \u2013  We  originally  planned  to  avoid  reimbursements  that  exceed  stability  fee  accrual  to  the  system  when debt level drops directly at the urn that was supposed to use the claim fee balance, by combining both the urn and claim fee balance and routing all its usage through a CDP Manager style contract which can create and manage a fixed-rate vault. This CDP Manager can have the required state transitions to keep both debt and claim fee balance of the vault in sync over its lifetime.  \u2013  We  now  plan  to  design  and  deploy  a  much  simpler  and  standalone  \u201cLiquidation  Penalty\u201d  contract instead  of  the  modified  CDP  Manager.  Liquidity  Penalty  contract  can  withdraw  an  amount  of  claim-fee balance  (burn  it)  held  by  a  user  address  to  match  any  reduction  in  debt  on  a  regular  vault  the  same address  holds.  We  don\u2019t  want  addresses  holding  claim  fee  balances  standalone  without  also  holding vaults of the collateral type between the issuance and maturity timestamps of the claim fee balance. This liquidation  penalty  contract  could  re-imburse  the  claim  fee  balance  after  taking  a  haircut  on  its  current  MakerDAO - Claim Fee Maker -   19  NoteVersion1    \fvalue(let\u2019s say 75%, make it attractive for fixed-rate vault owners to abandon their claim fee balance, but not  set  it  too  high  at  like  100%  to  ensure  no  reimbursement  but  force  claim  fee  holders  to  find  buyers among other vault owners to avoid loss of value) to ensure claim fee in circulation stays below the debt held in urn at all times, thereby also solving the issue at the ilk level.  MakerDAO - Claim Fee Maker -   20  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-claim-fee/"}, {"title": "6.1   Debt Recovery", "body": "  Debt recovery via single installment is not enforced. The Redeem stage of the PortfolioDebtToken can start with no assets inside the contract. In addition, the single redemption event is not guaranteed as well. These properties are hard to enforce, but users need to be aware of the potential issues.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-archblock-portfolio-debt-token/"}, {"title": "6.2   Gas Optimizations", "body": "  The  function  PortfolioDebtToken.status  does  two  storage  loads  (SLOAD)  upon  the  assertion assert(mintDeadline < redeemDeadline); followed by one or two more SLOAD in the if-else block.  The  same  result  can  be  achieved,  by  burning  less  gas,  and  by  loading  only  one  of  the  two variables in the assertion.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-archblock-portfolio-debt-token/"}, {"title": "6.3   Mint and Redeem Stage Durations", "body": "  the   checks  enforce   While  statuses (Mint->Redeem->Recover), the actual durations can be too short for the actions to be performed. In the extreme  case,  the  difference  between  mintDeadline  and  redeemDeadline  can  be  less  than  the difference between timestamps of two consecutive blocks.  sequence  of  PortfolioDebtToken   the  proper   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-archblock-portfolio-debt-token/"}, {"title": "6.4   Zero Value Events", "body": "  Even though the mint and deposit are disabled via the 0 max value setting, the 0 value deposits can still be performed by the users at any point. In the same way, the 0 value withdrawals and redeems can be performed not in redeem state of the PortfolioDebtToken. While such actions do not change the state of the contract, Deposit and Withdraw events will be still emitted.  Archblock & TrueFi - Portfolio Debt Token -   10  InformationalVersion1InformationalVersion1InformationalVersion1InformationalVersion1              \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-archblock-portfolio-debt-token/"}, {"title": "5.1   Precision Loss in rewardRate Calculation", "body": "  The  calculation  of  the  rewardRate  causes  a  potentially  harmful  loss  of  precision.  The  default rewardsDuration  denominator  (1  week  reward  duration)  loses  up  to  604800  wei  of  precision  every time notifyRewardAmount() is called, in the following calculation:  CS-MET-001  rewardRate = reward / rewardsDuration;  and  rewardRate = (reward + leftover) / rewardsDuration;  The amount lost due to rounding has been deposited in the contract, but the internal accounting loses track of it, rendering it unclaimable.  If  rewardsToken  is  a  token  with  a  high  value  per  wei,  the  loss  can  be  significant.  For  example,  if rewardsToken  is  USDC,  which  has  6  decimals,  the  loss  can  be  of  up  to  $  0.6048  every  time notifyRewardAmount() is called. If the token is WBTC, which has 8 decimals but much higher value per  wei,  is  computed.  Since notifyRewardAmount()  can  be  called  every  12  seconds  through  VestedRewardsDistribution,  the rounding amount can be lost up to 50400 times per week.  to  $  181  every   the  rewardRate   is  up   time   loss   the   For tokens with a higher number of decimals and a low value per wei, for example DAI or WETH, the loss is less significant. It amounts to a maximum of $ 0.00006 per week for WETH and $ 3e-18 per week for DAI. The maximum weekly loss can be calculated as follows:  weeklyLoss = rewardsDuration * tokenValuePerWei * blocksPerWeek  Risk accepted:  Maker states:  Maker - EndGame Toolkit -   10  DesignCriticalHighMediumLowRiskAcceptedDesignLowVersion1RiskAccepted         \fRisk accepted. We are aware of the issue with precision loss, however we wanted to avoid making changes to the original code as much as possible. The StakingRewards contract in this context will only ever handle tokens with 18 decimals (DAI, MKR, SubDAO tokens, NewStable \u2013 Dai equivalent, NewGov \u2013 MKR equivalent). If we take MKR as an example, its all-time high price was just short of 6,300 USD. Let\u2019s extrapolate its value imagining it could grow 100x for the duration of the staking rewards program. Using the formula you provided, we would have:  weeklyLoss  = rewardsDuration * tokenValuePerWei * blocksPerWeek             = 604800 * 50400 * (630000 * 10^(-18))             = 0.0192036096  Even in this extreme scenario, weekly losses would amount to less than 0.02 USD, which is acceptable for us.  Maker - EndGame Toolkit -   11  \f6   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-endgame-toolkit/"}, {"title": "6.1   Typo in Documentation", "body": "  In  the  NatSpec  for  the  VestedRewardsDistribution  contract  at  line  23  RewardsDistribution  is misspelled.  CS-MET-002  The typo has been corrected.  Maker - EndGame Toolkit -   12  InformationalVersion1  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-endgame-toolkit/"}, {"title": "7.1   Ability to Modify name & symbol", "body": "   introduces functionality for the priviledge role to update the token parameter name and symbol. Note that is unusual for ERC20 tokens and must be done with care. Some downstream applications or smart contracts may not be designed to accommodate such changes.  Consider these illustrative examples:   Upon deployment the name of Curve pools is set using the traded token names.   The  representative  token  deployed  by  third-party  bridges  to  other  chains  is  often  based  on  the  original token's name and symbol.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-endgame-toolkit/"}, {"title": "7.2   Rewards in StakingRewards Might Take", "body": " Longer to Vest Than Expected  Rewards added to StakingRewards could be expected to be payed out to stakers in rewardsDuration time,  which  is  initially  set  to  7  days.  However,  every  time  notifyRewardAmount()  is  called,  a  new rewardRate  the  next the  vesting  of  rewardDuration.  the  remaining  amount  over   is  computed  prolonging   As a simple example, assume we are distributing 1000 DAI over one week, then the rewardRate will be rewardRate  =  1000  *  10**18  /  rewardDuration.  If  after  3.5  days  have  passed  we  call notifyRewardAmount(), adding a 0 reward, the new rewardRate is computed as  rewardRate = (reward + leftover) / rewardsDuration;  which  will  amount  to  rewardRate  =  500  *  10**18  /  rewardDuration.  Moreover,  the from periodFinish  initialTime  + rewardDuration.  Overall,  the  reward  distribution  will  last  1.5  times  the  expected  duration,  with  the latter rewardDuration period having half the effective rewardRate as expected.  pushed  be  rewardDuration   by  initialTime   rewardDuration/2   rewardDuration,   moving   back   will   +   +   to   it   time   If we take this reasoning to the extreme, notifyRewardAmount() can be called every block, which will the  periodFinish  by  12  seconds,  and  reduce  every  the  reward  rate  by 1 - blockDuration/rewardDuration. This is because the new rewardRate will be the old reward minus the consumed reward.  increase   rewardRatet = (rewardt \u2212 1 \u2212 rewardRatet \u2212 1 * blockDuration)  rewardDuration  rewardt \u2212 1 \u2212 rewardt \u2212 1  RewardDuration * blockDuration rewardDuration  = = rewardt \u2212 1 rewardDuration * (1 \u2212 blockDuration rewardDuration ) = rewardRatet \u2212 1 * (1 \u2212 blockDuration  rewardDuration ) from   Over  by (1-blockDuration/rewardDuration)^n,  which  is  an  exponential  decay  for  the  rewardRate,  rewardRate  will   rewardRate   decrease   block   initial   the   the   n   Maker - EndGame Toolkit -   13  NoteVersion1Version2NoteVersion1      \fcorresponding  to  an  exponential  decay  of  the  remaining  reward.  The  reward  will  therefore  not  be distributed in a finite amount of time. Numerical simulations have showed that after 1 week 63% will have been distributed, after 2 weeks 86%, after 3 weeks 95%, after 4 weeks almost 99%.  In  practice,  anybody  can  trigger  notifyRewardAmount()  at  every  block  by  calling  the  distribute method  of  VestedRewardsDistribution,  the  cost  of  doing  so  in  terms  of  gas  is  likely  to  offset  any advantage that such an attacker can get from delaying in such a way the reward rate.  Calling distribute() every block will however not pass an amount of zero notifyRewardAmount(), but it will pass the reward per block vested in dssVest. In the steady state, when the dssVest has been supplying a constant stream of reward for a long time, even factoring in the exponential decay behavior, the rewardRate in StakingRewards will converge to the same constant rate as in dssVest.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-endgame-toolkit/"}, {"title": "7.3   Vesting Plan Must Be Restricted", "body": "  If a vesting plan of DSSVest is restricted, that means only the recipient of the rewards may claim them, no one else can trigger the distribution of the rewards.  For  the  correct  operation  of  VestedRewardsDistribution  it's  important  that  the  plan  is  restricted: VestedRewardsDistribution.distribute()  in amount  =  dssVest.unpaid(vestId);  only,  any  excess  balance  held  at  the  contract  is  not forwarded.  retrieved   forwards   amount   the   Maker - EndGame Toolkit -   14  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-endgame-toolkit/"}, {"title": "5.1   Allowances Enable Management of Both Base", "body": " Tokens and Collateral Assets  Users can give privileges to other accounts through the approve and allow functions. Both functions use the isAllowed mapping to store this information. Accounts for which isAllowed is set to true have full control over both the base tokens and the collateral assets of the user.  This is problematic for the following reasons:  It may not be clear to users who call the approve function (which is part of the ERC-20 interface) that this not only gives the spender access to their base tokens but also to their collateral assets. The function description does not specify this.   There is no means of giving partial privileges (i.e., access only to base tokens or only to collaterals)  to another account. This may force users to give unnecessary permissions to other accounts.   Given prior experiences with ERC-20 tokens, users might expect the approve function to allow the spender to transfer at most balanceOf tokens. However, this is not true here as an approval also allows  the  spender  to  borrow  funds.  As  a  result,  balanceOf  can  essentially  become  negative, which might not match the expectations of users or integrators.  Compound - Comet -   10  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedRiskAcceptedRiskAcceptedRiskAcceptedLowRiskAcceptedRiskAcceptedRiskAcceptedCorrectnessMediumVersion1RiskAccepted             \fTo  avoid  integration  issues  and  the  compromise  of  user  funds,  these  unexpected  behaviors  should  be clearly documented.  Risk accepted:  Compound has added dev notes documenting the special behaviour.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "5.2   Oracle Timestamps Not Checked", "body": "  The function getPrice does not verify that the round data received from Chainlink oracles is up-to-date. If there is any problem with the oracles that results in outdated pricing data being returned. As a result critical calculations for allowed borrowing and liquidations would become inaccurate. It might be possible to liquidate safe positions or take out under-collateralized borrows.  Risk accepted:  Compound  acknowledges  the  risk  and  notes  that  even  if  a  defense  against  a  lack  of  updates  was implemented,  the  ability  to  report  false  prices  make  the  price  oracles  a  primary  risk  vector  for  the protocol.  Moreover,  Compound  encourages  governance  to  invest  in  improvements  upon  the  oracle system, especially ones which can also reduce gas costs.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "5.3   approve Only Allows the Values 0 and MAX", "body": "  The  approve  function  only  allows  the  values  0  and  type(uint256).max  which  could  lead  to  the following complications:  1. All  approvals  are  infinite.  In  the  past,  infinite  approvals  given  to  buggy  contracts  have  been exploited (e.g., in the case of Multichain). The risk of this is increased when only infinite approvals can be given.  2. All  other  approvals  will  fail.  This  breaks  integration  with  existing  DeFi  protocols,  which  approve  exact values. Comet Tokens would be incompatible with such protocols.  Risk accepted:  Compound accepts the risk and refers to its documentation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "5.4   baseBorrowMin Is Not Enforced for", "body": " Destination of Transfer  Borrows  have  a  minimum  threshold,  called  baseBorrowMin  to  ensure  that  it  remains  worthwhile  to liquidate them. However, this minimum threshold does not always hold.  If Base Tokens are transferred to another address using transferBase and the sender has to borrow tokens,  the  call  reverts  if  the  amount  of  borrowed  tokens  does  not  exceed  the  baseBorrowMin threshold. However, if a user receives tokens such that his balance is still negative but now violates the baseBorrowMin threshold, the call does not revert.  Compound - Comet -   11  SecurityMediumVersion1RiskAcceptedDesignMediumVersion1RiskAcceptedCorrectnessMediumVersion1RiskAccepted                        \fAs  a  consequence,  an  attacker  could  intentionally  set  up  many  accounts  with  borrows  below  the threshold in order to avoid liquidation. However, setting up such accounts would also consume a lot of gas and hence is unlikely to be financially beneficial.  Risk accepted:  Compound accepts the risk with the following statement:  The intention behind baseBorrowMin is to disallow initiating new borrows for which liquidation would likely not be worthwhile relative to gas costs. The destination of a transfer can only end up with 'dust' if a debt is partially repaid by another account almost fully. Both new positions would still need to be fully  collateralized  according  to  the  borrow  collateral  factor.  If  some  kind  of  griefing  attack  were attempted, governance could declare such tiny borrows as liquidatable at any point, and potentially seize or sell all the collateral immediately.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "5.5   Balances Can Be Overflowed", "body": "  The  functions  presentValueSupply  and  presentValueBorrow  in  CometCore  allow  an  overflow due to unsafe casting to uint104. Consider the following scenario:   A user supplies type(int104).max Base Tokens to the protocol.   After some time, the baseSupplyIndex is equal to or greater than 2.   The user calls any of the functions that update their balance with 0 amount.   totalSupplyBase as well as the user's principal will be overflowed to a value smaller than the  current value.  If the base token uses the maximum of 18 decimals allowed in the protocol, around 10 trillion in principal balance  and  an  index  value  of  at  least  2  (otherwise  the  safe  cast  in  presentValue  will  kick  in)  are needed. This is practically infeasible for base tokens pegged to the USD. However, other base tokens (or USD-based  tokens  after  a  period  of  extreme  inflation)  can  bring  this  problem  into  the  realm  of possibilities.  Risk accepted:  Compound accepts the risk and extended the documentation to describe it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "5.6   Tracking Indices May Overflow on Large", "body": " Tracking Speed Values  The  state  variables  trackingSupplyIndex,  trackingBorrowIndex  as  well  as  each  user's baseTrackingIndex are of type uint64. The function accrueInternal updates these indices with the product of the passed seconds and baseTrackingSupplySpeed / baseTrackingBorrowSpeed divided  by  the  current  amount  of  totalSupplyBase  /  totalBorrowBase  (without  decimals). baseTrackingSupplySpeed / baseTrackingBorrowSpeed can be numbers with a decimal scale of up  to  15  which  will  result  in  an  overflow  after  a  non-negligible  time-frame  if  the  amount  of  supplied  / borrowed tokens is low and baseMinForRewards is set to a low value.  Compound - Comet -   12  CorrectnessLowVersion1RiskAcceptedCorrectnessLowVersion1RiskAccepted                \fSuppose trackingIndexScale, trackingSupplyIndex and trackingBorrowIndex are all set to 1e15  (e.g.  1  COMP  per  second).  The  safe  cast  to  uint64  in  accrueInternal  will  revert  after  only approximately 5 hours after the baseMinForRewards has been reached resulting in a denial-of-service for the whole contract. This time is multiplied by the amount of full tokens supplied.  Risk accepted:  Compound accepts this risk with the following statement:  The  overflow  behavior  depends  on  several  parameters  which  do  need  to  be  chosen  carefully  by governance.  However,  we  believe  these  values  can  be  chosen  safely  and  need  not  often,  if  ever, change. In the worst case, in which governance fails to set these safely, there would be a denial of service until resolved by governance. We believe this is an acceptable risk, given that the very worst case in which bad parameters are chosen still does not result in any loss of funds.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "5.7   targetReserves Limit in buyCollateral", "body": " Can Be Circumvented  The  targetReserves  value  describes  the  expected  value  of  the  protocol  reserves  expressed  in  the base  asset.  The  function  buyCollateral  reverts  if  the  current  protocol  reserves  are  higher  than targetReserves as it doesn't allow the purchase of Collateral assets in this case. However, if any of the  collateral  tokens  has  a  callback  as  part  of  transferFrom  (e.g.  ERC777),  then  this  check  can  be circumvented  with  a  reentrant  call  to  buyCollateral.  As  a  consequence,  more  collateral  can  be bought than intended by the protocol as the check is not correctly performed for the reentrant call.  Additionally,  even  without  a  reentrancy,  the  purchased  amount  might  far  exceed  the  value  of targetReserves. At the time of writing it was unclear whether this is intended in all cases.  Risk accepted:  Compound accepts the risk with the following statement:  The reserves target is a mechanism for governance to prevent the sale of collateral after a sufficient number  of  reserves  have  been  reached.  The  risk  that  collateral  assets  may  be  sold  and  increase reserves beyond the target amount, is not a risk to the protocol health, in fact generally the opposite, as  it  guarantees  a  larger  amount  of  reserves.  The  issue  is  that  it  could  prevent  the  protocol  from being as profitable as it might otherwise be in the event that assets are liquidated and sold and later become much more valuable (as has been the case previously for many crypto assets), but we are not concerned about that risk.  Compound - Comet -   13  SecurityLowVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Wrong Computation of Borrow Balance   -Severity Findings   No Handling of Ecrecover Return on Wrong Input    No Sanity Checks for liquidationFactor    CometInterface Not Implemented by the Contracts   -Severity Findings   Accrued Interest Not Accounted for in Balance Functions    Floating Pragma    Missing Constructor Sanity Checks    Missing Events    No Recovery of Accidental Token Transfers Possible    Possible Contract Size Reductions    Possible Gas Savings    Rounding Errors Between User Balances and Total Balances    Unused Custom Error   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.1   Wrong Computation of Borrow Balance", "body": "  function  borrowBalanceOf   The  baseBorrowIndex to compute the borrow balance:  inside   the  CometExt  uses  baseSupplyIndex   0  1  3  9  instead  of  function borrowBalanceOf(address account) external view returns (uint256) {     int104 principal = userBasic[account].principal;     return principal < 0 ? presentValueBorrow(baseSupplyIndex, unsigned104(-principal)) : 0;  As a consequence, the result is incorrect.    The borrowBalanceOf function now uses the correct index (i.e., baseBorrowIndex). In addition, unit tests  were  updated  to  catch  this  issue  by  using  a  different  value  for  baseSupplyIndex  and baseBorrowIndex.  Compound - Comet -   14  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected        \f6.2   No Handling of Ecrecover Return on Wrong Input  ecrecover returns 0 on error. This error value is not checked correctly within the allowBySig function. As a result anyone can call allowBySig with owner == 0 and thereby set approvals in the name of the  0-address.  Since  transfers  to  the  0-address  are  possible  in  the  contract,  falsely  sent  funds  to  this address could be recovered by an attacker.    The allowBySig function now reverts if the value returned by ecrecover is the 0-address.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.3   No Sanity Checks for liquidationFactor", "body": "  The  liquidationFactor  determines  the  liquidation  penalty  a  user  suffers  based  on  the  collateral asset. When setting the liquidationFactor in the function _getPackedAsset, it should be checked against  the  value  of  storeFrontPriceFactor.  The  storeFrontPriceFactor  describes  the discount  If liquidationFactor  >  storeFrontPriceFactor,  then  the  protocol  is  expected  to  lose  funds  on liquidations. Any user noticing this, could perform the following attack:  liquidated   collateral.   someone   protocol   when   gives   buys   the   Sandwich significant price updates which decrease any of the collateral prices or increase the base asset price using:   Supply a collateral and borrow the maximum   Absorb the account and liquidate  This would drain funds from the protocol. Hence, it should be ensured that this setting never exists.    liquidationFactor is now assured to be smaller than or equal to storeFrontPriceFactor.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.4   CometInterface Not Implemented by the", "body": " Contracts  The contracts Comet and CometExt contracts do not extend the CometInterface. This can lead to errors  during  development  and  integration  by  third  parties  as  the  interface  does  not  match  up  with  the implementations. One such error is that the contracts do not implement an accrue function even though it is defined in the CometInterface:  abstract contract CometInterface is CometCore, ERC20 {     ...     function accrue() virtual external;  Compound - Comet -   15  SecurityMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                        \f  CometInterface  was  split  into  CometMainInterface  and  CometExtInterface.  Comet  now implements CometMainInterface, and CometExt now implements CometExtInterface.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.5   Accrued Interest Not Accounted for in", "body": " Balance Functions  The  functions  balanceOf,  borrowBalanceOf  and  baseBalanceOf  do  not  accrue  interest  before returning  the  respective  balances.  This  can  result  in  unexpected  behavior.  Consider  the  following example:  1. A contract queries its borrowBalanceOf of asset A. The function returns X.  2. The contract supplies X of asset A, expecting to have paid back all its borrows. However, unless accrueInternal  has  by  chance  been  called  within  the  same  block,  there  will  be  a  remaining borrow balance.  This behavior needs to be explicitly specified, currently the function descriptions do not indicate this in any way:  /**  * @notice Query the current negative base balance of an account or zero  * @param account The account whose balance to query  * @return The present day base balance magnitude of the account, if negative  */    balanceOf,  borrowBalanceOf  and  baseBalanceOf  now  calculate  baseSupplyIndex / baseBorrowIndex before converting them to present values.  the  current  values  of  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.6   Floating Pragma", "body": "  Comet uses the floating pragma ^0.8.11. Contracts should be deployed with the compiler version and flags that were used during testing and auditing. Locking the pragma helps to ensure that contracts are not accidentally deployed using a different compiler version and help ensure a reproducible deployment.    Compiler version has been fixed to 0.8.13.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.7   Missing Constructor Sanity Checks", "body": "  The following sanity checks could potentially be added to the constructor:   Base Token decimals should be at least 6 to prevent accrualDescaleFactor from becoming 0.  Compound - Comet -   16  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f A  comment  for  baseMinForRewards  suggests  the  value  should  be  sufficiently  large  but  is  only  checked to be non-zero.   reserveRate  should  be  lower  or  equal  to  FACTOR_SCALE  to  prevent  reverting  on  underflow  in  getSupplyRate.   kink should be lower than or equal to FACTOR_SCALE.     Corrected: baseScale is assured to be greater than or equal to BASE_ACCRUAL_SCALE.   Risk accepted: Governance is trusted to choose the correct value for baseMinForRewards.   Corrected: kink is assured to be smaller than or equal to FACTOR_SCALE.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.8   Missing Events", "body": "  The following functions represent important state changes, for which an event might be helpful:   initializeStorage   pause   absorb   buyCollateral   withdrawReserves   allow   allowBySig  Additionally, if absorbing an account results in a loss of funds of reserves, because the collateral did not cover the borrow, an event could be emitted as well.    All  mentioned  functions  except  initializeStorage  and  buyCollateral  now  emit  events. Regarding the remaining events, Compound has issued the following statement:  Our view is that events should not be viewed as critical for tracking state changes, and that modern off-chain processors are capable of tracking all contract state transitions anyway.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.9   No Recovery of Accidental Token Transfers", "body": " Possible  In case an ERC-20 token other than the base tokens or collateral tokens is sent to the contract, then it cannot be recovered. Among other reasons, this might happen due to airdrops based on the base tokens or collateral tokens.    A new function approveThis has been introduced to allow the governance to approve any ERC20 token to any address.  Compound - Comet -   17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.10   Possible Contract Size Reductions  Instead  of  creating  an  empty  AssetConfig,  and  later  returning  (0,  0),  the  function _getPackedAsset could directly return (0, 0).   The  functions  isBorrowCollateralized,  getBorrowLiquidity,  isLiquidatable  and getLiquidationMargin share the same code with marginal modifications. The overlapping code could be factored out into new functions to save code size.   The baseScale variable is only needed internally and is derived from decimals and can thus be  defined as internal to reduce code size.   The   intialization  of  trackingSupplyIndex  and  trackingBorrowIndex   to  0   in   the  initializeStorage function can be omitted.     Corrected:  __getPackedAsset  now  directly  returns  (0,  0)  if  an  AssetConfig  element  is  empty.   Not  corrected:  Compound  claims  that  the  compiler  opimizations  already  account  for  a  sufficient getBorrowLiquidity,  isBorrowCollateralized,   contract  reduction  isLiquidatable and getLiquidationMargin.  size   in    Not corrected: Compound does not want to make an exception for one variable.   Corrected: trackingSupplyIndex and trackingBorrowIndex are no longer initialized to 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.11   Possible Gas Savings", "body": "   The  function  _getPackedAsset  calls  the  decimals  function  of  the  asset  ERC20  contract  and checks  if  it  equals  the  provided  decimals  variable  in  AssetConfig.  Since  the  external  call  to asset  is  done  anyways,  there  is  no  need  to  provide  the  decimals  in  the  config  and  perform  this check.   The  function  supplyCollateral  calls  getAddressInfoByAddress  and  updateAssetsIn  which calls getAddressInfoByAddress for the same address again.   The  function  absorbInternal  calls  isLiquidatable  and  then  proceeds  to  perform  a  very  similar computation (including the same calls to the price oracles) again.   The function isBorrowCollateralized is expected to be commonly called for contracts with a non-negative  base  balance,  e.g.,  for  address(this)  in  buyCollateral.  In  those  cases, isBorrowCollateralized can return true as soon as presentValue is non-negative. Then, the call to the price oracle can be skipped.     Not  corrected:  The  additional  decimals  value  in  the  supplied  config  is  used  as  sanity  check  to  determine if the caller actually knows the decimals of the asset being configured.   Corrected:  updateAssetsIn  now  takes  AssetInfo  as  argument  and  does  not  load  asset  infos  itself anymore.  Compound - Comet -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected               \f Not corrected: Compound claims that the compiler already optimizes the functions.   Corrected: isBorrowCollateralized now checks if the user's present value is greater than or  equal to zero before performing any calculations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.12   Rounding Errors Between User Balances and", "body": " Total Balances  Due  to  the  balance  calculation  with  indices  and  principal  values,  rounding  errors  can  introduce  an inconsistency between the user balances and the total balances. Consider the following scenario:   totalSupplyBase is 100.   baseSupplyIndex is 1.085 (without decimals).   A user now supplies 10 Base Tokens with the supply function.   totalSupplyBase gets updated to 108.   The user's principal gets updated to 9.  If the protocol holds no reserves, the last user to withdraw their balance from the contract might not be able to withdraw the full amount.    The calculation of totals was modified to address this issue: Indices are now no longer translated to their present values, updated and trasnlated back to their principal values. Instead, they are now updated with the delta of users' principal values.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "6.13   Unused Custom Error", "body": "  The Comet contract defines a BadAmount error that is never used.    Unused errors BadAmount in Comet and Unauthorized in CometExt have been removed.  Compound - Comet -   19  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "7.1   Event Reordering Possible", "body": "  doTransferIn  and  doTransferOut  are  always  called  before  events  are  emitted.  If  the  respective ERC20  tokens  that  are  called  implement  callbacks  to  the  sender  or  receiver,  events  could  possibly  be reordered due to reentrancy. While this is not problematic for the contract itself, this can introduce errors in third-party applications that make certain assumptions about the emitted events.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "7.2   Magic Numbers", "body": "  The  functions  _getPackedAsset  and  getAssetInfo  use  the  same  magic  numbers  for  packing  as well as descale and rescale factors:  uint256 word_a = (uint160(asset) << 0 |                   uint256(borrowCollateralFactor) << 160 |                   uint256(liquidateCollateralFactor) << 176 |                   uint256(liquidationFactor) << 192);  These numbers should be defined as constants to avoid errors during development.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "7.3   Potential Incentive to Withdraw Supply", "body": "  In certain circumstances, users might have an incentive to actually withdraw parts of their supplied base tokens. Consider the following scenario:   kink is set to 80%.   interestRateSlopeLow is set to 10%.   interestRateSlopeHigh is set to 300%.   interestRateBase is set to 5%   For simplification, reserveRate is set to 0.   User A has supplied 100 base tokens to the contract.   User B has borrowed 80 of those base tokens, resulting in 80% utilization.   User A currently receives 10.4 base tokens interest per year.   User A now withdraws 20 base tokens such that utilization becomes 100%   User  A  now  receives  58.4  base  tokens  interest  per  year,  even  though  they  have  reduced  their  balance.  Compound - Comet -   20  NoteVersion1NoteVersion1NoteVersion1          \fIf User A holds a significant stake in supplied base tokens, they might be incentivized to withdraw some of their supply for as long as the utilization is high enough so that they earn more than 10.4 base tokens per year. However, obviously such a scenario incentivizes others to supply liquidity or repay borrows, so that it is unlikely to last.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "7.4   Regular Use Expected", "body": "  For  the  sake  of  security,  the  protocol  assumes  that  each  contract  is  used  somewhat  regularly.  This  is required so that the function accrueInternal is called regularly. If there is no regular usage, e.g., if the contract is not called for a year, the following issue arises:  Collateral  that  normally  would  be  liquidatable  can  still  be  transferred  /  withdrawn.  This  is  because  the interest needs to be explicitly accrued to update the indexes. Transfers and withdrawals of collateral are allowed  without  explicit  accrual  and  hence  rely  on  recent  actions.  Theoretically,  this  can  lead  to under-collateralized  accounts,  but  given  typical  configurations,  this  would  take  years  of  inactivity.  The authors are aware of this requirement and added the following comment:  // Note: no accrue interest, BorrowCF < LiquidationCF covers small changes  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "7.5   Supported Tokens", "body": "  Not  all  ERC20  tokens  can  act  as  base  and  collateral  tokens  for  Comet  contracts.  In  particular,  the following tokens are not supported:   Tokens with more than 18 decimals   Tokens with less than 6 decimals, e.g., GUSD   Tokens with transfer fees   Tokens where the balance can change without a transfer, these include:  Interest bearing tokens that increase balances   Deflationary tokens that decrease balances   Rebasing tokens   Tokens with a missing return value on transfer or transferFrom (e.g., USDT)   Tokens that require certain receiver functions to be implemented in contracts, e.g., ERC223   Tokens with rapidly increasing/positively manipulatable prices (cannot be used as base token)   Tokens with rapidly decreasing/negatively manipulatable prices (cannot be used as collateral token)   Tokens  with  multiple  entry  points  for  which  more  than  one  entry  point  has  been  added  to  the  contract's collateral assets.  Additionally the following tokens can break the protocol depending on their use:   Tokens with blacklisting in case a Comet contract is blacklisted   Pausable tokens when paused   Upgradable tokens that later introduce one of the problematic features  Compound - Comet -   21  NoteVersion1NoteVersion1           \f7.6   The Fallback Function Is Payable  The fallback function of Comet is payable even though none of the functions of CometExt are payable. Hence, there is no reason for the fallback function to be payable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "7.7   Transfers to 0-Address Allowed", "body": "  The  functions  transferInternal  and  withdrawInternal  do  not  revert  on  transfers  to  the 0-address. As a consequence, the base asset and the collateral assets might accidentally be transferred to the 0-address.  Compound - Comet -   22  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-iii/"}, {"title": "5.1   Unexpected Staking of Tokens", "body": "  Since  the  spent  assets  are  not  validated  against  the  Balancer  v2  pool's  underlying  assets, lendAndStake() could stake LP tokens from the vault along with the newly generated ones.  Consider the following scenario  1. Vault holds 1 Balancer LP  2. Manager  triggers  lendAndStake  where  the  underlyings  of  the  Balancer  LP's  pool  and  Balancer  LP are specified as spent assets.  3. 1 more Balancer LP is generated.  4. The full balance (2) of Balancer LPs is staked.  In contrast, all unused spent assets during the lending part, are returned to the vault proxy. Hence, the adapter may not behave as expected.  Risk accepted:  Avantgarde Finance replied:  This actually seems like an unintended convenience (batches the staking of held LP tokens with buying + staking new LP tokens). It is going to be the case for many/most adapters that if the manager inputs an incorrect value, there could be unintended consequences or value loss (e.g., slippage). Especially since there is no reported path that leads to value loss here, we will leave as- is.  Avantgarde Finance - Sulu Extensions VII -   11  DesignCorrectnessCriticalHighMediumRiskAcceptedRiskAcceptedLowCorrectnessMediumVersion1RiskAccepted          \f5.2   Unhandled Stake Slashing on Kiln  When computing the managed assets of an external position on Kiln, the system assumes the position holds  validatorCount  *  32  ETH  +  address(this).balance,  thus  not  considering  any  stake slashing that may have occurred. This could lead to an over-evaluation of the position if the stake gets slashed on a validator.  Risk accepted:  Avantgarde Finance replied:  Rewards and slashing are not included in the current position valuation, as this requires external oracle monitoring of the consensus layer. The actual position value will deviate by some percent from the ideal value, which will generally tend to be more and more undervalued if we assume consensus rewards outweigh slashing in most cases. For now, managers will need to be aware of this, and if they require more precision, we can integrate a simple oracle to monitor the delta.  Avantgarde Finance - Sulu Extensions VII -   12  DesignMediumVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  lendAndStake() May Interact With Two Pools and Leave Tokens Behind   -Severity Findings   Event Emitted When Non-Existing Pool Is Removed    Missing Sanitization for _feeBps    Validation for Balancer Staking   0  0  1  3  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vii/"}, {"title": "6.1   lendAndStake() May Interact With Two", "body": " Pools and Leave Tokens Behind  lendAndStake() should mint LP tokens for a pool and stake them. However, it is possible that funds are deposited into one pool but another LP token is staked due to a potential mismatch between pool id and the staking token's LP token. Ultimately, the newly minted LP tokens are to be left in the adapter.  Consider the following scenario:  1. The vault holds LP token B.  2. A lend and stake action is started. The pool id is A, the staking token's underlying LP token is pool  with id B. The spent assets are the underlying tokens of pool id A and the LP token B.  3. Through the lending, LP token A is received.  4. If  the  adapter's  balance  of  LP  token  B  (spent  asset)  is  greater  than  its  balance  of  LP  token  A,  staking will be successful.  5. Only the spent assets are pushed back to the vault.  6. The minimum incoming checks can in the integration manager pass if the spent asset amount for  LP token B is greater than the minimum incoming amount.  Ultimately, funds can be lost.    pool   The  __parseAssetsForLendAndStake and __parseAssetsForUnstakeAndRedeem.  validated   against   staking   token's   now   the   is   underlying   BPT   in  Avantgarde Finance - Sulu Extensions VII -   13  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected           \f6.2   Event Emitted When Non-Existing Pool Is Removed  Function  BalancerV2StablePoolPriceFeed.removePool  emits  a  PoolRemoved  event  even  if  a pool  function BalancerV2StablePoolPriceFeed.removePoolFactories  emits  events  only  if  a  previously added factory is removed.  contrast,   added.   never   was   In     The check isSupportedAsset(pool) has been added to only allow the deletion, and emission of the associated event, of an existing pool.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vii/"}, {"title": "6.3   Missing Sanitization for _feeBps", "body": "  input   No  the ArbitraryTokenPhasedSharesWrapperLib.init.  One  could  deploy  with  feeBps  >  MAX_BPS intentionally or by mistake, which would block the redemption because local fees cannot be paid out.  sanitization   _feeBps   function   done   on   in   is     Input sanitization for the feeBps has been added. It must satisfy feeBps < MAX_BPS.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vii/"}, {"title": "6.4   Validation for Balancer Staking", "body": "  Both,  the  Balancer  native  staking  and  the  Aura  staking,  perform  validity  checks  on  the  staking  token when  parsing  the  assets  for  staking  or  unstaking  actions.  The  validation  ensures  that  the  LP  token matches the staking token. That is typically implemented as follows:  __validateBptForStakingToken(stakingToken, __getBptForStakingToken(stakingToken));  However,  __getBptForStakingToken(stakingToken)==__getBptForStakingToken(stakingToken) which is always true. Hence, the validation is redundant and increases gas consumption.  perform   check   that   the   will   that    The redundant checks have been removed. However, no validation of the staking addresses for Balancer native staking tokens has been added.  Avantgarde Finance - Sulu Extensions VII -   14  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vii/"}, {"title": "7.1   Unfair Distribution of Rebasing Tokens in", "body": " Shares Wrapper  In contrast to other system contracts, the shares wrapper for arbitrary deposit tokens does not support rebasing tokens.  For each deposit token wei deposited in the shares wrapper, one shares wrapper wei is minted to the depositor. If the deposit token is a rebasing token, that may lead to losses for early depositors in terms of rebase amounts.  Consider the following scenario:  1. Alice deposits 1 stETH and receives 1 stETH shares wrapper.  2. stETH rebases. The contract holds 2 stETH.  3. Bob deposits 1 stETH and receives 1 stETH shares wrapper.  4. Technically,  Alice  contributed  to  two  thirds  of  the  contracts  holdings  (2  stETH  out  of  3  stETH).  However, Bob and Alice both have claims to 50% of the contract's underlyings.  Ultimately, early-depositors could lose rebase amounts.  Avantgarde Finance - Sulu Extensions VII -   15  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vii/"}, {"title": "6.1   Locked Assets After Repay", "body": "  A manager could try to repay an amount bigger than what they owe to Aave. In such cases, the leftover amount will not be transferred back to the vault. Consider the following case:  1. A manager owes 100 DAI  2. The manager tries to repay 110 DAI  3. 110 DAI will be transferred from the vault to the external position  4. The  call  to  Aave  will  only  consume  100  DAI.  The  remaining  amount  will  remain  in  the  external  position    After the debt owed to Aave is repaid, the remaining balance of the repayment token is sent back to the vault proxy. Since the repayment token is an underlying and not an aToken, the transfer will not affect the health factor of the positions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-extensions-iii/"}, {"title": "6.2   Rebasing aToken Balance", "body": "  ATokens are rebasing tokens. This means that the balance an account holds changes in time and, thus, between the time a transaction is submitted and mined. In the current implementation, there is no way to remove  the  full  amount  of  the  collateral  by  querying  the  balance  the  external  position  holds  during  the execution of the transaction. This could result in dust remaining in the external position.  Avantgarde Finance - Extensions III -   11  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  By specifying the maximum integer as the amount, the full aToken balance will be withdrawn:  uint256 collateralBalance = ERC20(aTokens[i]).balanceOf(address(this));  if (amounts[i] == type(uint256).max) {     amounts[i] = collateralBalance; }  // If the full collateral of an asset is removed, it can be removed from collateral assets if (amounts[i] == collateralBalance) {     collateralAssets.removeStorageItem(aTokens[i]);     emit CollateralAssetRemoved(aTokens[i]); }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-extensions-iii/"}, {"title": "6.3   Redundant Call", "body": "  __addCollateralAsset  call  the  lending  pool  function  setUseReserveAsCollateral  which enables  an  asset  to  be  used  as  a  collateral.  However,  the  implementation  of  regular  transfers  will automatically  use  the  underlying  of  the  transferred  aToken  as  collateral  if  a  zero-balance  is  increased (see AToken code and lending pool\u2019s finalizeTransfer). Hence, the call may be redundant.    The call has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-extensions-iii/"}, {"title": "6.4   Sanity Check Missing", "body": "  compatible  with   An added collateral token is never sanitized. Assume a malicious manager to create an evil token which a  method is  UNDERLYING_ASSET_ADDRESS()  which  returns  a  token  used  by  Aave.  Since  this  token  is  never sanitized, it could be added as collateral since the call  the  AToken,   interface   exposes   the   i.e.   of   it   (lendingPoolAddress).setUserUseReserveAsCollateral(AaveAToken(aTokens[i]).UNDERLYING_ASSET_ADDRESS(), true);  will  succeed.  Adding  such  a  token,  however,  could  block  the  function  ControllerLib.calcGaV() which calculates the external position value. During the calculation, the managed assets are queried with getManagedAssets in order to be priced but no price feed for the evil token exists.    The AaveDebtPositionParser will now validate that the token added as collateral is a whitelisted token. Ultimately supported non-aTokens could be deposited. However, that does not block execution nor could it lock tokens.  Avantgarde Finance - Extensions III -   12  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-extensions-iii/"}, {"title": "7.1   Aave Paused", "body": "  The  lending  pool  of  Aave  could  be  paused  and,  hence,  actions  on  the  vault  will  not  be  possible  to execute. Ultimately, positions could be not modifiable, and funds could be stuck.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-extensions-iii/"}, {"title": "7.2   Sandwiching Transactions for Liquidation", "body": "  It is known that the behavior of the managers is monitored. However, we would like to point out that there are sequences of actions from which the manager can benefit. In particular, a malicious fund manager, who  sees  a  price  drop  in  the  Aave  oracle  of  a  collateral  asset,  could  create  a  malicious  sequence  of transactions  through  MEV  capabilities  to  borrow  with  user  funds  while  liquidating  the  position immediately. Consider the following sequence of transactions:  1. Move aDai to the Aave external position proxy and borrow WETH such that the health factor is 1.  2. The sandwiched oracle price changes: Dai price drops compared to WETH.  3. The fund manager liquidates the position and profits.  Avantgarde Finance - Extensions III -   13  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-extensions-iii/"}, {"title": "7.1   Incorrect Description of Dog.bark()", "body": "  After  the  intermediate  report  the  main  functions  of  Liquidations  2.0  have  been  annotated  with  their expected behavior taken from MIP45.  The description above Dog.bark() as well as the corresponding part in MIP45 are outdated: In order to address an other issue (Liquidation of Dusty Vaults), the behavior has been slightly altered.  Notably, the statement  // There is a precondition about `room` that needs // to be satisfied in order to create an auction: // room > 0 && room >= ilk.dust // otherwise the transaction fails  no longer applies in the updated code.  Specification changed:  The  code  comments  have  been  changed  and  now  explain  the  new  liquidation  behaviour  including  the preconditions.  Maker Foundation - Liquidations 2.0 - ChainSecurity  12  CriticalHighMediumSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion2Speci\ufb01cationChanged           \f7.2   Dirt Remains After Bad Auction  As  described  in  MIP45c4,  the  Hole/  ilk.hole  values  define  a  global  /  per-collateral  limit  of  the  total amount  of  DAI  needed  to  cover  the  summed  debt  and  liquidation  penalty  associated  with  all  active auctions.  The current debt is tracked by the global Dirt and the per collateral ilk.dirt variables.  Upon  auction  initiation,  the  tab,  the  new  debt  of  the  system  is  added  to  the  corresponding  variables. Upon  buying  from  an  auction,  the  owe  amount,  the  amount  of  debt  paid,  is  removed  from  the corresponding variables.  The expected behavior is only loosely covered in MIP45c8:  Lastly, various values are updated to record the changed state of the auction: the DAI needed to cover debt and fees for outstanding auctions, and outstanding auctions of the given collateral type, are reduced (via a callback to the liquidator contract) is reduced by owe, and the tab (DAI collection target) and lot (collateral for sale) of the auction are adjusted as well. If all collateral has been drained from an auction, all its data is cleared and it is removed from the active auctions list. If collateral remains, but the DAI collection target has been reached, the same is done and excess collateral is returned to the liquidated Vault.  As described in the specification above, the code only removes the received amount of DAI (owe) from the debt. This works as expected when the auction managed to cover the tab. In this case all debt added to the dirt during liquidation is removed. During exceptional circumstances however, the situation that an auction is unable to collect enough DAI to cover the tab despite selling all collateral may arise. In this scenario the auction terminates but the unrecovered debt amount remains in the dirt variables.  The expected behaviour in this scenario should be documented.  After such an auction, the value of Dirt will exceed the summed debt of all active auctions and it is no longer possible for the summed debt of all auctions to reach the limit defined by Hole.  If  this  happens  repeatedly,  e.g.  during  a  rapid  market  crash  the  accumulated  unaccounted  dirt  may severely  restricts  the  amount  of  active  auctions  possible.  Most  notably  this  will  impact  less  liquid collateral types with a comparatively low amount set for ilk.hole.    The code has been updated and now handles this case correctly: When an auction has sold all collateral (lot reduced to 0) the remaining tab is removed in addition to owe which is the aumount of DAI just collected:  // Removes Dai out for liquidation from accumulator dog_.digs(ilk, lot == 0 ? tab + owe : owe);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "7.3   Potential Reentrancy During Emergency", "body": " Shutdown  Maker Foundation - Liquidations 2.0 - ChainSecurity  13  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected              \fOnce the emergency shutdown mode has been entered, a reentrancy attack is possible. The reentrancy attack works as follows:  1. The attacker identifies an open auction to attack and the corresponding ilk. Note that this attack  can be repeated for different auctions.  2. The attacker ensures that the ilk has been caged inside the End contract. If not, the attacker can  enforce this by calling the cage function for the ilk in question.  3. The attacker calls take on the corresponding Clipper for the identified auction so that the auction  will be closed at the end.  4. The attacker specifies its contract as who for the callback.  5. The take function sends collateral to who.  6. As part of the callback the attacker calls the snip function of the End contract, which will call the  yank function of the Clipper.  7. The  snip  function  returns  the  collateral  and  the  debt  to  the  corresponding  vault  .  Hence,  the  collateral has been sent away twice at this point.  8. The  yank  function  signals  to  the  dog  that  the  auction  is  closed.  The  yank  function  deletes  the  auction and removes it from the active list.  9. After the return of the callback, the take function also signals to the dog that the auction is closed, also  deletes  it  and  finally  tries  to  remove  it  from  the  active  list.  At  this  point  it  removes  another auction from the active list.  The consequences are:   There are more active auctions than listed inside the active array.   Not  all  remaining  auctions  can  be  closed.  The  _remove  function  will  eventually  revert  once  the  active array is empty.   The  Dirt  values  of  the  Dog  is  incorrect.  Hence,  even  auctions  for  other  collaterals  could  revert  during yank or take as the corresponding calls to dog.digs will revert.   The Clipper does not hold sufficient collateral to serve all ongoing auctions.  Note that the exact consequences increase if the attack is performed multiple times.    The issue was addressed by adding the lock modifier to yank which prevents the reentrancy.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "7.4   Specification Mismatches", "body": "  There are multiple errors of different severity in the MIP45 specification. For each item we list the relevant part of the specification and the explanation of the error:   c7:  \"all  liquidations  disabled(2):  This  means  no  new  liquidations  (Clipper.kick),  no  takes  (Clipper.take), and no redos (Clipper.redo)\"  Reason:  While  this  is  correctly  implemented,  the  code  comment  is  a  bit  unclear  as  it  does  not specify that no kick invocations are allowed on level 2:  // Levels for circuit breaker // 0: no breaker // 1: no new kick()  Maker Foundation - Liquidations 2.0 - ChainSecurity  14  CorrectnessMediumVersion1Speci\ufb01cationChanged        \f// 2: no new redo() or take()   c8: \"If the auction reached the tail value, ... then the Clipper.take would revert if called\"  Reason:  This  description  of  the  tail  value  mismatches  with  its  description  in  c1:  \"Time  elapsed before auction reset\". Note that the source code follows c1:  function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {     price = calc.price(top, sub(block.timestamp, tic));     done  = (sub(block.timestamp, tic) > tail || rdiv(price, top) < cusp); }   c8: \"If the auction ... fell by cusp percent of top, then Clipper.take would revert if called, ...\"  Reason:  Discrepancy  with  c1  \"cusp  =  0.6  *  RAY  (60%  of  the  starting  price),  then  the  auction  will need to be reset when reaching just below the price of 720.\" c1 implies that the auction needs to be restarted once it falls by at least cusp percent, while c8 implies that it needs to be restarted when it falls by more than cusp percent.   c8: \"If the caller provided a bytestring with greater than zero length, an external call is made to the who  address,  assuming  it  exposes  a  function,  follow  Solidity  conventions,  with  the  following signature.\"  Reason: This is not entirely correct, as no call will be made if who is the Dog contract or the Vat contract.   c13: \"treats price at the current time as a function of the initial price of an auction and the time at  which it was initiated\".  Reason: The price is a function of the initial price and the duration since last redo.   c14: \"This process will repeat until all collateral has been sold or the whole debt has been collected\"  Reason: This is not true as the auction might also be completed through a call to the snip function.   c15:  \"The  Clipper.take  call  can  send  any  remaining  collateral  or  DAI  beyond  owe  to  a  cold  wallet  address inaccessible to the keeper.\"  Reason: This statement is slightly imprecise as the remaining collateral or DAI would be moved by the clipperCallee.   c16:  \"A  mutex  check  to  ensure  the  Clipper.take  function  is  not  already  being  invoked  from  clipperCallee.\"  Reason:.  The  mutex  check  prevents  reentrancy  into  Clipper.take/redo()  irregardless  of  the clipperCallee.   c17: \"calls dog.digs in order to increment its Hole and ilk.hole values by the remaining auction tab.\"  Reason: It is not Hole/hole that are modified but Dirt/dirt.   c18: \"function file(bytes32 what, uint256 data) external\"  Reason: data should be of the type address.   c18: function active() external view returns (uint256[]);  Reason: The automatically created getter active will requires numeric index as a parameter and returns a single uint256.   c26: \"urn.art * ilk.rate * ilk.chop ||\"  Reason: Missing operator for comparison.   c26:   In  equations   into  account  e.g., urn.art * ilk.rate * ilk.chop > room. However, this choice is not explicitly stated which creates mismatch with the implementation.  the  units  are  not   it  seems   taken   that   Maker Foundation - Liquidations 2.0 - ChainSecurity  15  \f c26: \"vault.art * ilk.rate <= room\"  Reason: Missing chop.   c27: \"if amt < lot && tab - (amt * abacus.price) < ilk.dust\"  Reason: Mismatch with code. The code says amt < lot && owe < tab.  Specification corrected:  The  specification  has  been  corrected  and  matches  the  code  behavior  apart  from  minor  diversions  that are irrelevant to general usage, e.g., internal restrictions on callback targets.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "7.5   Specification Mismatches Due to Final", "body": " Changes  The documentation still lists the function getId inside the Clipper contract. However this function was  of the code. Note that no functionality was removed as the active function can be removed in  used instead.  The  updust  function  was  newly  added  to  the  code  in    to  allow  a  caching  of  the  dust  value inside  the  Clipper,  see  Dust  Retrieval  Is  Relatively  Expensive  for  more  information.  The  updust function is not yet documented.  Specification changed:  The specification was adjusted accordingly to reflect the removal of the getId function and the addition of the updust function.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "7.6   Dust Retrieval Is Relatively Expensive", "body": "  Multiple clever gas optimizations have been performed by the developers. However, we note that a rather trivial looking line still contains major gas costs:  (,,,, uint256 dust) = vat.ilks(ilk);  This line retrieves the dust amount for the specific ilk. It occurs inside the Clipper functions take and redo. Inside the vat the following struct will be loaded:  struct Ilk {     uint256 Art;   // Total Normalised Debt     [wad]     uint256 rate;  // Accumulated Rates         [ray]     uint256 spot;  // Price with Safety Margin  [ray]     uint256 line;  // Debt Ceiling              [rad]     uint256 dust;  // Urn Debt Floor            [rad] }  Maker Foundation - Liquidations 2.0 - ChainSecurity  16  CorrectnessLowVersion3Speci\ufb01cationChangedVersion3Version3DesignLowVersion2CodeCorrected                \fHence, 5 SLOAD operations are necessary. After the activation of the upcoming Berlin hardfork this will cost 5 * 2,100 = 10,500 gas. However, in the current architecture there is no way to retrieve the dust value separately. Mirroring it inside the Clipper contract would reduce the costs significantly, but would introduce potential inconsistencies between the two values.    The code has been corrected. The dust value is cached inside the Clipper and can be kept consistent through a permissionless call to updust.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "7.7   Duplicate Functions in Clipper", "body": "  The  two  functions  getId  and  the  active  inside  the  Clipper  have  the  same  functionality.  Both functions take a list index as input and return the element of the active list at that index.  function getId(uint256 id) external view returns (uint256) {     return active[id];  Hence, it seems that the code size is unnecessarily increased.    The getId function was removed from the Clipper contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "7.8   Gas Inefficiency During Auction Removal", "body": "  When an auction is being removed from the Clipper, because it is finished or has been yanked, then the auction id will be removed from the active list. As part of this removal, the auction id is exchanged with the last auction id in the active list and the appropriate changes are made:  function _remove(uint256 id) internal {     uint256 _index   = sales[id].pos;     uint256 _move    = active[active.length - 1];     active[_index]   = _move;     sales[_move].pos = _index;  In case that the removed auction was already last in the list, which is not unlikely given that there is such a list for each collateral, two SSTORE and one SLOAD operation could have been skipped.  Code Corrected:  The code has been changed as follows:  function _remove(uint256 id) internal {     uint256 _move    = active[active.length - 1];     if (id != _move) {  Maker Foundation - Liquidations 2.0 - ChainSecurity  17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f        uint256 _index   = sales[id].pos;         active[_index]   = _move;         sales[_move].pos = _index;     }     active.pop();     delete sales[id]; }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "7.9   Liquidation of Dusty Vaults", "body": "  According to the protocol, the initiation of an auction will be reverted if the available room is less than the dust for the corresponding ilk. However, there might be the corner case where a dusty vault exists, e.g., after the dust amount for a particular ilk has been increased.  Dusty vaults can be blocked from liquidation even though there would be room for them. This is because of following check:  require(room > 0 && room >= dust, \"Dog/liquidation-limit-hit\");  Even  though  there  wouldn't  be  enough  room  for  dust,  there  would  still  be  enough  room  for  a  dusty auction. This state is temporary. Later, once even more room becomes available again, the dusty vault can be liquidated again.    Dusty vaults can now be liquidated. If there is room to liquidate the total art of the vault there are no further restrictions related to the dust to start the auction.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "7.10   room > 0 Check Can Be Omitted", "body": "  In dog.bark there is a check on whether the available room is positive. This check takes place in the following require statement:  require(room > 0 && room >= dust, \"Dog/liquidation-limit-hit\");  This check is only useful in the case where dust == 0 and room == 0, otherwise it holds trivially. In the  previously  mentioned  case,  however,  dart  ==  0  (since  dart  =  min(art,  0))  and (art - dart)*rate >= dust (since dust == 0).  Hence, dink = mul(ink, dart)/art == 0 and the following require statement reverts:  require(dink > 0, \"Dog/null-auction\");  Hence, the room > 0 sub-condition can be safely removed, which saves a small amount of gas during every execution.  Maker Foundation - Liquidations 2.0 - ChainSecurity  18  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fCode Corrected:  In  the  updated  implementation  the  logic  determining  whether  a  full  or  partial  liquidation  happens  has been changed in order to address another issue. The require statement listed above no longer exists and neither does an unnecessary > 0 check. Hence the issue has been resolved.  Maker Foundation - Liquidations 2.0 - ChainSecurity  19  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  contracts  in scope for this review are part of the Maker system which consists of many interacting contracts. Hence, the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead, they should raise awareness in order to improve the overall understanding for users and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "8.1   Blocked Calls From Clipper", "body": "  During the take function of the Clipper, an external call is executed. Certain call targets are blocked:  if (data.length > 0 && who != address(vat) && who != address(dog_)) {     ClipperCallee(who).clipperCall(msg.sender, owe, slice, data); }  As the Clipper has special privileges inside the vat and dog_ contracts, these contracts are blocked. However, additionally targets need to be blocked where the funds controlled by the Clipper could be moved  in  an  unauthorized  way.  A  good  example  is  the  GemJoin.exit  function.  This  function  could remove the stored collateral from the Clipper and send it to an attacker. Please note that this attack currently does not work as there is no collision between the signature hashes of   clipperCall(address,uint256,uint256,bytes) and   exit(address,uint256).  However, we note that for all future contracts added to the system it needs to be ensured that no such collisions exist or the call targets need to be blocked.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "8.2   Creation of Many Small Auctions", "body": "  As  discussed  in  the  MIP45,  incentive  farming  needs  to  be  avoided.  Besides  the  scenarios  that  are already described in the MIP45, another scenario is possible. This scenario comes into effect if either the capacity  for  one  collateral  or  the  overall  capacity  has  almost  reached  its  limit.  In  technical  terms  this means that the dirt is almost as large as the hole.  If, in this scenario, a large vault becomes unsafe, an attacker could create many small auctions out of it. The attacker would perform the following steps within a single transaction:  1. Create a small auction that fills up the capacity limit and receive the keeper incentive  2. Take a small amount (ideally dust) from another auction (note that given that the limit is reached,  there is likely a good auction available)  The  only  downside  for  the  attacker  compared  to  creating  a  big  auction  are  higher  gas  costs.  Note, however, that after EIP-2929 (in combination with EIP-2200) will come into effect the additional costs of performing step 2 multiple times will be significantly reduced, while the costs of repeated executions of step 1 will also be reduced.  Maker Foundation - Liquidations 2.0 - ChainSecurity  20  NoteVersion2NoteVersion1        \f8.3   Debt Queue Not Updated Automatically  The Vow contract manages a system debt queue called sin, not to be confused with the sin mapping inside the Vat contract. It is noteworthy that the debt queue is fully not synchronized with the liquidation system. In particular, the liquidation system makes new entries, but never resolves them.  This can have two possible effects:  1. The debt inside the system debt queue is released too quickly. In particular that means that auctions might still be ongoing for the released debt and hence some of the debt might still get covered. This can  occur  if  the  wait  value  inside  the  Vow  is  too  low  in  comparison  to  auction  durations.  As  a consequence it might be possible to trigger a debt auction even though there is no need for it.  2. The debt inside the system debt queue is released too slowly. In particular that means that auctions might have long finished and that the debt has already been repaid. This can occur if the wait value inside the Vow is too large in comparison with auction durations. As a consequence surplus auctions could be unnecessarily delayed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "8.4   Ethereum Is a Dark Forest", "body": "  Ethereum  is  a  Dark  Forest  describes  the  phenomena  of  bots  inspecting  the  pool  of  unmined transactions  and  front-running  profitable  transactions  with  their  own.  Although  the  exact  capabilities  of these bots are unknown, these bots are sophisticated.  Liquidations 2.0 relies on keepers to initiate liquidations of undercollateralized vaults. There is a certain cost overhead (e.g. running a software monitoring the blockchain) for keepers to detect undercollaterlized vaults.  Only  after  undercollateralized  vaults  have  been  identified,  they  can  be  liquidated  by  calling Dog.bark(). For their efforts, keepers are rewarded on-chain if tip and/or chip are set to non-zero values.  While  it  doesn't  matter  for  the  liquidation  system  when  bots  copy  and  front-run  these  transactions,  the honest  keepers  will  not  only  lose  their  anticipated  reward  for  the  liquidation,  but  also  lose  the  gas  fee paid. If this happens repeatedly, keepers may stop to identify & liquidate undercollateralize vaults as they can't make a profit. Once no keeper identifies and crafts transactions to liquidate vaults bots can't copy these transactions anymore - and hence in an extreme scenario no more liquidations happen.  Clipper.redo() is affected in a similar way, Clipper.take() may be affected partially, e.g. when there are flash-loans involved.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "8.5   Incentive Farming Might Be Possible Due to", "body": " Misconfiguration  As  mentioned  in  MIP45c19,  Incentive  Farming  is  a  risk  in  the  system.  However,  it  could  also  occur without  a  change  in  the  dust  value.  Note  that  there  is  no  mechanism  inside  the  smart  contracts  that prevents that a keeper's reward for kicking off an auction is bigger than the liquidation penalty which the system achieves. Hence, the governance needs to chose the corresponding parameters: chip, tip and chop very carefully as a misconfiguration allows a way to drain the system.  Maker Foundation - Liquidations 2.0 - ChainSecurity  21  NoteVersion1NoteVersion1NoteVersion1            \f8.6   Initialization and Deployment Requires Extra Care  As  with  any  smart  contract  care  needs  to  be  taken  during  deployment  and  initialization.  However,  for these contracts it is especially important as they:   will be integrated into an existing system   are not fully initialized during deployment  In particular the following steps need to be performed correctly:   Authorizations between the contracts need to be granted   All parameters need to be chosen. Not that some functionality will already be available with partially initialized  contracts,  e.g.  the  Clipper  contract  will  be  fully  functional  if  no  Vow  contract  has  been registered. However, all collected DAI will flow to the Zero address.  Initially given deployment authorizations need to be revoked   Authorizations for replaced contracts need to be revoked  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "8.7   Monotonicity of Price Functions", "body": "  The auction system is designed as \"Dutch style auction system, where auction prices generally start high and  drop  over  time\".  Note,  however  that  there  is  no  guarantee  in  the  system  that  prices  will  be monotonically decreasing. Apart from a redo which can trigger a price increase, the prices can also rise due to changed parameters of the corresponding Abacus contract.  As  an  example,  if  the  variable  tau  which  contains  the  \"Seconds  after  auction  start  when  the  price reaches zero\" is increased, ongoing auctions will see a price increase. Note, that users of the system can protect  themselves.  Auction  takers  can  specify  a  max  price  which  they  are  willing  to  pay  for  collateral. Then, they only stand to lose gas costs.  We  aim  to  educate  users  to  properly  use  the  max  value  even  though  there  is  a  seemingly  decreasing price.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "8.8   No Stability Fee During Auctions", "body": "  As  debt  accumulates  no  stability  fee  during  auctions,  it  needs  to  be  ensured  that  debt  doesn't  reside inside an auction for too long. In case the stability fee would be very high, the liquidation penalty would be  really  low,  and  the  auction  would  be  running  for  a  very  long  time,  the  stability  fee  lost  during  the auction time would exceed the liquidation penalty earned. In this hypothetical scenario a liquidation would be \"beneficial\" for a vault owner.  Note, however, that we deem this as highly unlikely as there is a general incentive to keep auctions short, which is also discussed in the MIP45. Even for the collateral with the currently highest stability fee (50%), the auction would have to take roughly 110 days to offset a regular liquidation penalty of 13%.  Maker Foundation - Liquidations 2.0 - ChainSecurity  22  NoteVersion1NoteVersion1NoteVersion1             \f8.9   Vat Debt Tracking Not Automatically Synchronized  At the beginning of an auction dog.bark() calls vat.grab() to reassign the collateral to the auction contract  and  the  debt  from  the  vault  to  the  system.  Hence,  both  vat.sin[vow]  and  vat.vice  are increased by dart times the collateral's rate. The sin mapping and vice are used to track the bad debt of the system inside the Vat contract.  However, these values are not updated after a successful auction. This is due to how the Maker system works: After a purchase in an auction, the DAI amount received is transferred to the vow. When the vow contract  has  a  surplus  amount  of  DAI,  anyone  may  call  vow.heal()  to  settle  the  debt  accrued  in vat.sin[vow]. Further functionality allows to handle debt or surplus auctions. Please note that the Vow and Vat contracts are not in scope of this review and are expected to work correctly.  Maker Foundation - Liquidations 2.0 - ChainSecurity  23  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-protocol-liquidations-2-0/"}, {"title": "5.1   Missing Event for poolCreator Update", "body": "  The functions that allow an update of the pool creator perform important state change without emitting an event.  Acknowledged:  MYSO  Finance  has  acknowledged  this  issue,  but  has  decided  to  keep  the  functions  as-is  due  to limitations on the code size.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "5.2   Gas Optimizations", "body": "  1. State  variables  r1,  r2,  liquidityBnd1,  liquidityBnd2,  and  minLoan  are  set  in  the constructor and are read-only afterwards, thus they can be declared as immutable to save gas.  2. In function removeLiquidity, the SLOAD to access totalLiquidity when emitting the event  could be avoided if memory variables are used.  3. In function borrow, the storage field totalLpShares is passed to updateAggregations. Even if  it  is  a  hot  address,  accessing  it  again  costs  100  gas,  a  memory  variable  would  be  more  MYSO Finance - Core Protocol V1 -   12  DesignCorrectnessCriticalHighMediumLowAcknowledgedCodePartiallyCorrectedAcknowledgedCodePartiallyCorrectedRiskAcceptedRiskAcceptedAcknowledgedAcknowledgedDesignLowVersion3AcknowledgedDesignLowVersion2CodePartiallyCorrectedAcknowledged                        \fefficient as MLOAD costs 3 gas. It is also the case for loanIdx in the borrow function and in the rollOver function.  4. rollOver  function  computes  _sendAmount  -  getLoanCcyTransferFee(_sendAmount)  multiple times. Storing the result in a memory variable will save gas.  5. In  function  updateAggregations,  repaymentUpdate  is  always  computed  but  is  only  needed  when _isRepay is true.  6. In   ,  the  constant  variable  treasury  was  changed  into  a  state  variable  poolCreator  which could be declared as immutable.  7. In   , function borrow performs an unnecessary SLOAD to get the loan index when emitting  the event Borrow.  Code partially corrected:  3. The storage variables totalLpShares and loandIdx are stored in memory variables.  4. The logic has been moved in function checkAndGetSendAmountAfterFees and the result of the  subtraction is cached.  Acknowledged  MYSO Finance replied:  We acknowledge that certain variables could be made immutable and also within functions a few cases where storing a repeatedly used variable as a memory variable would also save gas, but we were running against byte code limits and stack too deep errors, and instead of significantly refactoring, we decided against implementing many of the optimizations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "5.3   Force Other LPs to Sell Cheap Loans", "body": "  Liquidity providers have the guarantee that they receive a minimum interest (flat rate r2) from the repaid loans.  If  there  is  enough  demand  for  borrowing  from  a  pool,  the  interest  rate  goes  up  which  makes  it more attractive for LPs to provide liquidity into it. However, one can implicitly force LPs to lend tokens at a lower interest rate. To achieve that, an attacker needs to add liquidity into a pool and then borrow.  For example, if the available liquidity in a pool is between liquidityBnd1 and liquidityBnd2, the attacker  adds  enough  liquidity,  so  the  interest  rate  gets  lowered.  Taking  a  loan  immediately  after  this operation, the attacker consumes part of its liquidity and part of other LPs liquidity with a lower interest rate than the market rate. The attacker borrows enough tokens such that the interest rate is back to the one  before  the  attack  started.  This  way,  the  liquidity  added  by  the  attacker  is  not  exposed  to  lower interest rates, while other LPs effectively were forced to sell loans with low interest rates.  Code partially corrected:  MYSO Finance implemented two mitigation measures to reduce the likelihood of such attacks:  1. Smart contracts (or EOA) cannot add liquidity and borrow from the pool in the same transaction (or block), as functions addLiquidity and borrow track tx.origin. This complicates but Instead  of  using does  not  eliminate   the  attack  described  above.   risk  of   the   MYSO Finance - Core Protocol V1 -   13  Version2Version3DesignLowVersion1CodePartiallyCorrectedRiskAccepted          \fone single contract to atomically provide liquidity and borrow, an attacker would need to take the risk of carrying the attack non-atomically, or use flashbots, which require more work.  2. Increase  the  minimum  LP-ing  period  from  30sec  to  120sec  to  increase  the  exposure  of  the  attacker's liquidity to the same attack vector.  Risk accepted:  MYSO Finance is aware that the attack is inherent to the system's architecture and states that the two mitigation measures described above will reduce the likelihood of such attacks but not fully prevent them. Furthermore, the attack does not lower the interest rates below the flat rate of a pool (r2), hence LPs still earn a minimum yield.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "5.4   Optimizations at the Cost of Added", "body": " Complexity  The  function  updateLpArrays  considers  7  different  cases  when  an  LP  updates  its  position  and optimizes the storage usage by avoiding storing redundant data. This optimization of the storage comes with added complexity in the logic of the function updateLpArrays although the majority of cases (4 out of 7) are expected to happen rarely.  Risk accepted  The  client  accepts  the  risk  associated  with  the  code  complexity  to  optimize  storage  gas  costs  and  will consider refactoring the function in a future version of the codebase.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "5.5   Rollover Not Allowed in Certain Situations", "body": "  Function  rollOver  in  BasePool  reverts  if  a  borrower  renews  its  loan  and  the  new  loan  amount  is higher  than  the  repayment  of  the  previous  loan.  This  might  be  the  case  if  the  pool  has  more  available liquidity when rollover happens than when the loan was initially taken. The restriction is enforced in the following check:  if (loanAmount >= loanInfo.repayment) revert InvalidRollOver();  Acknowledged  MYSO Finance has decided to keep the code unchanged as this scenario is expected to happen rarely, and users still have an alternative to perform the same operation, as explained in their response:  For bytecode reasons we refrained from supporting this use case as it would require an additional if-else to distinguish between calling transferFrom (regular case where borrower pays to rollOver) and transfer (rare case where borrower receives a refund). The situation where a rollOver would lead to a refund is expected to occur - if at all - rather rarely, hence not supporting it isn\u2019t deemed a significant loss in functionality. Moreover, if necessary a borrower could also independently emulate a rollOver for this situation by atomically repaying and borrowing using a flashloan.  MYSO Finance - Core Protocol V1 -   14  DesignLowVersion1RiskAcceptedDesignLowVersion1Acknowledged                \f5.6   Unclaimed Tokens Remain Locked  Liquidity  providers  specify  the  loan  indices  for  their  claims  and  are  allowed  to  skip  loans  that  are  not sufficiently profitable. Once an LP skips a loan, it cannot claim it anymore. Hence, a pool continuously holds loan and collateral tokens amounts that cannot be claimed by LPs and are locked. The only way to recover  loan  token  funds  is  if  all  LPs  remove  their  liquidity  from  a  pool  (totalLpShares  ==  0)  and then  one  adds  liquidity  which  triggers  the  transfer  of  dust  to  the  treasury.  However,  there  is  no  way  to recover collateral amounts left in the pool from skipped claims.  Acknowledged  MYSO  Finance  acknowledges  the  issue  and  does  not  plan  on  adding  a  functionality  to  track  the unclaimed loans as it would increase significantly the gas costs. However, MYSO Finance will simplify the UI for claiming and promote aggregate claims to reduce the number of unclaimed loans.  MYSO Finance - Core Protocol V1 -   15  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  0  4  10  -Severity Findings  -Severity Findings  -Severity Findings   Mismatch of Implementation With Specification    Missing Loan Owner Sanity Check When Borrowing    Protocol Fee Computation Can Overflow    Total LP Shares Are Capped in Pools   -Severity Findings   Emission of ApprovalUpdate Event Can Be Tricked    Deletion of Timestamps From Mapping    Redundant Events Emitted    Disabled Optimizer   Inaccessible TREASURY Account   Insufficient Check for Minimal Loan Given Total LP Shares   Inverted NewSubPool Event Token Fields    Misleading ApprovalUpdate Event    Missing Precision of Pool Parameters    Non-indexed Events   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.1   Mismatch of Implementation With", "body": " Specification  The specifications of the borrow function state:  In this case the collateral is deducted from the 3rd party ``msg.sender`` address but the ``_onBehalfOf``  address receives the loan and is registered as the loan owner (including the ability to repay and reclaim the pledged collateral).  However,  the  function  takes  the  collateral  from  msg.sender  and  also  sends  the  loan  amount  to msg.sender in violation with the specifications:  IERC20Metadata(collCcyToken).safeTransferFrom(msg.sender, address(this), _sendAmount); ... IERC20Metadata(loanCcyToken).safeTransfer(msg.sender, loanAmount);  MYSO Finance - Core Protocol V1 -   16  CriticalHighMediumSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged           \fSpecification changed  The specification in section 'Calling Functions on Behalf' of the gitbook has been revised to reflect the code behavior:  In this case the collateral is deducted from msg.sender and msg.sender also receives the loan but the_onBehalfOf address is registered as the loan owner (including the ability to repay and reclaim the pledged collateral). This allows wrapping and unwrapping of tokens through a peripheral contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.2   Missing Loan Owner Sanity Check When", "body": " Borrowing  A borrower can take a loan on behalf of anyone without restriction and this can result in the loan never being repaid. If a borrower calls borrow with an _onBehalf address they do not control or is aware that it will be the owner of a loan, the loan will default since the borrower is not the loan owner and is probably not allowed to repay it. E.g., borrow is called with _onBehalf=address(0), then the loan will default for sure.  Code corrected  The function borrow has been updated to perform a sanity check that address _onBehalf is not set to addr(0)  by  mistake.  However,  the  caller  is  still  responsible  for  providing  a  correct  address  for _onBehalf which repays the loan if required.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.3   Protocol Fee Computation Can Overflow", "body": "  The  protocol  fee  computation  in  loanTerms  can  overflow  if  the  protocolFee  is  non-zero.  The multiplication in _protocolFee = uint128((_inAmountAfterFees * protocolFee) / BASE) is carried in uint128 and might overflow. Example is with protocolFee = 5 * 10**5 which is also the maximum allowed fee and _inAmountAfterFees=uint128(uint256(2**128) / uint256(5 *10**15))+1=68056473384187692692675  which  may  seem  to  be  a  lot  but  could  be  a  realistic amount for collateral tokens with 18 decimals and low value.  Code corrected  In the second version of the codebase, the variable protocolFee was renamed creatorFee and its type  was  changed  to  uint256  to  avoid  possible  overflows  in  the  computation  highlighted  in  the  issue above.  MYSO Finance - Core Protocol V1 -   17  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                  \f6.4   Total LP Shares Are Capped in Pools  The  function  _addLiquidity  performs  two  checks  to  guarantee  that  an  LP  will  get  non-zero  token amounts from a small loan, both on repay and default. The checks are implemented as follows:  if (     ((minLoan * BASE) / totalLpShares) * newLpShares == 0 ||     (((10**COLL_TOKEN_DECIMALS * minLoan) / maxLoanPerColl) * BASE) /         totalLpShares == 0 ) revert PotentiallyZeroRoundedFutureClaims();  The  first  condition  evaluates  to  true  whenever  totalLpShares  >  minLoan  *  BASE.  Since  both minLoan and Base are fixed for a pool, the totalLpShares is capped for a pool.  Similarly, the second condition evaluates to true whenever totalLpShares > ((10**COLL_TOKEN_ DECIMALS  *  minLoan)  /  maxLoanPerColl)  *  BASE)  sets  another  restriction  on  the  maximum totalLpShares.  Capping  the  totalLpShares  prevents  adding  liquidity  to  pools  that  are  attractive  to  users  and  have high activity.  Specification changed  The  specifications  have  changed  and  the  checks  described  above  have  been  removed,  hence  the unintended capping on total LP shares is not present anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.5   Emission of ApprovalUpdate Event Can Be", "body": " Tricked  There is no restriction on the parameter _packedApprovals of function setApprovals. One could set the 6th bit to 1 even if no approval is updated and the event will be emitted. Moreover, if bits higher than the 6th are set, they will be shown in the emitted event.    The input parameter _packedApprovals has been sanitized to consider only the 5 least significant bits.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.6   Deletion of Timestamps From Mapping", "body": "  The timestamp stored in lastAddOfTxOrigin are never deleted from the mapping although they are used  only  to  disallow  LPs  from  adding  liquidity  and  borrowing  in  the  same  block.  The  entries  of  this mapping can be deleted, e.g., when LP remove their liquidity, to get gas refunds.    MYSO Finance - Core Protocol V1 -   18  DesignMediumVersion1Speci\ufb01cationChangedDesignLowVersion3CodeCorrectedDesignLowVersion2CodeCorrected                      \fThe entry for an address in the mapping lastAddOfTxOrigin is deleted when liquidity is removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.7   Redundant Events Emitted", "body": "  The function setApproval iterates through all approval types and emits an event independently if an approval  status  is  updated  or  not.  Therefore,  even  if  only  one  approval  type  is  changed  for  an _approvee, five events will be emitted.  Code corrected  Function setApproval has been updated to emit the event when at least one of the approvals changes state.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.8   Disabled Optimizer", "body": "  In  hardhat.config.js  the  optimizer  is  not  explicitly  enabled  and  the  default  value  for  hardhat  is enabled: false. Enabling the optimizer may help to reduce gas cost.  Code corrected  The optimizer has been enabled and the runs are set to 1000.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.9   Inaccessible TREASURY Account", "body": "  TREASURY   The  to declared  0x1234567890000000000000000000000000000001  which  is  not  in  the  control  of  the  developers, hence  all  protocol  fees  collected  by  the  system  will  be  locked  forever.  MYSO  Finance  is  aware  of  this issue and will use a multisig account for the treasury on deployment.  constant   address   and   set   as   is   Code corrected  The constant variable TREASURY is replaced with the state variable poolCreator which is assigned to msg.sender in constructor.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.10   Insufficient Check for Minimal Loan Given", "body": " Total LP Shares  The second condition in the following code is supposed to check that repayment amount for a loan is big enough that all LPs can claim non-zero amounts if the loan is repaid given their share:  MYSO Finance - Core Protocol V1 -   19  DesignLowVersion2CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChanged                                \fif (     ... ||     ((repaymentAmount * BASE) / totalLpShares) == 0 ) revert ErroneousLoanTerms();  The  check  might  not  work  as  intended  for  loan  tokens  with  low  decimals,  e.g.,  USDC  (6  decimals),  as BASE  is  a  constant  with  value  10**18.  For  example,  if  repaymentAmount  is  10**7  (10  USDC)  and totalLpShares is 10**8 (2 LPs with 5 * 10**7 shares each) the check would still pass.  Specification changed  MYSO Finance has changed the specifications and decided to remove the check above as it effectively would increase the minimum loan amount over time as total LP shares increase.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.11   Inverted NewSubPool Event Token Fields", "body": "  The  NewSubPool  event  definition  in  IBasePool.sol  specifies  that  the  first  two  fields  are collCcyToken and loanCcyToken, but when the event is emitted in the constructor, the two fields are set to _loanCcyToken and _collCcyToken.  Code corrected  The definition of event NewSubPool in IBasePool is updated and the parameters are in line with the code that emits the event:  event NewSubPool(     address loanCcyToken,     address collCcyToken,     ... );  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.12   Misleading ApprovalUpdate Event", "body": "  The function setApprovals emits an event only when an approval type is set to true, even if it was previously the case, and nothing is emitted when an approval is unset. An example is: current approvals are  10101  and  the  updated  approvals  are  10100.  The  event  is  misleading  in  the  sense  that  it  will  be emitted for indices 0 and 2, which have not been updated, and no ApprovalUpdate event is emitted for the actual update of the index 4.  Code corrected  The event Approval is now emitted for every index with the status true or false and independently if it was changed from the previous state.  MYSO Finance - Core Protocol V1 -   20  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.13   Missing Precision of Pool Parameters  The  documentations  and  inline  specifications  do  not  describe  the  precision  of  the  pool  parameters.  To improve  the  readability  of  the  code  and  avoid  possible  mistakes,  the  decimals  used  for  all  pool parameters such as r1, r2, liquidityBnd1 and liquidityBnd2 should be stated clearly.  Code corrected  Inline  code  comments  were  added  for  the  variables  mentioned  above,  which  specify  the  precision  of expected values:  uint256 r1; // denominated in BASE and w.r.t. tenor (i.e., not annualized) uint256 r2; // denominated in BASE and w.r.t. tenor (i.e., not annualized) uint256 liquidityBnd1; // denominated in loanCcy decimals uint256 liquidityBnd2; // denominated in loanCcy decimals  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "6.14   Non-indexed Events", "body": "  No  parameters  are  indexed  in  the  events  of  contracts  BasePool.  It  is  recommended  to  index  the relevant event parameters to allow integrators and dApps to quickly search for these and simplify UIs.  Code corrected  MYSO  Finance  has  evaluated  the  events  used  in  BasePool  and  has  indexed  parameters  that  they deem useful for future UI and dashboard integrations.  Several events such as NewSubPool and Approval have non-indexed parameters, however, the client intentionally kept them unchanged.  MYSO Finance - Core Protocol V1 -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.1   LP Shares Dilute Over Time", "body": "  The shares of an LP dilute over time as more activity happens in a pool by users that borrow and LPs that add more liquidity. Therefore, LPs should monitor their proportion of LP shares to the total LP shares and  remove  their  liquidity  from  a  pool  when  their  share  to  loan  repayments  or  collateral  becomes insignificant.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.2   LPs Get Slightly Less Token for Their Shares", "body": "  The pool keeps a minimum of loan tokens and it does not allow LPs to fully empty a pool. When removing liquidity, LPs get slightly less tokens than their fair share to maintain the minimum liquidity in the pool. The relevant code is:  uint256 liquidityRemoved = (numShares *     (_totalLiquidity - MIN_LIQUIDITY)) / _totalLpShares;  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.3   LPs Should Be Careful When Claiming", "body": "  function  claim  or LPs  can  claim  repayments  and  collateral  claimFromAggregated.  It  is  important  to  note  that  LPs  are  responsible  for  claiming  loans  always  in order. Otherwise, any loan skipped during a claim is impossible to be claimed in the future.  their  share  of   tokens  via   Furthermore,  LPs  can  skip  all  loans  during  a  time  window  via  the  function  overrideSharePointer. Similarly,  if  an  LP  calls  this  function,  they  cannot  claim  anymore  the  repayments  and  collateral  for  all loans linked with the skipped shares.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.4   Limitations on Claiming Batch of Loans", "body": "  Both functions claim and claimFromAggregated allow LPs to claim loans in batches over a period during  which  the  LP  has  not  changed  its  shares  in  a  pool.  LPs  should  be  aware  that  modifying  their position in a pool by topping up or removing liquidity, will require them to perform multiple transactions for the claiming which increases gas costs and potentially prevents LPs from using aggregate claims.  MYSO Finance - Core Protocol V1 -   22  NoteVersion2NoteVersion1NoteVersion1NoteVersion1                \f7.5   Locked Tokens  ERC20 tokens could be accidentally/intentionally sent to the pool contracts. In that case the tokens will be  Incidents (https://coincentral.com/erc223-proposed-erc20-upgrade/) in the past showed this is a real issue as there always will be users sending tokens to the token contract.  recover   locked,   them.   with   way   no   to   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.6   Minimum Loan Amount Allowed", "body": "  The constructor of BasePool does not enforce any restriction on the minimum allowed amount for loans. Therefore, the pool deployer should carefully set this value depending on the specific token used as loan token.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.7   Positions in a Pool Are Non Transferrable", "body": "  All positions in pools held by liquidity providers or borrowers are tracked in the contract BasePool and they  are  non-transferable.  Users  can  approve  other  addresses  to  act  on  their  behalf,  but  there  is  no support for transferring ownership of positions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.8   Possible to Overpay Loans", "body": "  Functions  repay  and  rollOver  check  that  the  user  always  pays  at  least  the  due  amount.  However, both  functions  allow  users  to  overpay  their  loans  by  1%  in  case  users  cannot  precisely  calculate  the sending amount for tokens with transfer fees.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.9   Profits of a Pool Are Not Equally Distributed", "body": "  The  profits  of  a  pool  from  loan  repayments  are  not  equally  distributed  among  liquidity  providers.  The system  is  designed  such  that  profits  for  an  LP  depend  on  loans  that  borrow  most  of  their  liquidity.  For example, if a pool starts with an interest i and over time the interest rate goes to 3 x i, initial LPs will earn payments from loans with interest i, while LPs joining later will have higher profits (as the interest rate tripled to 3 x i).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "7.10   Transfer Fee for Upgradable Tokens", "body": "  function  getLoanCcyTransferFee   The  is hard-coded to return 0 as fee for the loan token, namely USDC. We would like to highlight that the pools would not work as expected if upgradable tokens were to introduce fees in new implementations.  in  contracts  PoolPaxgUsdc  and  PoolWethUsdc   MYSO Finance - Core Protocol V1 -   23  NoteVersion1NoteVersion2NoteVersion1NoteVersion1NoteVersion1NoteVersion1                      \f7.11   if Blocks Without Curly Braces  It  is  generally  good  practice  to  enclose  every  if/else  block  into  curly  braces.  It  increases  code readability  and  lowers  possibilities  for  bugs  like  the  famous  goto  fail;  bug  in  Apple  SSL  code https://blog.codecentric.de/en/2014/02/curly-braces/.  MYSO Finance - Core Protocol V1 -   24  NoteVersion1    \f8   Monitoring  A thorough code audit is just one important part of a comprehensive smart contract security framework.  Next  to  proper  documentation/specification,  extensive  testing  and  auditing  pre-deployment,  security monitoring  of  live  contracts  can  add  an  additional  layer  of  security.  Contracts  can  be  monitored  for suspicious  behaviors  or  system  states  and  trigger  alerts  to  warn  about  potential  ongoing  or  upcoming exploits.  Consider  setting  up  monitoring  of  contracts  post-deployment.  Some  examples  (non-exhaustive)  of common risks worth monitoring are:  1. Assumptions made during protocol design and development.  2. Protocol-specific invariants not addressed/mitigated at the code level.  3. The state of critical variables  4. Known risks that have been identified but are considered acceptable.  5. External  contracts,  including  assets  your  system  supports  or  relies  on,  that  may  change  without  your knowledge.  6. Downstream  and  upstream  risks  -  third-party  contracts  you  have  direct  exposure  to  (e.g.  a  third  party liquidity pool that gets exploited).  7. Privileged functionality that may be able to change a protocol in a significant way (e.g. upgrade the  protocol). This also applies to on-chain governance.  8. Protocols  relying  on  oracles  may  be  exposed  to  risks  associated  with  oracle  manipulation  or  staleness.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "8.1   Project-specific monitoring opportunities", "body": " We have identified some areas in Core Protocol V1 that would be well suited for security monitoring.  We classify these into two categories: invariants and suspicious changes. If an invariant of the system doesn't  hold  anymore,  there  has  been  unexpected  behavior  requiring  immediate  investigation.  If  a change of a suspicious condition has been observed, something has happened which could change the behavior of the system and requires timely investigation to ensure the continued safety.  The following monitoring opportunities have been identified:  suspicious   Identified  and getLoanCcyTransferFee are hardcoded to return a transfer fee of 0 for tokens that currently do not have  such  fees.  However,  for  upgradable  tokens  such  as  USDC,  this  could  change  in  new implementations, hence this change can be monitored and trigger an alert if fees ever change.  getCollCcyTransferFee   functions   change:   The   Identified suspicious change: All pools have a finite number of cycles for borrowing and adding liquidity until a potential overflow on the total LP shares may happen. Therefore, the value of totalLpShares can be monitored and trigger an alert if it becomes large enough to overflow, e.g., larger than 2**240, so a new pool can be deployed.  MYSO Finance - Core Protocol V1 -   25  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/myso-finance-core-v1/"}, {"title": "5.1   Distributing Multiple Times Is Possible Even", "body": " in the Same Block  The documentation specifies that the next distribution must be 7 days away from the last distribution. However, this is not necessarily the case. Consider the following example:  1. lastDistribute is block.timestamp - 2 weeks - 1  2. preDistribute() is called. lastDistribute is now block.timestamp - 1 weeks - 1  ISSUEIDPREFIX-001  3. Optionally, distribute() is called.  4. preDistribute() is called. lastDistribute is now block.timestamp - 1  5. Optionally, distribute() is called.  That may occur if the initial lastDistribute value is low (lack of sanity check in the constructor) or if the distribution is not called regularly. Ultimately, the specification is violated.  Further, the behaviour in such cases is unspecified.  Acknowledged:  USDFI has acknowledged this issue stating that:  Emergency option to resync time in case of epoch desync (ie, force majeur event)  USDFI - AMM, Gauges and Bribes -   11  DesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedRiskAcceptedRiskAcceptedCorrectnessLowVersion1Acknowledged            \f5.2   Lost Rewards  The  reward  rate  in  gauges  is  typically  computed  as  reward  /  DURATION.  If  reward  <  DURATION holds, the reward rate will be 0. Ultimately, the rewards are lost as they will not be accounted in in the future.  ISSUEIDPREFIX-002  Acknowledged:  USDFI replied  Rewards must be lost to prevent griefing attacks that can occur due to non-shareable numbers!  However, it could be possible to cache the non-distributable rewards so that they could be accounted for in the future.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "5.3   Poking May Revert", "body": "  Poking  can  revert  when  _prevWeight  *  _weight  <  _prevUsedWeight  holds.  That  may  be  the case  when  the  user  had  a  big  decrease  in  balance.  Another  scenario  could  be  when  the  user  had specified a small amount of weight allocated to a gauge (e.g. 1, balance decrease from 100 to 99). The revert occurs in the bribe where _deposit() and _withdraw() revert with zero amounts.  Ultimately, a user may not be poked anymore, which could lead to reverts in the gauge's updateReward modifier. However, the issue may be repaired by using vote() or reset().  ISSUEIDPREFIX-003  Risk accepted:  USDFI states:  Smaller amounts are not allowed by the voter, because of the linear drop no fast drops are possible (poking  reversion  is  completely  ruled  out  by  the  vote  escrow  function  in  the  vote  escrow  contract (outside of audit scope)).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "5.4   burn() Read-Only Reentrancy", "body": "  The  burn()  function  in  the  pair  contract  first  reduces  the  total  supply  and  the  user's  balance,  then transfers  the  underlying  tokens,  and  last  reduces  the  stored  reserves.  If  the  transferred  token  is  a reentrant token, a state inconsistency between the supply and the stored reserves is created.  Note that any computation based on the current supply and the underlying reserves may return wrong results.  ISSUEIDPREFIX-004  Risk accepted:  USDFI has accepted the risk to keep their implementation closer to Uniswap V2.  USDFI - AMM, Gauges and Bribes -   12  DesignLowVersion1AcknowledgedDesignLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                      \fUSDFI - AMM, Gauges and Bribes -   13    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Contracts Do Not Extend the Interfaces    DOS on Gauges When Derived Supply Is 0    ERC-2612 Violations    Lack of Testing   -Severity Findings   Different Library Versions    Fees Claimable After 50 Weeks   Initial Referral Fee    Lack of Events    Maximum Referral Fee    Used Weights Are Not Reset    recoverERC20() Allows Recovering Arbitrary Tokens   0  0  4  7  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.1   Contracts Do Not Extend the Interfaces", "body": "  Most  of  the  contracts  interact  with  each  other  based  on  the  interface  definitions.  For  example, GaugeFactory  relies  on  IBribe  to  handle  the  calls.  However  the  Bribe  contract  itself  does  not explicitly implement the IBribe interface (addReward is missing).  ISSUEIDPREFIX-012  The following is an incomplete list of further examples:   BaseV1Pair does not implement IBasePair   BaseV1Factory does not implement IBaseV1Factory   GaugeFactory does not implement IGaugeFactory   Similarly, this is true for other contracts.  Without typing, there are no compile-time guarantees that the contract will be compatible with the calls to the functions that the interface defines. This can lead to potential runtime errors and exceptions that are hard  to  debug.  It  is  important  to  explicitly  define  that  the  contracts  implement  the  corresponding interfaces, to minimize such errors.  USDFI - AMM, Gauges and Bribes -   14  CriticalHighMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrected         \f  The contracts are implementing now the corresponding interfaces.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.2   DOS on Gauges When Derived Supply Is 0", "body": "  The subtraction  (rewardPerToken() - userRewardPerTokenPaid[account])  ISSUEIDPREFIX-008  in earned() implies that the rewardPerToken() function should be an increasing function. Otherwise, the subtraction will revert. However, its value could decrease when the derived supply goes to zero.  Consider the following scenario:  1. Assume a user for whom userRewardPerTokenPaid[userA] > 0 holds. The derived supply is  0. The reward per token is 0.  2. A deposit to address 0 is made by an attacker with 1 wei. rewardPerTokenStored is set to 0.  3. User A wants to deposit again. The subtraction above reverts.  Note that a scenario for step 2 could occur when user A gets poked first so that his weight changes to 0 (and the total weight too). Then he could get kicked as his derived balance is 0. Ultimately, he will not be able to receive any rewards anymore.  Ultimately, user A will not be able to perform any actions on the gauge anymore.    Code  returns  0  if  derivedSupply  ==  0.  Hence,  the  aforementioned  scenario  cannot  revert earned().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.3   ERC-2612 Violations", "body": "  The permit() functionality is defined in ERC-2612 which is based on ERC-712. Note that there are two violations of the standards:  1. The PERMIT_TYPEHASH violates EIP-712 which describes the typehash to be the keccak256 of the  encoded struct. However, its value does not match the hash.  2. The lack of an external DOMAIN_SEPARATOR() function violates the ERC-2612 standard.  ISSUEIDPREFIX-017  Ultimately, the implemented standard is violated.    The code has been corrected.  USDFI - AMM, Gauges and Bribes -   15  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                  \f6.4   Lack of Testing  The codebase does not include any tests. Note that it is highly recommended to properly test intended and unintended behaviour with unit and end-to-end tests. These tests help can build an understanding of undocumented functionality.  ISSUEIDPREFIX-014    USDFI  has  implemented  a  testing  infrastructure  using  Hardhat.  Please  note  that  tests  are  considered out-of-scope. Hence, their correctness and/or coverage are not reviewed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.5   Different Library Versions", "body": "  The  libraries  have  different  versions.  For  example,  the  Audit/gauge_factory/Address.sol  and Audit/bribe_factory/Address.sol files have different versions.  ISSUEIDPREFIX-011    The issue has been addressed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.6   Fees Claimable After 50 Weeks", "body": "  The documentation specifies that fees are not claimable after 50 weeks. However, the code implements this differently.  Consider, the scenario where userTimestamp is 100 weeks ago. Then, the iteration in earned() will start at the userTimestamp and iterate for 50 weeks. Afterwards, the userTimestamp is updated to the current epoch. Hence, it forfeits the new rewards.  ISSUEIDPREFIX-018  Specification changed:  USDFI has decided to change his documentation, claiming that:  We believe that it's not logical to assume that a user actively votes in the protocol\u2019s governance, but does not claim his rewards for 50 consecutive weeks which are visibly on display every time he votes using the frontend.  Note  that  during  the  fix  window,  we  have  not  received  any  formal  documentation  (rather  than  code comments) from the USDFI to validate this specification has been changed.  USDFI - AMM, Gauges and Bribes -   16  DesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                        \f6.7   Initial Referral Fee  The documentation specifies that the default base referral fee shall be 2%. However, it is 0%.  ISSUEIDPREFIX-016  Code Corrected:  USDFI has correctly hardcoded baseReferralFee to 2000.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.8   Lack of Events", "body": "  Events  are  not  emitted  always  emitted  on  important  state-modifying  actions.  Note  that  this  is  the  case across all contracts. The following is an incomplete list of functions that lack event emissions:  ISSUEIDPREFIX-015   BaseV1Factory.setBaseStableFee()   BaseV1Factory.setBaseVariableFee()   BaseV1Factory.setShouldGasThrottleAndMaxGasPrice()   BaseV1Factory.setOwner()   BaseV1Factory.acceptOwner()   BaseV1Factory.setPause()   BaseV1Factory.setProtocolAddress()   BaseV1Factory.setAdmins()   BaseV1Factory.setPause()   BaseV1Factory.setPause()   BaseV1Factory.setPause()   BaseV1Pair.setFee()   GaugeFactory.preDistribute()   GaugeFactory.updateVeProxy()   GaugeFactory.updatePokeDelay()   GaugeFactory.updateMaxVotesToken()   GaugeFactory.updateReferrals()   ProtocolGovernance.setGovernance()   ProtocolGovernance.acceptGovernance()   ProtocolGovernance.setAdminAndVoter()   ProtocolGovernance.setStableMiner()   ProtocolGovernance.updateBaseReferrals()   Gauge.kick()   Gauge.updateReferral()   Gauge.setWhitelisted()  USDFI - AMM, Gauges and Bribes -   17  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \f BribeFactory.createBribe()   Bribe.addRewardtoken()   Bribe.setWhitelisted()   Bribe.updateReferral()  Emitting events could ease following the state of the contract.    USDFI has added emitting relevant events to the functions of the above list.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.9   Maximum Referral Fee", "body": "  The documentation specifies that the referral fee for gauges and bribes is at most 10%. However, that is not enforced, and; hence, the referral fee may exceed 10%.  ISSUEIDPREFIX-007    USDFI has corrected the code by enforcing this limit:  require((_baseReferralFee <= 10000), \"must be lower 10%\");  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.10   Used Weights Are Not Reset", "body": "  When weights are reset, usedWeight is not set to 0. While this has no impact on voting or execution, the automatic getter for usedWeight may return outdated values.  ISSUEIDPREFIX-013    USDFI has successfully corrected the code by setting usedWeights[_owner] to zero.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.11   recoverERC20() Allows Recovering", "body": " Arbitrary Tokens  The  recoverERC20()  function  should  according  to  the  documentation  allow  the  governance  to withdraw non-reward tokens from the bribe contract. However, reward tokens can be withdrawn, too.  ISSUEIDPREFIX-020  USDFI - AMM, Gauges and Bribes -   18  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f  USDFI correctly has changed to code to check that the token to be withdrawn is not a reward token.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.12   Comments With Errors", "body": "  The code contains some comments with errors. Examples are:  1. The comment for the stable parameter of BaseV1Pair specifies that is not immutable, while it is.  2. The comment for the baseStableFee of BaseV1Factory mentions that it is 0.04%. However, it  ISSUEIDPREFIX-009  is 0.05%.    USDFI has successfully resolved both the aforementioned errors.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.13   Gas Optimisation", "body": "  ISSUEIDPREFIX-019  The  codebase  has  several  inefficiencies  in  terms  of  gas  costs  when  deploying  and  executing  smart contracts. Here, we report a list of non-exhaustive possible gas optimisations:  1. Bribe.constructor:  To  deploy  a  bribe  contract,  in  order  to  set  firstBribeTimestamp, referralContract,  and  referralFee,  multiple  queries  to  the  gaugeFactory  are  made. However,  the  memory  variable  _gaugeFactory  has  the  same  address  and  using  it  instead  of gaugeFactory reduces number of storage reads.  2. getRewardForOwnerToOtherOwnerSingleToken of Bribe has a visibility of public, with input parameter in the memory. As this function is only called externally, its visibility can be changed to external and consequently the input parameters to calldata.  3. The visibility of updateReferral in Bribe can be changed to external and its input parameters to  calldata.  4. BribeFactory defines a storage variable named last_bribe, which is set but never read. Apart from  that,  the  constructor  returns  this  storage  variable,  although  a  local  memory  variable lastBribe holds the same address and returning it is more gas efficient.  5. Gauge  defines  two  state  variables  token  and  TOKEN,  which  necessarily  hold  the  same  address once set. Following the code path, they never get out of sync and are always equal. Hence, holding just one of them and cast it whenever neccesary.  6. gaugeFactory  in  Gauge  is  never  modified  after  being  set  in  the  constructor.  Hence,  it  can  be defined as immutable. Apart from that, they way it is set in the current implementation, it holds the same value as DISTRIBUTION.  7. Gauge._claimVotingFees  calculates  bribe  even  in  the  case,  where  neither  claimed0  nor  claimed1 is non-zero. Calculating bribe inside the if-statement makes it more gas efficient.  8. Gauge._deposit defines a local memory variable userAmount, which holds the value of input  parameter amount. It seems to be unnecessary.  USDFI - AMM, Gauges and Bribes -   19  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected            \f9. GaugeFactory._vote  updates  totalWeight  incementally  in  each  iteration  of  the  loop.  By accumulating all the changes at updating totalWeight after the last iteration, gas consumption can be reduced significantly.  10. GaugeFactory.addGauge  writes  to  the  last  element  of  maxVotesToken.  However,  this  last  element has the same value as the input parameter _tokenLP.  11. GaugeFactory.preDistribute  inside  the  loop,  makes  multiple  accesses  to  the  storage variable lockedWeights[_tokens[i]]. Doing the intermediate calculations in the memory and writing them back to storage is more gas efficient.  12. GaugeFactory.updateReferrals  can  be  defined  as  external  along  its  input  parameters  as  calldata.  13. GaugeFactory.delay can be defined as constant, as its value never changes later.  14. GaugeFactory.STABLE  after  being  assigned  a  value  in  the  constructor  never  gets  modified.  Hence, it can be defined as immutable.  15. BaseV1Pair.permit  recalculates  DOMAIN_SEPARATOR  for  every  call.  It  makes  sense  as  a prevention mechanism against forks. The storage write could potentially be done only if the chain id changed.  16. BaseV1Pair defines an event named Claim. It is called only once with sender and recipient  holding the same address.  17. BaseV1Factory.constructor sets the storage variable isPaused to false, which is the default  value for any boolean values.  18. BaseV1Factory defines three storage variables _temp0, _temp1, and _temp. These variables are  used  solely  as  input  parameters  when  deploying  a  BaseV1Pair.  Instead  of  occupying  extra storage for these variables, they can easily be defined as input parameters to the BaseV1Pair.  19. The  modifier  BaseV1Pair.gasThrottle  can  be  implemented  more  optimised,  by  assigning maxGasPrice == 0 as should not throttle, which consequently removes the need to define state variable shouldGasThrottel in BaseV1Factory.    USDFI  has  correctly  addresses  most  of  the  aforementioned  gas  inefficiencies.  The  following inefficiencies are going to be reviewed later by USDFI:  1. GaugeFactory.divisor can be defined as constant. Its value is not later set during deployment  through constructor.  2. BaseV1Factory defines three storage variables _temp0, _temp1, and _temp. These variables are  used  solely  as  input  parameters  when  deploying  a  BaseV1Pair.  Instead  of  occupying  extra storage for these variables, they can easily be defined as input parameters to the BaseV1Pair.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.14   No NatSpec", "body": "  While documentation was provided, the individual functions are not documented in the code. It is highly recommended  to  at  least  describe  each  entry  point  with  descriptive  comments  (e.g.  NatSpec  for  all functions).  ISSUEIDPREFIX-021  USDFI - AMM, Gauges and Bribes -   20  InformationalVersion1CodeCorrected      \f  Comments have been added. However, no NatSpec was used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "6.15   Referrals Default Values", "body": "  The  referralContract  by  default  is  the  0-address,  indicating  that  this  feature  is  deactivated. However, the code will revert if governance does not have a valid referral contract.  Further, if there is no mainRefFeeReceiver specified, the 0-address receives funds.  ISSUEIDPREFIX-010    Initial values need to be provided on construction now.  USDFI - AMM, Gauges and Bribes -   21  Version1CodeCorrected    \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "7.1   Magic Values", "body": "  The use of magic numbers in the codebase is not recommended, they should be replaced by variables with a self-explanatory name. Examples are:  ISSUEIDPREFIX-005   The scaling factor 1e18   1000   10000   100000   50 (number of maximum iterations in Bribe.earned)  Code partially corrected:  Some of the numbers have been replaced by variables with a self-explanatory name.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "7.2   Voting Twice per Epoch Possible", "body": "  poke() can be considered as a voting function. However, it ignores lastVote. Hence, it is technically possible to revote with the same allocations.  ISSUEIDPREFIX-006  Acknowledged:  USDFI has acknowledged this issue stating that:  This is by design since poke may be executed voluntarily at any time. Please note that re-poking and re-voting without acquiring more veTokens is only to the detriment of the user himself as the passage of time always reduces his voting power (veTokens) and is also costly  USDFI - AMM, Gauges and Bribes -   22  InformationalVersion1CodePartiallyCorrectedInformationalVersion1Acknowledged          \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.1   DOS Possibilities", "body": "  If governance adds to many gauges, preDistribute() may hit the gas limit. Additionally, users could vote for too many gauges so that they DOS themselves.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.2   Deprecated Gauges May Have Locked", "body": " Rewards  The function preDistribute() considers the weight of the deprecated gauges for the total amount of votes. However, the distribute() function will never distribute such rewards. Hence, as long as there are  any  deprecated  gauges  with  remaining  votes,  tokens  will  be  locked  in  the  contract.  It  is  worth mentioning  that  this  is  required  since,  otherwise,  the  distribution  could  be  DOSed,  if  a  gauge  was resurrected between predistribution and distribution.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.3   Low Default Fee Value for LPs", "body": "  LPs should be aware that by default only 20% percent of the accrued fees will be allocated to them.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.4   Reward Mechanics", "body": "  An  LP  with  high  liquidity  may  provide  liquidity  to  gauges,  when  he  sees  a  high  rate.  Other  users,  who bribed the voters to receive rewards, may end up getting less profit compared to just receiving fees.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.5   Sandwiching", "body": "  Users  should  be  aware  that  sandwiching  swaps  is  possible  (similar  to  Uniswap  V2  like  pools).  As described  in  System  Overview,  users  should  use  helper  contracts  that  allow  specifying  slippage protection so that sandwich attacks are limited to some degree.  USDFI - AMM, Gauges and Bribes -   23  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                    \f8.6   What Should Happen With Voteless Bribes?  If a bribe is notified about a reward, it stores the reward for the next epoch. However, if no voter voted for the allocations, and hence did not receive bribe shares, no one will be able to claim the bribes. Note that it is assumed that at least a voter will cast a vote to claim the rewards. However, gas fees could be higher than the reward's value.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.7   distribute() Without preDistribute()", "body": "  When  a  gauge  is  added,  hasDistributed  for  the  LP  token  will  be  false.  Hence,  it  is  technically possible to distribute rewards without preDistribute(), although its reward will be zero.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.8   gasThrottle", "body": "  The gasThrottle modifier is applied to the swap() function to reduce the impact of front-running by specifying a maximum gas price an action should be able to have. However, such a mechanism brings certain risks. The following is an incomplete list of examples:  1. Gas price changes naturally and exceeds the maximum. Swaps can be broken temporarily until the  maximum price is updated.  2. It is still be possible to front-run users with mints so that the price is affected. Consider the example, in  which  only  one  LP  exists.  Minting  does  not  yield  a  loss  for  the  user  in  that  scenario  but  can change the price significantly.  3. Some  liquidators  may  want  to  exchange  the  liquidated  funds  against  the  repayment  currency  so that the profit in the repayment currency is guaranteed. Since liquidations are time-sensitive, higher gas prices are set. gasThrottle could make it undesirable for liquidators to use the exchange in such scenarios.  Further,  note  that  MEV  often  is  done  by  transferring  ETH  to  the  block  creator  directly.  Hence,  in  such cases the mechanism is ineffective.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.9   refLevelPercent Is Ended With 0 Elements", "body": "  Users should be aware that a zero element in refLevelPercent will break the fee distribution for the subsequent elements.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "8.10   rewardsPerToken() Can Return", "body": " rewardsPerEpoch  The  function  rewardsPerToken()  returns  the  ratio  of  the  rewards  and  the  supply  at  a  given  epoch number. However, if the total supply is zero, rewardsPerEpoch is returned.  USDFI - AMM, Gauges and Bribes -   24  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/usdfi-amm-gauges-bribes/"}, {"title": "7.1   Gas Optimizations", "body": "  1. In the _mint function, the update of totalSupply can be done in the unchecked block to save gas.  The  total  supply  of  shares  is  bound  to  be  <=  total  supply  of  DAI,  which  is  bound  to type(uin256).max.  2. The internal function _rpow always take RAY as base, replacing base by RAY in the code will save  a bit of gas at runtime.  ISSUEIDPREFIX-001    1. The update of totalSupply has been moved in the unchecked block.  2. The base parameter of the function _rpow has been removed, and replaced by RAY everywhere.  Oazo Apps Limited - Savings Dai -   10  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-savingsdai/"}, {"title": "8.1   Known Attack Vector on approve()", "body": "  Users should be aware of the well known attack vector on approve() (front running changes to existing approvals, spending more tokens than intended by the owner). If needed, they should use the provided increaseAllowance() / decreaseAllowance() to mitigate this risk.  Oazo Apps Limited - Savings Dai -   11  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-savingsdai/"}, {"title": "7.1   Fees May Block Slow Path", "body": "  The  slow  path  goes  through  L1DAIWormholeBridge.finalizeRegisterWormhole()  which  calls requestMint with maxFee = 0.  When the vat is live, the computed fee in _withdraw function of WormholeJoin may be > 0 and the transaction would revert due to:  require(fee <= maxFee, \"WormholeJoin/max-fee-exceed\");  This essentially prevents users who are censored by the oracle to redeem using the slow path.    The only fee currently present, the WormholeConstantFee, now features a ttl after which the fee returned for this WormholeGUID is 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "7.2   L2 Addresses", "body": "  MakerDAO - DAI Wormhole -   13  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignHighVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                  \fThe address format can differ across L2 systems / different domains the DAI wormhole connects. While the majority work with address of 20 bytes, compatible with the solidity address type, other systems can use other address format. One example of those is StarkNet where addresses of are of type felt which are larger than 20 bytes.    The  receiver  and  operator  fields  of  the  WormholeGUID  struct  have  been  replaced  by  bytes32 types to accommodate for address formats up to 32 bytes.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "7.3   Minting Pending DAI Incurs Additional Fees", "body": "  Using the DAI Wormhole may take a fee from the user. This fee is taken on L1 and transferred to the VOW.  The  fee  is  accounted  for  inside  _withdraw()  and  calculated  using  an  external  Fee  adapter contract based on the wormholeGUID which contains all information about the transfer, the current debt and the line, the debt ceiling according to the source domain.  The amount of the fee taken is calculated before determination of the amount that is withdrawn.  uint256 fee = vatLive ? FeesLike(fees[wormholeGUID.sourceDomain]).getFees(wormholeGUID, line_, debt_) : 0; require(fee <= maxFee, \"WormholeJoin/max-fee-exceed\");  uint256 amtToTake = _min(                         pending,                         uint256(int256(line_) - debt_)                     );  The fee is based on the full amount of the wormholeGUID being processed, not on the actual amount withdrawn in this transaction. The actual amount withdrawn is limited by the maximum debt that can be created without exceeding the ceiling. The remaining amount can be retrieved later when more debt can be  accrued  using  mintPending().  This  however  again  uses  function  _withdraw  which  again calculates the fee based on the full amount of the wormholeGUID, the current debt and debt ceiling. The pending amount is not taken into account for the calculation of the fee.  Hence, should the amount to be withdrawn be limited by the remaining space between the debt ceiling (line) and the current debt, the user pays fees based on the full amount, not the amount being withdrawn. Later,  when  the  remaining  pending  amount  is  withdrawn,  the  user  again  pays  fees  based  on  the  full amount of the wormholeGUID, effectively paying again for the same transfer.    The fee computation function getFee takes more parameters (pending, amtToTake) into account. This allows  more  versatile  ways  to  compute  the  fee.  For  example,  WormholeConstantFee  can  now compute the fee relative to the amount being withdrawn instead of the full fee every time the full amount is partially withdrawn.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "7.4   Missing or Incomplete Natspec", "body": "   requestMint,  _mint  and  mintPending  are  missing  the  natspec  for  their  second  return  value  totalFee.  MakerDAO - DAI Wormhole -   14  DesignMediumVersion1CodeCorrectedDesignLowVersion2CodeCorrected                \fthe cure and getFee functions specification should specify the unit of its return value.  the isValid function specification should describe the return value.  the v, r and s parameters of BasicRelay.relay should be described in the specification    The issues raised above have been addressed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "7.5   Specification Mismatch", "body": "  The  specification  of  the  mintPending  function  says  that  it  is  only  callable  by  the  operator,  but  the receiver is also allowed to call the function.  Specification changed:  The description of the mintPending function has been fixed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "7.6   Code Inefficiency", "body": "   signers mapping in WormholeOracleAuth is address => bool, it would be more gas efficient  to have a address => uint256.  in  WormholeOracleAuth,  threshold  is  passed  as  a  function  parameter  in  isValid. threshold is a storage variable in the contract and thus can be accessed directly from isValid function and does not need to be passed as a parameter, this would save gas.  in  _withdraw  function  of  WormholeJoin,  the  overflow  check  for  _line  happens  every  time. Checking for overflow only once in the file function where the line for a domain is set would save gas.    the signers mapping has been changed to a mapping(address => uint256).   MakerDAO  wants  the  isValid  function  to  be  used  by  anyone  who  wants  to  verify  an  oracle  attestation.  the  file  function  checks  for  _line  validity  and  the  check  has  been  removed  from  _mint  (new version of _withdraw).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "7.7   Interface Mismatch", "body": "  MakerDAO - DAI Wormhole -   15  CorrectnessLowVersion2Speci\ufb01cationChangedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                               \f The   of   signature   is function approve(address, uint256) external returns(bool);, but WormholeJoin as and  function  approve(address,  uint256)  external;  in  the  interface  they  define  for TokenLike.  L1DAIWormholeBridge   approve   token's   have   DAI   the   it   Version 2:   The interface signature of requestMint in WormholeRouter exposes only one return value out of two. The interface signature of requestMint in L1DAIWormholeBridge exposes no return value at all.  The  compiler  will  just  drop  the  unused  return  values  without  causing  an  error,  but  this  design choice does not reflect the correct signatures and should be documented.     WormholeJoin  and  L1DAIWormholeBridge  have  the  correct  interface  for  the  DAI  token's  approve function.   The interface signature of requestMint() in WormholeRouter has been fixed in   .   L1DAIWormholeBridge  is  now  called  L1DAIWormholeGateway.  The  interface  is  now  defined  correctly in the imported WormholeInterface.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "7.8   Missing Index", "body": "   domain fields are indexed in WormholeJoin events. It could be useful to index the domain field of  WormholeRouter's File event to make it more easily searchable.   targetDomain  field  in  Flushed  event  of  L2DAIWormholeBridge  can  be  indexed  to  ease  its  search.    the domain fields in the File events are indexed.  the targetDomain field in the Flushed event is indexed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "7.9   file() Casting Bytes32 to Uint256", "body": "  Contrary to the other contracts which have multiple file functions with the data parameter of the actual type of the data passed, the WormholeOracleAuth has a file function taking a bytes32 argument as data which is then casted to uint256.    The  file  function  responsible  for  the  threshold  parameter  now  takes  directly  a  uint256  data  to avoid an unnecessary conversion.  MakerDAO - DAI Wormhole -   16  Version3DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "8.1   Breaking Changes of the Solidity Compiler", "body": "  The new compiler version behaves differently on code related to integer conversion/negation when the value is exactly 2**255.  The core DSS system which has been compiled with compiler version 0.6.12 first ensures that the value of the uint is below or equal to 2**255 before converting it to a (negative) integer.  An example of this pattern can be found in e.g. GemJoin.exit():  require(wad <= 2 ** 255, \"GemJoin/overflow\");        vat.slip(ilk, msg.sender, -int(wad));  This  project,  DSS-Wormhole  uses  a  more  recent  compiler  version  0.8.9.  Negating  2**255  is  no  longer possible and will result in the transaction reverting.  In DSS-Wormhole, WormholeJoin.settle() features such a pattern:  function settle(bytes32 sourceDomain, uint256 batchedDaiToFlush) external {     require(batchedDaiToFlush <= 2 ** 255, \"WormholeJoin/overflow\");     daiJoin.join(address(this), batchedDaiToFlush);     if (vat.live() == 1) {         (, uint256 art) = vat.urns(ilk, address(this)); // rate == RAY => normalized debt == actual debt         uint256 amtToPayBack = _min(batchedDaiToFlush, art);         vat.frob(ilk, address(this), address(this), address(this), -int256(amtToPayBack), -int256(amtToPayBack));  Note  that  in  this  case  the  check  is  superflous:  The  multiplication  in  daiJoin.join()  will  revert  due  to  an overflow on even lower values.  Nevertheless  it's  important  to  be  aware  of  this  behavior,  the  same  code  pattern  behaves  differently depending on the compiler version. This requires careful attention especially when such contracts, which have been compiled with different compiler versions, e.g. DSS-Wormhole and the VAT interact.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "8.2   Finality and State Change on L2", "body": "  The notion of finality of transactions and the resulting state change differs across the L2 solutions. The Wormhole  system,  especially  the  Maker  Oracle  Feeds  must  be  aware  of  that  and  take  each  finality definition into account. Ideally this is properly assessed and documented for each Domain the Wormhole connects to.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "8.3   Slow Path Requires Zero Fee", "body": "  The  slow  path  successful redemption of the wormhole with no fee due to:  through  L1DAIWormholeBridge.finalizeRegisterWormhole()   requires  MakerDAO - DAI Wormhole -   17  NoteVersion1NoteVersion1NoteVersion1          \ffunction finalizeRegisterWormhole(WormholeGUID calldata wormhole)     external     onlyFromCrossDomainAccount(l2DAIWormholeBridge) {     wormholeRouter.requestMint(wormhole, 0, 0); }  The interface definition of WormholeFees emphasizes this:  It should return 0 for wormholes that are being slow withdrawn.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "8.4   Surplus DAI for WormholeJoin in the VAT", "body": "  Function  settle()  of  the  WormholeJoin  contract  is  permissionless  and  given  enough  DAI  token balance  of  the  WormholeJoin  contract  (e.g.,  provided  by  the  caller)  can  be  executed  by  anyone. DaiJoin.join() returns the DAI tokens into the system and the contract's balance tracked by the DAI mapping  of  the  VAT  increases  accordingly.  This  increased  balance  however  is  stuck  when  everything has been settled.  Note  that  the  sourceDomain  can  be  chosen  arbitrarily  by  the  untrusted  caller.  Listeners  of  the  event Settle  must  be  aware  that  this  event  may  be  triggered  by  anyone  and  may  not  represent  a  debt repayment coming from the bridges.  MakerDAO - DAI Wormhole -   18  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dai-wormhole/"}, {"title": "6.1   Unpermissioned Access to onlyMate Methods", "body": "  CS-MRT-001  If  the  may  role  is  assigned  to  address  zero,  methods  guarded  by  the  onlyMate  modifier  become unpermissioned.  The  purpose  of  this  is  unclear,  as  conflicting  functionality  can  be  accessed  through onlyMate methods. A user could call push() to transfer the whole balance to the configured recipient, or push(1) to transfer a very low amount to the recipient and disable further push() access, since the to and psm variables are reset to zero after push() is called. Likewise, a user could call quit(), which transfers the DAI balance to the configured quitTo address.  Since  mutually  exclusive  functionality  is  accessible  through  the  onlyMate  modifier,  leaving  it unpermissioned  opens  the  door  to  race  conditions  and  unpredictable  behavior.  Only  trusted  parties should be granted access to onlyMate guarded methods.  Similarly, but to a lesser extent, pick() and hook() are unpermissioned when address zero is granted the can role.    MakerDAO  realized  output  conduits  should  never  be  permissionless.  The  abilitiy  to  make  the  may  and can roles unpermissioned has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-rwa-toolkit/"}, {"title": "6.2   Use of Unsafe Math Subject to Overflows", "body": "  Since the contract uses version 0.6.12 of solidity, unchecked arithmetics are used by default. Methods expectedGemAmt() and requiredDaiWad() are subject to possible artihmetic overflows. if their wad or amt parameters are set large enough.  Since  no  accounting  state  is  held  by  the  contract,  but  operations  are  performed  on  the  current  DAI balance, the overflows cannot be exploited, even by a malicious may user. However, external contracts  CS-MRT-002  MakerDAO - RWA Toolkit -   10  CriticalHighMediumCodeCorrectedLowCodeCorrectedSecurityMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fand off-chain users relying on the correctness of expectedGemAmt() and requiredDaiWad() might be negatively affected.    SafeMath  like  methods  were  introduced  to  ensure  the  calculations  in  expectedGemAmt()  and requiredDaiWad() cannot overflow.  MakerDAO - RWA Toolkit -   11  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-rwa-toolkit/"}, {"title": "5.1   Gas Savings Part 2", "body": "  0  0  0  3  Trading._fillFacingExchange now transfers the fee from the contract to the operator on every call. When multiple maker orders are processed, there is a fee transfer for every one of them. The fee could be sent after all orders have been processed instead.  Acknowledged:  The client acknowledges the possible gas savings and chooses to keep the code as-is.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "5.2   Accidental Token Transfers", "body": "  Tokens that have been accidentally sent to the contract can not be recovered.  Furthermore, if either the collateral token or one of the outcome tokens have been accidentally sent to the  contract,  the  next  executed  taker  order  will  receive  these  tokens  due  to  the  implementation  of Trading._updateTakingWithSurplus.  Risk accepted  Polymarket states:  Polymarket - Exchange -   10  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedRiskAcceptedCodePartiallyCorrectedDesignLowVersion2AcknowledgedDesignLowVersion1RiskAccepted                   \fRecovering tokens sent to the contract will require adding a permissioned ``withdrawTokens`` function, which introduces an unacceptably large trust assumption.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "5.3   Gas Savings", "body": "  The following parts can be optimized for gas efficiency:   The OrderStructs.OrderStatus struct occupies 2 words in storage. Decreasing the size of the remaining field by 1 byte could reduce the space requirement to 1 word. This fix has to be applied with caution using safe casts where appropriate.   The field token in the Registry.OutcomeToken struct is redundant as a specific struct can only  be accessed with that value.   The call to validateTokenId(token) in Registry.validateComplement is redundant as the  very same call is performed in the following call to getComplement.   Trading._matchOrders  and  _fillMakerOrder  redundantly  compute  the  order  hash  again,  after it has already been computed by _validateOrderAndCalcTaking.   Trading._updateOrderStatus   performs  multiple   redundant   storage   loads   of  status.remaining.   Trading._updateTakingWithSurplus  performs  a  redundant  calculation   in   the  return  statement. Returning actualAmount yields the same result at this point.   Assets.getCollateral(),   Fees.getFeeReceiver(), Assets.getCtf(),  Fees.getMaxFeeRate()  are  redundant  since  the  variables  they  expose  are  public  and  already define equivalent accessors.  Code partially corrected:  OrderStructs.OrderStatus  still  occupies  2  storage  slots.  All  other  gas  savings  have  been implemented sufficiently.  Polymarket - Exchange -   11  DesignLowVersion1CodePartiallyCorrected          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  2  1  3  10  -Severity Findings   Signatures Are Valid for Any Address    ORDER_TYPEHASH Is Incorrect   -Severity Findings   Fee Rate Not Hashed   -Severity Findings   Fee Approval Required    Unintended Order Types Possible    Zero Address EOA Signer Considered Valid   -Severity Findings   FeeCharged Event Not Emitted in fillOrder    OrderStruct.taker Specification Inconsistent    Code Replication    Domain Separator Cached    Floating Pragma    Non-optimized Libraries Used    Order Status Possibly Incorrect    Struct Order Has Redundant Fields    Wrong Notice on Order.feeRateBps   isCrossing Incorrect When takerAmount Is 0   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.1   Signatures Are Valid for Any Address", "body": "  Signatures.isValidSignature checks the validity of a given order's signature. For signature types POLY_GNOSIS_SAFE and POLY_PROXY, the code makes sure that an order's maker address belongs to the same account that signed the order.  This is not true for the signature type EOA. Any account can create a signature for an order that contains an arbitrary maker address. Since users give token approval to the protocol on order creation, malicious actors can generate orders for an account that already generated an order, but, for example, with a more favorable price. This order will then be executable although the account in question did not authorize it.  Code corrected  Polymarket - Exchange -   12  CriticalCodeCorrectedCodeCorrectedHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSecurityCriticalVersion1CodeCorrected         \fSignatures.verifyEOASignature  has  been  added,  which  additionally  ensures  Order.maker == Order.signer for EOAs.  that   the  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.2   ORDER_TYPEHASH Is Incorrect", "body": "  The  ORDER_TYPEHASH  in Hashing.hashOrder. It is used to calculate an EIP-712 compliant hash for an order which is then used to recover the signer of the given order. Since the typehash is incorrect, this mechanism will not work for correctly signed orders.  in  OrderStructs  does  not  equal   the  actual  encoded  data   Code correct  OrderStructs.ORDER_TYPEHASH is now computed at compile time on the correct structure signature.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.3   Fee Rate Not Hashed", "body": "  Hashing.hashOrder does not include the fee rate of an order into the hash. If the signatures are also generated this way and users do not recognize this, operators can always specify MAX_FEE_RATE_BIPS fees.  Code correct  Order hash computation now includes feeRateBps.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.4   Fee Approval Required", "body": "  Fees are charged by transferring the respective amount of tokens from the receiving user's account to the fee receiver.  The  user  has  to  give  additional  approval  for  the  token  they  actually  want  to  receive,  which  is counter-intuitive  and  also  opens  up  additional  security  risks.  Since  the  fee  is  always  smaller  than  the amount  of  tokens  sent  to  the  user,  this  special  behavior  is  not  necessary  as  the  fees  could  also  be deducted from the amount sent to the user.  Code correct  Fees are deducted directly on the exchange, instead of being pulled from the order maker. Additionally, _fillOrder implicitly collects fees by transferring the taking amount minus the fee from the operator.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.5   Unintended Order Types Possible", "body": "  Polymarket - Exchange -   13  CorrectnessCriticalVersion1CodeCorrectedDesignHighVersion1CodeCorrectedSecurityMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                                \fTrading._matchOrders  and  _fillOrder  miss  sanity  checks  for  combinations  of  makerAssetId, takerAssetId and side in the passed order structs.  of   in combinations  Eight  [ConditionalToken,  in [ConditionalToken,  Collateral]  are  possible,  but  only  two  of  them  should  be  allowed.  This seems  possible  as  the  side  seems  redundant  or  colliding  with  the  combinations  (struct  Order  has redundant fields).  takerAssetId   Collateral],   makerAssetId   SELL],   [BUY,   side   and   in   This  allows  for  matching  of  orders  that  are  not  intended.  For  example,  matching  of  a  BUY  order  with maker asset YES and taker asset USDC to a SELL order with maker asset USDC and taker asset YES is perfectly possible as long as the YES price in these orders is over 1 USDC (otherwise, the fee calculation reverts).  Code correct  Unintended order types are no longer possible as fields makerAssetId and takerAssetId have been replaced by a single field tokenId.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.6   Zero Address EOA Signer Considered Valid", "body": "  isValidSignature() returns true for signer equal to zero address, signatureType EOA and invalid signature.  The  check  is  performed  at  line  70  of  Signature.sol,  SilentECDSA.recover  returns  0  on  error. Setting the signer to zero address will incorrectly validate the signature.  Code correct  Signature  verification  now  uses  Openzeppelin's  ECDSA.recover  instead  of  SilentECDSA.  Invalid signatures now revert instead of returning the 0-address.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.7   FeeCharged Event Not Emitted in fillOrder", "body": "  in _fillOrder, the fee is charged implicitly by deducting it from the amount that is transferred to the order  maker  but  a  FeeCharged  event  is  not  emitted.  For  consistency  and  to  allow  proper  accounting based on events, FeeCharged should be emitted.    The event is now emitted.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.8   OrderStruct.taker Specification Inconsistent", "body": "  Polymarket - Exchange -   14  CorrectnessMediumVersion1CodeCorrectedDesignLowVersion2CodeCorrectedCorrectnessLowVersion2Speci\ufb01cationChanged                        \fThe taker field of the Order struct actually identifies the operator which can fill the order, not the taker that can be matched with the order as it seems to be intended from the natspec notice.  Specification changed:  The natspec of taker has been modified to reflect its actual usage.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.9   Code Replication", "body": "  Trading._fillOrder  same  _validateOrderAndCalcTaking. For maintainability reasons, code replications should be avoided.  contains   present   already   code   that   the   is   in  Code correct  Duplicated  refactored  _performOrderChecks (renamed from _validateOrderAndCalcTaking).  in  Trading._fillOrder   been   code   has   into   the   function  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.10   Domain Separator Cached", "body": "  Hashing exposes the domainSeparator with an implicit public getter for an immutable variable. When the chain id changes, for example due to a hardfork, the domainSeparator will not be correct on the new chain.    The domainSeparator is now re-calculated in case of a change of the chain id.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.11   Floating Pragma", "body": "  Exchange uses the floating pragma <0.9.0. Contracts should be deployed with the compiler version and flags that were used during testing and auditing. Locking the pragma helps to ensure that contracts are not accidentally deployed using a different compiler version and help ensure a reproducible deployment.  Code correct  Solidity version has been fixed to 0.8.15 in all instantiated contracts. Interfaces, libraries, and abstract contracts are left floating.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.12   Non-optimized Libraries Used", "body": "  Polymarket - Exchange -   15  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                                \f TransferHelper re-implements transfer functions while there already exists an optimized library  (SafeTransferLib) implementing these functions in the dependencies of the project.   Signatures uses SilentECDSA, a modified version of an outdated OpenZeppelin ECDSA version. The current version of this library could be used instead since it provides all required functionalities.     TransferHelper now utilizes the optimized library for transfer functions.   Signatures utilizes the OpenZepplin library.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.13   Order Status Possibly Incorrect", "body": "  Trading.getOrderStatus  returns  an  OrderStatus  struct  containing  a  variable  isCompleted  for any order hash. As the protocol has two distinct mechanisms of invalidating orders, this function might return that an order is still not completed, while in fact it has been invalidated by a nonce increase.    The field isCompleted has been renamed to isFilledOrCancelled which describes the behavior in an adequate way.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.14   Struct Order Has Redundant Fields", "body": "  In struct Order, the fields side, makerAssetId, and takerAssetId coexist redundantly.  If side is BUY, makerAssetId is implied to be 0. If side is SELL, takerAssetId is implied to be 0. a single  AssetId  field  would  therefore  be  sufficient  to  fully  specify  the  order,  or  similarly  side  can  be removed from the struct and be derived from makerAssetId and takerAssetId.  Redundant input arguments increase code complexity and facilitate potential bugs.    The fields makerAssetId and takerAssetId have been removed in favor of a new field tokenId.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.15   Wrong Notice on Order.feeRateBps", "body": "  The notice of feeRateBps says:  If BUY, the fee is levied on the incoming Collateral  However, the fee is always charged in the takerAssetId, which is not necessarily the collateral.  Specification changed:  The  Fee rate, in basis points, charged to the order maker, charged on proceeds.  feeRateBps   notice   now   for   reads:  Polymarket - Exchange -   16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                          \f6.16   isCrossing Incorrect When takerAmount Is 0  In the event of a SELL-SELL matching, where tokens should be merged to provide collateral back to the sellers,  CalculatorHelper.isCrossing  returns  true  when  at  least  one  side's  order  has takerAmount == 0. In the case that the other side's order has a price greater than ONE, the matching is not crossing since no sufficient amount of collateral can ever be redeemed to cover price > ONE, however the isCrossing returns true.    isCrossing now returns false in the mentioned cases.  Polymarket - Exchange -   17  CorrectnessLowVersion1CodeCorrected      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polymarket-exchange/"}, {"title": "6.1   IERC20 Incompatible With Tether", "body": "  USDT,  one  of  the  collaterals,  is  not  fully  ERC20  compliant,  notably  some  features  lack  the  mandatory return value to comply with the standard.  In  MultiplyProxyActions  the  interface  IERC20  is  used  to  interact  with  the  token  contracts.  In  the interface definition a return value is expected for e.g., the approve and the transfer functions. Hence the Solidity compiler generates bytecode that expects a return value and reverts if there is none.  Risk accepted:  Oazo Apps Limited replied:  Oazo Apps Limited - Multiply -   11  DesignCorrectnessCriticalHighMediumRiskAcceptedLowAcknowledgedAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedRiskAcceptedCodePartiallyCorrectedAcknowledgedAcknowledgedRiskAcceptedAcknowledgedCodePartiallyCorrectedAcknowledgedRiskAcceptedDesignMediumVersion1RiskAccepted                \fCurrently, Tether is not used as collateral in Maker Protocol. In case Tether is onboarded to Maker Protocol, the multiply feature will be disabled for it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.2   Flash Loan Preparation When Skipping", "body": " Flashloan  In  version  two,  flashloans  can  be  skipped.  However,  some  parameters  for  taking  the  flashloan  are prepared  even  though  they  will  remain  unused.  More  specifically,  the  assets,  amounts  and  modes arrays  are  set  which  increases  gas  cost  of  the  actions  skipping  flashloans.  That  part  of  flashloan preparation could be moved to the new takeAFlashloan function which would also further reduce the size of the code.  Acknowledged:  Oazo Apps Limited replied:  This is a minor gas inefficiency, will be fixed after MVP.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.3   Unnecessary Execution of Code", "body": "  _getDrawDart()  returns  the  change  in  debt  needed  in  order  to  have  access  to  the  DAI  amount specified in paramter wad.  This function executes two external calls which could be omitted under certain conditions:  In case the DAI amount needed is 0 the function the function could return 0 immediately  In case enough DAI is available already, the call to Jug.drip() could be omitted.  Note  that  with  the  new  skip  flashloan  functionality  the  case  that  enough  DAI  is  already  available  will happen frequently and hence the code should be optimized for it.  Acknowledged:  Oazo Apps Limited replied:  This is a minor gas inefficiency, will be fixed after MVP.  Oazo Apps Limited - Multiply -   12  DesignLowVersion2AcknowledgedDesignLowVersion2Acknowledged                    \f6.4   Approval for Full Balance Instead of Amount Transferred  In  MultiplyProxyActions._closeWithdrawDai()  the  exchange  contract  is  approved  to  transfer the full token balance of the MultiplyProxyActions contract. The exchange contract however uses this approval only to transfer ink amount of collateral.  Acknowledged:  Oazo Apps Limited replied:  Exchange contract is fully trusted by the multiply proxy actions contract.  To  the  question  why  not  a  \"infinite\"  (uint256(-1))  approval  is  given  once  for  all  executions  to  the exchange contract, Oazo Apps Limited responded:  Infinite approval could cause unexpected implications, therefore it is skipped in the scope of the MVP; the only negative impact is gas inefficiency.  Note:  This  issue  was  raised  and  discussed  in  Version  1  of  the  code  reviewed  where  the  skipFL functionality did not yet exist. After the introduction of the skipFL functionality access control to the swap functions of the Exchange contract has been removed, hence the trust model has changed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.5   Avoid Repeated Calls", "body": "  In  MultiplyProxyActions.joinDrawDebt(),  IManager(manager).urns(cdpData.cdpId)  is called twice in succession. Caching the address of the urn would be more efficient.  IManager(manager).urns(cdpData.cdpId)  for Additionally,  called  closeVaultExitCollateral()  and  closeVaultExitDai().  For  both,  in closeVaultExitGeneric()  and  the  third  call  is  in  wipeAndFreeGem().  The  second  call  is  in _closeWithdrawCollateral() and _closeWithdrawDai() respectively. Similarly, the same holds for IManager(manager).vat().  times  first  call   three  the   is   is   Moreover,  IVat(vat).hope(DAIJOIN)  is  called  on  every  increase  action  in  the  context  of MultiplyProxyActions  in  the  joinDrawDebt  function.  However,  the  opposite  function  nope  is  never called,  meaning  that  DAIJOIN  will  always  be  able  to  modify  the  gem  or  DAI  balance  of MultiplyProxyActions.  As  this  behaviour  is  required  and  the  permission  is  never  revoked,  it  could  be called only once in the constructor to reduce the amount of needed gas.  Code partially corrected:  in  joinDrawDebt()  was  optimized  by  caching   The  occurence  to IManager(manager).urns(cdpData.cdpId)  during  the  flow  of  closing  and  exiting  have  been reduced from three to two. For the last reported repeated call, IVat(vat).hope(DAIJOIN) the code remained unchanged.  the  value.  The  calls   Acknowledged:  Oazo Apps Limited replied for the unchanged sub-issues:  Oazo Apps Limited - Multiply -   13  DesignLowVersion1AcknowledgedDesignLowVersion1CodePartiallyCorrectedAcknowledged                \fThis is a minor gas inefficiency, will be fixed after MVP.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.6   Breaks for Collaterals With More Than 18", "body": " Decimals  Function convertTo18 converts the amount into wad as follows:  wad = amt.mul(10 ** (18 - IJoin(gemJoin).dec()));  For  tokens  with  more  than  18  decimals,  the  subtraction  results  in  an  underflow.  The  subsequent exponentiation and multiplication likely overflow resulting in a random value returned.  Risk accepted:  Oazo Apps Limited replied:  Such approach is consistent with the current Multi-Collateral DAI implementation and does not affect any existing collateral.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.7   Event Issues", "body": "  There are several issues regarding events:  1. The callback function executeOperation in MultiplyProxyActions.sol contains the logic for using the flash loan. It emits the event FLData, logging how much was borrowed and how much is to be returned to Aave. It is emitted as follows:  emit FLData(IERC20(DAI).balanceOf(address(this)),borrowedDaiAmount);  While borrowedDaiAmount actually specifies the value that must be returned to Aave, the balance of  the  MultiplyProxyAction  contract  may  not  be  the  amount  that  was  borrowed  since  the  method increaseMultipleDepositDai may also increase the balance.  2. Event  FLData  in  MultiplyProxyActions.sol  indexes  the  amount  borrowed  and  the  amount  to  be returned. While in general indexing events is useful, there is no direct use of indexing this event and, thus, the cost of emitting this event could be reduced.  3. Event AssetSwap in Exchange.sol is unindexed. It could be helpful to index the assets associated  with this event.  4. Event  FeePaid  in  Exchange.sol  does  not  log  the  beneficiary.  This  issue  is  related  to  issue feeRecepient of AddressRegistry and how it is resolved. If the receiver of the fee is not fixed for the contract, then logging the beneficiary could be useful since the beneficiary of the fee may change.  Code partially corrected:  Oazo Apps Limited - Multiply -   14  DesignLowVersion1RiskAcceptedDesignLowVersion1CodePartiallyCorrectedAcknowledged                  \f1. Corrected: The event does not emit the balance anymore. Now, the difference between the balance  and depositDai is emitted.  2. Corrected: FLData is now unindexed.  3. Corrected: assetIn and assetOut are indexed.  4. Not corrected: FeePaid now logs the beneficiary. Since the feeBeneficiary is public and cannot  be changed, it is not necessary to log the beneficary. Gas costs could be reduced.  However, Oazo Apps Limited responded to that last point as follows:  Such approach allows us to immediately find fee beneficiary for every future instance of exchange; it results in a minor gas inefficiency.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.8   Repeated Identical Multiplications", "body": "  Some  multiplications  are  done  repeatedly  within  the  same  functions.  E.g.,  in  _getDrawnDart(), wad.mul(RAY) is calculated three times. Avoiding repeated multiplications and calculating it only once and storing the result may be favorable.  Acknowledged:  Oazo Apps Limited replied  The outcome of the proposed fix is negligible, however, it is prioritized for a future update.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.9   Unchecked Return Values and Non-Compliant ", "body": " IGem Interface  The IGem Interface is used when handling collateral inside the MultiplyProxyActions contract. The return values of these calls is, however, never checked. While most ERC-20 tokens revert on a failed transfer, according to the ERC-20 specification it is sufficient to return false. A collateral with this behavior may not be supported correctly.  function approve(address, uint) virtual public; function transfer(address, uint) virtual public returns (bool); function transferFrom(address, address, uint) virtual public returns (bool);  Additionally,  note  that  the  function  approve  defined  in  IGem  has  no  return  value.  According  to  the ERC-20 specification ( https://eips.ethereum.org/EIPS/eip-20 ) this function must have a boolean return value:  function approve(address _spender, uint256 _value) public returns (bool success)  Oazo Apps Limited - Multiply -   15  DesignLowVersion1AcknowledgedDesignLowVersion1RiskAccepted                \fRisk accepted:  Oazo Apps Limited replied:  Such implementation is compliant with the current Maker Protocol - it was consulted and confirmed with the Maker DAO\u2019s Protocol Engineering Core Unit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.10   Unnecessary Call of getAaveLendingPool", "body": "  After  receiving  the  requested  flash  loan  from  Aave,  its  lending  pool  contract  calls  function executeOperation. As the lending pool is the message sender of this call, it would be unnecessarily expensive  to  retrieve  the  lending  pool  address  from  Aave's  lending  pool  provider.  However,  in executeOperation of contract MultiplyProxyActions the lending pool is retrieved as follows:  ILendingPoolV2 lendingPool = getAaveLendingPool(addressRegistry.aaveLendingPoolProvider);  getAaveLendingPool retrieves the Aave lending pool address from the lending pool provider. Thus, gas could be saved.  Acknowledged:  Oazo Apps Limited replied:  Optimisation will be done in a future version of the contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.11   Variables Could Be Immutable and Constant", "body": "  In  Exchange.sol  the  token  swap  logic  is  defined.  The  state  variable  feeBase  is  initialized  upon declaration and the state variable fee is initialized in the constructor. Both cannot be modified. Hence, they could be declared as constant and immutable respectively.  Code partially corrected:  feeBase was made constant. fee now has a setter and can no longer be immutable. However, with the updates Oazo Apps Limited decided to stick with the feeBeneficiaryAddress in Exchange.sol. However, this variable cannot be modified and, hence, it could be made immutable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.12   _getWipeDart() Returns art When Closing", "body": "  _getWipeDart()  is  used  in  MultiplyProxyActions.wipeAndFreeGem()  to  determine  the amount for dart to be passed to frob(). For closing operations, the intention is to wipe the whole art of the  urn  and,  thus,  calling  _getWipeDart()  creates  an  overhead  in  computation  as  it  will  return  the whole  art  of  the  urn.  The  actual  value  would  be  available  even  before  calling  wipeAndFreeGem().  Oazo Apps Limited - Multiply -   16  DesignLowVersion1AcknowledgedDesignLowVersion1CodePartiallyCorrectedDesignLowVersion1Acknowledged                        \fWhen closing a vault, immediately before the call to wipeAndFreeGem() the ink of the urn is querried from the vat:  (uint256 ink, ) = IVat(vat).urns(cdpData.ilk, urn);  Note  that  the  second  return  value,  the  art  of  the  urn  is  dropped.  Hence  the  value  would  be  available without any meaningful extra gas overhead. Therefore, the cases of wiping some and wiping all art when freeing gem could be distinguished, as it is similarly done in the DSS Proxy Actions contract, to reduce the gas cost of multiply closing actions.  Acknowledged:  Client  responded  that  they  want  to  remain  consistent  with  the  original  Proxy  Actions  in  the  Maker Protocol and refers to the DssProxyActions contract.  vault)  one  would  already   In  the  function  of  DssProxyActions  refered  to,  wipeAllAndFreeETH  is  public  and  works  with  the arguments passed. In MultiplyProxyActions, wipeAndFreeGem is an internal function. Depending on the call path one already knows whether it's a full or partial wipe. Notably in the case of a full wipe (closure of the  to (uint256 ink, ) = IVat(vat).urns(cdpData.ilk, urn); (where the returned value for art is  currently  ignored).  Note  that  the  original  Proxy  Actions  contract  implements  two  different  functions wipeAllAndFreeGem()  Actions, wipeAllAndFreeGem()  queries  vat.urns()  for  dart  while  in  MultiplyProxyActions  this  call  is already  made  in  the  function  calling  wipeAndFreeGem()  so  the  identical  functions  cannot  but  the concept could be reused.  wipeAndFreeGem().   for  dart  due   the  amount   original   Proxy   know   and   call   the   the   In   to   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.13   transfer Is Used for ETH Transfers", "body": "  Solidity  offers  different  options  to  perform  ETH  transfers.  When  performing  a  decrease  action withdrawing  collateral,  MultiplyProxyActions  receives  ETH  in  return  for  the  WETH  withdrawn  from  the vault in function _withdrawGem(). In the same function, the solidity transfer feature for sending ETH from the MultiplyProxyActions contract to the user. As transfer sends a fixed gas cost along with the funds, it is assumed that EVM gas costs remain constant in the future. Note that gas costs have change in  the  past,  which  has  led  to  issues  with  the  use  of  transfer.  Hence,  possible  integration consequences need to be considered.  Risk accepted:  Oazo Apps Limited replied:  Malfunction requires Ethereum hard fork. We will update the contract if that occurs.  Oazo Apps Limited - Multiply -   17  DesignLowVersion1RiskAccepted          \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  0  7  10  -Severity Findings  -Severity Findings  -Severity Findings   withdrawCollateral Is Added to borrowCollateral    Disabled Optimizer   Impossible Decrease Operations   Incorrect Decimals When Handling Collateral    Unclear Parameter Specification    Undocumented Public Functions   feeRecepient of AddressRegistry   -Severity Findings   Cannot Update Fees    Specification Mismatches    Unused Constant    skipFL Case in Flashloan Callback    Code Duplication    No Check on Amount Received From Flash Loan    Possible Casting Overflow    Unnecessary transferFrom    Use Available Constant and Avoid Call   increaseMultipleDepositDai Is Payable   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.1   withdrawCollateral Is Added to", "body": " borrowCollateral  In the updated specification received after the intermediate report, borrowCollateral is specified as follows:  If a Multiply decrease action: the amount of collateral that is needed to decrease multiple (it includes the ``withdrawCollateral`` amount if any is specified).  Oazo Apps Limited - Multiply -   18  CriticalHighMediumSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion2Speci\ufb01cationChanged            \fThat  implies  that  borrowCollateral  already  includes  withdrawCollateral.  However,  in  function _decreaseMP  the  amount  of  collateral  to  draw  from  the  vault  passed  to  wipeAndFreeGem()  is computed as follows:  cdpData.borrowCollateral.add(cdpData.withdrawCollateral)  Thus, withdrawCollateral is accounted twice and wipeAndFreeGem() will exit more collateral than intended.  Specification changed:  The  documentation  has  been  updated  and  no  longer  states  that  borrowCollateral  includes withdrawCollateral.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.2   Disabled Optimizer", "body": "  The solidity optimizer has been disabled in the hardhat configuration:  solidity: \"0.7.6\",     settings: {         optimizer: {             enabled: false,             runs: 1000      } },  The optimizer reduces both code size (thereby deployment costs), and execution costs.    The optimizer was enabled.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.3   Impossible Decrease Operations", "body": "  wipeAndFreeGem()  is  used  in  each  decrease  operation  to  withdraw  collateral  from  the  vault  to  the MultiplyProxyActions contract. However, the function reverts if the collateral has less than 18 decimals.  function wipeAndFreeGem(     address manager,     address gemJoin,     uint256 cdp,     uint256 borrowedDai,     uint256 collateralDraw ) public {     ...     uint256 wadC = convertTo18(gemJoin, collateralDraw);     IManager(manager).frob(cdp, -int256(wadC), _getWipeDart(vat, IVat(vat).dai(urn), urn, ilk));     IManager(manager).flux(cdp, address(this), wadC);     IJoin(gemJoin).exit(address(this), wadC); }  Oazo Apps Limited - Multiply -   19  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \fFollowing scenario could occur if the collateral is GUSD which has only two decimals.  1. Parameter collateralDraw is converted to 18 decimals representations which is stored in local  variable wadC. Meaning that wadC == collateralDraw * (10**16).  2. frob and flux are called with wadC as part of the argument.  3. GemJoin.exit() is also called with wadC as an argument.  4. In  GemJoin  contract's  exit(),  the  GemJoin  contract  will  try  to  call  the  GUSD  contract  to  transfer  wadC tokens.  5. The  transaction  reverts  since  wadC  is  much  higher  than  the  balance  in  GUSD  of  GemJoin  at  that  moment.  Since exiting creates a transfer in the GUSD contract, it must use the amount of decimals the token has.    collateralDraw instead of wadC is now passed to the call to gemJoin.exit() which is in the correct unit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.4   Incorrect Decimals When Handling Collateral", "body": "  The  functions  _closeWithdrawCollateralSkipFL  and  _closeWithdrawCollateral  receive multiple inputs including the ink of the relevant urn. The ink value has previously been queried from the vat. The ink value is then used as follows:  require(   IERC20(exchangeData.fromTokenAddress).approve(address(exchange), ink),   \"MPA / Could not approve Exchange for Token\" );  The ink value, however, has been adjusted to 18 decimals and hence will be incorrect here for all tokens that do not have 18 decimals.  Note that for the functions _closeWithdrawCollateral and _closeWithdrawDai the ink value is also incorrectly passed to wipeAndFeeGem.    The  updated  implementation  now  passes  cdpData.borrowCollateral  instead  of  ink  when  calling _closeWithdrawCollateralSkipFL and _closeWithdrawCollateral. Inside the called function this parameter is called ink. Althrough this solution technically works, it is not ideal:   Note   that  both   functions  already  cdpData.borrowCollateral separately is redundant.  take   the  struct  cdpData  as  parameter,  so  passing   The  call  to  token.approve()  remains  unchanged.  The  exchange  is  approved  to  transfer  the amount ink (which now is cdpData.borrowCollateral) however the amount the exchange will transfer is exchange.fromTokenAmount.  Risk accepted:  Refactoring / improvements are planned after the MVP.  Oazo Apps Limited - Multiply -   20  CorrectnessMediumVersion1CodeCorrected        \ffor  collaterals  with  non  18  decimals  has  been  uncovered   An  additional  problem  in _closeWithdrawCollateralSkipFL()  after  the  draft  report:  wipeAndFreeGem()  expects  the collateral  amount  in  the  unit  of  the  collateral  token  and  converts  it  to  the  18  decimal  representation. However in _closeWithdrawCollateralSkipFL this conversion is already done before the second call to wipeAndFreeGem(), hence the conversion will happen twice and result in an incorrect value for collaterals with less than 18 decimals. This has been correct by removing the conversion before the call to wipeAndFreeGem().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.5   Unclear Parameter Specification", "body": "  There  are  several  input  parameters  to  each  call.  These  are  passed  in  three  different  structs: ExchangeData,  CdpData,  AddressRegistry.  Some  definitions  of  the  parameters  of  the  strucs  are unclear and may lead to mistakes.   borrowCollateral  is  specified  to  be  the  collateral  to  buy  with  the  flashloan  in  increase operations.  However,  it  is  used  differently.  More  precisely,  it  is  used  in  function  _decreaseMP  to specify how much collateral to be withdrawn from the vault. The frontend may create mistakes. If the intention  of  borrowCollateral  is  to  be  used  as  the  amount  that  will  be,  together  with depositCollateral,  deposited  to  the  vault,  then  with  positive  slippage,  joinDrawDebt  would deposit too much collateral into the vault.   depositCollateral  is  specified  to  be  the  amount  of  collateral  the  user  deposits  in  increase actions that deposit collateral. For ETH that is not the case since msg.value is used and no check if  it  equals  depositCollateral  is  done.  The  call  will  work  but  the  result  may  differ  from  the expected behaviour.   fromTokenAmount is specified to be the amount of tokens to be exchanged. depositDai is the amount of DAI that should be exchanged jointly with the flashloaned DAI in increase operations. In _increaseMP in the call to swap the tokens to collateral, the to be swapped amount is specified as the  sum  of  fromTokenAmount  and  depositDAI.  However,  according  to  specification, fromTokenAmount should already be accounting for the deposit.   Depending on what the intended use of the parameters is, specifying invariants could be helpful to clarify  for  example  whether  the  fromTokenAmount  in  increase  operations  is  the  sum  of  the flashloaned and deposited DAI.  Clarifying  these  and  similar  ambiguities  may  help  users  to  understand  the  parameters  of  their transactions better.  Specification changed:  The parameters are now more precisely defined.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.6   Undocumented Public Functions", "body": "  Function wipeAndFreeGem of the MultiplyProxyActions contract is public. The function is only used internally and there is no valid use case to call it directly. Direct calls to this function will likely fail due to preconditions not being met. Furthermore the documentation does not list it as one of the public functions.  Similarly _collectFee() of the Exchange contract is public despite being used only internally. Here as well the documentation does not list _collectFee() as public function.  Oazo Apps Limited - Multiply -   21  DesignMediumVersion1Speci\ufb01cationChangedDesignMediumVersion1CodeCorrected                \f  The functions are now internal.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.7   feeRecepient of AddressRegistry", "body": "  In  the  last  paragraph  of  section  Architectural  decisions  of  the  specification  document  it's mentioned  that  the  feeRecipient  is  part  of  the  off-chain  registry  (the  struct  AddressRegistry passed as function parameter):  A caveat that has been raised is that using an off-chain registry managed by the frontend opens for other frontends using our smart contract while passing their own fee wallet address in the params.  This struct features a field feeRecepient:  struct AddressRegistry {     address jug;     address manager;     address multiplyProxyActions;     address aaveLendingPoolProvider;     address feeRecepient;     address exchange; }  However  in  the  smart  contracts  reviewed,  this  field  is  never  read.  The  exchange  contract  uses  a feeBeneficiary variable set in the constructor.    feeRecepient was removed from the struct.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.8   Cannot Update Fees", "body": "  In version two, setFee() was introduced to enable updating the fee variable for fees going to Oazo. The caller must be authorized. However, the only authorized caller is the MultiplyProxyActions contract which does not call setFee() and, hence, the fees cannot be update.    The feeBeneficiary is now also whitelisted and can set fees.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.9   Specification Mismatches", "body": "  Oazo Apps Limited - Multiply -   22  CorrectnessMediumVersion1CodeCorrectedDesignLowVersion2CodeCorrectedDesignLowVersion2Speci\ufb01cationChanged                        \fIn  version  two,  new  parameters  to  the  CdpData  struct  were  introduced.  However,  the  methodName element in the struct is unspecified in the documentation while it is used in the code.  Specification changed:  methodName was added to the documentation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.10   Unused Constant", "body": "  In MultiplyProxyActions, a constant ETH_ADDR is defined. However, it is not used in the code.    The constant was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.11   skipFL Case in Flashloan Callback", "body": "  Function  executeOperation  is  the  callback  for  the  Aave  flashloan.  It  is  not  intended  to  be  used  if flashloans are not utilized.  The following code snipped can be found at the end of the function:  if (cdpData.skipFL == false) {   IERC20(assets[0]).approve(     address(getAaveLendingPool(addressRegistry.aaveLendingPoolProvider)),     borrowedDaiAmount   ); }    The code was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.12   Code Duplication", "body": "  When  crafting  the MultiplyProxyActions  contract  have  the  same  code.  This  code  duplication  could  be  removed  by moving the respective code into an internal function.  flashloan  contract,  multiple   to  and  calling   functions  of   the  call   the     The common parts have been extracted into a function takeAFlashLoan.  Oazo Apps Limited - Multiply -   23  DesignLowVersion2CodeCorrectedDesignLowVersion2CodeCorrectedDesignLowVersion1CodeCorrected                        \f7.13   No Check on Amount Received From Flash Loan  The documentation specifies following check on the amount received from the flash loan:  We check in our smart contract whether the delivered amount matches our expected amounts. If not enough funds are delivered we revert the transaction with the message: \u201cFL malfunction\u201d.  However, this check is not made. Moreover, that could allow a malicious Aave to send less funds than requested. Performing an increase operation with personal DAI besides the flashloan may lead to Aave being paid more if the front-end does not set parameters such that this transaction would revert. In any case, there is a mismatch between documentation and implementation.  A require statement has been added to check whether sufficient funds have been received:  require(   cdpData.requiredDebt == IERC20(DAI).balanceOf(address(this)),   \"requested and received amounts mismatch\" );  However note that this require statement now breaks increaseMultipleDepositDai() for the case when  a  flashloan  is  used:  The  DAI  amount  to  deposit  has  already  been  transferred  onwards  to MultiplyActionsProxy, this amount will be included in the in the DAI balance and hence the balance will not equal the flashlaon amount. The transaction will revert.    The check has been changed to:  require(   cdpData.requiredDebt.add(cdpData.depositDai) <= IERC20(DAI).balanceOf(address(this)),   \"requested and received amounts mismatch\" );  For  the  final  version  of  the  code  the  strict  requirement  for  equality  has  been  weakened  to  allow  for surplus DAI balance at the contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.14   Possible Casting Overflow", "body": "  In  function  wipeAndFreeGem  it  is  necessary  to  cast  the  amount  of  collateral  to  be  withdrawn  from uint256  to  int256  so  it  can  be  passed  as  an  argument  when  calling  frob()  on  the  manager.  The cast  can  overflow  since  it  is  using  a  regular  cast  and,  hence,  frob()  could  be  called  with  wrong parameters. Instead, toInt256() could be used since it reverts if overflows occur.    toInt256() is now always used for casting from uint256 to int256.  Oazo Apps Limited - Multiply -   24  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f7.15   Unnecessary transferFrom  In function wipeAndFreeGem the MultiProxyActions contracts transfers DAI from itself to itself.  IDaiJoin(DAIJOIN).dai().transferFrom(address(this), address(this), borrowedDai);  As this call does not modify any DAI balance, it could be removed to save gas.    The call was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.16   Use Available Constant and Avoid Call", "body": "  In MultiplyProxyActions.wipeAndFreeGem() DAI is handled as follows:  IDaiJoin(DAIJOIN).dai().transferFrom(address(this), address(this), borrowedDai); IDaiJoin(DAIJOIN).dai().approve(DAIJOIN, borrowedDai);  Instead of using the DAIJOIN address and calling it repeatedly to query the DAI address, the constant DAI representing the address of the DAI contract could be used directly.    The constant DAI is now used directly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.17   increaseMultipleDepositDai Is Payable", "body": "  The system allows users to deposit additional DAI that will be, along with the flash-loaned DAI, swapped to the underlying collateral to enable increasing the leverage position. This functionality is implemented in the payable function increaseMultipleDepositDai. However, this method does not require having any additional ETH collateral and, thus, ETH could be mistakenly transferred to the contract executing the delegatecall to MuliplyProxyActions.    In the updated code increaseMultipleDepositDai is no longer payable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "7.18   transferFrom Used Instead of transfer", "body": "  In function _collectFee of Exchange.sol, IERC20(asset).transferFrom(address(this), fe eBeneficiaryAddress,   feeToTransfer)   simplified   could   be   to  Oazo Apps Limited - Multiply -   25  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedNoteVersion1CodeCorrected                            \fIERC20(asset).transfer(feeBeneficiaryAddress,  feeToTransfer).  transfer()  could be safer to use if, at any point in the future, Oazo decides to accept other tokens than DAI for fees, even though this is currently not the case nor is it planned for the future. For example, that call would revert if asset was USDT which reverts if the contract has not approved itself in such a scenario.    The code was changed to use safeTransfer().  Oazo Apps Limited - Multiply -   26  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  Hence,  the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead,  they  should  raise  awareness  in  order  to  improve  the  overall  understanding  for  users  and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "8.1   Deprecated safeApprove", "body": "  In function swap of the Exchange, safeApprove() is called. However, a deprecated implementation of safeApprove() is used. Be aware that using the most recent implementation, safeApprove() may revert if the approval has not been set to zero.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "8.2   Documentation Treats Should as Must", "body": "  The documentation uses should when describing what values the parameters passed from the frontend to the backend will have.  RFC 2119 defines should as follows:  SHOULD This word, or the adjective \"RECOMMENDED\", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.  For example, following exchange parameter is defined as follows in the documentation:  allowPartialFill  -  Value  should  be  set  to  false  in  order  to  ensure  that  the  whole  amount  is swapped, otherwise the tx will fail.  That allows allowPartialFill to be true in certain scenarios. However, it could be dangerous to set this value to true since in _closeWithdrawDai() the contract swaps collateral for DAI and does not check whether there is some unswapped collateral returned from the exchange. Hence, users could lose funds. Clarifying how parameters are set clearly may help avoid mistakes.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "8.3   Gas Costs Vs Flashloan Fee", "body": "  MultiplyProxyActions  uses  a  flashloan  to  leverage  the  exposure  of  the  collateral  in  one  action. There is an implicit assumption that the fee for the flashloan is less than what the gas costs would be to reach  the  same  multiply  ratio  by  using  the  borrowed  dai  to  buy  collateral  and  to  borrow  additional  dai repeatedly.  For  very  large  amounts  the  flashloan  fee  may  exceed  the  gas  cost  and  using  the MultiplyProxyActions may be more expensive than doing the actual steps repeatedly.  Oazo Apps Limited replied:  From our experience in implementing a Multiply solution using repeated actions on Vaults we do not believe this approach to be feasible from a practical point of view. Further, going forward we expect to integrate to several flash loan providers and we expect the flash loan fee to go towards zero.  Oazo Apps Limited - Multiply -   27  NoteVersion1NoteVersion1NoteVersion1          \f8.4   No Checks on Outcome  The MultiplyProxyAction smart contract does not check the actual outcome of an action on a vault. However,  the  execution  highly  depends  on  the  front-end  and  the  APIs  it  interacts  with  and  has  much interaction with external contracts. In such systems, there is typically an optional feature enabling users to enforce certain postconditions such as a minimum collateralization ratio or other similar properties in order to safeguard their actions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "8.5   Opposite Effect of What the Function Name", "body": " Suggests Possible  Note that while in general increaseMultiple... increases and decreaseMultiple... decreases the leverage of a vault, due to the added possibility of adding or withdrawing within the same action the final collateralization ratio / leverage may be changed in the opposite direction to what the function name increase/decrease suggested.  The documentation does not describe this behavior in detail.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "8.6   Whitelisted Contracts for Exchange Not Public", "body": "  In Exchange.sol, there is an internal mapping WHITELISTED_CALLERS specifying which contracts can use the Exchange contract. Since currently only the MultiplyProxyActions will be set in the constructor, it is  relatively  simple  to  decide  whether  a  contract  is  whitelisted  or  not.  However,  in  the  future  more contracts may be whitelisted. Thus, making this mapping public could be useful.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "8.7   CDPManager Must Have Created Vault", "body": "  The  MultiplyProxyActions  contract  is  only  compatible  with  vaults  that  have  been  opened  through the  CDPManager.  Vaults  that  have  been  opened  directly  are  not  supported  as  the  CDPManager  is unable to acquire permission to modify the vault. The documentation is vague on this topic and may be clarified.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "8.8   closeVaultExitCollateral Surplus DAI", "body": " Transferred to fundReceiver  Function  closeVaultExitCollateral  of  the  MultiplyProxyActions  contracts  can  be  used  to close  a  vault  and  exit  all  funds  in  collateral  to  the  fundReceiver  address.  A  part  of  the  collateral  is necessary  to  repay  the  flashloan  and  hence  is  exchanged  into  DAI.  Note  that  should  there  be  surplus  Oazo Apps Limited - Multiply -   28  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                    \fDAI tokens after the exchange, these are transferred to the fundReceiver address in addition to the collateral.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "8.9   msg.value Unchecked for ERC-20 Deposits", "body": "  In  function  increaseMultipleDepositCollateral,  collateral  is  deposited.  msg.value  should  be non-zero  if  the  collateral  to  lock  in  the  vault  will  be  WETH.  However,  it  could  also  be  non-zero  if  the collateral  is  a  ERC-20  token.  The  ETH  sent  along  with  the  ERC-20  will  be  unused  will  remain  in  the contract after the transaction has finished.  Oazo Apps Limited - Multiply -   29  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-smart-contracts/"}, {"title": "6.1   Unused Import", "body": "  In the Lido rate provider, ERC4626 is imported and never used.  CS-YRNPR-001  Yearn - yETH Periphery -   10  InformationalVersion1  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-periphery/"}, {"title": "7.1   Implementation Might Change for Proxies", "body": "  Multiple  rate  providers  are  proxy  contracts.  Their  implementation  might  change.  In  consequence, incorrect rate updates or reverts might happen. Constant monitoring and updates as well as contact with the development teams of the corresponding projects might be useful for mitigation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-periphery/"}, {"title": "7.2   Providers Might Revert Instead of Returning", "body": " Values  When the total amount of staked tokens is null, providers behaviours can vary, some of them will return a rate of 1 to 1 with ETH while other will revert. Such a corner case should be carefully evaluated.  Yearn - yETH Periphery -   11  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-periphery/"}, {"title": "6.1   Gas Optimizations", "body": "   The state variables _name, _symbol and _decimals could be declared as constants. As a result, the compiler does not reserve a storage slot for these variables, and every occurrence is replaced by  the  respective  value.  Compared  to  regular  state  variables,  the  gas  costs  of  constant  and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to  all  the  places  where  it  is  accessed  and  also  re-evaluated  each  time.  This  allows  for  local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if  they  would  fit  in  fewer  bytes.  Due  to  this,  constant  values  can  sometimes  be  cheaper  than immutable values. (see Solidity docs)  CS-FRTK-001  recipient.  Because    _transfer() does not need to use safeMath when modifying the _balances of the sender and the  in detectTransferRestriction()  to  ensure  sufficient  funds  for  the  transfer.  And  the  recipient's balance is always less or equal to totalSupply, in case totalSupply does not overflow during minting, the recipient's balance will never overflow.  sender's   checked   balance   already   been   has   the    _mint() does not need to use safeMath when updating _balances[account]. The balance of any  account  is  always  less  or  equal  to  totalSupply.In  case  the  previous  update  to _totalSupply does not overflow, _balances[account] will not overflow as well. This applies to the updates of _totalSupply in _burn() as well.   The  check  of  onlyOwner  is  redundant  for  internal  function  _mint(),  because  _mint()  is  only called by the external function mintTo(), which is already marked with modifier onlyOwner. This applies to the internal function _burn() as well.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/firetoken-smart-contracts/"}, {"title": "6.2   Indexed Fields of Events", "body": "  The events Burn, Mint, Block and Unblock do not mark the field code as indexed. Indexing fields in events allows to easily search for certain events. code is not a random number but is a limited set and could be indexed.  CS-FRTK-002  Fire Group Ltd. states:  The field code is more an add-on-info for the reason of events. At the time of writing the contract, searching based on codes seemed not to be a requirement. Thus, it was decided to not index the code part of the event.  Fire Group Ltd. - Firetoken -   10  InformationalVersion1InformationalVersion1        \f6.3   Missing Events of KYC Roles Updates  The  contract  owner's  call  to  addUserListToKycRole()  and  removeUserFromKycRole()  will update the KYC roles, nevertheless, no events will be emitted to reflect the storage modification.  CS-FRTK-003  Fire Group Ltd. states:  KYC data is stored off-chain while executing the KYC processes. Thus, it was decided to not emit events for adding and removing KYC roles as this information is available off-chain.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/firetoken-smart-contracts/"}, {"title": "6.4   Redundant Transfer Restriction", "body": "  Without specifications it is unclear if address(0) is an address that has transfer restrictions in the _kyc set or not. In case it does have transfer restrictions and is not part of the set, the requires in _transfer are redundant.  CS-FRTK-004  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/firetoken-smart-contracts/"}, {"title": "6.5   Unused Variable _propertyAmountLocks", "body": "  The contract defines a state variable called _propertyAmountLocks but it is not used.  CS-FRTK-005  Fire Group Ltd. - Firetoken -   11  InformationalVersion1InformationalVersion1InformationalVersion1          \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/firetoken-smart-contracts/"}, {"title": "7.1   No Way to Recover ETH or Token Sent to the", "body": " Contract  The  contract  has  no  functionality  to  recover  ETH  or  token  sent  to  the  contract.  All  funds  sent  to  the contract will be locked forever.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/firetoken-smart-contracts/"}, {"title": "7.2   Reserve Code <100 for Contract Internal Use", "body": "  When  the  owner  inserts  a  new  code  into  the  mapping,  the  code  is  required  to  be  larger  than  100. Whereas only less than 6 are used in the constructor, the rest are unused.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/firetoken-smart-contracts/"}, {"title": "7.3   Unusual Decimals", "body": "  The  token  has  only  5  decimals.  Most  contracts  have  18  decimals  which  is  the  standard  base  in  the Ethereum network. Many issues can arise when a token with other than 18 decimals shall be included in third party protocols. Hence, Fire Group Ltd. should carefully evaluate if it is necessary to use 5 decimals and state this very clearly everywhere (in-line documentation, online documentation, website and if other protocols are using the token) to mitigate future issues.  Fire Group Ltd. - Firetoken -   12  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/firetoken-smart-contracts/"}, {"title": "5.1   Gas Inefficiencies", "body": "  0  0  0  1  addExtraRewards  iterates  over  all  extra  reward  tokens  to  check  whether  the  rewardTokens  array contains them. However, the rewardTokens array is loaded from storage on every iteration. The gas consumption  could  be  reduced  by  caching  the  array  into  memory  or  using  a  set  like  data  structure  for checking whether a token is already present.  Acknowledged:  Avantgarde Finance replied:  We attempted implementing the suggested optimization, but rather than leading to savings, it led to inefficiencies in the most frequent case and a more complex code surface area. The case where Convex extra pool tokens are >1 is extremely rare (the vast majority of Curve pools have 0 or 1 extra rewards tokens), and the extra logic involved with copying `rewardTokens` into memory, validating that it is a unique set, etc makes the refactor more expensive rather than less in the vast majority of cases. For those rare cases, since `rewardTokens` is already accessed in the first loop, all SLOAD operations are already warm lookups, so the gas hit isn\u2019t significant.  Avantgarde Finance - Sulu Extensions II -   10  SecurityDesignCriticalHighMediumLowAcknowledgedDesignLowVersion1Acknowledged            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Potential Reentrancy   0  0  0  1  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ii/"}, {"title": "6.1   Potential Reentrancy", "body": "  Transfers  modify  balances  of  users.  Hence,  checkpointing  is  required  to  be  performed  before  any balances  modification  to  ensure  fair  distribution  of  rewards.  However,  transfer  functions  are  not reentrancy-protected which offers the following attack vector:  1. Assume a Convex pool staking wrapper contract where one user holds 50 out of 100 tokens while no rewards have been earned so far. Also assume that one reward token has an on-receive-hook to the recipient of the token.  2. Now,   the  attacker  contract  calls  claimRewardsFor()   itself. ___checkpointAndClaim is called internally which harvests the Convex pool and then proceeds to checkpointing and claiming with __updateHarvestAndClaim.  to  send   rewards   to   3. 100  reward  tokens  are  harvested.  The  total  and  the  user  integral  are  updated  accordingly.  The amount to transfer to the attacking contract is 50 reward tokens. However, the claimable amount is set to 0 in storage due to the transfer. Note, that lastCheckpointBalance is not updated.  4. The transfer starts and modifies the balance to 50 and then calls the attacking contracts  hook.  1. The  attacking  contract  reenters  the  wrapper  contract  in  the  reentereable  transfer()  function inherited from ERC20.  2. ___checkpoint   is  called.  Harvesting  Convex  has  no  effect  but  now  __updateHarvest is called.  3. The last checkpointed balance (still 0) and the current balance (now 50) are queried. The  difference implies more rewards.  4. Now, the integrals are updated and so is the claimable amount is now set to 25 for the  attacking contract. The checkpointed balance is now set to 150.  5. The  execution  returns  and  nothing  happens  since  the  checkpointed  balance  is  equal  to  the  balance. No event is emitted.  6. The attacking contract claims his claimable amount. Totally, the attacking contract has claimed 75  instead of 50 reward tokens.  Ultimately,  accounting  issues  occur  since  there  are  less  rewards  available  than  expected.  Also,  some user will potentially not be able to withdraw their LP tokens due to impossible transfers.  Avantgarde Finance - Sulu Extensions II -   11  CriticalHighMediumLowCodeCorrectedSecurityLowVersion1CodeCorrected        \fEven though we specify reward tokens to be regular ERC-20 tokens, it could be possible that, since the future is unforeseeable, ERC-777 tokens could be added as rewards, which would open up such attack vectors. Hence, the underlying issue is that the Checks-Effect-Interaction design pattern is not followed.    The  nonReentrant  modifier  was  added  to  _transfer.  Hence,  all  entrypoints  that  perform checkpointing  are  protected  from  reentrancy.  Additionally,  all  checkpointing  variables  were  made private.  Hence,  more  derived  contracts  are  protected  from  reentrancy  attack  vectors  modifying checkpointing state.  Avantgarde Finance - Sulu Extensions II -   12  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-ii/"}, {"title": "5.1   Circumvention of Ramping", "body": "  The management account of Pool can initiate a change of asset weights or the amplification factor for a pool.  The  change  should  be  applied  slowly  to  minimize  profits  from  sandwiching  attacks,  see Sandwiching  Curve  changes.  However,  the  function  add_asset  allows  the  management  to  modify (reduce)  the  weights  of  assets  and  the  amplification  factor  by  avoiding  the  ramping  limitations  entirely. The natspec description of the function notes:  @dev Every other asset will have their weight reduced pro rata @dev Caller should assure that effective amplification before and after call are the same  Code partially corrected:  The function add_asset now sets an upper limit of 1% on the initial weight of the new asset being added to  the  pool.  Although  this  reduces  the  likelihood  of  accidentally  changing  the  weights  of  assets  Yearn - Yearn yETH -   11  SecurityDesignCorrectnessCriticalHighMediumCodePartiallyCorrectedLowAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedCodePartiallyCorrectedRiskAcceptedRiskAcceptedAcknowledgedAcknowledgedDesignMediumVersion1CodePartiallyCorrected             \fsignificantly, it does not enforce any restriction on the amplification factor (_amplification represents the  term  A  *  f^n  in  the  whitepaper).  Therefore,  management  should  consider  sandwiching  attacks when calling this function and carefully choose input parameters. The response of Yearn is:  Added a limit to the new asset weight, it is not allowed to exceed 1%. Since the `amplification` in the pool represents 'A * f^n', we cannot easily put bounds on the amplification factor. It is up to the management role to make sure the call cannot be sandwiched, either by picking a new amplification factor and initial weight (even lower than 1%) that minimises the effect or by first pausing the pool and in a separate call add the asset before unpausing.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "5.2   Decreasing Pool Value Through Rate Updates", "body": "  Big rate updates might drain value from the pool. Assuming a swap_fee of 0.3%, then a rate update of 1% (e.g. from 1.00 -> 1.01) seems already too big. Generally, it seems that any rate change twice as big as the swap_fee (so any rate change >= 0.6% for a swap_fee of 0.3%) leads to this issue.  We provide an example with three assets. In the beginning, everything is balanced and the rates are all ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "1.00. Now, the pool can lose value in the following way:", "body": "   The price of asset 2 in the market rises from 1.00 -> 1.01   Assuming  an  efficient  market,  trades  happen  inside  the  pool  which  imbalance  the  pool  so  that get_dy(2, 0, 10**18) == get_dy(2, 1, 10**18) == 1.01 * 10**18. (If such trades do not happen an attacker can front-run the rate update with such trades.) Here the pool is selling asset 2 too cheaply.   Now the rate update is performed, setting the rate of asset 2 from 1.00 -> 1.01.   As  a  consequence,   (and asset 2 => asset 0), will now go to roughly 1.02. The pool is paying too much to obtain asset 2.  from  asset  2  =>  asset  1   the  pool's  exchange   rate    Therefore an attacker trail-runs the rate update and sells asset 2 to the pool.   Eventually, the price of asset 2 goes back down from 1.01 -> 1.00.   Again  trades  happen  which  change  the  balance  of  the  pool  so  that  it  has  a  1:1  exchange  ratio  between the assets. Here the attacker or others sell asset 2 to the pool.   Now the rate update is performed, setting the rate of asset 2 from 1.01 -> 1.00.  As a consequence, the pool's exchange rate is so that asset 2 can be bought too cheaply. Hence, the attacker  buys  asset  2  cheaply.  After  all,  trades  are  settled,  the  pool  has  fewer  funds  than  at  the beginning.  In  this  example,  they  might  have  lost  0.3%  of  value.  As  a  consequence,  the  balance  in  the Staking contract is now smaller, even though all prices are the same as in the beginning.  Generally, the significance of this issue depends on different parameters, like number of assets, weights and amplification factor. In some configurations, it will be more severe than in others. A combination of smaller, parallel rate updates for different assets might also be problematic.  Acknowledged  Yearn  is  aware  of  the  issue  and  acknowledges  it.  They  will  take  care  to  mitigate  it  by  only  using high-quality rate providers that return the backing rate on the beacon chain which they assume will not fluctuate  much  to  be  an  issue.  Additionally,  these  oracles  are  assumed  to  be  not  influenced  by  the market. Yearn emphasized that every oracle will be rigorously tested and simulated before being used.  Yearn - Yearn yETH -   12  DesignLowVersion1Acknowledged        \f5.3   Guardian Can Front-Run Kill Command  The guardian role in contract Pool can set or unset the paused flag, while only management can set the  flag  killed  to  true.  For  the  function  kill  to  execute  successfully,  the  flag  paused  should  be true. Therefore, guardian can prevent the execution of function kill by frontrunning the transaction with a call to function unpause.  Acknowledged:  Yearn  acknowledges  the  risk  of  frontrunning  and  accepts  the  consequences  of  the  attack  with  the following  reasoning:  \"In  the  unlikely  case  the  guardian  decides  to  grief  by  front-running  such  a  call, management has the option to replace the guardian\".  We  want  to  note  that  the  replacement  of  the  guardian  can  also  be  front-run  by  the  guardian  as set_guardian can be called by both roles.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "5.4   Implementation Mismatch With ERC-4626", "body": "  The  contract  Staking  implements  the  external  functions  specified  in  the  standard  ERC4626.  The implementation  of  functions  maxWithdraw  and  maxRedeem  is  not  in  line  with  the  standard.  Both functions return max_value(uint256), but the standard for maxWithdraw (similarly for maxRedeem) states:  MUST return the maximum amount of assets that could be transferred from ``owner``  through ``withdraw`` and not cause a revert, which MUST NOT be higher than the  actual maximum that would be accepted (it should underestimate if necessary).  MUST factor in both global and user-specific limits, like if withdrawals are  entirely disabled (even temporarily) it MUST return 0.  Code partially corrected:  Both functions have been updated in  can be withdrawn or redeemed by address _owner.   to return the maximum amount of assets or shares that  However,  the  special  case  when  totalSupply  cannot  be  less  than  MINIMUM_INITIAL_DEPOSIT  is not handled correctly. Therefore, it is possible that both functions maxWithdraw and maxRedeem return non-zero values, while the respective functions withdraw and redeem could revert, which violates the standard.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "5.5   Inefficient Initial Approximation Value for Pi in", "body": " Supply Calculation  Yearn - Yearn yETH -   13  SecurityLowVersion1AcknowledgedCorrectnessLowVersion1CodePartiallyCorrectedVersion3DesignLowVersion1Acknowledged                        \fWhen  a  rate  change  or  balance  change  occurs,  the  starting  value  for  pi  (vb  product),  to  later approximate the supply, is:  vb_prod * self._pow_up(prev_rate * PRECISION / rate, wn) / PRECISION  or  vb_prod_final * self._pow_up(prev_vb * PRECISION / vb, wn) / PRECISION  The result of this calculation is then passed into _calc_supply. In _calc_supply an iterative method is used to approximate the correct supply. Starting with the result as the first guess for r in:  r = unsafe_div(unsafe_mul(r, sp), s)  The initial guess seems inefficient and almost always dominated by the old value for pi as starting value.  Acknowledged:  Yearn replied:  The value for pi needs to be updated somewhere before or during the iteration process, as otherwise the supply will not converge to the correct value. It might be possible to save on iterations by updating pi to the correct value after the first iteration, but such a change would significantly complicate the function and as such is deemed not worth it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "5.6   Missing Sanity Checks", "body": "  The following functions update important state variables but do not perform any sanity check on inputs.  Staking contract:  1. _asset in function __init__.  2. _fee_rate in function set_performance_fee_rate.  3. _management in function set_management.  4. _treasury in function set_treasury.  5.  6.  Pool contract:  : If _value is larger than current allowance, an underflow happens.  : _spender in functions that modify allowance.  7. _assets in function __init__ can include duplicate.  8. _duration in function set_ramp can be 0.  9. _rate_provider in function set_rate_provider.  10. _staking in function set_staking.  11. _guardian in function set_guardian.  12. _management in function set_management.  Yearn - Yearn yETH -   14  DesignLowVersion1CodePartiallyCorrectedVersion2Version2        \fCode partially corrected:  Missing sanity checks reported in the Staking contract have been added. Additionally, the same checks were applied in the Token contract. In the Pool contract sanity checks for points 10 and 12 were added. The sanity check for _guardian (point 11) is intentionally left out to allow for flexibility of burning the role in the future.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "5.7   Possible to Frontrun the First Deposit in Pool", "body": "  The first liquidity provider in a pool does not pay any fee. Other liquidity providers do not pay a fee only if they deposit tokens in the same ratio as the current state of the pool. If a user adds liquidity into a pool in an unbalanced manner (e.g., single token or with different ratios from the current state), a fee is payed.  An attacker can frontrun the first deposit to add tokens in a pool in a wrong ratio such that the victim user pays high fees. The fees are sent to the Staking contract and can be claimed after a delay by users that have  staked  their  yETH.  The  profits  of  the  attacker  depend  on  the  amount  of  tokens  deposited  by  the victim  and  the  share  of  yETH  staked  by  the  attacker  at  the  time  rewards  (includes  fee)  move  to unlocked bucket in Staking contract.  Risk accepted:  Yearn replied:  This is acceptable behaviour, and can be mitigated by setting a very tight value for the minimum amount of tokens received for the initial deposit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "5.8   Possible to Update Ramp Step While Ramping", "body": "  The  function  set_ramp_step  sets  a  new  ramp_step  without  checking  if  there  is  currently  an  active ramp. Raising ramp_step while there is an active ramp increases the risks of sandwiching attacks (see Sandwiching Curve changes) as the _duration of ramping remains the same.  Risk accepted:  Yearn replied:  We\u2019d like to retain the option to increase the step size, even during a ramp. However, management should take care not to increase it to such a degree that it affects the sandwich risk in a significant way. This is in line with the responsibilities the management account already has. It has the ability to set the duration of a ramp, which suffers from the same consequences if not set properly  Yearn - Yearn yETH -   15  DesignLowVersion1RiskAcceptedCorrectnessLowVersion1RiskAccepted                  \f5.9   Violation of Sum of Weights  The  trading  curve  is  defined  by  a  function  that  assumes  that  the  sum  of  all  weights  in  a  pool  equals PRECISION  (100%).  However,  this  invariant  does  not  apply  always  as  the  weights  of  assets  change when: i) adding a new asset, ii) updating weights in a ramp. Therefore, it is possible that these dynamic changes of weights break the invariant due to rounding errors. For instance, current is rounded down in the following code:  if current > target:     current = current - (current - target) * span / duration else:     current = current + (target - current) * span / duration  Acknowledged:  Yearn acknowledges the issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "5.10   Voting Weight Increase Differs for New and", "body": " Existing Positions  Transferring  shares  to  a  position  increases  the  voting  weight  of  the  receiving  position.  For  the  same amount  of  shares  transferred,  the  new  voting  weight  depends  on  the  existing  state  of  the  receiver, namely variable Weight.t.  The picture below plots voting power where x-axis is the time and y-axis is the voting weight. The blue line  illustrates  a  position  that  has  staked  25  shares  for  a  long  time.  If  this  position  receives  25  more shares, its voting power will change over time as shown by the red dashed line.  However,  if  25  shares  are  sent  to  a  new  position,  its  voting  weight  increases  according  to  the  violet dashed  line.  The  green  line  shows  the  difference  on  the  voting  weight  after  new  tokens  are  received between  an  existing  position  (red  dashed  line)  versus  existing  position  and  new  position  that  receives tokens (blue line and violet dashed line). The plot suggests that receiving shares in new positions instead of existing ones maximizes the voting weight of a party.  Acknowledged:  Yearn - Yearn yETH -   16  CorrectnessLowVersion1AcknowledgedCorrectnessLowVersion1Acknowledged              \fYearn replied:  This is an acceptable side effect of our choice to have a asymptotically increasing weight function.  Yearn - Yearn yETH -   17    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  0  5  10  -Severity Findings  -Severity Findings  -Severity Findings  Incorrect Computation of Product Term    Missing Transfer of Tokens When Adding New Assets    Pool Might End up With Less Shares Than MINIMUM_INITIAL_DEPOSIT    Share Distribution Depends on First Deposit    Wrong Calculation of Voting Weight for Withdrawn Shares   -Severity Findings   Approve Can Be Frontrun    Default Target Weight   Incomplete Specifications for Paused Pool   Inconsistent Behavior of Conversion Function    Mismatch of Code With the Specification for Pending Rewards    Missing Slippage Protection When Adding New Asset    No Meaningful Revert Messages    Possible to Lock Management Role    Types of Variables in Weight    Unused Event in Staking   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.1   Incorrect Computation of Product Term", "body": "  The product term pi in the whitepaper depends on D, w_i and x_i. The function _calc_vb_prod takes as input _s which is the sum of tokens in the Pool and is different from D if the pool is not at equilibrium point.  This issue was found by Yearn also while the review was ongoing.    function  _update_weights  has  been  updated   The  _calc_vb_prod as follows:  to  pass  supply  when  calling   function  Yearn - Yearn yETH -   18  CriticalHighMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected           \fsupply: uint256 = self.supply if supply > 0:     vb_prod = self._calc_vb_prod(supply)  Furthermore, the function _calc_vb_prod_sum, which is called on first deposit or when adding a new asset, is revised to not take _s (sum term) as an input parameter.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.2   Missing Transfer of Tokens When Adding New", "body": " Assets  Function  add_asset  can  be  called  only  by  management  which  is  trusted  to  behave  correctly  in  the contract  Pool.  The  parameter  _amount  in  function  add_asset  is  the  amount  of  tokens  that  are deposited into the Pool when the new asset is added. However, the code does not pull the funds from an external  account  (if  approved)  or  check  that  the  Pool  has  already  the  required  balance  (if  already transferred).    The issue has been resolved by adding the code in function add_asset that pulls the respective tokens from msg.sender:  assert ERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.3   Pool Might End up With Less Shares Than ", "body": " MINIMUM_INITIAL_DEPOSIT  The  new  MINIMUM_INITIAL_DEPOSIT  amount  does  not  mitigate  that  a  user  manipulates  the  share amount to be very low before another user deposits or rewards are accounted.  A malicious user might deposit MINIMUM_INITIAL_DEPOSIT tokens but could immediately call redeem in  such  a  way  that  they  end  up  with  one  remaining  share.  This  breaks  the  assumption  that  the  pool always has a minimum amount of assets, which could have unintended side effects.    The  internal  function  _withdraw  has  been  updated  in    to  enforce  that  totalSupply  in  the contract Staking is either 0 or larger than MINIMUM_INITIAL_DEPOSIT. This restriction is implemented in the following code:  if total_shares < MINIMUM_INITIAL_DEPOSIT:     assert total_shares == 0  Yearn - Yearn yETH -   19  CorrectnessMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrectedVersion3                  \f6.4   Share Distribution Depends on First Deposit  The user's shares when depositing an amount of yETH are calculated as:  _assets * _total_shares / _total_assets  However, in the case of the first deposit, the number of assets deposited is the number of shares the user receives. In case a user deposits a very small amount (at best 1 WEI), they would receive 1 share. When the total assets increase because profits are made, the fraction _total_shares / _total_assets will become 0 for amounts smaller than _total_assets. Additionally, when adding assets, they need to  be  multiples  of  _total_assets.  Hence,  the  first  deposit  determines  the  minimum  step  size  or rounding error for the following deposits.  The was independently reported by Yearn while the review was ongoing.    implemented  a  practical   Yearn  specifying  a  minimum  deposit  amount MINIMUM_INITIAL_DEPOSIT of 1e15 which makes the attack unlikely in practice. However, we would like to highlight that the core issue is still present even with this practical mitigation. The issue arises only in case of a high discrepancy between the first deposit and the potential rewards which now should be higher by a factor of 1e15.  solution  by   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.5   Wrong Calculation of Voting Weight for", "body": " Withdrawn Shares  By depositing yETH into the Staking contract, users gain voting power that continuously increases over time.  The  voting  power  depends  on  the  amount  of  shares  a  user  has  and  the  time  they  have  been for  a  user:  weights  and deposited  previous_weights. weights track the latest state of a position, while previous_weight stores the state of the position in the week before latest changes.  the  contract.  The  contract  stores   two  checkpoints   in   The function vote_weight should consider previous_weights when the position is updated on the ongoing week. However, the code checks for two conditions as follows:  if weight.week > week or weight.week == 0:     weight = self.previous_weights[_account]  The  second  condition  is  true  for  users  that  have  withdrawn  or  transferred  out  all  their  shares.  In  this case, the code still considers their previous_weights and incorrectly computes a voting power based on the state of the position before its shares were removed. This can be exploited by attackers to create positions that gain voting power, and then move shares to a new position.  This issue was uncovered by Yearn also while the review was ongoing.  Code partially corrected:  : The internal function _update_account_shares has been revised to reset only field t when  an account withdraws all of its shares:  Yearn - Yearn yETH -   20  CorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrectedVersion2              \fif shares == 0:     t = 0     last_shares = 0  The function vote_weight checks if the position of an account has been updated on the ongoing week as follows:  if week > current_week or week == 0:     packed_weight = self.previous_packed_weights[_account]  The second condition week == 0 is true only for empty accounts, which should have a voting weight of 0 and there is no need to consider their previous state.    : The unnecessary check week == 0 has been removed from function vote_weight.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.6   Approve Can Be Frontrun", "body": "  The function approve in Staking contract is vulnerable to frontrunning attacks. The function approve always overwrites the current value without checking if the allowance has been consumed or not.  Assume  a  scenario  where  Alice  provides  an  allowance  of  value  X  to  a  spender.  Then,  she  decides  to change the allowance to a value Y. The spender can front-run the second transaction, spend X, and then spend the new allowance Y also. This attack vector and possible mitigations are discussed in EIP20.    increaseAllowance and decreaseAllowance functions were added. These functions are similar to approve  function,  but  they  do  not  overwrite  the  current  value.  Instead,  they  increase  or  decrease  the current value with a given delta.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.7   Default Target Weight", "body": "  The function weight in contract Pool returns 0 as the default target weight when no ramp is active:  if self.ramp_last_time == 0:     target = 0  Furthermore, the function add_asset does not set 0 as target weight although no ramp is active.    The  external  function  weight  has  been  updated  to  return  the  current  weight  of  an  asset  in  the  pool when there is no active ramp.  Yearn - Yearn yETH -   21  Version3SecurityLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                  \f6.8   Incomplete Specifications for Paused Pool  When a pool is paused no swaps can be executed. Furthermore, rate providers cannot be updated while the pool is in this state as _update_rates reverts. Specifications do not describe these behaviors.  The following functions cannot be executed when a pool is paused:   update_rates   update_weights   set_ramp   swap   swap_exact_out   add_liquidity   remove_liquidity_single   set_rate_provider  Specifications changed:  The specifications regarding pause mode have been extended in file specification.md.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.9   Inconsistent Behavior of Conversion Function", "body": "  External  view  functions  convertToShares  and  convertToAssets  return  the  input  value,  _assets and  _shares  respectively,  when  total_assets  is  0.  However,  on  the  same  conditions  (`` _total_assets  ==  0``)  both  internal  functions  _preview_deposit  and  _preview_mint  return  0. Therefore, depositing and minting in this scenario reverts.    Yearn corrected the code and both external functions are now in line with the internal ones.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.10   Mismatch of Code With the Specification for", "body": " Pending Rewards  The specifications of the contract Staking state:  If the balance has increased, it is added to the pending bucket. If one or more week has been missed, the increase is distributed instead over the three buckets fairly.  However, the function _get_amounts adds rewards to the streaming bucket if it is called on the first day of a new week:  Yearn - Yearn yETH -   22  CorrectnessLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                      \fif weeks == 1 and block.timestamp % WEEK_LENGTH <= DAY_LENGTH:     streaming += rewards  Specification changed:  Yearn added a more concise specification for this scenario:  If the first update of the week is in the first day, it is added to the streaming bucket directly instead.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.11   Missing Slippage Protection When Adding", "body": " New Asset  The management can add a new asset into a Pool by calling the function add_asset. The caller should send _amount tokens of the new asset to the pool, which increases the overall value of the Pool. The function mints the difference in the total supply (supply - prev_supply) as LP tokens to the address _receiver, however no slippage protection is implemented.    The function add_asset has been revised to take an additional argument _min_lp_amount as input and  now  explicitly  asserts  that  supply  has  strictly  increased  and  the  caller  receives  more  LP  shares than _min_lp_amount:  ... assert supply > prev_supply lp_amount: uint256 = unsafe_sub(supply, prev_supply) assert lp_amount >= _min_lp_amount PoolToken(token).mint(_receiver, lp_amount) ...  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.12   No Meaningful Revert Messages", "body": "  Reverts  could  emit  meaningful  messages  to  provide  the  reason  for  failed  calls.  The  downside  of informing  users  accordingly  is  the  slightly  increased  gas  costs.  Hence,  Yearn  needs  to  evaluate  if  a meaningful revert message should be returned.    Yearn added selected revert messages.  Yearn - Yearn yETH -   23  SecurityLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.13   Possible to Lock Management Role  Both  contracts  Staking  and  Pool  implement  the  function  set_management  that  allows  the  existing management  account  to  set  a  new  management  address.  As  management  is  responsible  for  setting multiple parameters of contracts, measures should be taken to avoid mistakes when updating it. Besides sanity  checks,  the  update  of  critical  roles  that  cannot  be  recovered  should  follow  the  set/accept approach.    Both  functions  were  changed  to  a  commit/accept  scheme  with  two  functions  set_management  and accept_management.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.14   Types of Variables in Weight", "body": "  The types uint16, uint56 and uint128 are used for variables of struct Weight. Together these values fit in a storage slot (256 bits). However, Vyper does not optimize storage used by packing together variables  that  fit  in  32  bytes.  As  each  value  is  stored  in  a  separate  storage  slot,  EVM  uses  additional operations to convert the value from 32 bytes to the correct type.    Yearn  added  a  custom  way  to  pack  the  variables  in  a  single  storage  slot  for  the  variables: previous_packed_weights  and  packed_weights.  This  optimization  on  the  storage  comes  with slighly added gas costs on execution due to packing and unpacking of variables in a single storage slot.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.15   Unused Event in Staking", "body": "  The event SetMinter in the contract Staking is not used.    The unused event has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.16   Functions Return True Always", "body": "  The natspec description for the return value of functions transfer and transferFrom states:  @return Flag indicating whether the transfer was successful  Both functions return only True, otherwise they revert.  Yearn - Yearn yETH -   24  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected                            \f  The natspec description for the return value has been updated: @return True.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.17   Missing Natespec", "body": "  A  majority  of  the  critical  logic  is  implemented  in  internal  functions.  In-line  documentation  and  proper natspec for all functions can significantly improve code readability to understand correctly the intended behavior of the code.    Natspec was added to all functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.18   Possible to Index Event Parameters", "body": "  It  is  recommended  to  index  the  relevant  event  parameters  to  allow  integrators  and  dApps  to  quickly search  for  these  and  simplify  UIs.  We  would  like  to  highlight  that  asset  could  be  indexed  in  the respective events.    The  parameter  asset  SetWeightBand.  is  now   indexed   in  events  Swap,  RemoveLiquiditySingle  and  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.19   Possible to Mark Functions as View", "body": "  Functions virtual_balance and rate in Pool do not modify the state and can be marked as view.    Both functions have been marked as view functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.20   Redundant Code in _Calc_Supply", "body": "  The code inside if/else branches in the function _calc_supply is redundant and could be removed if the delta between values s and sp is computed first.  Yearn - Yearn yETH -   25  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                        \f  The function _calc_supply has been revised to avoid the redundant code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.21   Return Values When Removing Liquidity", "body": "  The function remove_liquidity_single returns dx which is the amount of tokens being withdrawn for the target asset. However, the function remove_liquidity does not return any value.  Specification provided:  Yearn informed ChainSecurity that this was done intentionally as a gas saving measure, as otherwise it would need to construct and return an array of up to 32 values of type uint256.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "6.22   Transfers of 0 Values Revert in Staking", "body": "  Both  functions  transfer  and  transferFrom  check  that  value  being  transferred  is  non-zero (assert _value > 0). This behavior is not in line with EIP20 which has the following note:  Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.    Yearn changed the code to allow zero value transfers.  Yearn - Yearn yETH -   26  InformationalVersion1Speci\ufb01cationChangedInformationalVersion1CodeCorrected            \f7   Open Questions  Here,  we  list  open  questions  that  came  up  during  the  assessment  and  that  we  would  like  to  clarify  to ensure that no important information is missing.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "7.1   Adding New Assets When Paused", "body": "  The function add_asset does not check if the pool has been paused when adding a new asset. Is this behavior intentional?  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "7.2   Approval Events on transferFrom", "body": "  The Staking.transferFrom function does not emit any event regarding the approval change. Thus, it is  not  possible  to  recover  state  based  on  Approval+Transfer  events.  While  this  is  compliant  with ERC4626/ERC20  specification,  some  libraries  like  OpenZeppelin,  emit  explicit  Approval  event  during the transferFrom. On the other hand, DAI token does not emit such event. We would like to bring this detail to your attention and know if it is as expected in your case.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "7.3   Total Assets Can Be 0", "body": "  Both  functions  _preview_deposit  and  _preview_mint  check  if  _total_assets  ==  0  although _total_shares are non-zero. Can you please describe the scenarios when this happens?  Yearn - Yearn yETH -   27  OpenQuestionVersion1OpenQuestionVersion1OpenQuestionVersion1          \f8   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "8.1   Extracting Value From First Deposit in Pool", "body": "  The  attacks  based  on  strategies  that  artificially  inflate  the  value  of  LP  shares  in  Pool  are  unlikely  to succeed  due  to  the  way  how  rewards  (donations)  are  tracked  in  different  buckets.  Nevertheless,  it  is theoretically  possible  for  an  attacker  to  extract  value  from  the  first  depositor  if  certain  conditions  hold before first deposit, e.g., significant rewards are ready to be moved to unlocked bucket.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "8.2   Incomplete Natspec", "body": "  The natspec description for the return value of function update_weights is incomplete.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "8.3   Missing Events in Staking Contract", "body": "  Functions  rescue,  set_half_time,  set_management  and  set_treasury  in  contract  Staking update the state, but no event is emitted.  Code partially corrected:  The respective events in the functions listed above were added except function rescue, which still does not emit an event.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "8.4   Preview Functions Round in Favor of Users", "body": "  The functions _preview_withdraw is used to calculate the number of shares a user needs to pay for withdrawing a given amount of assets. The calculation rounds in favor of the user. This means the user needs to pay slightly less shares for the respective assets. Hence, reducing the value of all shares. The same  issue  is  also  present  in  _preview_mint.  The  magnitude  of  the  rounding  error  depends  on  the share-to-assets ratio.  This  violates  the  invariant  that  the  share  value  can  only  go  down  by  incurred  losses.  Still,  the  impact should be limited and the issue is mainly theoretical.  Yearn - Yearn yETH -   28  InformationalVersion2InformationalVersion1InformationalVersion1CodePartiallyCorrectedInformationalVersion2                  \f8.5   Theoretical Underflow in _Get_Amounts  The function Staking._get_amounts can theoretically underflow when the shortage is higher than the  sum  of  all  tokens  accounted  in  the  buckets.  The  underflow  happens  in  the  statement unlocked  -=  shortage.  However,  practically  this  should  not  happen  as  the  loss  cannot  be  larger than the balance of Staking contract in yETH.  Yearn - Yearn yETH -   29  InformationalVersion1  \f9   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.1   Assets Cannot Be Removed From Pool", "body": "  Contract  Pool  implements  the  function  add_asset  that  allows  the  management  account  to  add  new assets  into  the  Pool,  up  to  a  total  of  32  assets.  We  highlight  that  the  contract  does  not  implement  a functionality to remove an asset from a Pool. Therefore, the asset removal requires a redeployment of the contract, which forces all LPs to withdraw their liquidity from the old Pool and deposit into the new one.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.2   Assumption on Balance of Staking", "body": "  The  internal  function  _update_supply  is  called  when  key  functionalities  of  the  contract  Pool  are performed.  Based  on  the  activity  of  the  Pool  LP  tokens  are  minted  to  the  staking  (if  supply increases),  or  LP  tokens  are  burned  from  the  staking  (if  supply  decreases).  The  implementation  of the function assumes that the staking contract has always enough balance in yETH to cover the losses of the pool such that the burning of LP tokens will always succeed.  Yearn  is  aware  that  after  deployment  or  in  certain  conditions  (e.g.,  no  staked  tokens)  this  assumption might not hold, and extra measures need to be taken for the function to work as intended.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.3   Buckets Can Be Updated at Most Once per", "body": " Block  The function _get_amounts returns the current state if the buckets have already been updated in the same block:  if updated == block.timestamp:     return self.pending, self.streaming, self.unlocked, 0, 0  If the Staking contract receives rewards in a block, after function _update_totals has already been called,  the  pending  and  streaming  buckets  do  not  get  updated.  Note  that,  the  unlocked  bucket  is always updated when users stake or unstake their yETH tokens.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.4   Charged Fees Are Unclear", "body": "  The function add_liquidity charges fees depending on the differences between deposited amounts and the current state of the pool. The larger the delta, the higher the fees. However, it is not easy for a  Yearn - Yearn yETH -   30  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fliquidity  provider  to  know  the  actual  fees  payed.  Similarly,  the  function  remove_liquidity_single charges fees but it is not explicit to the caller.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.5   Decay of Voting Weight on Transfers", "body": "  Voting weight is computed by a asymptotic function that depends on the amount of shares and the time they  have  been  staked.  The  variable  Weight.t  is  adjusted  (lowered)  when  a  position  receives  new shares  such  that  the  voting  weight  before  and  after  the  transfer  remains  the  same.  However,  when transferring out tokens the variable Weight.t is not modified.  The side effect of this behavior is that if a position with a voting weight v1 receives x shares and then transfers out the same amount x shares, ends up with a lower voting weight v2 (v2 < v1) although the number of staked shares has not changed. Furthermore, transfers also affect the global voting weight as transfers decrease voting weight of individual positions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.6   Large Ratio Drops for an Asset Break Pool", "body": " Composition  Pool  implements  a  safety  mechanism  to  ensure  that  the  portfolio  composition  of  underlying  assets  is according to specified parameters. Each asset in the Pool has a target weight (a range) associated with it.  User  operations,  like  swap,  deposit,  or  withdraw,  that  change  the  asset  balances  in  the  Pool  are permitted only if they do not move the actual weights of the involved assets outside the specified ranges. However, the Pool composition changes also when updating rates as asset balances change. The safety mechanism is not enforced in such changes of Pool composition.  While  the  mechanism  of  safety  bands  helps  to  maintain  the  desired  composition  of  the  Pool  when  all assets have a backing ratio as expected (around 1 ETH), they do no limit the value loss of the Pool when the  ratio  of  one  asset  drops  significantly  (e.g.,  goes  towards  0).  A  lower  rate  for  an  asset  results  in  a lower  virtual  balance  for  the  asset,  which  lowers  its  weight  in  the  Pool,  therefore  enabling  trades  that transfer  the  cheaper  asset  into  the  Pool  and  transfer  out  other  assets.  If  the  rate  of  one  asset  drops significantly  (e.g.,  due  to  a  hack),  the  Pool  should  be  paused  immediately,  before  the  new  ratio  is published by the respective provider, to prevent traders from selling the worthless asset to the Pool.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.7   Precision of Packed Weights", "body": "  The precision of weight variables passed as arguments in function is 18 decimals. This precision is lost when the variables are stored as packed in storage due to space limitations. Variables weight, target, lower and upper are limited to 20 bits, therefore they can store values with a precision of 6 digits only. The  management  account  should  take  into  consideration  this  behavior  when  setting  the  respective parameters of Pool.  For instance, the function set_ramp does not enforce a lower bound on the values passed in the array _weights.  If  a  value  smaller  than  10**12  is  passed  as  target  weight  for  an  asset,  the  function _pack_weight will store 0. In this case, the ramp cannot complete and main functionalities of the Pool stop  working  as  the  function  _update_weights  calls  function  _calc_vb_prod  which  requires  the weight of each asset to be non-zero: assert weight > 0.  Yearn - Yearn yETH -   31  NoteVersion1NoteVersion1NoteVersion1              \f9.8   Sandwiching Curve Changes  There  are  many  ways  a  Curve  can  significantly  change  its  shape.  A  prominent  attack  example  is  the sandwich attack on Curve when the amplification factor is changed. Therefore, these important changes are ramped (split in smaller changes over a defined time) to minimize the revenue of sandwiching these changes. Yearn also implements ramping for weight changes and amplification factor. However, ramping does not guarantee that an attack is not profitable. As Yearn does have more potential ways to change their Curve than e.g., the original Curve by Curve finance, this risk is increased.  Ramping  can  be  initiated  only  by  the  trusted  account  management  which  should  carefully  select  the parameters  _amplification,  _weights,  _duration  and  ramp_step.  First,  as  _amplification represents  the  factor  A  *  f^n  and  f  depends  on  weights,  both  target  _amplification  and  target _weights should be chosen such that they stay in line with each-other in intermediary steps of ramping. Otherwise, management should execute each step as a separate ramp. For instance, transitioning from a pool with weights (10%, 20%, 70%) to a pool with weights (60%, 30%, 10%) introduces an error in the amplification factor of up to 49% in the intermediary steps of the ramping. The error gets higher for more excessive changes. For example, transitioning from a pool with weights (1%,99%) to weights (99%,1%) introduces an error up to 72% in the intermediary steps of the ramping.  Finally,  _duration  and  ramp_step  should  be  carefully  chosen  such  that  each  step  of  ramping  does not  change  the  curve  significantly.  Any  update  of  the  ramp_step  should  take  into  consideration  the ongoing ramp.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.9   Staking Does Not Lock Tokens", "body": "  Users holding yETH can stake their tokens into the contract Staking. The contract does not lock staked tokens and there is no time restriction to withdraw them. The only incentive to keep tokens staked is the increasing voting weight. Hence, yETH holders might have a stronger incentive to stake their tokens if the Pool generates rewards and withdraw if there are losses.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "9.10   Supply Updates in Pool", "body": "  The rate update of underlying assets can be triggered explicitly by calling the function update_rates or it  gets  triggered  when  sensitive  operations  are  executed,  e.g.,  adding/removing  liquidity  or  swaps.  The rate update changes the composition of the virtual balances of assets in the pool. The new supply is then computed, and Pool mints or burns tokens to/from the staking based on the positive or negative delta.  Updates of the supply provide different incentives to users. For instance, if new rates are published and they  lower  supply,  an  existing  LP  can  profit  by  sandwiching  the  transaction  that  triggers  the  supply update by withdrawing their tokens first and then deposing again after the supply gets updated.  On the other case, if supply is going to be increased, LPs have an additional incentive to stake their yETH to claim the respective rewards (subject to delays).  Yearn - Yearn yETH -   32  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-yeth-smart-contracts/"}, {"title": "5.1   Provoking an Aave Liquidity Crisis", "body": "  AaveKandel  stops  providing  liquidity  if  too  much  is  borrowed.  Generally,  market  makers  should  be aware of that. However, one can throw Aave temporarily into a liquidity crisis by  ISSUEIDPREFIX-001  1. flashloaning the entire balance  2. borrowing the entire balance  That  could  allow  an  attacker  to  create  a  temporary  liquidity  crisis  wrapping  a  sniping  operation  on Mangrove core for his profit.  However, note that the flashloaning attack is to some degree by the economic factor of Aave flashloans while the other operation can be achieved even for free by taking out free flashloan for collateral assets on other protocols. Such attacks are however limited by the borrow caps that Aave can impose. Namely, the attack can be carried out as long as the Aave's available capital after the borrow cap is reached is less than an offer's promised amount. Note that 1. and 2. can be combined to reduce the total cost of an attack with 1. so that the limit set by the borrow caps can be bypassed.  Risk accepted:  Mangrove Association (ADDMA) replied:  1/ deploy 80 offers from AAVE kandel (WETH,USDC) on mangrove  Note 1: 80 offers is the limit beyond which one cannot collect all failing offers because of stack overflow Note 2: WETH has borrow cap on AAVE so the attack has to be on offers that have USDC outbound  Mangrove Association (ADDMA) - Kandel Strats -   11  SecurityDesignCorrectnessCriticalHighRiskAcceptedMediumLowAcknowledgedSecurityHighVersion1RiskAccepted           \f2/ attacker supplies enough DAI on AAVE to be able to borrow the whole supply of USDC  Note 1: the script mocks up a flashloan of DAI to obtain enough collateral. There is currently no real way to flashloan DAIs on polygon. In the overall cost of the attack we add 400K gas as an estimate of the flashloan cost plus the cost of repaying the borrow on AAVE which is not scripted here (AAVE on polygon still does not allow repay and borrow on the same block, although ethereum deployment does). The attack using AAVE native flashloan has also been tested but result in a prohibitive cost for the attacker (around 1000 USD worth of fees).  Note 2: there is currently a supply cap on AAVE for DAI which is just enough to do this, but supplying a bit too much DAI actually reverts  3/ attacker borrows USDC supply and triggers a market order  4/ all 80 aave kandel offers trigger a failure cascade and the bounty is sent to the attacker Assuming a tx.gasprice == Mangrove\u2019s gasprice at 90 gwei, we get:      Attack collects 0.84691197 matics for 9 936 879 gas units     cost of the attack: 0.89431911 native tokens  Conclusion:    - Under favorable gas conditions for the attacker, drying up the AAVE pool can be profitable (when tx.gasprice is     significantly lower than Mangrove\u2019s). However the profit is quite low compared to traditional flashloan attacks     and not iterable: failing Aave Kandel\u2019s offer do not repost themselves. Yet the attack would at least be griefing     users as it would result in losing provision and having their offers unpublished from Mangrove.    - We believe the best protection relies on launching AAVE Kandel Strats on markets that have a borrow cap,     which would force the attacker of going through the costly AAVE flashloan mechanism to bypass the cap.    - The above script is included in the test AaveKandel.t.sol (test_liquidity_borrow_marketOrder_attack)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "5.2   Posthook Revert Due to Overflow in Dual", "body": " Offer Computation  The maker posthook of Kandels can revert due to a potential overflow in dualWantsGivesOfOffer() in extreme scenarios. Consider the following example:  ISSUEIDPREFIX-002   Assume that the previously computed gives is equal to 2**96-1.   Assume that r is equal to (2*10**5)**8 = 2**8 * 10**40.   Hence, the first computed givesR will be (2**104-2**8) * 10**40, which needs 237 bits.  In  the  else  branch,  assume  that  order.offer.wants()  is  small,  e.g.  1,  the  updated  givesR now needs 256 bits   Hence,  with  offerGives  >=  2**19,  the  computed  wants  will  be  >  2**256  which  leads  to  a  reverting overflow.  Ultimately, the posthook for small offers could revert.  Acknowledged:  Mangrove Association (ADDMA) replied:  The scenario that yields an overflow occurs with unlikely values. The outcome of the overflow is to make offer logic\u2019s posthook fail and hence entails no penalty for maker.  Mangrove Association (ADDMA) - Kandel Strats -   12  DesignLowVersion1Acknowledged           \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Depositing ATokens Allows Stealing Them   -Severity Findings  -Severity Findings   Wrong Dual Price Computation on Crossing Boundaries   -Severity Findings   Balance in Router Can Be Present    More Precision Can Be Used for wants    Reserve Balance Does Not Include Kandel's Balance    Tokens Without Return Values    AaveKandelSeeder Missing Active Market Check   1  0  1  5  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.1   Depositing ATokens Allows Stealing Them", "body": "  The Aave v3 pooled router, allows arbitrary tokens. Tokens that are not supported by Aave are kept in the  router  contract  directly  and  treated  equivalent  to  buffered  tokens  coming  from  Aave  withdrawals. However,  depositing  aTokens  leads  to  accounting  issues,  treating  the  aTokens  received  from  actual supply operations as donations and, hence, buffered tokens.  ISSUEIDPREFIX-007  Consider the following scenario:  1. 1M aDAI held by the router (DAI was supplied).  2. Attacker creates Kandel and uses depositFunds() to supply 1 aDAI.  3. Since not shares exist for aDAI, the INIT_MINT will be minted. The supply fails but the code does  not revert since noRevert is true.  4. The attacker now uses withdrawFunds() to redeem aDAI.balanceOf(router) aDAI.  5. The  router's  withdraw  function  realizes  that  there  is  enough  buffered  amount  of  aDAI.  Hence,  toRedeem is 0.  6. _burnShares() first computes the shares to burn. Since there is no overlying for aDAI, the input amount will match the aDAI balance of the contract. Hence, the total shares for aDAI will be burned which are equal to INIT_MINT and thus equal to the attacker's shares. All shares are burned since the attacker is the only holder.  7. toRedeem is 0. Hence, withdrawing from Aave will not be tried. All the aDAI balance is sent to the  attacker.  Ultimately, all funds in the Aave pooled router could be at risk.  Mangrove Association (ADDMA) - Kandel Strats -   13  CriticalCodeCorrectedHighMediumCodeCorrectedLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityCriticalVersion1CodeCorrected        \f  On  deployment,  the  AaveKandel  tries  to  call  UNDERLYING_ASSET_ADDRESS()  on  the  base  and  the quote token. In case staticcall does not revert, the token is classified as an aToken and the deployment will  revert.  In  case  the  staticcall  reverts,  the  error  is  caught  and  execution  proceeds.  Note  that  the staticcall could revert without the error message if the base or quote token are EOAs.  Further, only the base and quote tokens can be deposited to and withdrawn from the AaveKandel.  Both restrictions combined, prevent aTokens from being deposited to the router from Kandels.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.2   Wrong Dual Price Computation on Crossing", "body": " Boundaries  When the dual price is computed, the function GeomertricKandel.dualWantsGivesOfOffer is not aware of how many steps the price should move to stay within the defined boundaries and will always move it by ratio**spread. Whenever steps <= spread holds, this can lead to prices that are off by factors of ratio on the boundary of the indices, thus breaking the assumption that each index should be at a distance ratio from its neighbors.  ISSUEIDPREFIX-013  Consider the following example:  1. The following setup is active:  pricePoints = 6 spread = 3 compoundRate = p = 10 ** PRECISION  2. A trade occurs against a Bid at index = 4 so that the dual offer parameters are (note that since  the pricePoints limit of 5 is exceeded, it is set to the maximum value allowed):  virtual_dual_index = 7 => dual_index = 5  dualOffer = Ask  Hence,  we  jump  by  only  1  index  and  expect  a  price  update  of  ratio  /  p.  Hence,  the expected price is the expected price at index 5  expected_wants / expected_gives = (order.wants * ratio**1 / p**1) / (order.gives)  3. The gives of the dual offer are computed (assume now that at index 5 gives had been 0):  new_gives = order.gives * compoundRate * ratio**spread / (ratio**spread * p) <=> new_gives = order.gives  4. The wants of the dual offer are computed:  new_wants = order.wants * new_gives * ratio**spread / (order.gives * p**spread) <=> new_wants = order.wants * order.gives * ratio**spread / (order.gives * p**spread) <=> new_wants = order.wants * ratio**spread / p**spread  Mangrove Association (ADDMA) - Kandel Strats -   14  CorrectnessMediumVersion1CodeCorrected        \f5. The price at index 5 is now:  new_wants / new_gives = (order.wants * ratio**spread / p**spread) / (order.gives)  Note that the new price at index 5 is distinct from the expected price.    The spread applied to the ratio is now updated by GeometricKandel.transportDestination for the price to stay within bounds.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.3   Balance in Router Can Be Present", "body": "  Note that the documentation of AavePooledRouter.__pull__() specifies:  ///@dev outside a market order (i.e if `__pull__` is not called during offer logic's execution) the `token` balance of this router should be empty. /// This may not be the case when a \"donation\" occurred to this contract /// If the donation is large enough to cover the pull request we use the donation funds  ISSUEIDPREFIX-012  However, note that this is not necessarily the case since the posthook of the first puller could revert and leave the funds inside the router without pushing them out. However, after the next execution or the next deposit, the funds should be moved to Aave if everything works correctly.  Note that an attacker could force a balance into the router without donating to it by  increasing the total supply on Aave such that the supply cap makes the first puller's flushing revert.  trading  against  an  attacker-strategy-owned  Kandel  and  then  trading  against  the  attacker  strategy that changes the router of the Aave Kandel so that the Aave Kandel does not push and supply on the Aave router.  Specification Changed:  The comment has been adapted.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.4   More Precision Can Be Used for wants", "body": "  ISSUEIDPREFIX-009  When  computing  is  used  when uint160(givesR)  ==  givesR  ||  order.wants  <  2  **  18,  but  the  second  condition  can  be relaxed to be order.wants < 2 ** 19 to allow full precision more often.  the  wants  amount  of   the  dual  offer,   full  precision     The second condition has been relaxed to accept values < 2 ** 19.  Mangrove Association (ADDMA) - Kandel Strats -   15  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                    \f6.5   Reserve Balance Does Not Include Kandel's Balance  The  reserveBalance()  is  the  available  balance  for  a  strategy  of  an  offered  token.  Note  that  Direct strategies try to use the local balance always first, see function __get__().  ISSUEIDPREFIX-011  uint amount_ = IERC20(order.outbound_tkn).balanceOf(address(this)); if (amount_ >= amount) {   return 0; }  However, the AaveKandel does not account for the local balance (potentially received through donations) in reserveBalance().    The  function  AaveKandel.reserveBalance()  has  been  updated  to  take  its  own  balance  into account.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.6   Tokens Without Return Values", "body": "  The Mangrove core system and the transfer libraries used in Kandel handle tokens without return values on transfers. However, for approvals return values are always expected. Note that this is not always the case due to tokens implementing the ERC-20 standard incorrectly (e.g., USDT).  ISSUEIDPREFIX-008    The approve() function handles now the case where no return value exists.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.7   AaveKandelSeeder Missing Active Market", "body": " Check  Only  the  (BASE,QUOTE)  market  is  checked  to  be  active  on  Mangrove,  but  the  (QUOTE,BASE)  base market should also be checked as it is used as well. If the inverse market is inactive, initial Ask and the Bid dual offers will fail to be posted.  ISSUEIDPREFIX-006    The two markets are now checked to be active on Mangrove in AbstractKandelSeeder.sow().  Mangrove Association (ADDMA) - Kandel Strats -   16  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f6.8   Explicit Variable Visibility  Several variables have undeclared visibility which results in variables being internal. Note that clear specifying clear visibility can help maintain code.  ISSUEIDPREFIX-005    Variables have now explicit visibility.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.9   Gas Inefficiencies", "body": "  1. The internal function DirectWithBidsAndAsksDistribution.populateChunk initializes i to  0, this is a redundant assignment.  ISSUEIDPREFIX-004  2. When  using  tokenPairOfOfferType()  with  both  offer  function,  e.g., DirectWithBidsAndAsksDistribution.populateChunk  or DirectWithBidsAndAsksDistribution.retractOffers,  one  of  the  function  calls  can  be avoided by assigning the inverted token pair.  types   in  a   3. In the function CoreKandel.retractAndWithdraw the modifier onlyAdmin is unnecessary    For 3, the modifier was not removed by choice.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.10   NatSpec", "body": "  The  NatSpec  documentation  is  extensive.  However,  there  at  several  places  the  NatSpec  is  missing  or incomplete.  For  _supply,  checkAsset,  _totalBalance  or  balanceOfReserve  return  value  undocumented.  For  _sharesOfAmount,  mintShares  or  _burnShares  an  argument  undocumented. depositFunds or withdrawFunds do not have any NatSpec.  the   is is  Note that the examples are an incomplete list of lacking NatSpec documentation.  ISSUEIDPREFIX-010  Documentation changed:  The documentation has been adapted.  Mangrove Association (ADDMA) - Kandel Strats -   17  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1Speci\ufb01cationChanged                  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "7.1   Magic Values", "body": "  The use of magic numbers in the codebase is not recommended, they should be replaced by variables with a self-explanatory name. Examples are:  ISSUEIDPREFIX-003   \"mgv/writeOffer/density/tooLow\"   \"mgv/tradeSuccess\"  Acknowledged:  Mangrove Association (ADDMA) replied:  since these magic values are part of mangrove\u2019s specification, we assume they won\u2019t change.  Mangrove Association (ADDMA) - Kandel Strats -   18  InformationalVersion1Acknowledged    \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "8.1   Maker Should Oversupply Due to Aave Being", "body": " off by 1  The maker should oversupply AaveKandel by some WEI to account for Aave internal loss of precision, that can lead the token amount to be off by 1 on redemption, as it could make the trade revert if they are the only one to use the Aave pool from a given AavePooledRouter.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "8.2   Supplying Caps Not Considered", "body": "  Aave V3 has supply caps. However, these are not considered when supplying. Hence, supplying could fail so that tokens are treated as buffered.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "8.3   AaveKandelSeeder Missing Existence Check", "body": " of Pool for Asset  No check is done on strategy deployment for a pool of BASE or QUOTE on AaveV3. If such pools cannot be supplied, the AaveKandel strategy can be deployed but there will be no yield from the deposits to the router.  Mangrove Association (ADDMA) - Kandel Strats -   19  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-kandel-strats-smart-contracts/"}, {"title": "6.1   Locked Refunded Provision", "body": "  ISSUEIDPREFIX-007  When  a  maker  submits  an  order  to  the  Mangrove  orderbook,  they  need  to  provide  some  ETH,  also known as the provision, to compensate the takers in case the makerExecute hook reverts. A maker can update their offer by calling Forwarder.updateOffer. Note that at this point a maker can update most of the parameters of the order including gasreq, i.e. the gas required for the makerExecute hook to execute. A maker could reduce the gas requirements meaning that some provision will be refunded to them. Forwarder.updateOffer does not handle this refunding (the ownerData.weiBalance is not updated) and Mangrove system only sees MangroveOrder as a maker. This means that the refunded amount is essentially lost for the end-user of the MangroveOrder. Note that if the provision needs to be increased again, the end-user must provide extra ETH.  Code Corrected:  In the current implementation, the provision can only be increased therefore no funds are locked.  Mangrove Association (ADDMA) - MangroveOrder -   12  CriticalHighCodeCorrectedCodeCorrectedMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected            \f6.2   Wrong Calculation of Locked Provision  When a user updates their offer through Forwarder.updateOffer, MangroveOrder tries to calculate the new gas price by calling deriveGasprice. The gas price depends on the total provision available for  this  order.  That  is  the  sum  of  the  extra  provision  attached  which  is  stored  in  args.fund  and  the already locked provision. Currently, the locked amount is calculated with the following snippet:  vars.offerDetail.gasprice() * 10 ** 9 * args.gasreq + vars.local.offer_gasbase()  ISSUEIDPREFIX-011  This formula is wrong for two reasons:  1. It depends on args.gasreq which is the updated gas requirement of the order as passed by  the user.  2. There are parentheses missing around args.gasreq + vars.local.offer_gasbase(),  as this entire term should be multiplied by the gas price.  This miscalculation can have multiple consequences:  1. Can allow users to steal funds (see relevant issue).  2. An  order  can  be  submitted  with  smaller  gasprice  since  the  calculated  total  provision  is  too  small.  Code Corrected:  Forwarder.updateOffer has been updated. Currently, users can only increase the provision for an order.  Users  cannot  determine  args.gasreq  as  it  is  set  to  be  equal  to  the  offerGasreq().  It  is important  to  notice  that  offerGasreq()  is  not  constant  but  depends  on  the  configuration  of  the MangroveOrder and in particular the gas requirements of the router.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.3   Expiration Date Cannot Be Updated", "body": "  A  user  can  update  most  of  the  offer  details  by  calling  Forwarder.updateOffer.  However,  the expiration date cannot be changed. In order to change the expiration date of an order, one must retract it and submit a new one.  ISSUEIDPREFIX-003  Code Corrected:  MangroveOrder.setExpiry has been added to allow users to update the expiration date of the order.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.4   Underflow in postRestingOrder", "body": "  ISSUEIDPREFIX-009  Mangrove Association (ADDMA) - MangroveOrder -   13  CorrectnessHighVersion1CodeCorrectedDesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged                      \fOnce the market order part of GTC order has been filled as much as possible, the remaining amount the user  wants  to  trade  is  put  into  a  resting  order.  Note  that  if  fillWants  ==  true,  then  the  Mangrove engine will have stopped matching the order either when it is fully filled, there are no more orders on the books, or when the total average price of the order would fall below the threshold of the ratio between the order's initial wants and gives. Hence, if the matching stops before the order's wants are fully filled, we are  guaranteed  not  to  have  given  away  more  than  the  order  initially  had  (else  the  total  average  price would be below what we initially wanted).  However,  if  fillWants  ==  false,  this  condition  no  longer  holds.  The  order  can  receive  arbitrarily many tokens before giving away all the tokens it has to give away. As the price of a trade is defined by the  maker,  there  could  be  orders  on  the  books  which  give  away  arbitrarily  many  tokens  for  a  very  low price.  Hence,  the  user  can  receive  more  tokens  in  the  market  order  part  of  the  trade  than  they  were expecting to. As such, res.takerGot + res.fee can exceed tko.takerWants despite only having partially filled the order.  When we go to post a resting order, the following code is executed:  res.offerId = _newOffer(   OfferArgs({     outbound_tkn: outbound_tkn,     inbound_tkn: inbound_tkn,     wants: tko.makerWants - (res.takerGot + res.fee), // tko.makerWants is before slippage     gives: tko.makerGives - res.takerGave,     gasreq: offerGasreq() + additionalGasreq, // using default gasreq of the strat + potential admin defined increase     gasprice: 0, // ignored     pivotId: tko.pivotId,     fund: fund,     noRevert: true, // returns 0 when MGV reverts     owner: msg.sender   }) );  When  the  wants  for  the  resting  order  are  calculated,  an  underflow  can  occur  in  the  case  described above, as the market order part of the GTC order could have received arbitrarily many tokens. As Solidity ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "0.8.10  is  used,  this  will  simply  revert  the  transaction,  but  will  unnecessarily  prevent  the  user  from", "body": " completing their trade.  Specification Changed:  Currently,  the  order  is  posted  with  the  same  price  as  the  taker  originally  wanted.  Thus,  the  issue  has been mitigated.  Mangrove Association (ADDMA) replied:  this  problem  made  use  reevaluate  our  specification:  requiring  the  (instant)  market  order  and  the (asynchronous) maker order to respect a limit average price is not well defined. In some cases this would lead the maker order to be posted for a 0 price. We decided to change the specification and post the maker order at the price initially set by the taker for the market order (irrespectively of the obtained price).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.5   Users Can Steal Funds From MangroveOrder", "body": "  The core Mangrove system maintains the balanceOf mapping which stores how much ETH is available for each maker to be used as a provision for their orders. Importantly, the MangroveOrder contract is seen  as  one  single  maker  by  the  system,  even  though  there  might  be  many  end  users  creating  their orders through it. Let us assume that at some point the balance of MangroveOrder is positive and an attacker has already submitted an order. It is possible as we show in another issue that there might be  ISSUEIDPREFIX-013  Mangrove Association (ADDMA) - MangroveOrder -   14  SecurityMediumVersion1CodeCorrected        \fsome non-claimable balance since updateOrder does not handle refunds. An attacker can steal money from mangrove by employing any of the following two vectors:  1. Updating an order without sending funds:   The attacker calls Forwarder.updateOrder for their order with msg.value == 0 and  they increase the gas requirement of their order.   This means that args.fund == 0 so gas price will remain the same, however, the total  provision needed has been increased as the gas requirements have been increased!   At this point MGV.updateOffer is called with msg.value == 0.   Mangrove core does not perform any check if there are enough funds attached to the call  since it relies on the balanceOf mapping by calling debitWei.   Mangrove core uses the amount stored in balanceOf for the extra provision.   The  attacker  now  retracts  the  order  and  withdraws  the  provision  of  the  order  which  includes the stolen amount.  2. Updating an order by attaching funds:   The attacker calls Forwarder.updateOrder for their order with msg.value != 0 and  they increase the gas requirement of their order.   Since funds have been attached to the transaction, the gas price will be recalculated.   The  new  provision  at  this  point  is  calculated  wrongly  since  the  provision  parameter passed  to  derivePrice  depends  on  args.gasreq  which  represents  the  updated  gas that requirements  of  args.gasreq can be freely set by the users so arbitrarily large value could be passed. As a result, the new gas price is greater than it should be but the extra funds passed are not enough to cover for the extra provision needed by the offer.  the  offer  and  not  vars.offerDetail.gasreq().  Note    Mangrove core uses the amount stored in balanceOf for the extra provision.   The  attacker  now  retracts  the  order  and  withdraws  the  provision  of  the  order  which  includes the stolen amount.  A  similar  attack  can  be  performed  when  some  of  the  global  parameters  change,  which  could  result  in inaccurate accounting of provisions. If the gasbase of the token pair related to an order changes in the core mangrove system, calling updateOffer can result in an increased (or decreased) provision without providing any additional funds. This will credit (or debit) funds to the MangroveOrder contract which aren't attributed  to  any  user.  In  particular,  if  the  global  gas  price  is  increased,  calling  updateOffer  of Mangrove core with an unchanged gasprice which is lower than the new global gas price, the mangrove core system will set the gas price higher without receiving any funds. This again changes the balance of the  MangroveOrder  contract,  without  attributing  it  to  any  individual  user.  While  _newOffer  and _updateOffer in Forwarder have checks to make sure the offer's gas price is higher than the global gas price, __posthookSuccess__ in MangroveOffer does not. Hence, if the global gas price changes, then an order is partially filled and attempts to repost, its provision will be increased with no additional submitted funds. While the amounts of funds are small, it is conceivable that a malicious user could be able to exploit a change in the global gas price or the gasbase in order to steal funds.  It  is  important  to  note  that  this  issue  cannot  result  in  users  losing  funds  since  the  excessive  provision which can be stolen cannot be claimed by any specific user. In the normal case, no excessive provision should  be  available.  Therefore,  it  is  expected  the  amount  that  can  be  stolen  to  be  low.  Hence,  we consider the issue as medium severity.  Code partially corrected:  The issue has been addressed in multiple different ways:  Mangrove Association (ADDMA) - MangroveOrder -   15  \f1. In the current implementation there shouldn't be unallocated users' funds in Mangrove core.  2. Users can only increase the provision of an order using MangroveOrder.updateOrder, not decrease  it.  Hence,  they  must  provide  additional  provision  and  can  not  submit  orders  which could make use of funds that are already stored in the Mangrove core.  3. The __posthookSuccess__ uses Forwarder._updateOffer.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.6   Interpretation of type(uint24).max Not", "body": " Up-To-Date  ISSUEIDPREFIX-006  Before  Forwarder contract, i.e., gasreq = offerGasreq. In  is  removed  MangroveOffer.getMissingProvision  which  will  return  an  gasreq >= type(uint24).max.  ,  the  value  type(uint24).max  or  more  had  a  special  meaning  for  gasreq  in  the , the meaning of that value has been function the  if  called  with  incorrect  value   Forwarder,   present   from   still   the   but   in     The  function  has  been  removed.  It  has  been  suggested  that  MgvReader.getProvision()  can  be used as an alternative.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.7   Wrong Comment", "body": "  The NatSpec of __posthookSuccess__ specifies for example \"posthook/filled\" as return data. However, the return data has changed its format.  ISSUEIDPREFIX-014  Specification changed:  The specification has been adapted.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.8   Inaccurate Comment", "body": "  In MangroveOrder.checkCompleteness, the following is mentioned:  // when fillWants is true, the market order stops when takerWants units of outbound_tkn have been obtained;  However, this comment is inaccurate since part of the takerWants goes to cover the fees, so not the full takerWants amount can be obtained.  In AbstractRouter.push, the return value is described as follows:  ISSUEIDPREFIX-005  Mangrove Association (ADDMA) - MangroveOrder -   16  CorrectnessLowVersion4CodeCorrectedVersion4Version4CorrectnessLowVersion4Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \f///@return pushed fraction of amount that was successfully pushed to reserve.  However,  for  tokens  with  fees,  provided  the  TransferLib  is  used,  the  whole  amount  will  always  be reported.  Code Corrected:  The comments have been updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.9   Missing Natspec", "body": "  The Natspec is missing in the following cases:   For AbstractRouter.bind, the maker parameter.   For AbstractRouter.unbind, the maker parameter.   For SimpleRouter.__pull__, the strict parameter.   For IOfferLogic.OfferArgs, the gasprice field.  Code Corrected:  The Natspec has been added to the respective functions.  ISSUEIDPREFIX-008  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.10   Redundant pragma abicoder v2", "body": "  Many contracts include the pragma abicoder v2 directive. However, for solidity 0.8 the abicode v2 is the default one, so the pragma is redundant.  ISSUEIDPREFIX-010  Code Corrected:  The pragma has been removed from most of the contracts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.11   Setting Expiration Date", "body": "  A user can define the time-to-live of a resting order submitted through MangroveOrder by specifying the TakeOrder.timeToLiveForRestingOrder.  It  is  important  to  note  that  an  order  can  remain  in  the mempool  for  a  long  time  before  it's  executed.  Specifying  an  explicit  expiration  date  instead  of  the time-to-live might be more convenient for users since it's independent of the time it takes for a transaction to be included in a block.  ISSUEIDPREFIX-002  Mangrove Association (ADDMA) - MangroveOrder -   17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fCode Corrected:  The  expiration  date  is  now  absolute  and  no  longer  relative  to  the  time  the  transaction  is  added  to  the blockchain.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.12   Forwarder.provisionOf Calculation Is", "body": " Wrong  ISSUEIDPREFIX-012  As its natspec suggests Forwarder.provisionOf computes the amount of native tokens that can be redeemed  when  In MgvOfferMaking.retractOffer, the provision is calculated as follows:  offer.  However,   deprovisioning   given   true.   this   not   is   a   provision = 10 ** 9 * offerDetail.gasprice() //gasprice is 0 if offer was deprovisioned   * (offerDetail.gasreq() + offerDetail.offer_gasbase());  The important part to notice is that provision depends on offerDetail.offer_gasbase().  This is not the same for Forwarder.provisionOf where the provision is calculated as follows:  provision = offerDetail.gasprice() * 10 ** 9 * (local.offer_gasbase() + offerDetail.gasreq());  Here,  offerDetail.offer_gasbase().  provision   the   depends   on   local.offer_gasbase()   instead   of  Code Corrected:  The provision is now calculated using the offerDetail.offer_gasbase().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.13   Array Length Mismatch", "body": "  The batched functions of the TransferLib can take arrays differently sized arrays. The desired execution in that case is unclear.  ISSUEIDPREFIX-001    The batched functions have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "6.14   Explicit Variable Visibility", "body": "  Mangrove Association (ADDMA) - MangroveOrder -   18  ISSUEIDPREFIX-004  DesignLowVersion1CodeCorrectedInformationalVersion4CodeCorrectedInformationalVersion1CodeCorrected                    \fAccessControlled has now a state variable _admin. However, it does not have explicit visibility defined. Note that this does not lead to any double getters since its by default internal. However, specifying explicit visibility may make code clearer.  Note that this is the case also for boundMakerContracts in AbstractRouter.    The code has explicit variable visibility now.  Mangrove Association (ADDMA) - MangroveOrder -   19  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "7.1   Updating Approvals on Order Update", "body": "  A  user  can  update  their  orders  by  using  Forwarder.updateOffer.  It  is  important  for  users  to remember  that,  in  case  the  makerExecute  hook  to  their  order  fails,  they  will  have  to  reimburse  the taker. A reason for an order to fail is that there is not enough allowance given to the router to transfer funds from the maker's reserve to MangroveOrder contract. This is highly likely to happen after a user updates their offer by having it give more funds to the taker.  Mangrove Association (ADDMA) - MangroveOrder -   20  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangroveorder-smart-contracts/"}, {"title": "5.1   Cure.cage() Might Block Shutdown Procedure", "body": "  The cage function of the Cure contract, when called, requires that live is 1 and sets it to 0 :  function cage() external auth {     require(live == 1, \"Cure/not-live\");     live = 0;     /*...*/ }  The function is meant to be called from the End contract :  function cage() external auth {     /*...*/     cure.cage();     /*...*/ }  If an authorized user (the Governance) were to call the cage function of the Cure contract before the End  contract,  then  live  would  be  0,  therefore  the  call  to  cage  would  revert,  effectively  blocking  the shutdown process.  Risk Accepted:  MakerDAO states:  We accept this risk as it is, and actually exists in other modules such as the Vow. We understand each governance action might have important consequences. Each spell needs to be carefully evaluated.  MakerDAO - DSS Cure -   9  DesignCriticalHighMediumRiskAcceptedLowAcknowledgedDesignMediumVersion1RiskAccepted         \f5.2   Possible Optimizations  When using a uint256 as a boolean value, it is more efficient to check if it is non-zero than to check if it is equal to 1. Both the auth modifier and the liveness checks can be optimized in order to reduce gas costs and bytecode size.  The auth modifier could be implemented as follows:  modifier auth {     require(wards[msg.sender] != 0, \"Cure/not-authorized\");     _; }  The liveness could be checked like this:  require(live != 0, \"Cure/not-live\");  In total these changes reduce the bytecode size by 36 bytes and the cost of each check by 6 gas.  Acknowledged:  Rather than prioritizing minimal gas optimization Maker prefers to follow the standard of how things have been done before.  MakerDAO - DSS Cure -   10  DesignLowVersion1Acknowledged        \f6   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-cure/"}, {"title": "6.1   Delete Amt[Src] in Drop Function Is Useless", "body": "  In  the  drop  function,  the  entry  in  the  mapping  amt  that  corresponds  to  the  source  that  is  removed  is deleted :  function drop(address src) external auth {     /*...*/     delete amt[src];     /*...*/ }  This function can only be executed when the Cure contract is live :  function drop(address src) external auth {     require(live == 1, \"Cure/not-live\");     /*...*/ }  On  the  other  hand,  the  amt  mapping  can  only  be  updated  in  the  load  function,  which  can  only  be executed when the Cure contract has been caged :  function load(address src) external {     require(live == 0, \"Cure/still-live\");     /*...*/     uint256 newAmt_ = amt[src] = SourceLike(src).cure();     /*...*/ }  Since the Cure contract cannot become live again after it has been caged, the amt mapping cannot be non zero during a call to drop, thus it is useless to remove the entry.  MakerDAO - DSS Cure -   11  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-cure/"}, {"title": "5.1   Temporary DOS Through Donations", "body": "  In Notional, depositing collateral for others is possible. For example, depositUnderlyingToken can deposit  collateral  to  another  address  than  msg.sender.  Hence,  it  is  possible  to  donate  collateral  to  a position  in  such  a  way  that  it  becomes  tracked  within  the  Notional  system.  Since  the  external  position computes  the  managed  assets  based  on  what  Notional's  getAccount  returns,  such  donations  will become visible to the external position. Hence, it could be possible to temporarily DOS the position by donating to it an unsupported token.  Acknowledged:  Avantgarde Finance replied:  Preventative measures for this are challenging and add complexity, so since the worst case is that the position will have a reverting price, and since the owner can resolve this state by removing that collateral, we will provide a fix if this ever becomes an issue in practice.  Avantgarde Finance - Sulu Extensions VI -   11  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedDesignLowVersion1Acknowledged             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Balancer Price Feed Vulnerable to Read-Only Reentrancy   -Severity Findings   Borrowing From cTokens With Same Underlying Can Lead to Unreported Debt   -Severity Findings   Remaining BPT in Adapter    mulUp Incorrect Comment   0  1  1  2  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vi/"}, {"title": "6.1   Balancer Price Feed Vulnerable to Read-Only", "body": " Reentrancy  Balancer's system is vulnerable to read-only reentrancy. During the removal of liquidity, an inconsistency between the total supply and a pool's balances can be created (using native ETH transfers). That can be leveraged to manipulate the price feed upwards - leading to an over-evaluation of the fund.    Now, a reentrancy protected call to setRelayerApproval() is made when the price is computed to ensure that Balancer is not reentered.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vi/"}, {"title": "6.2   Borrowing From cTokens With Same", "body": " Underlying Can Lead to Unreported Debt  Some  cTokens  may  have  the  same  underlying  (e.g.  cWBTC  and  cWBTC2).  The  parser  validates  the cTokens to borrow from as follows:  // validate ctokens for (uint256 i; i < cTokens.length; i++) {     address cTokenStored = ICompoundDebtPosition(_externalPosition)         .getCTokenFromBorrowedAsset(assets[i]);      if (cTokenStored == address(0)) {  Avantgarde Finance - Sulu Extensions VI -   12  CriticalHighCodeCorrectedMediumCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedSecurityHighVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f        require(             CompoundPriceFeed(getCompoundPriceFeed()).getTokenFromCToken(cTokens[i]) ==                 assets[i],             \"parseAssetsForAction: Bad token cToken pair\"         );     } else {         require(             cTokenStored == cTokens[i],             \"parseAssetsForAction: Assets can only be borrowed from one cToken\"         );     } }  Note that the validation aims to prohibit borrowing from two cTokens that have the same underlying. In most cases, this works correctly. However, borrowing from both cTokens (with the same underlying) for the first time in the same action will bypass the validation. Consider the following scenario:  1. Borrow for the first time from both cWBTC and cWBTC2.  2. In the first iteration of the loop, cTokenStored will be 0x0 due to WBTC never being borrowed.  3. In  the  second  iteration  of  the  loop,  cTokenStored  will  still  be  0x0  since  the  mapping  in  the external position has not been updated yet. The update will happen in __borrowAssets, after the parser returns.  This will allow the external position to borrow from both cTokens. Note that __borrowAssets will only keep track of the first cToken. Hence, debt of the second cToken will not be tracked. The total debt will be underreported in such a scenario.    The parser now solely validates against the price feed while the library now validates against the stored cToken.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vi/"}, {"title": "6.3   Remaining BPT in Adapter", "body": "  Avantgarde Finance reported an issue when redeeming Balancer LP tokens. It was possible to redeem BPTs so that a maximum amount of burned LP tokens is specified along with exact received underlying amounts. If the maximum was not reached, the BPT remained in the adapter.    After redemption, any surplus BPT remaining in the contract is sent back to the vault proxy.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vi/"}, {"title": "6.4   mulUp Incorrect Comment", "body": "   function mulUp(uint256 _a, uint256 _b) internal pure returns (uint256 res_) {     uint256 product = _a * _b;     require(_a == 0 || product / _a == _b, \"mul overflow\");  Avantgarde Finance - Sulu Extensions VI -   13  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChanged                \f    if (product == 0) {         return 0;     } else {         // The traditional divUp formula is:         // divUp(x, y) := (x + y - 1) / y         // To avoid intermediate overflow in the addition, we distribute the division and get:         // divUp(x, y) := (x - 1) / y + 1         // Note that this requires x != 0, which we already tested for.          return ((product - 1) / ONE) + 1;     } }  The  comment  in  the  mulUp()  function  of  BalancerV2FixedPoint  mentions  divUp.  It  was  likely  copied from  there  and  not  changed.  This  issue  is  also  present  in  the  Balancer  contract  that  mulUp()  was adopted from.  Specification changed:  The comments in the files were adapted to reflect that the comments are not reviewed.  Avantgarde Finance - Sulu Extensions VI -   14  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-vi/"}, {"title": "6.1   EIP-170 Mix Up / Unlimited Contract Size", "body": "  EIP-170 has been introduced into the Ethereum mainnet with the Spurious Dragon hardfork in order to limit the maximum codesize of a contract.  The short specification of the EIP reads:  ... if contract creation initialization returns data with length of more than 0x6000 (2**14 + 2**13) bytes, contract creation fails with an out of gas error.  The data returned by the contract creation initialization is the code of the newly deployed smart contract that will be stored as the code of the smart contract. This is valid regardless wether the contract has been deployed  directly  from  a  transaction  or  a  during  code  execution  of  a  CREATE  /  CREATE2  opcode.  For more details please refer to chapter 7 of the Ethereum Yellowpaper.  The  TxPermissionBased  contract  _deployerInputLengthLimit. There is an annotated function for the owner to set this variable:  the  POSDAO  system  attempts   to  enforce  a  in   /// @dev Sets the limit of `input` transaction field length in bytes /// for contract deployment transaction made by the specified deployer. /// @param _deployer The address of a contract deployer.  POA Network - POSDAO -   15  DesignCorrectnessCriticalHighRiskAcceptedMediumRiskAcceptedAcknowledgedRiskAcceptedAcknowledgedLowAcknowledgedRiskAcceptedAcknowledgedAcknowledgedCorrectnessHighVersion1RiskAccepted            \f/// @param _limit The maximum number of bytes in `input` field of deployment transaction. /// Set it to zero to reset to default 24Kb limit defined by EIP 170.  And inside the _allowedTxTypes function which is annotated with:  /// @dev Defines the allowed transaction types which may be initiated by the specified sender with /// the specified gas price and data. Used by node's engine each time a transaction is about to be /// included into a block.  there is:  if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {     // Don't let to deploy too big contracts     return (NONE, false); }  There is a mixup here: What the TxPermission contract actually limits with this parameter is the lenght of  the  data  field  of  the  transaction,  not  the  limit  of  a  contract's  code  size.  This  has  nothing  to  do  with EIP-170. Hence if the limit is only \"enforced\" by the TxPermission contract and there is no further limit set in the chain specification anyone may deploy a contract of arbitrary size, limited only by the gas limit. EIP-170 is not activated in the template/spec.json chain sepcification file available in the repository.  Note that the Ethereum mainnet has no excplicit limit on the data field of a transaction (called input in the function description in POSDAO). This is only limited by the gas limit of a block.  Ethereum Yellowpaper: https://ethereum.github.io/yellowpaper/paper.pdf EIP-170 Specification: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md  Risk Accepted:  POA Network accepts this risk and states: Some popular projects on xDai require the abi lity to deploy contracts with size greater than 24 Kb. The limit on transacti on size is intended as an easy protection against script kiddies.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "6.2   Changing Mining and Staking Addresses", "body": " While Banned  ValidatorSetAuRa  allows  to  change  the  mining  and  staking  address  while  a  pool  is  banned.  This updates the state, including:  idByStakingAddress[oldStakingAddress] = 0; idByStakingAddress[_newStakingAddress] = poolId;  or  idByMiningAddress[_oldMiningAddress] = 0; idByMiningAddress[_newMiningAddress] = _poolId;  The available specification does not cover this scenario and it remains unclear if this should be possible or not.  POA Network - POSDAO -   16  DesignMediumVersion1RiskAccepted        \fIn case of a change of the mining address while a pool is banned, the return value of following functions may be unexpected for the caller:  /// @dev Returns the block number when the ban will be lifted for the specified mining address. /// @param _miningAddress The mining address of the pool. function bannedUntil(address _miningAddress) public view returns(uint256) {     return _bannedUntil[idByMiningAddress[_miningAddress]]; }  bannedUntil() will return 0 if the mining address of the banned pool has been changed even though the pool is banned.  function isValidatorBanned(address _miningAddress) public view returns(bool) {     uint256 bn = bannedUntil(_miningAddress);     if (bn == 0) {         // Avoid returning `true` for the genesis block         return false;     }     return _getCurrentBlockNumber() <= bn; }  This holds similarly for this function which notably is querried by BlockRewardAuRaBase.reward().  Within the system one such address can only be used once for an unique purpose, e.g. an address that has been a mining or staking address once cannot be reused anymore.  This is tracked by following mappings:  mapping(address => uint256) public hasEverBeenMiningAddress; mapping(address => bool) public hasEverBeenStakingAddress;  The information to which pool the mining address once belonged to is availabe in this mapping.  Risk accepted:  POA Network states this is expected behavior in order to allow pools to change their staking or mining address if they are compromised during the ban period.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "6.3   Incoherent Event ChangedMiningAddress", "body": " Emitted  To change a mining address, changeMiningAddress is called from the participants staking address. If the  participant  is  a  current  validator,  the  change  is  not  done  immediately.  This  emits  the InitiateChange.  Additionally,  the  function  will  always  emit  the  ChangedMiningAddress  event. Given the name of the event and that it is also emitted when the mining address is changed immediately because the participant is not part of the current validator set, this seems incoherent. As the event name suggests, the event should be emitted only when the mining address is changed or maybe renamed.  Acknowledged:  POA  Network  is  aware  that  the  ChangeMiningAddress  event  only  corresponds  to  the  immediate change of the mining address when a pool is not a validator. Unfortunately no events can be emitted at  POA Network - POSDAO -   17  DesignMediumVersion1Acknowledged        \fthe moment of the real change for the delayed case inside the system's finalizeChange function as events cannot be emitted during execution of this system operation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "6.4   Limitations of the TxPermissions Contract", "body": "  The  _allowedTxTypes  function  of  the  TxPermissions  contract  is  applied  to  all  transactions  to  be include into a block. However this means all checks are only done on external transactions created from externally  owned  accounts,  internal  transactions  (calls  within  transactions)  are  not  subject  to  these checks.  Some of these checks including e.g.  if (validatorSetContract.isValidator(_to)) {     // Validator's mining address can't receive any coins     return (NONE, false); }  can  be  circumvented  by  internal  transaction.  Internal  transactions  are  calls  from  within  bytecode execution, e.g. during execution of a smart contract.  Risk Accepted:  POA  Network  is  aware  that  the  rules  defined  by  the  TxPermissions  contracts  are  only  applied  to transactions of EOAs.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "6.5   Role Switch Needed", "body": "  The  TokenMinter  contract  calls  permissioned  functions.  These  are  mint, setBridgeContract, transferOwnership. To successfully call these functions, the TokenMinter contract needs to be the owner of the ERC677MultiBridgeToken contract.  token  contract   Regarding the setBridgeContract we have opened a separate issue because this call will always fail. But the ERC677MultiBridgeToken contract also implements other functions that are permissioned to be called only by the owner. Given the TokenMinter contract is the owner these functions could not be are:  addBridge,  removeBridge,  setBlockRewardContract, called.  These  setStakingcontract.  functions   To call this functions, the ownership needs to be transferred from the minter contract to an other contract and then back. This seems undesirable.  Acknowledged:  POA Network explains that the TokenMinter contract is used as an intermediate owner contract for the PermittableToken contract wich represents the STAKE token. To clarify this, comments where added to the TokenMinter contract.  POA Network - POSDAO -   18  DesignMediumVersion1RiskAcceptedDesignMediumVersion1Acknowledged                  \f6.6   Gas Inefficiency During Removal From Array  The staking contract keeps track of the pools using multiple arrays. When an entry has to be removed, this is done as in the following example:  uint256 indexToDelete = poolToBeRemovedIndex[_poolId];     if (_poolsToBeRemoved.length > indexToDelete && _poolsToBeRemoved[indexToDelete] == _poolId) {         uint256 lastPool = _poolsToBeRemoved[_poolsToBeRemoved.length - 1];         _poolsToBeRemoved[indexToDelete] = lastPool;         poolToBeRemovedIndex[lastPool] = indexToDelete;         poolToBeRemovedIndex[_poolId] = 0;         _poolsToBeRemoved.length--;     }  In case that the removed entry was already last in the list two SSTORE and one SLOAD operation could have been skipped.  Acknowledged:  Client states that this operation is quiet rare and, hence, will not change the implementation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "6.7   Inconsistent Use of Safemath", "body": "  The code has multiple calculations including multiplications and divisions without safemath. Even though we  could  not  find  a  place  where  we  think  calculation  would  over  or  underflow,  the  consistent  use  of safemath would ensure this.  Risk accepted:  Safe math was not used intentionally in critical functions to not cause reverts and risk a network break down. Hence, POA network accepted the risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "6.8   Potentially Compromised Key Needed to", "body": " Change Key  To change a potentially compromised staking key, the staking key is needed. Even though, the mining key is not used for tasks like key changes, in this case it might make sense from a security perspective. One reason to change a key is that it might be corrupted. In this case, it might be safer to use an other already existing key to change it.  Acknowledged:  POA network wants to keep the strong separation regarding the key usage.  POA Network - POSDAO -   19  DesignLowVersion1AcknowledgedDesignLowVersion1RiskAcceptedDesignLowVersion1Acknowledged                        \f6.9   Superfluous Call of  _finalizeNewValidators  changeMiningAddress sets _finalizeValidators.list to the unedited _pendingValidators. In  finalizeChange  triggers _finalizeNewValidators.  _finalizeNewValidators  first  removes  all  validators  and  then  adds the same. This seems unnecessary. Additionally, the comment suggest another use case for the else if.  true  and   the  else   condition   to  be   causes   this   if   Acknowledged:  POA network acknowledged the issue but decided to leave the code unchanged.  POA Network - POSDAO -   20  DesignLowVersion1Acknowledged        \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  0  3  7  -Severity Findings  -Severity Findings  -Severity Findings   Failing Function Call    No Canonical Definition of Calldata for onTokenTransfer    claimOrderedWithdraw Not Always Successful   -Severity Findings  Incorrect Comment in finalizeChange   Incorrect Description    Make onTokenTransfer() External    Multiplication After Division    No Indexed Fields for ReportedMalicious    Unchecked Return Value of Transfer    certify Missing Sanity Check   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.1   Failing Function Call", "body": "  The  TokenMinter  contract  implements  the  function  setBridgeContract  which  should  call tokenContract.setBridgeContract.  The  setBridgeContract  function  does  not  exists  in  the ERC677MultiBridgeToken contract. Hence, the function call would fail and the interface definition at the beginning is incorrect.  Specification changed:  POA Network explains that the TokenMinter contract is used as an intermediate owner contract for the PermittableToken contract wich represents the STAKE token. To clarify this, comments where added to the TokenMinter contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.2   No Canonical Definition of Calldata for ", "body": " onTokenTransfer  POA Network - POSDAO -   21  CriticalHighMediumSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1Speci\ufb01cationChanged                  \fThe function onTokenTransfer uses inline assembly to read the receiver and calldata from the calldata arguments.  The  assembly  strongly  relies  on  some  assumptions  about  the  argument  encoding  of  the Solidity.  One  of  them  is  that  there  are  no  \"garbage  bits\"  between  the  byte  offset  of  the bytes  calldata  _data  variable  and  the  length  field  of  the  bytes  calldata  _data  argument. This  assumption  will  hold  true  in  most  cases,  but  is  not  guaranteed  to  hold.  This  assumption  can  be eliminated  letting  the  compiler  copy  the  _data  into  the  memory  and  dealing  with  it  there.  Full expectations  about  the  expected  information  in  the  _data  argument  must  be  properly  documented,  to avoid the misinterpretation of the interface.  function onTokenTransfer(     address _from,     uint256 _value,     bytes calldata _data ) external returns (bool) {  A similar situation can be found in the TxPermissions contract.  Specification Changed:  The code has been commented as follows:  // It is assumed that the `_data` field contains the `length` field in its first 32 bytes. // There are data bytes right after the `length` field (without \"garbage bits\" between them).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}, {"title": "7.3   claimOrderedWithdraw Not Always", "body": " Successful  After  using  the  StakingAuRa.orderWithdraw()  function  the  validator  can  complete  the  withdrawal starting from the next epoch using claimOrderedWithdraw().  To prevent abuse, this function queries _isWithdrawAllowed once more in order to determined if the validator  may  have  been  banned  in  the  meantime.  However  _isWithdrawAllowed  also  includes  a check whether staking or withdrawals are currently allowed using areStakeAndWithdrawAllowed().  Normally such actions are not allowed near the end of a staking epoch in order to not interfere with the validator selection process. Note that claiming a previously ordered withdrawal has no influence on this and hence shouldn't be subject to this restriction. If a party happens to claim their withdrawal at the end of an epoch their withdrawal fails without apparent reason.    The _isWithdrawAllowed function has been refactored and parts of it's functionality has been moved into a new _isPoolBanned() function. This function is now querried in claimOrderedWithdraw() which resolves problem with the blocked withdrawals at the end of an epoch as described above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/poa-network-posdao/"}]