[{"title": "ERC20 non-standard names", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/117", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  Usually, the functions to increase the allowance are called `increaseAllowance` and `decreaseAllowance` but in `SherXERC20` they are called `increaseApproval` and `decreaseApproval`  ## Recommendation Rename these functions to the more common names.  "}, {"title": "`initializeSherXERC20` can be called more than once", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/116", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SherXERC20.initializeSherXERC20` function has `initialize` in its name which indicates that it should only be called once to initialize the storage. But it can be repeatedly called to overwrite and update the ERC20 name and symbol.  ## Recommendation Consider an `initializer` modifier or reverting if `name` or `symbol` is already set.  "}, {"title": "Sanitize `_weights` in `setWeights` on every use", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/115", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `setWeights` function only stores the `uint16` part of `_weights[i]` in storage (`ps.sherXWeight = uint16(_weights[i])`). However, to calculate `weightAdd/weightSub` the full value (not truncated to 16 bits) is used. This can lead to discrepancies as the actually added part is different from the one tracked in the `weightAdd` variable.   "}, {"title": "Anyone can unstake on behalf of someone", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/114", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PoolBase.unstakeWindowExpiry` function allows unstaking tokens of other users. While the tokens are sent to the correct address, this can lead to issues with smart contracts that might rely on claiming the tokens themselves.  For example, suppose the `_to` address corresponds to a smart contract that has a function of the following form:  ```solidity function withdrawAndDoSomething() {     uint256 amount = token.balanceOf(address(this));     contract.unstakeWindowExpiry(address(this), id, token);     amount = amount - token.balanceOf(address(this));     token.transfer(externalWallet, amount) } ```  If the contract has no other functions to transfer out funds, they may be locked forever in this contract.  "}, {"title": "[Gas optimizations] - Public functions that are public, but could be external", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  The following functions are public, but they could be decla  ``` getUnactivatedStakersPoolBalance(IERC20) should be declared external:         - PoolBase.getUnactivatedStakersPoolBalance(IERC20) (contracts/facets/PoolBase.sol#146-148) getTotalUnmintedSherX(IERC20) should be declared external:         - PoolBase.getTotalUnmintedSherX(IERC20) (contracts/facets/PoolBase.sol#170-173) accruedDebt(bytes32,IERC20) should be declared external:         - LibPool.accruedDebt(bytes32,IERC20) (contracts/libraries/LibPool.sol#31-34) getTotalAccruedDebt(IERC20) should be declared external:         - LibPool.getTotalAccruedDebt(IERC20) (contracts/libraries/LibPool.sol#36-39) accrueSherX(IERC20) should be declared external:         - LibSherX.accrueSherX(IERC20) (contracts/libraries/LibSherX.sol#75-81) accrueSherXWatsons() should be declared external:         - LibSherX.accrueSherXWatsons() (contracts/libraries/LibSherX.sol#83-86) deposit() should be declared external:         - AaveV2.deposit() (contracts/strategies/AaveV2.sol#75-81) ```   ## Tools Used  Slither     "}, {"title": "`_doSherX` does not return correct precision and it's confusing", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `_doSherX` function does not return the correct precision of `sherUsd` and it is **not** the \"Total amount of USD of the underlying tokens that are being transferred\" that the documentation mentions.  ```solidity sherUsd = amounts[i].mul(sx.tokenUSD[tokens[i]]); ```  Instead, the amount is inflated by `1e18`, it should divide the amount by `1e18` to get a USD value with 18 decimal precision.  The severity is low as the calling site in `payout` makes up for it by dividing by `1e18` in the `deduction` computation.  We still recommend returning the correct amount in `_doSherX` already to match the documentation and avoid any future errors when using its unintuitive return value.  "}, {"title": "Missing verification on `tokenInit`'s lock", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Gov.tokenInit` skips the underlying token check if the `_token` is SHERX:  ```solidity if (address(_token) != address(this)) {   require(_lock.underlying() == _token, 'UNDERLYING'); } ```  ## Impact This check should still be performed even for `_token == address(this) // SHERX`, otherwise, the lock can have a different underlying and potentially pay out wrong tokens.  ## Recommendation Verify the underlying of all locks.  "}, {"title": "`transferFrom` gas improval", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SherXERC20.transferFrom` function reads the allowance from memory twice. It should be read once, cached, and then use that value for the `if(cachedAllowance ...)` and for the `newApproval = ...` expressions.  "}, {"title": "`increaseApproval` gas improval", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SherXERC20.increaseApproval` function reads the allowance from memory twice. It should be read once and then cached and for the event you the `cache + _amount` value.  "}, {"title": "[Bug] A critical bug in bps function", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/90", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## A critical bug in bps function: PoolBase.sol  ``` solidity function bps() internal pure returns (IERC20 rt) {   // These fields are not accessible from assembly   bytes memory array = msg.data;   uint256 index = msg.data.length;    // solhint-disable-next-line no-inline-assembly   assembly {     // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.     rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)   } } ```  The above function is designed to expect the token at the end of `calldata`, but a malicious user can inject extra values at the end of `calldata` and fake return values.  The following contract demonstrates an example:  ``` solidity pragma solidity 0.8.6;  interface IERC20 {}  error StaticCallFailed();  contract BadEncoding {     /// Will return address(1). But address(0) is expected!     function f() external view returns (address) {         address actual = address(0);         address injected = address(1);          (bool success, bytes memory ret) = address(this).staticcall(abi.encodeWithSelector(this.g.selector, actual, injected));          if (!success) revert StaticCallFailed();          return abi.decode(ret, (address));     }     function g(IERC20 _token) external pure returns (IERC20) {         // to get rid of the unused warning         _token;         // Does it always match _token?         return bps();     }     // From Sherlock Protocol: PoolBase.sol     function bps() internal pure returns (IERC20 rt) {         // These fields are not accessible from assembly         bytes memory array = msg.data;         uint256 index = msg.data.length;          // solhint-disable-next-line no-inline-assembly         assembly {             // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.             rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)         }     } } ```  ### An example exploit  This can be used to exploit the protocol:  ``` solidity function unstake(   uint256 _id,   address _receiver,   IERC20 _token ) external override returns (uint256 amount) {   PoolStorage.Base storage ps = baseData();   require(_receiver != address(0), 'RECEIVER');   GovStorage.Base storage gs = GovStorage.gs();   PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];   require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');   // period is including   require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');   require(     withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow >= uint40(block.number),     'UNSTAKE_WINDOW_EXPIRED'   );   amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());    ps.stakeBalance = ps.stakeBalance.sub(amount);   delete ps.unstakeEntries[msg.sender][_id];   ps.lockToken.burn(address(this), withdraw.lock);   _token.safeTransfer(_receiver, amount); } ```  State token `Token1`. Let's say there is a more expensive token `Token2`.  Here's an example exploit:  ``` solidity bytes memory exploitPayload = abi.encodeWithSignature(     PoolBase.unstake.selector,     (uint256(_id), address(_receiver), address(Token2), address(Token1)) ); poolAddress.call(exploitPayload); ```  All the calculations on `ps` would be done on `Token2`, but at the end, because of, `_token.safeTransfer(_receiver, amount);`, `Token2` would be transferred. Assuming that `Token2` is more expensive than `Token1`, the attacker makes a profit.  Similarly, the same technique can be used at a lot of other places. Even if this exploit is not profitable, the fact that the computations can be done on two different tokens is buggy.  There are several other places where the same pattern is used. All of them needs to be fixed. I've not written an exhaustive list.   "}, {"title": "General suggestions", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/89", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use `type(uintX).max` instead of `uintX(-1)`  ``` diff modified   contracts/facets/Gov.sol @@ -55,7 +55,7 @@ contract Gov is IGov {      GovStorage.Base storage gs = GovStorage.gs();      SherXStorage.Base storage sx = SherXStorage.sx();  -    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(uint16(-1)); +    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(type(uint16).max);    }     function getWatsonsUnmintedSherX() external view override returns (uint256) { ```  Use `type(integerType).max` for such cases. There are also other places that could use this.  ## Have NatSpec comments for all functions ## Avoid the diamond standard  The most significant optimization that can be done in the contract is to get rid of the diamond standard, because, proxy architectures are inherently expensive. Unless there are specific reasons, such as contract size limits, a diamond makes the contract unnecessary complex. Also, try to avoid upgradability if you can afford it.   "}, {"title": "[Optimization] Changing memory to calldata and again caching in loops", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Change memory to calldata and caching in loop  ``` diff modified   contracts/facets/Manager.sol @@ -139,16 +139,17 @@ contract Manager is IManager {     function setProtocolPremiumAndTokenPrice(      bytes32 _protocol, -    IERC20[] memory _token, -    uint256[] memory _premium, -    uint256[] memory _newUsd +    IERC20[] calldata _token, +    uint256[] calldata _premium, +    uint256[] calldata _newUsd    ) external override onlyGovMain {      require(_token.length == _premium.length, 'LENGTH_1');      require(_token.length == _newUsd.length, 'LENGTH_2');       (uint256 usdPerBlock, uint256 usdPool) = _getData();  -    for (uint256 i; i < _token.length; i++) { +    uint length = _token.length; +    for (uint256 i; i < length; i++) {        LibPool.payOffDebtAll(_token[i]);        (usdPerBlock, usdPool) = _setProtocolPremiumAndTokenPrice(          _protocol, ```  About caching in loop, see my other report on why it's needed.  For the old code, i.e., having an array in memory, there is an unnecessary copy from `calldata` to `memory`. In the proposed patch, this unnecessary copy is avoided and values are directly read from `calldata` by using `calldataload(...)` instead of going via `calldatacopy(...)`, then `mload(...)`). Saves memory expansion cost, and cost of copying from `calldata` to `memory`.  There are several other places throughout the codebase where the same optimization can be used. I've not provided an exhaustive list.   "}, {"title": "[Optimization] Caching in for loops", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching in for loops  ``` diff modified   contracts/facets/PoolBase.sol @@ -128,19 +128,21 @@ contract PoolBase is IPoolBase {    {      PoolStorage.Base storage ps = baseData();      GovStorage.Base storage gs = GovStorage.gs(); -    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) { -      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) { +    PoolStorage.UnstakeEntry[] storage entries = ps.unstakeEntries[_staker]; +    uint length = entries.length; +    for (uint256 i = 0; i < length; i++) { +      if (entries[i].blockInitiated == 0) {          continue;        }        if ( -        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <= +        entries[i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=          uint40(block.number)        ) {          continue;        }        return i;      } -    return ps.unstakeEntries[_staker].length; +    return length;    } ```  Caching expensive state variables would avoid re-reading from storage. Solidity's optimizer currently will not be able to cache this value (the IR based codegen and the Yul optimizer can do it; but that is not activated by default).   "}, {"title": "[Optimization] Packing various structs carefully", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Packing the struct  ``` diff modified   contracts/storage/GovStorage.sol @@ -14,15 +14,17 @@ library GovStorage {    struct Base {      // The address appointed as the govMain entity      address govMain; +    // The amount of blocks the cooldown period takes +    uint40 unstakeCooldown; +    // The amount of blocks for the window of opportunity of unstaking +    uint40 unstakeWindow; +    // Check if the protocol is included in the solution at all +    uint16 watsonsSherxWeight; +    // The last block the total amount of rewards were accrued.      // NOTE: UNUSED      mapping(bytes32 => address) protocolManagers;      // Based on the protocol identifier, get the address of the protocol that is able the withdraw balances      mapping(bytes32 => address) protocolAgents; -    // The amount of blocks the cooldown period takes -    uint40 unstakeCooldown; -    // The amount of blocks for the window of opportunity of unstaking -    uint40 unstakeWindow; -    // Check if the protocol is included in the solution at all      mapping(bytes32 => bool) protocolIsCovered;      // The array of tokens the accounts are able to stake in      IERC20[] tokensStaker; @@ -33,8 +35,6 @@ library GovStorage {      address watsonsAddress;      // How much sherX is distributed to this account      // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this acocunt -    uint16 watsonsSherxWeight; -    // The last block the total amount of rewards were accrued.      uint40 watsonsSherxLastAccrued;    } ```  In the current layout, the members `govMain`, `unstakeCooldown`, `unstakeWindow`, `watsonsSherxWeight` all can be packed to a single slot or exactly 256 bits. This can save gas if both such elements are read or written at the same time (please use at least 0.8.2, since it has some improvements centred around optimizing packed Structs).  In the previous layout:  1.  `govMain` would have a slot of its own. 2.  `unstakeCooldown` and `unstakeWindow` would be packed together in a     single slot. 3.  `watsonsSherxWeight` and `watsonsSherxLastAccrued` would be packed     together in a single slot.  Note that gas savings are mainly relevant in the following cases:  1.  Compiler can optimize certain reads and writes to the same slot. 2.  Berlin EIP-2929 based gas accounting, i.e., if the same tx leaves     one of the slot warm. 3.  Berlin EIP-2930 for access lists. Instead of having to making three     different slots warm (in the original code), one only has to make     two slots warm, if necessary.  If none of these applies for your case, this suggestion may be ignored.  ## Packing for PoolStorage  ``` diff modified   contracts/storage/PoolStorage.sol @@ -15,20 +15,35 @@ library PoolStorage {     struct Base {      address govPool; +    // The last block the total amount of rewards were accrued. +    // Accrueing SherX increases the `unallocatedSherX` variable +    uint40 sherXLastAccrued; +    // Protocol debt can only be settled at once for all the protocols at the same time +    // This variable is the block number the last time all the protocols debt was settled +    uint40 totalPremiumLastPaid; + +    // How much sherX is distributed to stakers of this token +    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool +    uint16 sherXWeight;      //      // Staking      //      // Indicates if stakers can stake funds in the pool      bool stakes; -    // Address of the lockToken. Representing stakes in this pool -    ILock lockToken;      // Variable used to calculate the fee when activating the cooldown      // Max value is uint32(-1) which creates a 100% fee on the withdrawal      uint32 activateCooldownFee; +    // Address of the lockToken. Representing stakes in this pool +    // Indicates if protocol are able to pay premiums with this token +    // If this value is true, the token is also included as underlying of the SherX +    bool premiums; + +    ILock lockToken;      // The total amount staked by the stakers in this pool, including value of `firstMoneyOut`      // if you exclude the `firstMoneyOut` from this value, you get the actual amount of tokens staked      // This value is also excluding funds deposited in a strategy.      uint256 stakeBalance; +      // All the withdrawals by an account      // The values of the struct are all deleted if expiry() or unstake() function is called      mapping(address => UnstakeEntry[]) unstakeEntries; @@ -39,12 +54,6 @@ library PoolStorage {      // SherX could be minted before the stakers call the harvest() function      // Minted SherX that is assigned as reward for the pool will be added to this value      uint256 unallocatedSherX; -    // How much sherX is distributed to stakers of this token -    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool -    uint16 sherXWeight; -    // The last block the total amount of rewards were accrued. -    // Accrueing SherX increases the `unallocatedSherX` variable -    uint40 sherXLastAccrued;      // Non-native variables      // These variables are used to calculate the right amount of SherX rewards for the token staked      mapping(address => uint256) sWithdrawn; @@ -52,9 +61,6 @@ library PoolStorage {      //      // Protocol payments      // -    // Indicates if protocol are able to pay premiums with this token -    // If this value is true, the token is also included as underlying of the SherX -    bool premiums;      // Storing the protocol token balance based on the protocols bytes32 indentifier      mapping(bytes32 => uint256) protocolBalance;      // Storing the protocol premium, the amount of debt the protocol builds up per block. @@ -62,9 +68,6 @@ library PoolStorage {      mapping(bytes32 => uint256) protocolPremium;      // The sum of all the protocol premiums, the total amount of debt that builds up in this token. (per block)      uint256 totalPremiumPerBlock; -    // Protocol debt can only be settled at once for all the protocols at the same time -    // This variable is the block number the last time all the protocols debt was settled -    uint40 totalPremiumLastPaid;      // How much token (this) is available for sherX holders      uint256 sherXUnderlying;      // Check if the protocol is included in the token pool ```  For the same reasons as before. Taking a quick look at the code, this change should reduce gas. (Might require 0.8.2, though; there was an improvement in the optimizer that would apply to packed structs in storage.)   "}, {"title": "[Optimization] Setting higher value for optimize-runs", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Higher value of optimize-runs  ``` diff modified   hardhat.config.js @@ -25,7 +25,7 @@ module.exports = {      settings: {        optimizer: {          enabled: true, -        runs: 200, +        runs: 20000,        },      },    }, ```  This value is a tuning parameter for deploy v/s runtime costs. Higher values optimize for lower runtime cost, which is what you are looking for. The above value is an example, please decide a suitable high value, and run tests.  "}, {"title": "[Optimization] A branchless version of an if else statement", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Writing a branch less version  ``` diff @@ -76,11 +77,11 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();      uint256 oldValue = sx20.allowances[msg.sender][_spender]; -    if (_amount > oldValue) { -      sx20.allowances[msg.sender][_spender] = 0; -    } else { -      sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); -    } +    uint256 newValue; +    assembly { +        newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) +    } +    sx20.allowances[msg.sender][_spender] = newValue;      emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);      return true;    } ```  The branch-less version avoids at least two `jumpi`, i.e., at least 20 gas and some additional stack operations, along with deploy costs.  Here's a SMT proof that the transformation is equivalent:  ``` python from z3 import *  # A SMT proof that # # if (_amount > oldValue) { #   sx20.allowances[msg.sender][_spender] = 0; # } else { #   sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); # } # # is same as # # assembly { #     newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) # } # sx20.allowances[msg.sender][_spender] = newValue; #  n_bits = 256 amount = BitVec('amount', n_bits) oldValue = BitVec('oldValue', n_bits) allowance = BitVec('oldValue', n_bits)  old_allowance_computation = If(UGT(amount, oldValue), 0, oldValue - amount)  def GT(x, y):     return If(UGT(x, y), BitVecVal(1, n_bits), BitVecVal(0, n_bits)) def MUL(x, y):     return x * y def SUB(x, y):     return x - y  new_allowance_computation = MUL(GT(oldValue, amount), SUB(oldValue, amount))  solver = Solver() solver.add(old_allowance_computation != new_allowance_computation)  result = solver.check() print(result) # unsat ```   "}, {"title": "[Optimization] Caching variable", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching variable  ``` diff modified   contracts/facets/SherXERC20.sol @@ -66,8 +66,9 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_spender != address(0), 'SPENDER');      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20(); -    sx20.allowances[msg.sender][_spender] = sx20.allowances[msg.sender][_spender].add(_amount); -    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]); +    uint256 newAllowance = sx20.allowances[msg.sender][_spender].add(_amount); +    sx20.allowances[msg.sender][_spender] = newAllowance; +    emit Approval(msg.sender, _spender, newAllowance);      return true;    } ```  The above change would avoid a `sload`, and will instead use `dupX`, saving \\`100\\` gas.   "}, {"title": "withdraw returns the final amount withdrawn", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function withdraw in ILendingPool returns the actual withdrawn amount, however, function withdraw in AaveV2 strategy does not check this return value so e.g. function strategyWithdraw may actually withdraw less but still add the full amount to the staked balance:      ps.strategy.withdraw(_amount);     ps.stakeBalance = ps.stakeBalance.add(_amount);  ## Recommended Mitigation Steps function withdraw in IStrategy should return uint indicating the actual withdrawn amount and functions that use it should account for that.  "}, {"title": "Functions aBalance and balanceOf", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is no difference between functions aBalance and balanceOf in contract AaveV2, they both return aWant, so there is no point in having them separately.  ## Recommended Mitigation Steps Remove internal function aBalance and make balanceOf public.  "}, {"title": "AaveV2 approves lending pool in the constructor", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract AaveV2 does not cache the lending pool, it retrieves it when necessary by calling a function getLp(). This is great as the implementation may change, however, this contract also approves an unlimited amount of want in the constructor:    ILendingPool lp = getLp();    want.approve(address(lp), uint256(-1)); so if the implementation changes, the approval will reset. This will break the deposit function as it will try to deposit to this new lending pool with 0 approval.   For reference, function setLendingPoolImpl: https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65   Not sure how likely is that lending pool implementation will change so marking this as 'Low'.  ## Recommended Mitigation Steps Before calling lp.deposit check that the approval is sufficient and increase otherwise.  "}, {"title": "typo: `ineglible_yield_amount` -> `ineligible_yield_amount`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details    "}, {"title": "Use calldata is a little more gas efficient ", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact Using `calldata` for function parameter is a slightly more gas efficient   ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L192-L225 ## Tools Used None ## Recommended Mitigation Steps ref: https://mudit.blog/solidity-gas-optimization-tips/   "}, {"title": "Gov.sol: Use SafeERC20.safeApprove in tokenUnload()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/51", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  This is probably an oversight since `SafeERC20` was imported and `safeTransfer()` was used for ERC20 token transfers. Nevertheless, note that `approve()` will fail for certain token implementations that do not return a boolean value (Eg. OMG and ADX tokens). Hence it is recommend to use `safeApprove()`.  ### Recommended Mitigation Steps  Update to `_token.safeApprove(address(_native), totalToken)` in `tokenUnload()`.  "}, {"title": "Yield distribution after large payout seems unfair", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When a large payout occurs, it will lower unallocatedSherX. This could mean some parties might not be able to get their Yield.  The first couple of users (for which harvest is called or which transfer tokens) will be able to get their full Yield,  until the moment unallocatedSherX is depleted. The next users don't get any yield at all. This doesn't seem fair.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from, address to, uint256 amount) private { ... ps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108  function payout( address _payout, IERC20[] memory _tokens, uint256[] memory _firstMoneyOut, uint256[] memory _amounts, uint256[] memory _unallocatedSherX,  address _exclude ) external override onlyGovPayout {     // all pools (including SherX pool) can be deducted fmo and balance     // deducting balance will reduce the users underlying value of stake token     // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards     // for users that did not claim them (e.g materialized them and included in SherX pool) ....     // Subtract from unallocated, as the tokens are now allocated to this payout call         ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);  ## Tools Used  ## Recommended Mitigation Steps If unallocatedSherX is insufficient to provide for all the yields, only give the yields partly (so that each user gets their fair share).   "}, {"title": "SherX.sol: Change variable names weightSub and weightAdd to totalWeightOld and totalWeightNew", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In `setWeights()`, the variables `weightAdd` and `weightSub` are used to ensure that there is no difference in the total weight.  ### Recommended Mitigation Steps  Consider `totalWeightOld` and `totalWeightNew` as the variable names instead as they are more indicative of the intended usage and behaviour.  "}, {"title": "Manager.sol: Pass ps.sherXUnderlying instead of ps into updateData()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The only value from poolStorage in `updateData()` is the `sherXUnderlying` value. It is cheaper to pass this `uint256` variable instead of the storage variable itself.  ### Recommended Mitigation Steps  Change `PoolStorage.Base storage ps` to `uint256 sherXUnderlying`, saves about ~160 gas.  "}, {"title": "Manager.sol: Can avoid safemath sub in usdPerBlock and usdPool calculations", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In `updateData()`,   ```jsx if (sub > add) {   usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18)); } else {   usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18)); } ```  we can calculate the difference between `sub` and `add` in both cases without SafeMath because we already know one is greater than the other.   Also, the logic can be made similar to the `usdPool` calculation since nothing changes in the case where `sub == add`.  The same safemath subtraction avoidance can be implemented for the `usdPool` calculation.  Finally, the variables `sub` and `add` are confusing (makes the code difficult to read because of safemath's add and sub). It is suggested to rename them to `oldUsdPerBlock` and `newUsdPerBlock` respectively.  ### Recommended Mitigation Steps  ```jsx // If oldUsdPerBlock == newUsdPerBlock, nothing changes if (oldUsdPerBlock > newUsdPerBlock) {   usdPerBlock = usdPerBlock.sub((oldUsdPerBlock - newUsdPerBlock).div(10**18)); } else if (oldUsdPerBlock < newUsdPerBlock) {   usdPerBlock = usdPerBlock.add((newUsdPerBlock - oldUsdPerBlock).div(10**18)); }  if (_newUsd > _oldUsd) {  usdPool = usdPool.add((_newUsd - _oldUsd).mul(ps.sherXUnderlying).div(10**18)); } else if (_newUsd < _oldUsd) {  usdPool = usdPool.sub((_oldUsd - _newUsd).mul(ps.sherXUnderlying).div(10**18)); } ```  "}, {"title": "LibSherX.sol: Optimise calcUnderlying()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  - `tokens` can be directly be assigned to `gs.tokensSherX`. - Redundant zero Initialization of the array element `amounts[i] = 0;` in the else case of `calcUnderlying()` (L69-L71).  ### Recommended Mitigation Steps  ```jsx function calcUnderlying(uint256 _amount)  external  view returns (IERC20[] memory tokens, uint256[] memory amounts) {  GovStorage.Base storage gs = GovStorage.gs();    tokens = gs.tokensSherX;   amounts = new uint256[](gs.tokensSherX.length);    uint256 total = getTotalSherX();    for (uint256 i; i < gs.tokensSherX.length; i++) {     IERC20 token = tokens[i];     if (total > 0) {       PoolStorage.Base storage ps = PoolStorage.ps(token);       amounts[i] = ps.sherXUnderlying.add(LibPool.getTotalAccruedDebt(token)).mul(_amount).div(         total       );     }   } } ```  Gas reporter reports a gas reduction of ~150 gas. Gas savings should scale with number of underlying collaterals.  "}, {"title": "Gov.sol: Non-intuitive comment in tokenRemove()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In `tokenRemove()`, the comment `// NOTE: removed because firstMoneyOut will always be less or equal to stakeBalance` is not intuitive because it is not clear what is removed.  Perhaps `// NOTE: check that firstMoneyOut == 0 not needed since firstMoneyOut <= stakeBalance` will be better.  "}, {"title": "Define Global Constants", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  For better code readability, it would be good to specify the constants `uint16(-1)`, `uint32(-1)` and `10**18` in a separate contract to be imported in relevant contracts.  - `10e17` was used in payout() instead of the conventional `10**18` defined everywhere else - The docs specified that the cooldown fee and sherX weight are scaled by `10**18`, but they are scaled by `uint32(-1)` and `uint16(-1)` respectively (interfaces natspec is correct).  ### Recommended Mitigation Steps  Consider suggestive constants like `MAX_SHERX_WEIGHT` or `SHERX_DENOM`, `MAX_COOLDOWN_FEE` or `COOLDOWN_FEE_DENOM` and `PRECISION`.  "}, {"title": "prevent burn in _transfer", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer in SherXERC20.sol allow transfer to address 0. This is usually considered the same as burning the tokens and the Emit is indistinguishable from an Emit of a burn.  However the burn function in LibSherXERC20.sol has extra functionality, which _transfer doesn't have. sx20.totalSupply = sx20.totalSupply.sub(_amount);  So it is safer to prevent _transfer to address 0 (which is also done in the openzeppelin erc20 contract) See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L226  Note: minting from address 0 will not work because that is blocked by the safemath sub in:  sx20.balances[_from] = sx20.balances[_from].sub(_amount);  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherXERC20.sol#L118 function _transfer(address _from, address _to, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.balances[_to] = sx20.balances[_to].add(_amount);     emit Transfer(_from, _to, _amount);   }  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherXERC20.sol#L29 function burn(address _from, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.totalSupply = sx20.totalSupply.sub(_amount);     emit Transfer(_from, address(0), _amount);   } ## Tools Used  ## Recommended Mitigation Steps add something like to following to _transfer of SherXERC20.sol:         require(_to!= address(0), \"Transfer to the zero address\");  Or update sx20.totalSupply if burning a desired operation.  "}, {"title": "series of divs", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function payout contains an expression with 3 sequential divs. This is generally not recommended because it could lead to rounding errors / loss of precision. Also a div is usually more expensive than a mul. Also an intermediate division by 0 (if SherXERC20Storage.sx20().totalSupply) == 0) could occur.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108 function payout( ..  uint256 deduction =  excludeUsd.div(curTotalUsdPool.div(SherXERC20Storage.sx20().totalSupply)).div(10e17);  ## Tools Used  ## Recommended Mitigation Steps Verify the formula and replace with something like: uint256 deduction =  excludeUsd.mul(SherXERC20Storage.sx20().totalSupply).div(  curTotalUsdPool.mul(10e17) )  "}, {"title": "don't use add(add.sub(sub)", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _updateData contains variables with the names \"sub\" and \"add\". There are also functions with the names \"sub\" and \"add\". The resulting code is not very readable:       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));  Generally it is not recommended to use the same name for variables and functions.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Manager.sol#L386  function _updateData( ..     uint256 sub = _oldPremium.mul(_oldUsd);  ..    uint256 add = _newPremium.mul(_newUsd);      if (sub > add) {       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));     } else {       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));     }  ## Tools Used  ## Recommended Mitigation Steps Rename the variables \"add\" and \"sub\" to different names.   "}, {"title": "prevent div by 0", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn't done.  Especially in doYield a first check is done for totalAmount >0, however a few lines later there is an other div(totalAmount) which isn't checked.  The proof of concept show another few examples.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from,address to,uint256 amount) private { ..     uint256 totalAmount = ps.lockToken.totalSupply(); ..      if (totalAmount > 0) {       ineglible_yield_amount = ps.sWeight.mul(amount).div(totalAmount);     } else {       ineglible_yield_amount = amount;     }     if (from != address(0)) {       uint256 raw_amount = ps.sWeight.mul(userAmount).div(totalAmount);  // totalAmount could be 0, see lines above  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L295 function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) { ...   uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());   // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L351  function unstake( uint256 _id, address _receiver, IERC20 _token ) external override returns (uint256 amount) { ...    amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());  // // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L67  function stake( PoolStorage.Base storage ps,uint256 _amount, address _receiver ) external returns (uint256 lock) { ...      lock = _amount.mul(totalLock).div(stakeBalance(ps));   // stakeBalance(ps) might be 0  ## Tools Used  ## Recommended Mitigation Steps Make sure division by 0 won't occur by checking the variables beforehand and handling this edge case.  "}, {"title": "x > 0 ==> x!=0", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact A small gas optimization is possible by replacing x > 0 with  x != 0 provide x is an unsigned integer. As the entire code only uses unsigned integers it can be done on all these locations. The proof of concept shows the locations where the \"x > 0\" construction is used.  ## Proof of Concept  .\\facets\\Gov.sol:    require(_tokens.length > 0, 'ZERO'); .\\facets\\Gov.sol:    if (totalToken > 0) { .\\facets\\Gov.sol:    if (totalFee > 0) { .\\facets\\Gov.sol:    if (balance > 0) { .\\facets\\Manager.sol:    if (ps.sherXUnderlying > 0) { .\\facets\\Manager.sol:    if (usdPerBlock > 0 && _currentTotalSupply == 0) { .\\facets\\Manager.sol:    } else if (usdPool > 0) { .\\facets\\Payout.sol:      if (unallocatedSherX > 0) { .\\facets\\Payout.sol:      if (firstMoneyOut > 0) { .\\facets\\Payout.sol:    if (totalUnallocatedSherX > 0) { .\\facets\\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolBase.sol:    if (fee > 0) { .\\facets\\PoolBase.sol:    if (_forceDebt && accrued > 0) { .\\facets\\PoolBase.sol:    if (ps.protocolBalance[_protocol] > 0) { .\\facets\\PoolBase.sol:    if (ps.protocolPremium[_protocol] > 0) { .\\facets\\PoolOpen.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\SherX.sol:    if (stakeBalance > 0) { .\\facets\\SherX.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\SherX.sol:    if (totalAmount > 0) { .\\facets\\SherX.sol:      if (withdrawable_amount > 0) { .\\libraries\\LibSherX.sol:      if (total > 0) { .\\libraries\\LibSherX.sol:    if (sherX > 0) { .\\libraries\\LibSherX.sol:    if (sherX > 0) { .\\strategies\\AaveV2.sol:    require(amount > 0, 'ZERO_AMOUNT');  ## Tools Used grep  ## Recommended Mitigation Steps replace x > 0 with  x != 0  "}, {"title": "delete ps.stakeBalance", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function tokenUnload, ps.stakeBalance is only deleted if balance >0 e.g it is deleted if ps.stakeBalance > ps.firstMoneyOut So if ps.stakeBalance ==  ps.firstMoneyOut then ps.stakeBalance will not be deleted. And then a call to tokenRemove will revert, because it checks for ps.stakeBalance to be 0  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L271  function tokenUnload( IERC20 _token, IRemove _native, address _remaining ) external override onlyGovMain { ...     uint256 balance = ps.stakeBalance.sub(ps.firstMoneyOut);     if (balance > 0) {       _token.safeTransfer(_remaining, balance);       delete ps.stakeBalance;     } ..   delete ps.firstMoneyOut;   function tokenRemove(IERC20 _token) external override onlyGovMain {   ...     require(ps.stakeBalance == 0, 'BALANCE_SET');   ## Tools Used  ## Recommended Mitigation Steps Check what to do in this edge case and add the appropriate code.  "}, {"title": "confusing comment in protocolUpdate", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/19", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The comment \"NOTE: UNUSED\" can be interpreted that both protocolManagers and protocolAgents are unused. See proof of concept below. However only protocolManagers is unused.   ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L148 function protocolUpdate( bytes32 _protocol, address _eoaProtocolAgent,address _eoaManager) public override onlyGovMain { ...     // NOTE: UNUSED     gs.protocolManagers[_protocol] = _eoaManager;     gs.protocolAgents[_protocol] = _eoaProtocolAgent;   }  ## Tools Used  ## Recommended Mitigation Steps Change the comment to: // NOTE: protocolManagers UNUSED    "}, {"title": "extra check setUnstakeWindow and setCooldown", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setUnstakeWindow and setCooldown don't check that the input parameter isn't 0. So the values could accidentally be set to 0 (although unlikely). However you wouldn't want the to be 0 because that would allow attacks with flashloans (stake and unstake in the same transaction)  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L124  function setUnstakeWindow(uint40 _unstakeWindow) external override onlyGovMain {     require(_unstakeWindow < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeWindow = _unstakeWindow;   }    function setCooldown(uint40 _period) external override onlyGovMain {     require(_period < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeCooldown = _period;   }  ## Tools Used  ## Recommended Mitigation Steps Check the input parameter of setUnstakeWindow and setCooldown isn't 0     "}, {"title": "Two functions with the same implementation", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions getTotalUsdPool and viewAccrueUSDPool have the same implementation. It saves some gas on the deployment to integrate these functions. Also the maintenance will be a bit easier.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L42 function getTotalUsdPool() external view override returns (uint256) {     SherXStorage.Base storage sx = SherXStorage.sx();     return sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L18   function viewAccrueUSDPool() public view returns (uint256 totalUsdPool) {     SherXStorage.Base storage sx = SherXStorage.sx();     totalUsdPool = sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  ## Tools Used  ## Recommended Mitigation Steps Integrate the functions getTotalUsdPool and viewAccrueUSDPool (e.g. keep one and remove the other and update the references)  "}, {"title": "Different solidity pramas", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Several different solidity pragmas are uses for different solidity version. Its cleaner to use the same version everywhere  ## Proof of Concept .\\ForeignLock.sol:pragma solidity ^0.7.4; .\\NativeLock.sol:pragma solidity ^0.7.4; .\\facets\\Gov.sol:pragma solidity ^0.7.4; .\\facets\\GovDev.sol:pragma solidity ^0.7.0; .\\facets\\Manager.sol:pragma solidity ^0.7.4; .\\facets\\Payout.sol:pragma solidity ^0.7.4; .\\facets\\PoolBase.sol:pragma solidity ^0.7.4; .\\facets\\PoolDevOnly.sol:pragma solidity ^0.7.4; .\\facets\\PoolOpen.sol:pragma solidity ^0.7.4; .\\facets\\PoolStrategy.sol:pragma solidity ^0.7.4; .\\facets\\SherX.sol:pragma solidity ^0.7.4; .\\facets\\SherXERC20.sol:pragma solidity ^0.7.1; .\\interfaces\\IGov.sol:pragma solidity ^0.7.4; .\\interfaces\\IGovDev.sol:pragma solidity ^0.7.4; .\\interfaces\\ILock.sol:pragma solidity ^0.7.4; .\\interfaces\\IManager.sol:pragma solidity ^0.7.4; .\\interfaces\\IPayout.sol:pragma solidity ^0.7.4; .\\interfaces\\IPoolBase.sol:pragma solidity ^0.7.4; .\\interfaces\\IPoolStake.sol:pragma solidity ^0.7.4; .\\interfaces\\IPoolStrategy.sol:pragma solidity ^0.7.4; .\\interfaces\\IRemove.sol:pragma solidity ^0.7.4; .\\interfaces\\ISherlock.sol:pragma solidity ^0.7.4; .\\interfaces\\ISherX.sol:pragma solidity ^0.7.4; .\\interfaces\\ISherXERC20.sol:pragma solidity ^0.7.1; .\\interfaces\\IStrategy.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\DataTypes.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IAaveDistributionManager.sol:pragma solidity 0.7.6; .\\interfaces\\aaveV2\\IAaveGovernanceV2.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IAaveIncentivesController.sol:pragma solidity 0.7.6; .\\interfaces\\aaveV2\\IAToken.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IExecutorWithTimelock.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IGovernanceV2Helper.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\ILendingPool.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\ILendingPoolAddressesProvider.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IProposalValidator.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IStakeAave.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\MockAave.sol:pragma solidity ^0.7.4; .\\libraries\\LibPool.sol:pragma solidity ^0.7.4; .\\libraries\\LibSherX.sol:pragma solidity ^0.7.4; .\\libraries\\LibSherXERC20.sol:pragma solidity ^0.7.4; .\\storage\\GovStorage.sol:pragma solidity ^0.7.0; .\\storage\\PayoutStorage.sol:pragma solidity ^0.7.0; .\\storage\\PoolStorage.sol:pragma solidity ^0.7.0; .\\storage\\SherXERC20Storage.sol:pragma solidity ^0.7.1; .\\storage\\SherXStorage.sol:pragma solidity ^0.7.0; .\\strategies\\AaveV2.sol:pragma solidity ^0.7.4; .\\util\\ERC20Mock.sol:pragma solidity ^0.7.4; .\\util\\Import.sol:pragma solidity ^0.7.4; .\\util\\RemoveMock.sol:pragma solidity ^0.7.4; .\\util\\StrategyMock.sol:pragma solidity ^0.7.4;  ## Tools Used grep  ## Recommended Mitigation Steps  Use the same solidity version everywhere  "}, {"title": "Declare NativeLock underlying variable as immutable", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas cost when reading the underlying variable from NativeLock given that it is only set once in the constructor  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/NativeLock.sol#L14  ## Tools Used Manual review  ## Recommended Mitigation Steps IERC20 public override immutable underlying;  "}, {"title": "Aav2V2 is Ownable but not owner capabilites are used", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  patitonar   # Vulnerability details  ## Impact Reduce bytecode size of AaveV2 by removing Ownable given that there is no functionality for owners  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L21  ## Tools Used Manual Review  ## Recommended Mitigation Steps Update AaveV2 to only extend from IStrategy and remove Ownable import  "}, {"title": "Avoid storing lp in AaveV2 constructor", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas costs on constructor by not storing the result of a method invocation in a variable  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L51-L52  ## Tools Used Manual Review  ## Recommended Mitigation Steps Use the result directly. Example: want.approve(address(getLp()), uint256(-1));  "}, {"title": "Make variables immutable or constant", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  bw   # Vulnerability details  ## Impact The `AaveV2.sol` contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  ## Proof of Concept  ### Code Diff  ``` diff --git a/contracts/strategies/AaveV2.sol b/contracts/strategies/AaveV2.sol index 1b6ed56..9592986 100644 --- a/contracts/strategies/AaveV2.sol +++ b/contracts/strategies/AaveV2.sol @@ -21,15 +21,15 @@ import '../interfaces/IStrategy.sol';  contract AaveV2 is IStrategy, Ownable {    using SafeMath for uint256;   -  ILendingPoolAddressesProvider public lpAddressProvider = +  ILendingPoolAddressesProvider public constant lpAddressProvider =      ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5); -  IAaveIncentivesController public aaveIncentivesController; +  IAaveIncentivesController public immutable aaveIncentivesController;   -  ERC20 public override want; -  IAToken public aWant; +  ERC20 public immutable override want; +  IAToken public immutable aWant;   -  address public sherlock; -  address public aaveLmReceiver; +  address public immutable sherlock; +  address public immutable aaveLmReceiver;      modifier onlySherlock() {      require(msg.sender == sherlock, 'sherlock'); @@ -49,7 +49,7 @@ contract AaveV2 is IStrategy, Ownable {      aaveLmReceiver = _aaveLmReceiver;        ILendingPool lp = getLp(); -    want.approve(address(lp), uint256(-1)); +    ERC20(_aWant.UNDERLYING_ASSET_ADDRESS()).approve(address(lp), uint256(-1));    } ```  ### Gas Reporter Diff  ``` diff --git a/base.rst b/immutable.rst index 36b3138..79703fc 100644 --- a/base.rst +++ b/immutable.rst @@ -1,199 +1,199 @@  \u00b7----------------------------------------------------|---------------------------|-------------|-----------------------------\u00b7  |                Solc version: 0.7.6                 \u00b7  Optimizer enabled: true  \u00b7  Runs: 200  \u00b7  Block limit: 12450000 gas  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  Methods                                           \u00b7              100 gwei/gas               \u00b7       2058.77 usd/eth       \u2502 +|  Methods                                           \u00b7              100 gwei/gas               \u00b7       2061.52 usd/eth       \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Contract      \u00b7  Method                           \u00b7  Min        \u00b7  Max        \u00b7  Avg        \u00b7  # calls      \u00b7  usd (avg)  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2        \u00b7  claimRewards                     \u00b7     397877  \u00b7     437371  \u00b7     417624  \u00b7            2  \u00b7      85.98  \u2502 +|  AaveV2        \u00b7  claimRewards                     \u00b7     391566  \u00b7     431060  \u00b7     411313  \u00b7            2  \u00b7      84.79  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2        \u00b7  deposit                          \u00b7          -  \u00b7          -  \u00b7     278549  \u00b7            4  \u00b7      57.35  \u2502 +|  AaveV2        \u00b7  deposit                          \u00b7          -  \u00b7          -  \u00b7     274205  \u00b7            4  \u00b7      56.53  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2        \u00b7  withdraw                         \u00b7     260005  \u00b7     294205  \u00b7     277105  \u00b7            2  \u00b7      57.05  \u2502 +|  AaveV2        \u00b7  withdraw                         \u00b7     253692  \u00b7     287892  \u00b7     270792  \u00b7            2  \u00b7      55.82  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2        \u00b7  withdrawAll                      \u00b7      59690  \u00b7     275814  \u00b7     167752  \u00b7            2  \u00b7      34.54  \u2502 +|  AaveV2        \u00b7  withdrawAll                      \u00b7      53349  \u00b7     267370  \u00b7     160360  \u00b7            2  \u00b7      33.06  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 |  Deployments                                       \u00b7                                         \u00b7  % of limit   \u00b7             \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2                                            \u00b7          -  \u00b7          -  \u00b7     802248  \u00b7        6.4 %  \u00b7     165.16  \u2502 +|  AaveV2                                            \u00b7          -  \u00b7          -  \u00b7     762851  \u00b7        6.1 %  \u00b7     157.26  \u2502 ```  ### Average Improvements  | Function      | Base      | Immutable | Diff    | |---------------|-----------|-----------|---------| | claimRewards  | 417624    | 411313    | -1.53%  | | deposit       | 278549    | 274205    | -1.58%  | | withdraw      | 277105    | 270792    | -2.33%  | | withdrawAll   | 167752    | 160360    | -4.61%  | | deployment    | 802248    | 762851    | -5.16%  |  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced to `700206`, which is an 14.57% reduction in gas costs.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the `immutable` key word to all variables that are only set during the constructor. Add the `constant` modifier for `lpAddressProvider`.  "}, {"title": "Cache storage variables to local variables to save gas", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In general, if a state variable is read more than once, caching its value to a local variable and reusing it will save gas since a storage read spends more gas than a memory write plus a memory read.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L122-L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L122-L125) [TransactionManager.sol#L254-L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L254-L260)  ## Recommended Mitigation Steps  Rewrite #L122-L125 as follows:  ```solidity uint256 balance = routerBalances[msg.sender][assetId]; require(balance >= amount, \"removeLiquidity: INSUFFICIENT_FUNDS\");  // Update router balances routerBalances[msg.sender][assetId] = balance - amount; ```  Rewrite #L254-L260 as follows:  ```solidity uint256 balance = routerBalances[invariantData.router][invariantData.receivingAssetId]; require(     balance >= amount,     \"prepare: INSUFFICIENT_LIQUIDITY\" );  // Decrement the router liquidity routerBalances[invariantData.router][invariantData.receivingAssetId] = balance - amount; ```  "}, {"title": "Use the `unchecked` keyword to save gas", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Using the `unchecked` keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.  ## Proof of Concept  We can apply the `unchecked` keyword in the following lines of code since there are `require` statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  Referenced code: [TransactionManager.sol#L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L125) [TransactionManager.sol#L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L260) [TransactionManager.sol#L364](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L364) [TransactionManager.sol#L520](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L520)  ## Recommended Mitigation Steps  For example, change the code at line 364 to:  ```solidity unchecked {     uint256 toSend = txData.amount - relayerFee; } ```  "}, {"title": "Deflationary and fee-on-transfer tokens are not correctly accounted", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  When a router adds liquidity to the `TransactionManager`, the manager does not correctly handle the received amount if the transferred token is a deflationary or fee-on-transfer token. The actual received amount is less than that is recorded in the `routerBalances` variable.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L97](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L97) [TransactionManager.sol#L101](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L101)  ## Recommended Mitigation Steps  Get the received token amount by calculating the difference of token balance before and after the transfer, for example:  ```solidity uint256 balanceBefore = getOwnBalance(assetId); require(LibERC20.transferFrom(assetId, router, address(this), amount, \"addLiquidity: ERC20_TRANSFER_FAILED\"); uint256 receivedAmount = getOwnBalance(assetId) - balanceBefore;  // Update the router balances routerBalances[router][assetId] += receivedAmount; ```  "}, {"title": "Missing @param in fulfill NatSpec", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The currect implementation of NatSpec of fulfill function lacks @param callData  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L302  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps It's suggested to complete adding @param callData  "}, {"title": "Revert strings", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Revert strings  ### Consider using custom errors instead of revert strings  Can save gas when the revert condition has been met. And also during runtime.  ### Consider shortening revert strings to less than 32 bytes  Revert strings more than 32 bytes require at least one additional `mstore`, along with additional operations for computing memory offset, etc.  Even if you need a string to represent an error, it can usually be done in less than 32 bytes / characters.  Here are some examples of strings that can be shortened from codebase:  ``` txt ./contracts/TransactionManager.sol:96:      \"addLiquidity: ETH_WITH_ERC_TRANSFER\" ./contracts/TransactionManager.sol:97:      \"addLiquidity: ERC20_TRANSFER_FAILED\" ./contracts/TransactionManager.sol:122:     \"removeLiquidity: INSUFFICIENT_FUNDS\" ```  Note that this will only decrease runtime gas when the revert condition has been met. Regardless, it will decrease deploy time gas.    "}, {"title": "Don't ask for the user's signature when msg.sender == txData.user", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I think it would make sense not to check the user's signature in recoverCancelSignature or recoverFulfillSignature if the caller is the user himself.   ## Recommended Mitigation Steps Replace: require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, \"cancel: INVALID_SIGNATURE\"); require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\"); with: require(msg.sender == txData.user || recoverCancelSignature(txData, relayerFee, signature) == txData.user, \"cancel: INVALID_SIGNATURE\"); require(msg.sender == txData.user || recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\");  "}, {"title": "Refacotr: Reuse same code for hashVariantTransactionData with txData and when preparedBlockNumber is 0", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact  The code uses `hashVariantTransactionData` to verify the hash of the VariantTransactionData It also uses ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  To generate VariantTransactionData with `preparedBlockNumber` set to 0  A simple refactoring of: ```   function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     return hashVariantTransaction(txData.amount, txData.expiry, txData.preparedBlockNumber)   }    function hashVariantTransaction(uint256 amount, uint256 expiry, uint256 prepareBlocNumber) internal pure returns (bytes32) {     return keccak256(abi.encode(VariantTransactionData({       amount: amount,       expiry: expiry,       preparedBlockNumber: preparedBlockNumber     })));   }  ```  This would allow to further steamline the code from ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  to  ```     variantTransactionData[digest] = hashVariantTransaction(txData.amount, txData.expiry, 0) ```  ## Recommended Mitigation Steps This has no particular benefit beside making all code related to Variant Data consistent   "}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks are in general a best-practice. However, addLiquidity() and removeLiquidity() are missing zero-address checks on router and recipient addresses respectively.    addLiquidity() on Eth transfers will update the zero index balance and get logged as such in the event without the amount getting accounted for the correct router.  For ERC20 assets, token.transfer() generally implements this check but the Eth transfer using transferEth() does not have this check and calls addr.call(value) which will lead to burning in the case of removeLiquidity().   The checks may be more important because assetID is 0 for Eth. So a router may accidentally use 0 values for both assetID and router/recipient.  There is also a missing zero-address check on sendingChainFallback which is relevant for Eth transfers in cancel(). The comment on L178 indicates the need for this but the following check on L179 ends up checking receivingAddress instead (which is also necessary).   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88 https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L101-L104  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L116 https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128-L131  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address checks.  "}, {"title": "Lack of guarded launch approach may be risky", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol appears to allow arbitrary assets, amounts and routers/users without an initial time-bounded whitelist of assets/routers/users or upper bounds on amounts. Also, there is no pause/unpause functionality. While this lack of ownership and control makes it completely permissionless, it is a risky design because if there are latent protocol vulnerabilities there is no fallback option.  ## Proof of Concept  Lack of owner, whitelisting, thresholds, pause/unpause in the protocol.  See https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider an initial guarded launch approach to owner-based whitelisting asset types, router/recipient addresses, amount thresholds and adding a pause/unpause functionality for emergency handling. The design should be able to make this owner configurable where the owner can renounce ownership at a later point when the protocol operation is sufficiently time-tested and deemed stable/safe.  "}, {"title": "Expired transfers will lock user funds on the sending chain", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/47", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The cancelling relayer is being paid in receivingAssetId on the sendingChain instead of in sendingAssetID. If the user relies on a relayer to cancel transactions and that receivingAssetId asset does not exist on the sending chain (assuming only sendingAssetID on the sending chain and receivingAssetId on the receiving chain are assured to be valid and present) then the cancel transaction from the relayer will always revert and user\u2019s funds will remain locked on the sending chain.  Impact: Expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change receivingAssetId to sendingAssetId in transferAsset() on L514.  "}, {"title": "Router liquidity on receiving chain can be double-dipped by the user", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/46", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  During fulfill() on the receiving chain, if the user has set up an external contract at txData.callTo, the catch blocks for both IFulfillHelper.addFunds() and IFulfillHelper.excute() perform transferAsset to the predetermined fallback address txData.receivingAddress.  If addFunds() has reverted earlier, toSend amount would already have been transferred to the receivingAddress. If execute() also fails, it is again transferred.   Scenario: User sets up receiver chain txData.callTo contract such that both addFunds() and execute() calls revert and that will let him get twice the toSend amount credited to the receivingAddress. So effectively, Alice locks 100 tokenAs on chain A and can get 200 tokenAs (or twice the amount of any token she is supposed to get on chainB from the router), minus relayer fee, on chainB. Router liquidity is double-dipped by Alice and router loses funds.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L395-L409  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L413-L428  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The second catch block for execute() should likely not have the transferAsset() call. It seems like a copy-and-paste bug unless there is some reason that is outside the specified scope and documentation for this contest.  "}, {"title": "Checking non-zero value can avoid an external call to save gas", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Checking if toSend > 0 before making the external library call to LibAsset.transferAsset() can save 2600 gas by avoiding the external call in such situations.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L375-L380  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L364  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toSend > 0 to predicate on L375 similar to check on L387.  "}, {"title": "Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on different functions", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  While it may be considered extra-safe to have a nonreentrant modifier on all functions making any external calls even though they are to trusted contracts, when functions implement Checks-Effects-Interactions (CEI) pattern, it is helpful to evaluate the perceived security benefit vs gas usage trade-off for using nonreentrant modifier.  Functions adhering to the CEI pattern may consider not having the nonreentrant modifier which does two SSTORES (getting more expensive with the London fork EIP-3529) to its _status state variable.   Example 1: In addLiquidity(), by moving the updating of router balance on L101 to before the transfers from L92, the function would adhere to CEI pattern and could be evaluated to remove the nonreentrant modifier.  Example 2: removeLiquidity() already adheres to CEI pattern and could be evaluated to remove the nonreentrant modifier.  prepare() can be slightly restructured to follow CEI pattern as well. However, fulfill() and cancel() are risky with multiple external calls and its safer to leave the nonreentrant call at the expense of additional gas costs.  Impact: Save gas by removing nonreentrant modifier if function is deemed to be reentrant safe. This can save gas costs of 2 SSTORES per function call that uses this modifier: _status SSTORE from 1 to 2 costs 5000 and _status SSTORE from 2 to 1 which costs 100 (because it was already accessed) which is significant at 5100 per call post-Berlin EIP-2929.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L92-L101  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on functions that may already be reentrant safe or do not need this protection. It may indeed be safe to leave this modifier (while accepting the gas impact) if such an evaluation is tricky or depends on assumptions.  "}, {"title": "Consolidating library functions can save gas by preventing external calls", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  While code modularity is generally a good practice and creating libraries of functions commonly used across different contracts can increase maintainability and reduce contract deployment size/cost, it comes at the increased cost of gas usage at runtime because of the external calls. EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600.   Impact: A LibAsset.transferAsset() call from TransactionManager.sol makes LibERC20.transfer() call for ERC20 which in turn makes another external call to LibUtils.revertIfCallFailed() in wrapCall. So an ERC20 transfer effectively makes 3 additional (besides the ERC20 token contract function call assetId.call(..) external calls -> LibAsset -> LibERC20 -> LibUtils, which costs 2600*3 = 7800 gas.   Combining these functions into a single library or making them all internal to TransactionManager.sol can convert these delegatecalls into JMPs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L58  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L44  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L64  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L369  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L378  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L406  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L425  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L514  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L525  And other Lib* calls.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider moving all the library functions internal to this contract or to a single library to save gas from external calls each of which costs 2600 gas.  "}, {"title": "Checking before external library call can save 2600 gas", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600. LibUtils.revertIfCallFailed() reverts and passes on the revert string if the boolean argument is false. Instead, moving the checking of the boolean to the caller avoids the library call when the boolean is true, which is likely the case most of the time.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibUtils.sol#L10-L19  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L35  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the boolean parameter from revertIfCallFailed() and move the conditional check logic to the call sites.  "}, {"title": "Using access lists can save gas due to EIP-2930 post-Berlin hard fork", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of SLOADs and CALL* family opcodes increasing them for not-accessed slots/addresses and decreasing them for accessed slots. EIP-2930 optionally supports specifying an access list (in the transaction) of all slots and addresses accessed by the transaction which reduces their gas cost upon access and prevents EIP-2929 gas cost increases from breaking contracts.   Impact: Considering these changes may significantly impact gas usage for transactions that call functions touching many state variables or making many external calls. Specifically, removeUserActiveBlocks() removes an active block from the array of blocks for an user, all of which are stored in storage. Transactions for fulfill() and cancel() functions that call removeUserActiveBlocks()  can consider using access lists for all the storage state (of user\u2019s active blocks) they touch (read + write) to reduce gas.   ## Proof of Concept  https://eips.ethereum.org/EIPS/eip-2929  https://eips.ethereum.org/EIPS/eip-2930  https://hackmd.io/@fvictorio/gas-costs-after-berlin  https://github.com/gakonst/ethers-rs/issues/265  SLOADs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L580  SSTOREs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L583  Calls: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L346  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L490   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the feasibility of using access lists to save gas due to EIPs 2929 & 2930 post-Berlin hard fork. The tooling support is WIP.  "}, {"title": "MAX_TIMEOUT", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is a MIN_TIMEOUT for the expiry but I think you should also introduce a MAX_TIMEOUT to avoid a scenario when, for example, expiry is set far in the future (e.g. 100 years) and one malicious side does not agree to fulfill or cancel the tx so the other side then has to wait and leave the funds locked for 100 years or so.  ## Recommended Mitigation Steps Introduce a reasonable MAX_TIMEOUT.  "}, {"title": "Approval is not reset if the call to IFulfillHelper fails", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/31", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Function fulfill first approves the callTo to transfer an amount of toSend tokens and tries to call IFulfillHelper but if the call fails it transfers these assets directly. However, in such case the approval is not reset so a malicous callTo can pull these tokens later:     // First, approve the funds to the helper if needed         if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {           require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\");         }          // Next, call `addFunds` on the helper. Helpers should internally         // track funds to make sure no one user is able to take all funds         // for tx         if (toSend > 0) {           try             IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(               txData.user,               txData.transactionId,               txData.receivingAssetId,               toSend             )           {} catch {             // Regardless of error within the callData execution, send funds             // to the predetermined fallback address             require(               LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),               \"fulfill: TRANSFER_FAILED\"             );           }         }  ## Recommended Mitigation Steps Approve should be placed inside the try/catch block or approval needs to be reset if the call fails.  "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact ETHER_ASSETID is a bit missleading name, I think a better name would be NATIVE_ASSETID:    address constant ETHER_ASSETID = address(0);  Misleading comment (should be 'for fulfillment'):   // The structure of the signed data for cancellations   struct SignedFulfillData {  MIN_TIMEOUT could be expressed in days:  uint256 public constant MIN_TIMEOUT = 1 days; // 24 hours   "}, {"title": "txData.expiry = block.timestamp", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function fulfill treats txData.expiry = block.timestamp as expired tx:     // Make sure the expiry has not elapsed     require(txData.expiry > block.timestamp, \"fulfill: EXPIRED\");  However, function cancel has an inclusive check for the same condition:     if (txData.expiry >= block.timestamp) {     // Timeout has not expired and tx may only be cancelled by router  ## Recommended Mitigation Steps Unify that to make the code coherent. Probably txData.expiry = block.timestamp should be treated as expired everywhere.  "}, {"title": "activeTransactionBlocks are vulnerable to DDoS attacks", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/27", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is a potential issue in function removeUserActiveBlocks and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for activeTransactionBlocks it may grow so large that the for loop may never finish. You should consider introducing an upper limit for activeTransactionBlocks. Also, a malicious actor may block any account (DDOS) by just calling prepare again and again with 0 amount acting as a router. This will push activeTransactionBlocks to the specified user until it is no longer possible to remove them from the array.  This is also a gas issue as function removeUserActiveBlocks iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an EnumerableMap so you can find and remove elements in O(1) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol It depends on what is the usual number of activeTransactionBlocks. If it is expected to be low (e.g. less than 5), then the current approach will work, but with larger arrays, I expect EnumerableMap would be more efficient.  ## Recommended Mitigation Steps An upper limit will not fully mitigate this issue as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. As you need to improve both the security and performance of removeUserActiveBlocks I think that EnumerableMap may be a go-to solution.  "}, {"title": "Code Consistency for hashVariantTransactionData()", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  greiart   # Vulnerability details  ### Proof of Concept  `hashVariantTransactionData()` should follow the same style of `hashInvariantTransactionData()` and the recover signature functions, where the payload is generated is stored in memory before hashing. Preliminary tests in remix show that it is minimally more gas efficient as well.  ```jsx function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     VariantTransactionData memory variant = VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: txData.preparedBlockNumber   });   return keccak256(abi.encode(variant));   } ```  ### Alternative View on Notion  [https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21](https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21)  "}, {"title": "Gas: Only pass transactionId as parameter instead of TransactionData", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  cmichel   # Vulnerability details  Both the `recoverFulfillSignature` and `recoverCancelSignature` functions take a large `TransactionData` object as their first argument but only use the `transactionId` field of the struct. It should be more efficient to only pass `txData.transactionId` as the parameter.  "}, {"title": "Unsafe approve", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/13", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value. (See [Line 201](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) The `LIibERC20.approve` function does not do this - unlike OpenZeppelin's `safeApprove` implementation.  ## Impact Repeated USDT cross-chain transfers to the same user on receiving chain = ETH mainnet can fail due to this line not resetting the approval to zero first:  ``` require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\"); ```  ## Recommended Mitigation Steps `LiibERC20.approve` should do two `approve` calls, one setting it to `0` first, then the real one. Check OpenZeppelin's `safeApprove`.  "}, {"title": "wrapCall with weird ERC20 contracts", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function wrapCall is not completely safe for all possible ERC20 contracts.  If the returnData.length is larger than 1 the \"abi.decode(returnData, (bool));\" will fail. Which means the interactions with that ERC20 contract will fail. Although this is unlikely, it is easy to protect against it.  ## Proof of Concept // https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibERC20.sol#L21     function wrapCall(address assetId, bytes memory callData) internal returns (bool) {         ...         (bool success, bytes memory returnData) = assetId.call(callData);         LibUtils.revertIfCallFailed(success, returnData);         return returnData.length == 0 || abi.decode(returnData, (bool));     }  ## Tools Used  ## Recommended Mitigation Steps Change return returnData.length == 0 || abi.decode(returnData, (bool)); to: return (returnData.length == 0) || (returnData.length == 1 && abi.decode(returnData, (bool)));  "}, {"title": "don't use assembly ", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function revertIfCallFailed of LibUtils.sol uses \"assembly\" to log error information in a revert situation.  In the latest solidity version this can be done in solidity using the \"error\" keyword. See: https://docs.soliditylang.org/en/latest/control-structures.html?#revert Using pure solidity improves readability.  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibUtils.sol#L10  function revertIfCallFailed(bool success, bytes memory returnData) internal pure {         if (!success) {             assembly {  revert(add(returnData, 0x20), mload(returnData))  }         }     }  ## Tools Used   ## Recommended Mitigation Steps use the error constructs of solidity 0.8.4+    "}, {"title": "Incorrect balance computed in `getUsersConfirmedButNotSettledSynthBalance()`", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  Consider the following state:  long_synth_balace = 300; short_synth_balace = 200;  marketUpdateIndex[1] = x; userNextPrice_currentUpdateIndex = 0; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;  User calls shiftPositionFromLongNextPrice(marketIndex=1, amountSyntheticTokensToShift=100)  This results in following state changes:  long_synth_balace = 200; short_synth_balace = 200; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; userNextPrice_currentUpdateIndex = x+1 ;   Due to some other transactions, oracle updates twice, and now the marketUpdateIndex[1] is x+2 and also updating price snapshots.  When User calls getUsersConfirmedButNotSettledSynthBalance(user, 1)  initial condition ``` if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&       userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex     )  ``` will be true;  syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex] (https://github.com/hack3r-0m/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L532)  this uses price of current x+2 th update while it should balance of accounting for price of x+1 th update.  "}, {"title": "Users could shift tokens on `Staker` with more than he has staked", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/141", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `shiftTokens` function of `Staker` checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the `shiftTokens` function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked.  ## Proof of Concept  Referenced code: [Staker.sol#L885](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L885)  ## Recommended Mitigation Steps  Add checks on `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` to ensure that the sum of the two variables does not exceed user's stake balance.  "}, {"title": "Gas: `SyntheticToken` does not use pausing functionality", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SyntheticToken` overwrites the `_beforeTokenTransfer` hook and removes the pausing functionality of `ERC20PresetMinterPauser`. But the `ERC20PresetMinterPauser` constructor still assigns pauser roles which leads to unnecessary gas costs. Inherit from an `ERC20PresetMinterPauser`-like contract without the pausing functionality. This would also make the intention of the code more clear by showcasing that it does not implement the pauser interface functions `pause`/`unpause` (which it currently still does but they don't have any effect).   "}, {"title": "treasury state variable in LongShort", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract LongShort has a 'treasury' state variable that is not used in any meaningful way. It is only initialized in function initialize and can be changed by function changeTreasury, no other interactions. YieldManagerAave has its own separate treasury variable that it allocates funds to so this dead code can be removed to save some gas at least.   "}, {"title": "onlyValidMarket is never used", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/107", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Dead code: Staker contract has a modifier onlyValidMarket that is not used anywhere. I think you do not use it as you trust that admin and LongShort contract will not pass invalid values. Unused code can be removed to reduce gas costs.  "}, {"title": "Cache storage access and duplicate calculations", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions _mintNextPrice, _redeemNextPrice, _shiftPositionNextPrice could cache a result here and re-use it to avoid duplicate calculations of the same value:     marketUpdateIndex[marketIndex] + 1; Also, you can extract duplicate storage access to a storage variable and update the state on it, e.g.: accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] is accessed 3 times in _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot.  "}, {"title": "The address of Aave lendingPool may change", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract YieldManagerAave caches lendingPool, however, in theory, it is possible that the implementation may change (see https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65). I am not sure how likely in practice is that but a common solution that I see in other protocols that integrate with Aave is querying the lendingPool on the go (of course then you also need to handle the change in approvals).  ## Recommended Mitigation Steps An example solution you can see here: https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L63-L65  "}, {"title": "[Optimization] Cache length in the loop", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hrkrshnn   # Vulnerability details   ## Cache length in the for loop  ``` solidity modified   contracts/contracts/LongShort.sol @@ -1059,7 +1059,8 @@ contract LongShort is ILongShort, Initializable {    /// @param user The address of the user for whom to execute the function for.    /// @param marketIndexes An array of int32s which each uniquely identify a market.    function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external { -    for (uint256 i = 0; i < marketIndexes.length; i++) { +    uint length = marketIndexes.length; +    for (uint256 i = 0; i < length; i++) {        _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);      }    } ```  In the previous case, at each iteration of the loop, length is read from memory. something like `mload(memory_offset)`. It takes `6` gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  In the replacement, the value is placed in the stack only once and each iteration involves a `dupN` (3 gas). Saves around 3 gas per iteration.  Here are other places that can use this.  ``` text ./contracts/contracts/LongShort.sol:776:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/LongShort.sol:1063:    for (uint256 i = 0; i < length; i++) { ./contracts/contracts/Staker.sol:790:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/mocks/BandOracleMock.sol:84:    for (uint256 i = 0; i < _bases.length; i++) { ./contracts/contracts/testing/LongShortInternalStateSetters.sol:34:    for (uint256 i = 0; i < marketIndexes.length; i++) { ```   "}, {"title": "Function visibility can be changed from public to external", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Changing a function\u2019s visibility from public to external can save gas by avoiding the unnecessary copying of data to memory. Function stakeFromUser() in Staker.sol is only called from SyntheticTokens.sol and not from within the contract itself which means this can be made external.   ## Proof of Concept  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/Staker.sol#L839  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/SyntheticToken.sol#L56   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility to external where possible.  "}, {"title": "Caching state variables in local variables can save gas", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/76", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There are multiple places where state variables are reused within functions by loading them multiple times. These operations result in expensive SLOAD instructions where the first SLOAD costs 2100 gas and successive SLOADs of the same variable cost 100 gas (since the Berlin hardfork).  Using local memory variables to cache them will remove the unnecessary SLOADs costing 100 gas resulting in MLOADs that only cost 3 gas units.  ## Proof of Concept  Caching latestMarket can save upto 13 SLOADs i.e. 1300 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L261-L298  Caching staked can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L267 https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L276  Caching latestMarket can save upto 3 SLOADs i.e. 3 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L352-L365  Caching marketUpdateIndex[marketIndex] appropriately can save many SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L817-L819  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L677-L757  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L860-L864  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L911-L922  Caching longShort address can save 300 300 gas by avoiding 3 SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/TokenFactory.sol#L68-L70  Caching amountReservedInCaseOfInsufficientAaveLiquidity can save upto 2 SLOADs i.e. 200 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L114-L121  Caching paymentToken can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L132-L142  Caching aaveIncentiveController can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167  Caching totalReservedForTreasury can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache storage-based state variables in local memory-based variables appropriately to convert SLOADs to MLOADs and reduce gas consumption from 100 units to 3 units.  "}, {"title": "YieldManagerAave.sol: Wrong branch in depositPaymentToken() if amountReservedInCaseOfInsufficientAaveLiquidity == amount", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In the unlikely event `amountReservedInCaseOfInsufficientAaveLiquidity == amount`, the `else` case will be executed, which means `lendingPool.deposit()` is called with a value of zero. It would therefore be better to change the condition so that the `if` case is executed instead.  ### Recommended Mitigation Steps  ```jsx function depositPaymentToken(uint256 amount) external override longShortOnly {   // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount   // It basically always be zero besides extreme and unlikely situations with aave.   if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {   // instead of strictly greater than     if (amountReservedInCaseOfInsufficientAaveLiquidity >= amount) {       amountReservedInCaseOfInsufficientAaveLiquidity -= amount;       // Return early, nothing to deposit into the lending pool       return;     }  ... } ```  "}, {"title": "Staker.sol: Updating kValue requires interpolation with initial timestamp", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Updating a `kValue` of a market requires interpolation against the initial timestamp, which can be a hassle and might lead to a wrong value set from what is expected.   ### Proof of Concept  Consider the following scenario:  - Initially set `kValue = 2e18`, `kPeriod = 2592000` (30 days) - After 15 days, would like to refresh the market incentive (start again with `kValue = 2e18`), lasting another 30 days.  In the current implementation, the admin would call `_changeMarketLaunchIncentiveParameters()` with the following inputs:  - `period = 3888000` (45 days) - `kValue` needs to be worked backwards from the formula      `kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod)`. To achieve the desired effect, we would get `kValue = 25e17` (formula returns 2e18 after 15 days with kPeriod = 45 days).  This isn't immediately intuitive and could lead to mistakes.  ### Recommended Mitigation Steps  Instead of calculating from `initialTimestamp` (when `addNewStakingFund()` was called), calculate from when the market incentives were last updated. This would require a new mapping to store last updated timestamps of market incentives.  For example, using the scenario above, refreshing the market incentive would mean using inputs `period = 2592000` (30 days) with `kValue = 2e18`.  ```jsx // marketIndex => timestamp of updated market launch incentive params  mapping(uint32 => uint256) public marketLaunchIncentive_update_timestamps;  function _changeMarketLaunchIncentiveParameters(   uint32 marketIndex,   uint256 period,   uint256 initialMultiplier ) internal virtual {  require(initialMultiplier >= 1e18, \"marketLaunchIncentiveMultiplier must be >= 1e18\");    marketLaunchIncentive_period[marketIndex] = period;   marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  marketLaunchIncentive_update_timestamps[marketIndex] = block.timestamp; };  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {   // Parameters controlling the float issuance multiplier.   (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);    // Sanity check - under normal circumstances, the multipliers should   // *never* be set to a value < 1e18, as there are guards against this.   assert(kInitialMultiplier >= 1e18);   // currently: uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  // changed to take from last updated timestamp instead of initial timestamp   uint256 initialTimestamp = marketLaunchIncentive_update_timestamps[marketIndex];    if (block.timestamp - initialTimestamp <= kPeriod) {     return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);   } else {     return 1e18;   } }  ```  "}, {"title": "Staker.sol: TODO add link in comment", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In `_calculateFloatPerSecond()`, there is an outstanding TODO in L437  `@dev to see below math in latex form see TODO add link`  The missing URL seems to be the one provided in the README on float [token rate issuance](https://www.overleaf.com/read/jpyhjgrvhfkr).  ### Recommended Mitigation Steps  Update / finish up the TODO.  "}, {"title": "Staker.sol: Cache shift amounts", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The user's `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` are retrieved a number of times in `_calculateAccumulatedFloat()`. Caching these values would help save gas.  Note that block scoping is needed to avoid the stack too deep problem.  ### Recommended Mitigation Steps  ```jsx function _calculateAccumulatedFloat() {  // block scope for shiftAmount variable to avoid stack too deep  {   // Update the users balances    uint256 shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];    if (shiftAmount > 0) {      amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        true,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedLong -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;    }      shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user]    if (shiftAmount > 0) {      amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        false,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedShort -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;    }  }  // end of block scoping   // Save the users updated staked amounts  ... } ```  "}, {"title": "Spelling Errors", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  LongShort.sol   - `re-uising` \u2192 `reusing` - `visa versa` \u2192 `vice versa` - `@param marketIndex An int32` \u2192 `@param marketIndex A uint32` - `Non-existant` \u2192 `Non-existent`  Staker.sol  - `Explicitely` \u2192 `Explicitly` - `extremeley` \u2192 `extremely`  YieldManagerAave.sol  - `revent` \u2192 `revert`  "}, {"title": "LongShort.sol: Inconsistency in _claimAndDistributeYieldThenRebalanceMarket()", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/59", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The comparison and effecting `valueChange` in `_claimAndDistributeYieldThenRebalanceMarket()` can be made consistent with the other functions.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  ### Recommended Mitigation Steps  Change the `else` case to `else if (valueChange < 0)`.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else if (valueChange < 0) {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  "}, {"title": "LongShort.sol: Cache marketUpdateIndex[marketIndex]", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  By storing `marketUpdateIndex[marketIndex];` locally in `_updateSystemStateInternal()`, multiple sLOADs can be avoided.  ### Recommended Mitigation Steps  Gas savings of about 500-600 is achieved.  ```jsx function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {  ...  // cache marketUpdateIndex[marketIndex]   uint256 currentMarketIndex = marketUpdateIndex[marketIndex];    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;   if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex     ];     uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][       currentMarketIndex     ];    if (       userNextPrice_currentUpdateIndex[marketIndex][staker] == currentMarketIndex + 1 &&       assetPriceHasChanged     ) {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)         currentMarketIndex + 1       );     } else {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         0       );     }   ...   // increment currentMarketIndex   currentMarketIndex ++;    marketUpdateIndex[marketIndex] = currentMarketIndex;   syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_long;      syntheticToken_priceSnapshot[marketIndex][false][      currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_short;   ...   emit SystemStateUpdated(      marketIndex,      currentMarketIndex,    ...   );  } } ```  "}, {"title": "Wrong aave usage of `claimRewards`", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact Aave yield manager claims rewards with the payment token. According to aave's document, aToken should be provided. The aave rewards would be unclaimable.  ## Proof of Concept YieldManager's logic: https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L161-L170  Reference: https://docs.aave.com/developers/guides/liquidity-mining#claimrewards  ## Tools Used None ## Recommended Mitigation Steps Change to ```solidity     address[] memory rewardsDepositedAssets = new address[](1);     rewardsDepositedAssets[0] = address(aToken); ```   "}, {"title": "LongShort should not shares the same Yield Manager between different markets", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-08-floatcapital-findings", "body": "# Handle  jonah1005   # Vulnerability details  # LongShort should not shares the same Yield Manager between different markets ## Impact The LongShort contract would not stop different markets from using the same yield manager contracts. Any extra aToken in the yield manager would be considered as market incentives in function `distributeYieldForTreasuryAndReturnMarketAllocation`. Thus, using the same yield manager for different markets would break the markets and allow users to withdraw fund that doesn't belong to them.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L179-L204  ## Tools Used None  ## Recommended Mitigation Steps Given the fluency of programming skills the dev shows, I believe they wouldn't make this mistake on deployment. Still, I think there's space to improve in the YieldManagerAave contract. IMHO. As it's tightly coupled with longshort contract and its market logic, a initialize market function in the yield manager seems more reasonable.  "}, {"title": "Gas optimization for withdraw and withdrawAll", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/44", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-08-floatcapital-findings", "body": "# Handle  0xImpostor   # Vulnerability details  ## Impact  Use `marketIndex` to updateSystemState instead of querying `marketIndexOfToken[token]` twice.  ## Proof of Concept  Swap line 949 with 951 and swap line 974 with 976.  For example  ``` function withdrawAll(address token) external {     uint32 marketIndex = marketIndexOfToken[token];      ILongShort(longShort).updateSystemState(marketIndex);      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token       ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]       : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];      _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);   }  ```  ## Tools Used  Manual analysis  "}, {"title": "FloatToken would revoke stakerAddress's permission if msg.sender == stakerAddress", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-08-floatcapital-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact FloatToken would revoke staker's permission if msg.sender == stakerAddress. In `initializeFloatToken` the contract would first grant roles to `stakerAddress` and than revoke`msg.sender`'s permissions. The contract would be left with no privileged address if stakerAddress == msg.sender.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/FloatToken.sol#L21-L35  ## Tools Used None ## Recommended Mitigation Steps  ```solidity   function initializeFloatToken(     string calldata name,     string calldata symbol,     address stakerAddress   ) external initializer {     initialize(name, symbol);      renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);     renounceRole(MINTER_ROLE, msg.sender);     renounceRole(PAUSER_ROLE, msg.sender);        _setupRole(DEFAULT_ADMIN_ROLE, stakerAddress);     _setupRole(MINTER_ROLE, stakerAddress);     _setupRole(PAUSER_ROLE, stakerAddress);   } ```  "}, {"title": "Docstring", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  evertkors   # Vulnerability details  A lot of docstrings for marketIndex are ` @param marketIndex An int32 which uniquely identifies a market.` but it is a `uint32` not an `int32`  "}, {"title": "confusing comments", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact I've seen comments which are confusing: ~10^31 or 10 Trillion (10^13) ==> probably should be 2^31 x * 5e17` == `(x * 10e18) / 2`   ==> probably should be 1e18/2  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L19 // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)  //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L480       // NOTE: `x * 5e17` == `(x * 10e18) / 2`  ## Tools Used  ## Recommended Mitigation Steps Double check the comments  "}, {"title": "latestMarket used where marketIndex should have been used", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions initializeMarket and _seedMarketInitially use the variable latestMarket. If these functions would be called seperately from createNewSyntheticMarket, then latestMarket would have the same value for each call of initializeMarket and _seedMarketInitially   This would mean that the latestMarket is initialized multiple times and the previous market(s) are not initialized properly. Note: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.  Note: the functions can only be called by the admin, so if createNewSyntheticMarket and initializeMarket are called in combination, then it would not lead to problems, but in future release of the software the calls to createNewSyntheticMarket and initializeMarket might get separated.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L304 function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {    ...     ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);   // should be marketIndex     ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);  // should be marketIndex    function initializeMarket(      uint32 marketIndex,....)   ...     require(!marketExists[marketIndex], \"already initialized\");     require(marketIndex <= latestMarket, \"index too high\");      marketExists[marketIndex] = true; ..     IStaker(staker).addNewStakingFund(       latestMarket,                                       // should be marketIndex       syntheticTokens[latestMarket][true],   // should be marketIndex       syntheticTokens[latestMarket][false],  // should be marketIndex   ...  ## Tools Used  ## Recommended Mitigation Steps Replace latestMarket with marketIndex in the functions initializeMarket and _seedMarketInitially  p.s. confirmed by Jason of float capital: Definitely an issue, luckily both of those functions are adminOnly. But that is definitely not ideal!  "}, {"title": "2 variables not indexed by marketIndex", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/8", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the token contract: batched_stakerNextTokenShiftIndex is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.  stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex So the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping  can be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex [market2]  This will lead to weird results in _calculateAccumulatedFloat, allocating too much or too little float.  ## Proof of Concept // https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L622     function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     ...       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;       stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;       batched_stakerNextTokenShiftIndex[marketIndex] += 1; ...  ## Tools Used  ## Recommended Mitigation Steps Add an index with marketIndex to the variables: - stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping  - stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping   Also consider shortening the variable names, this way mistakes can be spotted easier.  Confirmed by Jason of Float Capital: Yes, you are totally right, it should use the marketIndex since they are specific per market!  "}, {"title": "Staker.sol: Wrong values returned in edge cases of _calculateFloatPerSecond()", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle \r \r hickuphh3\r \r # Vulnerability details\r \r ### Impact\r \r In `_calculateFloatPerSecond()`, the edge cases where full rewards go to either the long or short token returns\r \r `return (1e18 * k * longPrice, 0);` and\r \r `return (0, 1e18 * k * shortPrice);` respectively. \r \r This is however `1e18` times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. `longRewardUnscaled = 0`  and `shortRewardUnscaled = 1e18`. Plugging this into the calculation below,\r \r `return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);` results in\r \r `(0, 1e18 * k * shortPrice / 1e18)` or `(0, k * shortPrice)`.\r \r As we can see, this would result in an extremely large float token issuance rate, which would be disastrous.\r \r ### Recommended Mitigation Steps\r \r The edge cases should return `(k * longPrice, 0)` and `(0, k * shortPrice)` in the cases where rewards should go fully to long and short token holders respectively."}, {"title": "copy paste error in _batchConfirmOutstandingPendingActions", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _batchConfirmOutstandingPendingActions of LongShort.sol processeses the variable batched_amountSyntheticToken_toShiftAwayFrom_marketSide, and sets it to 0 after processing. However probably due to a copy/paste error, in the second instance, where batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed, the wrong version is set to 0: batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0  This means the next time the batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1126 LongShort.sol function _batchConfirmOutstandingPendingActions( ..     amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];     batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; ...         amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];            batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; // should probably be false         ## Tools Used  ## Recommended Mitigation Steps change the second instance of the following (on line 1207)    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0   to    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0    p.s. confirmed by Jason of Floatcapital: \"Yes, that should definitely be false!\"  "}, {"title": "Potential DOS in Contracts Inheriting `UUPSUpgradeable.sol`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/98", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  There are a number of contracts which inherit `UUPSUpgradeable.sol`, namely; `GovernanceAction.sol`, `PauseRouter.sol` and `NoteERC20.sol`. All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract. However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.  ## Proof of Concept  Initial information about this issue was found [here](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).  Consider the following scenario: - Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`. - This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract. - Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role. - The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` shown [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls [this](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function. - As a result, the implementation contract will be self-destructed due the user controlled delegate call shown [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider initializing the implementation contract for `NoteERC20.sol` and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.  "}, {"title": "`StorageLayoutV1` Gas Optimisations", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `StorageLayoutV1.sol` contract is inherited by several contracts and represents a shared common state that ensures the slot layout of certain contracts are the same. It is possible to minimise the number of storage slots used by rearranging the state variables in the most efficient way.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/global/StorageLayoutV1.sol  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Arrange the `uint16`  and `bytes1` variables such that they fit into the same slot.  "}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The current ownership transfer process involves the current owner calling `NoteERC20.transferOwnership()`. This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the `onlyOwner()` modifier.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L123-L127  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  "}, {"title": "Lack of Zero Address Validation", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/93", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  There is currently no input validation done on the `Router.initialize()` and `NoteERC20.initialize()` functions, potentially leading to an initialized state where the contracts have no owner and the deployer needs to re-deploy the contract to have it working properly.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L63-L92 https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L90-L108  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Perform zero address checks for the `owner_`, `pauseRouter_` and `pauseGuardian_` inputs to ensure the contract isn't initialized into an unexpected state.  "}, {"title": "Missing validation on latestRoundData", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/92", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  a_delamo   # Vulnerability details  On `ExchangeRate.sol`, we are using `latestRoundData`, but there are no validations that the data is not stale.  The current code is:  ```solidity             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, \"ExchangeRate: invalid rate\"); ```  But is missing the checks to validate the data is stale   ```solidity (roundId, rawPrice,, updatedAt, answeredInRound) = AggregatorV2V3Interface(rateOracle).latestRoundData(); require(rawPrice > 0, \"Chainlink price <= 0\"); require(updateTime != 0, \"Incomplete round\"); require(answeredInRound >= roundId, \"Stale price\"); ```  More information: https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round    "}, {"title": "Used a fixed or pragma that spans only a single `0.x.*`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/90", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Used a fixed or pragma that spans only a single `0.x.*`  Currently, the pragma `>0.7.0` is used in several contracts. However, since 0.7.0 and 0.8.0 has breaking changes, especially the safemath by default, the contracts could be semantically different when compiled via `0.7.*` and `0.8.*`.   "}, {"title": "Caching length in for loops", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra `sload` operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra `mload` operation (3 additional gas for each iteration except for the first).  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` operation is only done once and subsequently replaced by a cheap `dupN` instruction.  This optimization is especially important if it is a storage array or if it is a lengthy for loop.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project.  ### Examples  Here are some examples where this can be applied (found using a simple grep)  ``` txt ./contracts/external/Views.sol:187:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/BatchAction.sol:42:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/BatchAction.sol:120:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/ERC1155Action.sol:62:        for (uint256 i; i < accounts.length; i++) { ./contracts/external/actions/ERC1155Action.sol:91:        for (uint256 i; i < portfolio.length; i++) { ./contracts/external/actions/ERC1155Action.sol:240:        for (uint256 i; i < ids.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:121:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:146:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:537:        for (uint256 i; i < nToken.cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/TradingAction.sol:81:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/TradingAction.sol:123:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/nTokenMintAction.sol:110:        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) { ./contracts/external/actions/nTokenRedeemAction.sol:138:        for (uint256 i; i < markets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:222:        for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:265:        for (uint256 i; i < markets.length; i++) { ./contracts/external/adapters/CompoundToNotionalV2.sol:81:        for (uint256 i; i < notionalV2CollateralIds.length; i++) { ./contracts/external/governance/NoteERC20.sol:98:        for (uint256 i = 0; i < initialGrantAmount.length; i++) { ./contracts/internal/balances/BalanceHandler.sol:300:        for (uint256 i; i < settleAmounts.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:31:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:345:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:449:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:528:            for (uint256 i; i < markets.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:77:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:131:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:232:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:495:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/markets/CashGroup.sol:297:        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) { ./contracts/internal/markets/CashGroup.sol:309:        for (uint256 i; i < cashGroup.rateScalars.length; i++) { ./contracts/internal/nTokenHandler.sol:279:        for (uint256 i; i < depositShares.length; i++) { ./contracts/internal/nTokenHandler.sol:306:        for (uint256 i; i < proportions.length; i++) { ./contracts/internal/nTokenHandler.sol:371:        for (; i < array1.length; i++) { ./contracts/internal/nTokenHandler.sol:494:            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/BitmapAssetsHandler.sol:96:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:20:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:40:        for (uint256 i; i < assetArray.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:129:        for (uint256 i; i < newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:161:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:171:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:202:        for (uint256 i; i < portfolioState.newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:283:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/TransferAssets.sol:47:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:32:        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:137:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:231:        for (uint256 i = portfolioIndex; i < assets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:250:        for (; j < assets.length; j++) { ./contracts/mocks/BaseMockLiquidation.sol:52:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/mocks/BaseMockLiquidation.sol:72:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/mocks/MockFlashLender.sol:30:        for (uint256 i; i < assets.length; i++) { ./contracts/mocks/MockFlashLender.sol:39:        for (uint256 i; i < assets.length; i++) { ```   "}, {"title": "Liquidity token value can be manipulated", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/85", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The liquidity token value (`AssetHandler.getLiquidityTokenValue`) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see `AssetHandler.getCashClaims` / `AssetHandler.getHaircutCashClaims`:  ```solidity // @audit token.notional are the LP tokens to redeem assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity); fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity); ```  This means the value depends on the **current market reserves** which can be manipulated. You're essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.  See the \"How do I tell if I\u2019m using spot price?\" section on [https://shouldiusespotpriceasmyoracle.com/](https://shouldiusespotpriceasmyoracle.com/). > However, by doing this you\u2019re actually incorporating the spot price because you\u2019re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this [footgun](https://cmichel.io/pricing-lp-tokens/) in this writeup by @cmichelio.  ## Impact The value of an LP token is computed as `assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) )` where `(assetCashClaim, fCashClaim)` depend on the current market reserves which can be manipulated by an attacker via flashloans. Therefore, an attacker trading large amounts in the market either increases or decreases the value of an LP token.  If the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens. If the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.  The exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage. In constant-product AMMs like Uniswap it's profitable and several projects have already been exploited by this, like [warp.finance](https://cmichel.io/pricing-lp-tokens/). However, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles: > \"Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated.\" - Market.sol L424  ## Recommendation Do not use the current market reserves to determine the value of LP tokens. Think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.   "}, {"title": "`DateTime.getMarketIndex` bounds should be tighter", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.getMarketIndex` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact \"Valid\" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  "}, {"title": "`DateTime.isValidMarketMaturity` bounds should be tighter", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/81", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.isValidMarketMaturity` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact \"Valid\" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  "}, {"title": "`TokenHandler.safeTransferIn` does not work on non-standard compliant tokens like USDT", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/80", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transferFrom` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Withdrawals for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin\u2019s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "`TokenHandler.safeTransferOut` does not work on non-standard compliant tokens like USDT", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/79", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferOut` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transfer(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transfer` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Deposits for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin\u2019s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "`TokenHandler.transfer` wrong branch order", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.transfer` should handle the `if (token.tokenType == TokenType.Ether)` case first, as if the token type is `Ether` but `netTransferExternal <= 0` it treats the token as an `ERC20` token and tries to call `ERC20` functions on it.   ## Impact Luckily, trying to call ERC20 functions on the invalid token address will revert which is the desired behavior.  ## Recommended Mitigation Steps We still recommend reordering the branches and adding a `netTransferExternal <= 0` check. The code becomes cleaner and it's more obvious that the transaction will fail.   "}, {"title": "`TokenHandler.setToken` ERC20 missing return value check", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/77", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin\u2019s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "NoteERC20.getPriorVotes includes current unclaimed incentives", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.getPriorVotes` function is supposed to return the voting strength of an account at a specific block in the past. This should be a static value but it directly includes the _current_ unclaimed incentives due to the `getUnclaimedVotes(account)` call.  ## Impact Users that didn't even have tokens at the time of proposal creation but are now interested in voting on the proposal can farm unclaimed incentives and impact the outcome of the proposal.  ## Recommended Mitigation Steps Adding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it'd cost too much gas. It also needs to be ensured that incentives cannot be increased through flash-loaning of assets.  "}, {"title": "NoteERC20 missing initial ownership event", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.initialize` function does not emit an initial `OwnershipTransferred` event.  ## Recommended Mitigation Steps In `initialize`, emit `OwnershipTransferred(address(0), owner_)`.   "}, {"title": "Governor average block time is not up-to-date", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `GovernorAlpha.MIN_VOTING_PERIOD_BLOCKS = 6700` value indicates an average block time of 12.8956s which was correct a year ago, but at the moment a more accurate block time would be 13.2s, see [blocktime](https://etherscan.io/chart/blocktime).  ## Recommended Mitigation Steps Use a `MIN_VOTING_PERIOD_BLOCKS` of `6545`.  "}, {"title": "nTokenERC20Proxy emits events even when not success", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/72", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenERC20Proxy` functions emit events all the time, even if the return value from the inner call returns `false` indicating an unsuccessful action.  ## Impact An off-chain script scanning for `Transfer` or `Approval` events can be tricked into believing that an unsuccessful transfer was indeed successful. This happens in the `approve`, `transfer` and `transferFrom` functions.  ## Recommended Mitigation Steps Only emit evens on `success`.  "}, {"title": "Unclear decimals value in `cTokenAggregator`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `cTokenAggregator.decimals` value is set to `18` but `cTokens` only have `8` decimals. It's unclear what this `decimals` field refers to.  ## Recommended Mitigation Steps If it should refer to the `cToken` decimals, it's wrong and should be set to `8`. This value is not used inside the contract but it's `public` and anyone can read it.    "}, {"title": "Access restrictions on `CompoundToNotionalV2.notionalCallback` can be bypassed", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/69", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CompoundToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.  ```solidity function notionalCallback(     address sender,     address account,     bytes calldata callbackData ) external returns (uint256) { // @audit sender can be passed in by the attacker require(sender == address(this), \"Unauthorized callback\"); ```  ## Impact An attacker can call the function passing in an arbitrary `account` whose tokens are then transferred to the contract. The `account` first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker frontruns the actual transaction.  It's at least a griefing attack: I can pass in a malicious `cTokenBorrow` that returns any token of my choice (through the `.underlying()` call) but whose `repayBorrowBehalf` is a no-op. This will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:  ```solidity // @audit using a malicious contract, this can be any token address underlyingToken = CTokenInterface(cTokenBorrow).underlying(); bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount); require(success, \"Transfer of repayment failed\");  // Use the amount transferred to repay the borrow // @audit using a malicious contract, this can be a no-op uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount); ```  Note that the assumption at the end of the function \"// When this exits a free collateral check will be triggered\" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.  ## Recommended Mitigation Steps Fix the authorization check.   "}, {"title": "`CompoundToNotionalV2.notionalCallback` ERC20 return values not checked", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/68", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  See `CompoundToNotionalV2.notionalCallback`'s `IERC20(underlyingToken).transferFrom` call.  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value. As there is a `cToken` with `USDT` as the underlying this issue directly applies to the protocol.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   "}, {"title": "`CompoundToNotionalV2.enableToken` ERC20 missing return value check", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `enableToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin\u2019s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "Allowance checks not correctly implemented", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenAction` implements two token approvals, the `nTokenWhitelist` which is always used first, and the `nTokenAllowance` which is checked second. If the `nTokenWhitelist` does _not_ have enough allowance for the transfer, the transaction fails, even in the case where `nTokenAllowance` still has enough allowance.  ## Impact Transfers that have sufficient allowance fail in certain cases.  ## Recommended Mitigation Steps Instead of reverting if the `nTokenWhitelist` allowance is not enough, default to the `nTokenAllowance` case:  ```solidity // something like this  uint256 requiredAllowance = amount;  uint256 allowance = nTokenWhitelist[from][spender]; // use whitelist allowance first if (allowance > 0) {     uint256 min = amount < allowance ? amount : allowance;     requiredAllowance -= min;     allowance = allowance.sub(min);     nTokenWhitelist[from][spender] = allowance; }  // use currency-specific allowance now if(requiredAllowance > 0)     // This is the specific allowance for the nToken.     allowance = nTokenAllowance[from][spender][currencyId];     require(allowance >= requiredAllowance, \"Insufficient allowance\");     allowance = allowance.sub(requiredAllowance);     nTokenAllowance[from][spender][currencyId] = allowance; } ```   "}, {"title": "Open TODOs in `ERC1155Action`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action._checkPostTransferEvent` has open TODOs:  ```solidity // TODO: retrieve revert string require(status, \"Call failed\"); ```  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  "}, {"title": "Untrusted externall call on `ERC1155Action.safeTransfer*`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action.safeTransferFrom` / `ERC1155Action.safeBatchTransferFrom` functions do not follow the [recommended re-entrancy protection guidelines](https://docs.soliditylang.org/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern) and allow a re-entrancy through the `onERC1155Received` while state still has to be written.  ## Impact The re-entrancy doesn't seem to open any attacks currently as the re-entrancy call happens right at the beginning and no interesting variables are set yet.  ## Recommended Mitigation Steps While no immediate re-entrancy issues could be found, it's better to add these checks, especially, as calling this function from another Notional finance function in the future might lead to unintended issues.  "}, {"title": "ERC1155Action returns `false` on `supportsInterface` with the real ERC1155 interface", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details As the return value of `ERC1155.balanceOf` was changed to a signed integer, the `nERC1155Interface` does not implement the `ERC1155` interface and the `supportsInterface` call will return false if people call it with the actual `ERC1155` interface ID.  ## Impact Not all users of the contract might care about the `balance` function and call `supportsInterface` with the original EIP1155 interface. The contract will still deny the   ## Recommended Mitigation Steps It is indeed debatable if this contract should be considered implementing ERC1155 and what the correct return value of `supportsInterface(ERC1155.interface)` should be for compatibility. Users need to be aware that this contract is not standard compliant and the `supportsInterface` call will fail.  "}, {"title": "`initialize` functions can be frontrun", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/59", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `initialize` function that initializes important contract state can be called by anyone. Occurences: - `NoteERC20.initialize` - `Router.initialize`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.   "}, {"title": "DAO proposals can be executed by anyone due to vulnerable TimelockController", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/58", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `GovernorAlpha` inherits from a vulnerable `TimelockController`. This `TimelockController` allows an `EXECUTOR` role to escalate privileges and also gain the proposer role. See details on [OZ](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr) and the [fix here](https://github.com/OpenZeppelin/openzeppelin-contracts/compare/v4.3.0...v4.3.1). The bug is that `_executeBatch` checks if the proposal was scheduled only **after** the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed. As the custom `GovernorAlpha.executeProposal` function removed the original \"queued state check\" (`require(state(proposalId) == ProposalState.Queued`), the attack can be executed by anyone, even without the `EXEUCTOR_ROLE`.  ## POC 1. Create a proposal using `propose`. The calldata will be explained in the next step. (This can be done by anyone passing the min `proposalThreshold`) 2. Call `executeProposal(proposalId, ...)` such that the following calls are made:  ``` call-0: grantRole(TIME_LOCK_ADMIN, attackerContract) call-1: grantRole(EXECUTOR, attackerContract) call-2: grantRole(PROPOSER, attackerContract) call-3: updateDelay(0) // such that _afterCall \"isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp\" passes call-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential) // attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal ```  > \u2139\ufe0f  I already talked to Jeff Wu about this and he created a test case for it confirming this finding  ## Impact Anyone who can create a proposal can become Timelock admin (proposer & executor) and execute arbitrary transactions as the DAO-controlled `GovernorAlpha`. Note that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the `globalTransferOperator` and steal all tokens.  ## Recommended Mitigation Steps We recommend updating the vulnerable contract to `TimelockController v3.4.2`. It currently uses `OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7`   "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/57", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Some parameters of functions are not checked for invalid values: - `PauseRouter.constructor`: addresses can be zero or not a contract - `CompoundToNotionalV2.constructor`: addresses can be zero or not a contract   ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "Total supply dependency on decimals", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Total supply depends on the decimals. I think it makes sense to express totalSupply something like this to make it more readable and maintainable in case you will decide to change decimals:      /// @notice EIP-20 token decimals for this token     uint8 public constant decimals = 8;      /// @notice Total number of tokens in circulation (100 million NOTE)     uint256 public constant totalSupply = 10_000_0000 * 10 ** decimals;   "}, {"title": "Wrong order in Approval event", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function transferFrom in nTokenERC20Proxy emits Approval event:   emit Approval(msg.sender, from, newAllowance); The order of the parameters is wrong, 'msg.sender' and 'from' should be in the opposite order. This may confuse frontends or other services that consume these events from the outside.  ## Recommended Mitigation Steps   emit Approval(from, msg.sender, newAllowance);  "}, {"title": "uint is always >= 0", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are several checks that uint is not negative, e.g.:   cashGroup.maxMarketIndex >= 0 && These checks are pretty much useless as uint can never be negative. Remove them to save some gas.   "}, {"title": "lack of zero address validation in constructor", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/51", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter of the constructor are used to initialize the sate variable and these state variable are used throughout the contract error in these parameter can lead to redeployment of the contract  ## Proof of Concept  constructor of ctokenAggregator.sol,  NotionalV1ToNotionalV2.sol, nTokenERC20Proxy.sol, Reservoir.sol, PauseRouter.sol lack zero address validation  ## Tools Used manual review  ## Recommended Mitigation Steps add address(0) validation in constructor  "}, {"title": "NotionalV1ToNotionalV2 should reject ETH transfers from others than WETH", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract NotionalV1ToNotionalV2 has an empty receive function which allows it to receive Ether. I suppose this was needed to receive ETH when withdrawing from WETH. As there is no way to send out accidentally sent ETH from this contract, I suggest adding an auth check to this receive function to only accept ETH from WETH contract.  ## Recommended Mitigation Steps require(msg.sender == address(WETH), \"Not WETH\");  "}, {"title": "Check if address is a contract", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/47", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are several places that check if the address is a contract or not, e.g.:     uint256 codeSize;     assembly {         codeSize := extcodesize(operator)     }     // Sanity check to ensure that operator is a contract, not an EOA     require(codeSize > 0, \"Operator must be a contract\"); First of all, I want you to be aware that this check can be easily bypassed. A contract does not have source code available during construction. This means that while the constructor is running, it can make calls to other contracts, but extcodesize for its address returns zero. In your case, currently, I do not see a real problem with that as you only use it as an additional check (no critical functionality) but I have a suggestion for you to extract this check to a separate library to make it more maintainable or use a library from OpenZeppelin that exposes this function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L26   "}, {"title": "notionalCallback returns no value", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function notionalCallback (in NotionalV1ToNotionalV2 and CompoundToNotionalV2) declares to return uint, however, no actual value is returned.   ## Recommended Mitigation Steps Either remove the return declaration or return the intended value (I assume it may return a value that it gets from depositUnderlyingToken/depositAssetToken). Otherwise, it may confuse other protocols that later may want to integrate with you.  "}, {"title": "notionalCallback can be tricked by anyone", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/45", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Anyone can call function notionalCallback with arbitrary params and pass the auth check. The only auth check can be easily bypassed by setting sender param to the address of this contract. It allows to choose any parameter that I want:     function notionalCallback(         address sender,         address account,         bytes calldata callbackData     ) external returns (uint256) {         require(sender == address(this), \"Unauthorized callback\");  ## Recommended Mitigation Steps It needs to check that msg.sender is Notional.  "}, {"title": "Address.isContract with no check of returned value", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function activateNotional calls Address.isContract(...) but does not check the returned value, thus making this call pretty much useless:   Address.isContract(address(notionalProxy_));  ## Recommended Mitigation Steps Wrap this in a require statement.  "}, {"title": "lack of input validation of arrays", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact function migrateBorrowFromCompound(         address cTokenBorrow,         uint256 cTokenRepayAmount,         uint16[] memory notionalV2CollateralIds,         uint256[] memory notionalV2CollateralAmounts,         BalanceActionWithTrades[] calldata borrowAction     ) ;  if the  array length of notionalV2CollateralId ,  notionalV2CollateralAmounts and  borrowAction is not equal it can lead to an error  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/CompoundToNotionalV2.sol#L24   ## Tools Used  manual review  ## Recommended Mitigation Steps check the input array length  "}, {"title": "proposal get defeated even if forVotes == againstVotes in GovernorAlpha.sol", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact proposal get defeated even if forVotes == againstVotes during the voting which impact the given proposals. Instead of this condition forVotes <= againstVotes, it should be  forVotes < againstVotes  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/GovernorAlpha.sol#L389  ## Tools Used manual review  ## Recommended Mitigation Steps change the condition for determining the states  "}, {"title": "SHOULD CHECK RETURN DATA FROM CHAINLINK AGGREGATORS", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/34", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract ExchangeRate.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID nor timeStamp, resulting in stale prices. Stale prices could put funds at risk. Freshness of the returned price should be checked, since it affects an account's health (and therefore liquidations). Stale prices that do not reflect the current market price anymore could be used which would influence the liquidation pricing.   ## Proof of Concept  1. Navigate to \"https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/valuation/ExchangeRate.sol\". 2. latestRoundData has been used in the repository. 3. The code can be seen from the below. Stale prices have not been checked.  ```         } else {             address rateOracle = address(bytes20(data << 96));             // prettier-ignore             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, \"ExchangeRate: invalid rate\");              uint8 rateDecimalPlaces = uint8(bytes1(data << 88));             rateDecimals = int256(10**rateDecimalPlaces);             if (                 bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */             ) {                 rate = rateDecimals.mul(rateDecimals).div(rate);             }         }  ```  ## Tools Used  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, \"Chainlink price <= 0\");  require(answeredInRound >= roundID, \"...\"); require(timeStamp != 0, \"...\"); ```   "}, {"title": "No checks on target variable", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Lack of checks on target could lead to loss of funds.  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/Reservoir.sol#L50  ## Recommended Mitigation Steps Require that target is non-zero.  "}, {"title": "Possible reentrancy in balanceOf, decimals, mint", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/14", "labels": ["bug", "duplicate", "invalid", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Registering tokens that aren't properly vetted can lead to a loss of funds if the token has callbacks.  CREAM finance got hacked in a similar way because the ampleforth token had a callback in the transfer method that wasn't noticed when they vetted it.   ## Proof of Concept For example, the redeem function is vulnerable to such a reentrancy in the balanceOf method, since address balances aren't updated before the token call.  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L131   ## Recommended Mitigation Steps Either: - Add nonreentrant modifiers - Update all storage variables before making outside calls with the token - Put steps in place for devs to properly vet tokens.  "}, {"title": "DOS by Frontrunning NoteERC20 `initialize()` Function", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/7", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `scripts/` folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilise the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic. When users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. `NoteERC20.sol` and `Router.sol` both implement an `initialize()` function which aims to replace the role of the `constructor()` when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious frontrunning. However, `scripts/deployment.py` does not follow this pattern when deploying `NoteERC20.sol`'s proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the `NoteERC20` contract and frontrun the `initialize()` transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional's contract deployment, leading to unrecoverable gas expenses.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60 https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  As the `GovernanceAlpha.sol` and `NoteERC20.sol` are co-dependent contracts in terms of deployment, it won't be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the `NoteERC20.sol` proxy contract is deployed and initialized in the same transaction, or ensure the `initialize()` function is callable only by the deployer of the `NoteERC20.sol` contract. This could be set in the proxy contracts `constructor()`.   "}, {"title": "_transfer what happens if sender==recipient", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/6", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer of nTokenAction.sol uses temporary variables and updates the sender and recipient separately. This is a dangerous constructions because the update of the recipient could overwrite the update of the sender. This has led to several hacks at other comparable contracts  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol ```JS  function _transfer(uint256 currencyId,address sender,address recipient, uint256 amount) internal returns (bool) {        ...           senderBalance.netNTokenTransfer = amountInt.neg();         recipientBalance.netNTokenTransfer = amountInt;          senderBalance.finalize(sender, senderContext, false);         recipientBalance.finalize(recipient, recipientContext, false);         senderContext.setAccountContext(sender);         recipientContext.setAccountContext(recipient); ... ```  ## Tools Used  ## Recommended Mitigation Steps Double check what happens when sender==recipient  Add checks to make sure (sender!=recipient) because that usually isn't useful anyway.   "}, {"title": "Use pragma abicoder v2", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The code contains \"pragma experimental ABIEncoderV2;\" In the later Solidity versions it is no longer necessary to use the \"experimental\" version. Using experimental constructions is not recommended for production code.  See: https://docs.soliditylang.org/en/v0.8.7/layout-of-source-files.html#abiencoderv2  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol ```JS pragma experimental ABIEncoderV2; ```  ## Tools Used  ## Recommended Mitigation Steps Replace pragma experimental ABIEncoderV2; with pragma abicoder v2;  And make sure you use at least solidity version 0.7.5    "}, {"title": "Double check for \"birthday\" collision", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getRouterImplementation of Router.sol checks the selectors of functions and calls the appropriate function. Selectors are only 4 bytes long so there is a theoretical probability of a collision (e.g. two functions having the same selector).  This is comparable to the \"birthday attack\" : https://en.wikipedia.org/wiki/Birthday_attack The probability of a collision when you have 93 different functions is 10^\u22126. Due to the structure of the Router.sol, the solidity compiler does not prevent collisions  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L97 ```JS   function getRouterImplementation(bytes4 sig) public view returns (address) {         if (             sig == NotionalProxy.batchBalanceAction.selector ||             sig == NotionalProxy.batchBalanceAndTradeAction.selector ||      ...  ```  ## Tools Used  ## Recommended Mitigation Steps Double check (perhaps via a continuous integration script / github workflow), that there are no collisions of the selectors.  "}, {"title": "Self transfer can lead to unlimited mint", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/1", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  Omik   # Vulnerability details  ## Impact The implementation of the transfer function in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol is the different from the usual erc20 token transfer function, this happen because it count the incentive that the user get, but the with self tranfer it can lead to unlimited mint, because https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L278 it makes the amount to negative, but in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279 it return the value to amount that not negative, so in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282 it finalize the positive value only since the negative value is change to the positive value, you can interact this transfer function through https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used Manual  ## Recommended Mitigation Steps add (sender != recipient)  "}, {"title": "Possible enhancements to supply/redeem full balance", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Consider adding functions in SwappableYieldSource to supply/redeem the whole balance of the user, so users will not need to pass an exact amount in case they want to fully join/exit the pool.  Also, you can consider joining the BoostedVault for some extra rewards, however, I think then funds will need to be locked for some time for the rewards to start accruing.   "}, {"title": "Validation", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function supplyTokenTo should check that mAssetAmount and creditsIssued > 0 and to != address(0) or if empty to address is provided, it can replace it with msg.sender to prevent potential burn of funds. function redeemToken should check that mAssetAmount and creditsBurned > 0. function transferERC20 should similarly validate erc20Token, to and amount parameters. function _mintShares requires that shares > 0, while _burnShares lacks such requirement.   "}, {"title": "Retrieve stuck tokens from MStableYieldSource", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Tokens sent directly to the MStableYieldSource will be stuck forever. Consider adding a function that allows an admin to retrieve stuck tokens: * Balance of mAsset - total deposited amount of mAsset; * Similar with credit balances as credits are issued as a separate erc20 token. * All the other tokens.  "}, {"title": "Incorrect comment about memory", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Incorrect comment  [Context](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L47)  ``` diff modified   contracts/MStableYieldSource.sol @@ -44,7 +44,7 @@ contract MStableYieldSource is IYieldSource, ReentrancyGuard {       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {          // As immutable storage variables can not be accessed in the constructor, -        // create in-memory variables that can be used instead. +        // create in-stack variables that can be used instead.          IERC20 mAssetMemory = IERC20(_savings.underlying());           // infinite approve Savings Contract to transfer mAssets from this contract ```  The comment and therefore the variable name aren't accurate. The value would be in stack, and not memory.  However, this doesn't affect the code in any way.   "}, {"title": "[Optimization] Use 0.8.4 in MStableYieldSource.sol", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use 0.8.4  The version 0.8.4 includes an important low level inliner that can save gas. Upgrading `MStableYieldSource.sol` from 0.8.2 to 0.8.4 should improve gas.   "}, {"title": "Gas: swapYieldSource", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SwappableYieldSource.swapYieldSource` function receives a `_newYieldSource` as a parameter and reads a `_currentYieldSource` from storage. A single storage read should therefore be enough for the entire function and sub-calls.  However, the `_transferFunds` function reads the new yield source from storage again, performing a second storage read. This can be optimized by `_transferFunds` taking an `oldYieldSource` and `newYieldSource` as parameters instead.   "}, {"title": "`_requireYieldSource` does not check return value", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `_requireYieldSource` function performs a low-level status code and parses the return data even if the call failed as it does not check the first return value (`success`). It could be the case that non-zero data is returned even though the call failed, and the function would return `true`.  Check the return value or perform a high-level call using the `_yieldSource` interface.  "}, {"title": "Declaring functions as `external` to save gas", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In general, if not called by the contract itself, public functions can be declared as `external` to save gas.  ## Proof of Concept  Referenced code: [MStableYieldSource.sol#L61](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61) [MStableYieldSource.sol#L69](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L69) [SwappableYieldSource.sol#L67](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L67) [SwappableYieldSource.sol#L98](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98) [SwappableYieldSource.sol#L219](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L219)  ## Recommended Mitigation Steps  Change `public` to `external` in the referenced functions.  "}, {"title": "Use `abi.encodePacked` for gas optimization", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Changing the `abi.encode` function to `abi.encodePacked` at line 77 of `SwappableYieldSource` can save gas since the `abi.encode` function pads extra null bytes at the end of the call data, which is unnecessary. Also, in general, `abi.encodePacked` is more gas-efficient.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L77](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L77)  [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  Change `abi.encode` to `abi.encodePacked` at line 77.  "}, {"title": "Inconsistent balance when supplying transfer-on-fee or deflationary tokens", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `supplyTokenTo` function of `SwappableYieldSource` assumes that `amount` of `_depositToken` is transferred to itself after calling the `safeTransferFrom` function (and thus it supplies `amount` of token to the yield source). However, this may not be true if the `_depositToken` is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L211-L212](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L211-L212)  ## Recommended Mitigation Steps  Get the actual received amount by calculating the difference of token balance before and after the transfer. For example, re-writing line 211-212 to:  ```solidity uint256 balanceBefore = _depositToken.balanceOf(address(this)); _depositToken.safeTransferFrom(msg.sender, address(this), amount); uint256 receivedAmount = _depositToken.balanceOf(address(this)) - balanceBefore; yieldSource.supplyTokenTo(receivedAmount, address(this)); ```  "}, {"title": "Use of safeApprove will always cause approveMax to revert", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin\u2019s safeApprove() which has been documented as 1) Deprecated because of approve-like race condition and 2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.  The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L60-L65  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L51  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L135-L143  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L37-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use logic similar to SwappableYieldSource instead of using safeApprove().  "}, {"title": "Overly permissive access control lets anyone approve max amount", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Overly permissive access control to lets anyone approve max amount. This may be ok but is inconsistent with SwappableYieldSource.sol where the similar function is onlyOwner.   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61-L65  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L133-L135   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check requirements/spec and ensure this is ok or else add Ownable inheritance to enforce onlyOwner for this function.  "}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks as input validation closest to the function beginning is a best-practice. There are two places where an explicit zero-address check is missing which may lead to a later revert, gas wastage or even token burn.  ## Proof of Concept  1. Explicit zero-address check is missing here for _newYieldSource  and will revert later down the control flow on L256: https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L269  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L256   2. Missing zero-address check on \u2018to\u2019 address will lead to token burn because imBalances accounts it for the zero-address from which it can never be redeemed using msg.sender: https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L85  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L94   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add explicit zero-address checks closest to the function entry.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In redeemToken(), given that mAssetBalanceAfter will always be >= mAssetBalanceBefore, using the unchecked directive (solc 0.8.2 has default overflow/underflow checks) on L106 can save bit of gas from the unnecessary (in this case) internal underflow checks on the subtraction.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L2  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L106  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L100-L106  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change to unchecked {mAssetsActual = mAssetBalanceAfter - mAssetBalanceBefore;}  "}, {"title": "Redundant zero-address check", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The zero-address check on owner is present even in transferOwnership() which makes it redundant.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L110   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/access/OwnableUpgradeable.sol#L68  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove explicit check to rely on the one in transferOwnership().  "}, {"title": "Changing function visibility from public to external can save gas", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Assuming the initialize() function is going to be called from a deployment script, its visibility can be made external.   For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function\u2019s parameters are not copied into memory and are instead read from calldata directly.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98-L104   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change visibility to external.  "}, {"title": "SwappableYieldSource: Missing same deposit token check in transferFunds()", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/29", "labels": ["bug", "3 (High Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `transferFunds()` will transfer funds from a specified yield source `_yieldSource` to the current yield source set in the contract `_currentYieldSource`. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.  ### Proof of Concept  Assumptions:  - `_yieldSource` has a deposit token of WETH (18 decimals) - `_currentYieldSource` has a deposit token of DAI (18 decimals) - 1 WETH > 1 DAI (definitely true, I'd be really sad otherwise)  Attacker does the following:  1. Deposit 100 DAI into the swappable yield source contract 2. Call `transferFunds(_yieldSource, 100 * 1e18)`     - `_requireDifferentYieldSource()` passes     - `_transferFunds(_yieldSource, 100 * 1e18)` is called         - `_yieldSource.redeemToken(_amount);` \u2192 This will transfer 100 WETH out of the `_yieldSource` into the contract         - `uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));` \u2192 This will equate to \u2265 100 WETH.         - `require(_amount <= currentBalance, \"SwappableYieldSource/transfer-amount-different\");` is true since both are `100 * 1e18`         - `_currentYieldSource.supplyTokenTo(currentBalance, address(this));` \u2192 This supplies the transferred 100 DAI from step 1 to the current yield source     - We now have 100 WETH in the swappable yield source contract 3. Call `transferERC20(WETH, attackerAddress, 100 * 1e18)` to withdraw 100 WETH out of the contract to the attacker's desired address.   ### Recommended Mitigation Steps  `_requireDifferentYieldSource()` should also verify that the yield sources' deposit token addresses are the same.  ```jsx function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(yieldSource), \"SwappableYieldSource/same-yield-source\");   require(_newYieldSource.depositToken() == yieldSource.depositToken(), \"SwappableYieldSource/different-deposit-token\"); } ```  "}, {"title": "SwappableYieldSource.sol: Wrong reporting amount in FundsTransferred() event", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `FundsTransferred()` event in `_transferFunds()` will report a smaller amount than expected if `currentBalance > _amount`.  This would affect applications utilizing event logs like subgraphs.  ### Recommended Mitigation Steps  Update the event emission to `emit FundsTransferred(_yieldSource, currentBalance);`  "}, {"title": "SwappableYieldSource.sol: Save depositToken as a storage variable", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Assuming that `depositToken` of a yield source doesn't change, it would make sense to save its value as a storage variable in the contract as well, so that an external call to `yieldSource` to retrieve it can be avoided whenever it is needed.  ### Recommended Mitigation Steps  Define `address public override depositToken;` or `IERC20Upgradeable public depositToken;` which gets initialized in the `initialize()` function. The nice thing is that it also doesn't need to be updated when swapping sources because a requirement is that the new yield source must have the same deposit token.  As an optimization, since the `_requireYieldSource()` function already retrieves the `depositToken` address, it can return it so that its value need not be externally retrieved again in the `initialize()` function.  The `depositToken()` function can be removed if the former suggestion is implemented (ie. `address public override depositToken`).  Then, `yieldSource.depositToken()` can be replaced with `depositToken` where applicable (with appropriate casting).  A part of the former implementation is provided below.  ```jsx address public override depositToken;  function initialize(...) {  address depositTokenAddress = _requireYieldSource(_yieldSource);  yieldSource = _yieldSource;   depositToken = depositTokenAddress;  ...  IERC20Upgradeable(depositTokenAddress).safeApprove(address(_yieldSource), type(uint256).max); }  function _requireYieldSource(IYieldSource _yieldSource) internal view returns (address depositTokenAddress) {  ...  (depositTokenAddress) = abi.decode(depositTokenAddressData, (address)); }  // function depositToken() can be removed // yieldSource.depositToken() can be replaced with depositToken in other functions // Example: _setYieldSource function _setYieldSource(IYieldSource _newYieldSource) internal {  _requireDifferentYieldSource(_newYieldSource);  // Commented out check below should be shifted to inside _requireDifferentYieldSource()  // Optimization: it can also return depositToken to avoid another SLOAD  // similar to _requireYieldSource() above  // require(_newYieldSource.depositToken() == depositToken, \"SwappableYieldSource/different-deposit-token\");    yieldSource = _newYieldSource;   IERC20Upgradeable(depositToken).safeApprove(address(_newYieldSource), type(uint256).max);    emit SwappableYieldSourceSet(_newYieldSource); } ```  "}, {"title": "MStableYieldSource.sol: approveMax can use mAsset instead of savings.underlying()", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The immutable `mAsset` is assigned to the immutable `savings` contract. Hence, we can avoid an external function call to the savings contract in the `approveMax` function by replacing it with `mAsset`.   ### Recommended Mitigation Steps  ```jsx function approveMax() public {  mAsset.safeApprove(address(savings), type(uint256).max);   emit ApprovedMax(msg.sender); } ```  "}, {"title": "No input validation for  while setting up value for immutable state variables", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Since  immutable state variable cant be change after initialization in constructor, their value should be checked before initialization       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {             // @audit --> there should be a input validation          // As immutable storage variables can not be accessed in the constructor,         // create in-memory variables that can be used instead.         IERC20 mAssetMemory = IERC20(_savings.underlying());          // infinite approve Savings Contract to transfer mAssets from this contract         mAssetMemory.safeApprove(address(_savings), type(uint256).max);          // save to immutable storage         savings = _savings;         mAsset = mAssetMemory;          emit Initialized(_savings);     }   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L45  ## Tools Used no tool used  ## Recommended Mitigation Steps add a require condition to validate input values  "}, {"title": "[MStableYieldSource.sol] Public functions that should be declared as external to save gas", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  maplesyrup   # Vulnerability details  ## Impact  This is a gas optimization, does not affect the contract negatively, only optimizes it.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), functions that are never called within the contract should be declared as external to save gas for the contract.  In this case, there were only 2 functions in the contract that were found that should be declared as external for further gas optimization.  -----------  Code Snippet:  function approveMax() public {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #61-65)  function depositToken() public view override returns (address underlyingMasset) {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #69-71)   ------------  Console output:  INFO:Detectors: approveMax() should be declared external:  - MStableYieldSource.approveMax() (contracts/yield-source/MStableYieldSource.sol#61-65) depositToken() should be declared external:  - MStableYieldSource.depositToken() (contracts/yield-source/MStableYieldSource.sol#69-71) Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external  ## Tools Used  PoolTogether Contracts Solidity (v 0.7.4) Hardhat (v 2.5.0) Yarn (v 1.22.10) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for PoolTogether Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts via artifacts  "}, {"title": "Variable name or isInvalidYieldSource is confusion", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/8", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _requireYieldSource of the contract SwappableYieldSource has a state variable: isInvalidYieldSource  You would expect isInvalidYieldSource == true would mean the yield source in invalid However in the source code  isInvalidYieldSource == true mean the yield source is valid.  This is confusing for readers and future maintainers. Future maintainers could easily make a mistake and thus introduce vulnerabilities.  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol#L74 function _requireYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(0), \"SwappableYieldSource/yieldSource-not-zero-address\");     (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));     bool isInvalidYieldSource;     if (depositTokenAddressData.length > 0) {       (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));       isInvalidYieldSource = depositTokenAddress != address(0);     }     require(isInvalidYieldSource, \"SwappableYieldSource/invalid-yield-source\");   }  ## Tools Used  ## Recommended Mitigation Steps Change isInvalidYieldSource to isValidYieldSource   "}, {"title": "setYieldSource leads to temporary wrong results", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/4", "labels": ["bug", "3 (High Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The use of setYieldSource leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.  The function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.  More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).  It is possible to make use of this problem in the following way: - monitor the blockchain until you see setYieldSource has been done - immediately call the function supplyTokenTo (which can be called because there is no access control on this function)  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {     _setYieldSource(_newYieldSource);    function _setYieldSource(IYieldSource _newYieldSource) internal { ..     yieldSource = _newYieldSource;   function supplyTokenTo(uint256 amount, address to) external override nonReentrant {    ..     yieldSource.supplyTokenTo(amount, address(this));     _mintShares(amount, to);   }   function _mintShares(uint256 mintAmount, address to) internal {     uint256 shares = _tokenToShares(mintAmount);     require(shares > 0, \"SwappableYieldSource/shares-gt-zero\");     _mint(to, shares);   }   function _tokenToShares(uint256 tokens) internal returns (uint256) {     uint256 shares;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this))); // based on incomplete yieldSource.balanceOfToken(address(this))       shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);     function balanceOfToken(address addr) external override returns (uint256) {     return _sharesToToken(balanceOf(addr));   }   function _sharesToToken(uint256 shares) internal returns (uint256) {     uint256 tokens;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply); // based on incomplete yieldSource.balanceOfToken(address(this))       tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);  ## Tools Used  ## Recommended Mitigation Steps Remove the function setYieldSource  (e.g. only leave swapYieldSource) Or temporally disable actions like supplyTokenTo, redeemToken and balanceOfToken, after setYieldSource and until transferFunds has been done  "}, {"title": "Old yield source still has infinite approval", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/3", "labels": ["bug", "2 (Med Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L268  ## Recommended Mitigation Steps Decrease approval after swapping the yield source.  "}, {"title": "Some tokens do not have decimals.", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact There are a few tokens out there that do not use any decimals. As far as I know none of them would be a good yield source, but just in case something comes out, you may want to include the possibility that decimals = 0.  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L116  ## Recommended Mitigation Steps Remove the require statement.   "}, {"title": "Sponsored event not used", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "mStableYieldSource", "sponsor confirmed", "disagree with severity"], "target": "2021-07-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact The sponsored event is declared but never used.  ## Proof of Concept https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L27  ## Recommended Mitigation Steps Remove the unused event.  "}, {"title": "Rewards squatting - setting rewards in different ERC20 tokens opens various economic attacks. ", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/64", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  moose-code   # Vulnerability details  ## Impact Users have essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.   Although stated on line 84, it does not take into account the implications and lock in this contract will have on the future value of new tokens able to be issued via rewards.   ## Proof of Concept Smart users will monitor the mempool for setRewards transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they front run this transaction by calling claim. Otherwise they let their accrued 'token a' roll into rewards of of the more valuable 'token b'.  Given loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards.   Economically, given the above it makes sense that the value of new reward tokens, i.e. 'token b' should always be less than that of 'token a'. This is undesirable in a rewards token contract as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.  i.e. You could not in future say we want to run a rewards period of of issuing an asset like WETH rewards for 10 days, after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.  P.s. This is one of the slickest contracts I've read. Love how awesome it is.Just believe this should be fixed, then its good to go.   ## Tools Used Manual analysis  ## Recommended Mitigation Steps It is true you could probably write a script to manually go call 'claim' on thousands of squatting token addresses but this is a poor solution.   A simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).  "}, {"title": "Timelock.sol: Indexing targets array might not be useful", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "EmergencyBrake", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  As per the [solidity documentation](https://docs.soliditylang.org/en/v0.8.1/abi-spec.html?highlight=events#events):  However, for all \u201ccomplex\u201d types or types of dynamic length, including all arrays, string, bytes and structs, EVENT_INDEXED_ARGS will contain the Keccak hash of a special in-place encoded value (see Encoding of Indexed Event Parameters), rather than the encoded value directly.  It therefore might not be useful to index `address[] targets` in `Timelock.sol` and `address[] contacts` in `EmergencyBrake.sol`, since it's the keccak hash of the addresses. [Also saves gas to drop the indexed keyword](https://ethereum.stackexchange.com/questions/56486/does-it-make-a-difference-to-index-an-event-with-one-parameter/56491).  ### Recommended Mitigation Steps  Remove the `indexed` keyword for the arguments mentioned above.  "}, {"title": "Methods should be external instead of public", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/61", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  As brought up in a [previous audit issue](https://github.com/code-423n4/2021-05-yield-findings/issues/4), \"the suggestion of changing all public auth functions to external auth will be applied\". The same should therefore be done for the new contracts `Strategy.sol` and `ERC20Rewards.sol`, since all public methods in it aren't called internally.  "}, {"title": "ERC20Rewards.sol: Unnecessary return argument for _updateRewardsPerToken()", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/60", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `uint128` output by `_updateRewardsPerToken()` isn't used by any function. Furthermore, L107 returns a wrong value.  `if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod.start) return 0;`  It should return `rewardsPerToken_.accumulated` instead, because in the case of a new rewards schedule being set, `rewardsPeriod.start` is updated to a new timestamp. Hence, the current accumulated value of all previous reward schedules thus far should be returned.  ### Recommended Mitigation Steps  Since the return value isn't used anywhere, remove it.  "}, {"title": "ERC20Rewards.sol: latest() is unused", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `latest()` function is unused and can be removed.  ### Recommended Mitigation Steps  Remove L68-L71  "}, {"title": "ERC20Rewards.sol: Have a method to calculate the latest rewardsPerToken accumulated value", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  This would be equivalent to [Unipool's `rewardPerToken()` function](https://github.com/k06a/Unipool/blob/master/contracts/Unipool.sol#L69). Note that `rewardsPerToken.accumulated` only reflects the latest stored accumulated value, but does not account for pending accumulation like Unipool, and is therefore not the same. It possibly might be mistaken to be so, hence the low risk classification.  ### Recommended Mitigation Steps  A possible implementation is given below.  ```jsx function latestRewardPerToken() external view returns (uint256) {  RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;  if (_totalSupply == 0) return rewardsPerToken_.accumulated;  uint32 end = earliest(block.timestamp.u32(), rewardsPeriod.end);  uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated;  return rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply; } ```  "}, {"title": "ERC20Rewards.sol: Consider making rewardsToken immutable", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/56", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  While it might seem like a good feature to have, being able to switch reward tokens will only be useful for tokens which are equivalent in value (probably stablecoins, pegged tokens) since it carries over unclaimed rewards from the previous reward program. It would be safer to keep the reward token immutable as a safeguard against violations of this condition.  "}, {"title": "Missing check for contract existence", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level call returns success even if the contract is non-existent. This requires a contract existence check before making the low-level call.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L93  See: \u201cThe low-level functions\u00a0call,\u00a0delegatecall\u00a0and\u00a0staticcall\u00a0return\u00a0true\u00a0as their first return value if the account called is non-existent, as part of the design of the EVM. Account\u00a0existence\u00a0must be checked prior to calling if needed.\u201d from https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for target contract existence before call.  "}, {"title": "Unused cauldron_ parameter", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  That cauldron_ parameter is not used here and ladle_.cauldron() is used instead. The Ladle constructor initializes its cauldron value and so the only way this could differ from the parameter is if the argument to this function is specified incorrectly.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L106-L107  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/Ladle.sol#L33   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Either use parameter or remove it in favor of the value from ladle_.cauldron().  "}, {"title": "Missing emits for events", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/51", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor confirmed", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Few events are missing emits which prevents the intended data from being observed easily by off-chain interfaces.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L48-L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emits or remove event declarations.  "}, {"title": "Upgrading solc compiler version may help with bug fixes\u2028", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  solc version 0.8.3 and 0.8.4 fixed important bugs in the compiler. Using version 0.8.1 misses these fixes and may cause a vulnerability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2  https://github.com/ethereum/solidity/releases/tag/v0.8.4: Solidity 0.8.4 fixes a bug in the ABI decoder. The release contains an important bugfix. See\u00a0decoding from memory bug\u00a0blog post for more details.  https://github.com/ethereum/solidity/releases/tag/v0.8.3: Solidity 0.8.3 is a bugfix release that fixes an important bug about how the optimizer handles the Keccak256 opcode. For details on the bug, please see the\u00a0bug blog post.   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider upgrading to 0.8.3 or 0.8.4  "}, {"title": "Missing input validation to check that end > start", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  setRewards() is missing input validation on parameters start and end to check if end > start. If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one.   ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check that end > start.  "}, {"title": "Check made redundant by following check", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "EmergencyBrake", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact The check for array lengths is unnecessary in two places where the following check on txHash will anyway fail if the lengths don\u2019t match with what was hashed earlier during schedule. Removing the length check can save a little gas.  Such a require() in cancel() can be removed because if there is a mismatch, the entry lookup in transactions[] will fail anyway and also, this will not be sceduled/executed.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L70-L72  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L81-L85   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate and remove these checks.  "}, {"title": "Redundant check\u2028", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The require check for decimals_ <= 18 is unnecessary given its set to 18 right above unless this needs to be obtained differently as hinted by the comment.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/compound/CTokenMultiOracle.sol#L110-L111  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate check and remove.  "}, {"title": "Two functions with same code can be replaced by a single one", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  As noted in the code comment, peek and get functions are the same for this oracle. So we can change `peek` to public visibility and have `get` call `peek` instead of copying the same code here. Minor deployment cost savings but increase in readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L91  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L74-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace two functions having the same code with a single function.  "}, {"title": "Not using memory data location specifier for external function parameters will save gas", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "EmergencyBrake", "FYTokenFactory"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function parameters are passed in calldata. For external functions, these are simply read from calldata. But explicitly specifying memory location for such parameters will force their copying to memory resulting in extra bytecode and more gas. Leaving them in calldata will save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L45-L46  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L66-L67  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L77-L78  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L101-L102  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L116-L117  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/FYTokenFactory.sol#L21-L22  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Do not use memory data location specifier for external function parameters  "}, {"title": "Using parameters or local variables instead of state variables in event emits can save gas", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Event emits where there are equivalent local variables or parameters for state variables can save gas by using those instead of state variables because of the expensive SLOADs.  ## Proof of Concept  rewardsToken: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L97  delay: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L51   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use parameters or local variables instead of state variables in event emits  "}, {"title": "Caching state variable in local variables for repeated reads saves gas by converting expensive SLOADs into much cheaper MLOADs", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  SLOADs cost 2100 gas for first time reads of state variables and then 100 gas for repeated reads in the context of a transaction (post Berlin fork). MLOADs cost 3 gas units. Therefore, caching state variable in local variables for repeated reads saves gas.  ## Proof of Concept  Examples of state variables that are read at the lines shown and also later in that same function:  rewardsPeriod: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L80  _totalSupply: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L107  nextPool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L163  ladle: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L172  base: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L180  pool (600 gas savings): https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L183  pool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L208  cached: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L262   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider caching state variables in local variables.  "}, {"title": "Changing function visibility from public to external saves gas", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Public functions need to copy their arguments from calldata to memory resulting in more bytecode and gas consumption. If functions are never called from within the contracts, they can be declared external in which case their parameters are always in calldata without being copied to memory. This results in gas savings. There are many such public functions that don\u2019t appear to be called from within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L75  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100-L101  All functions declared in this range: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L127-L252  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external\u2028  "}, {"title": "Gas optimization on `_updateRewardsPerToken` of `ERC20Rewards`", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `_updateRewardsPerToken` function of `ERC20Rewards` is called when a token is transferred, minted, or burned. Thus, it could be called multiple times in a single block. Gas optimization is possible by checking if the `end` variable is equal to `rewardsPerToken_.lastUpdated`. If so, the function can return after line 112 since no reward needs to be updated. The early return could avoid writing to the storage (line 117) and thus save gas.  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L112](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L112) [ERC20Rewards.sol#L117](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L117)  ## Recommended Mitigation Steps  Simply return if `end == rewardsPerToken_.lastUpdated` if the `_updateRewardsPerToken` function.  "}, {"title": "Exchange rates from Compound are assumed with 18 decimals", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/38", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `CTokenMultiOracle` contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the [Compound documentation](https://compound.finance/docs/ctokens#exchange-rate), the exchange rate returned from the `exchangeRateCurrent` function is scaled by `1 * 10^(18 - 8 + Underlying Token Decimals)` (and so does `exchangeRateStored`). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens.  ## Proof of Concept  Referenced code: [CTokenMultiOracle.sol#L110](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110)  ## Recommended Mitigation Steps  Follow the documentation and get the decimals of the underlying tokens to set the correct decimal of a `Source`.  "}, {"title": "Uninitialized `updateTime` variables in `CompositeMultiOracle`", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/37", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor confirmed", "disagree with severity", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `peek` and `get` functions of `CompositeMultiOracle` do not initialize the return variable `updateTime`, which is always 0 since the oldest timestamp is chosen and returned.  ## Proof of Concept  Referenced code: [CompositeMultiOracle.sol#L76](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L76) [CompositeMultiOracle.sol#L96](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L96)  ## Recommended Mitigation Steps  Handle the case when `updateTimeIn` is 0 in the private `_peek` and `_get` functions. If so, simply return `updateTimeOut`.  "}, {"title": "Use `safeTransfer` instead of `transfer`", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/36", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Tokens not compliant with the ERC20 specification could return `false` from the `transfer` function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the [EIP-20](https://eips.ethereum.org/EIPS/eip-20) specification:  > Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned!  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L175](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  "}, {"title": "Gas: `ERC20Rewards._updateRewardsPerToken` return value is not needed", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The return value is never used and should be removed to save some gas.  "}, {"title": "Gas: `TimeLock.setDelay` reads storage variable for event", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/33", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  `TimeLock.setDelay` reads storage variable for event which produces an `SLOAD`. It should use `emit DelaySet(_delay)` instead of `emit DelaySet(delay)`  "}, {"title": "No ERC20 safe* versions called", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `claim` function performs an ERC20 transfer `rewardsToken.transfer(to, claiming);` but does not check the return value, nor does it work with all legacy tokens.  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.   ## Impact Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer and tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   "}, {"title": "ERC20Rewards breaks when setting a different token", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/29", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `setRewards` function allows setting a different token. Holders of a previous reward period cannot all be paid out and will receive **their old reward amount** in the new token.  This leads to issues when the new token is more (less) valuable, or uses different decimals.  **Example:** Assume the first reward period paid out in `DAI` which has 18 decimals. Someone would have received `1.0 DAI = 1e18 DAI` if they called `claim` now. Instead, they wait until the new period starts with `USDC` (using only 6 decimals) and can `claim` their `1e18` reward amount in USDC which would equal `1e12 USDC`, one trillion USD.  ## Impact Changing the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.  ## Recommended Mitigation Steps Disallow changing the reward token, or clear user's pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.  "}, {"title": "ERC20Rewards returns wrong rewards if no tokens initially exist", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/28", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ERC20Rewards._updateRewardsPerToken` function exits without updating `rewardsPerToken_.lastUpdated` if `totalSupply` is zero, i.e., if there are no tokens initially.  This leads to an error if there is an active rewards period but not tokens have been minted yet.  **Example:** `rewardsPeriod.start: 1 month ago`, `rewardsPeriod.end: in 1 month`, `totalSupply == 0`. The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case). - `_mint` is called, calls `_updateRewardsPerToken` which short-circuits. `rewardsPerToken.lastUpdated` is still set to `rewardsPeriod.start` from the constructor. Then `_updateUserRewards` is called and does not currently yield any rewards. (because both balance and the index diff are zero). User is now minted the tokens, `totalSupply` increases and user balance is set. - User performs a `claim`: `_updateRewardsPerToken` is called and `timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month`. Contract \"issues\" rewards for the past month. The first mintee receives all of it.  ## Impact The first mintee receives all pending rewards when they should not receive any past rewards. This can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet. Note that `setRewards` also allows setting a date in the past which would also be fatal in this case.  ## Recommended Mitigation Steps The `rewardsPerToken_.lastUpdated` field must always be updated in `_updateRewardsPerToken` to the current time (or `end`) even if `_totalSupply == 0`. Don't return early.  "}, {"title": "TimeLock cannot schedule the same calls multiple times", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TimeLock.schedule` function reverts if the same `targets` and `data` fields are used as the `txHash` will be the same. This means one cannot schedule the same transactions multiple times.  ## Impact Imagine the delay is set to 30 days, but a contractor needs to be paid every 2 weeks. One needs to wait 30 days before scheduling the second payment to them.  ## Recommended Mitigation Steps Also include `eta` in the hash. (Compound's Timelock does it as well.) This way the same transaction data can be used by specifying a different `eta`.   "}, {"title": "The `Strategy.Divest` event is not fired", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Strategy.Divest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `endPool`.  "}, {"title": "The `Strategy.Invest` event is not fired", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Strategy.Invest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `startPool`.  "}, {"title": "EmergencyBrake.sol: Permissions cannot be re-planned after termination", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "EmergencyBrake"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Given a configuration of target, contacts and permissions, calling `terminate()` will permanently prevent this configuration from being used again because the state becomes `State.TERMINATED`. All other functions require the configuration to be in the other states (UNKNOWN, PLANNED, or EXECUTED).  In other words, the removal of the restoring option for the configuration through `EmergencyBrake` is permanent.  ### Recommended Mitigation Steps  Since `EmergencyBrake` cannot reinstate permissions after termination, it would be better to have terminate change its state to UNKNOWN. The TERMINATED state can therefore be removed.  "}, {"title": "CompositeMultiOracle.sol - bases.length in setSources() and setPaths() can be stored in a variable", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In the external functions `setSources` and `setPaths` of `CompositeMultiOracle.sol`, we call `bases.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L39-L46  https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L60-L67  ## Recommended Mitigation Steps Store `bases.length` in a variable and declare `i` with the default value: ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == sources_.length,     \"Mismatched inputs\" );  for (uint256 i; i < basesLength; i++) {     _setSource(bases[i], quotes[i], sources_[i]); } ``` ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == paths_.length,     \"Mismatched inputs\" );  for (uint256 i; i < basesLength; i++) {     _setPath(bases[i], quotes[i], paths_[i]); } ```  "}, {"title": "CompositeMultiOracle.sol - Add natspec documentation", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In `CompositeMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L79-L81  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L97-L99  ## Recommended Mitigation Steps Add natspec documentation to describe the contract and not just his title: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L11-L12  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L15 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L17-L18 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L20 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L25-L26 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L110 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L120 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L130 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L140  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L31 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L38 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L52 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L59 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L74 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L94  "}, {"title": "CTokenMultiOracle.sol - cTokenIds.length in setSources() can be stored in a variable", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In the external function `setSources` of `CTokenMultiOracle.sol`, we call `cTokenIds.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L38-L39  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L42  ## Recommended Mitigation Steps Store `cTokenIds.length` in a variable and declare `i` with the default value: ``` uint256 cTokenIdsLength = cTokenIds.length;  require(     cTokenIdsLength == underlyings.length &&     cTokenIdsLength == cTokens.length,     \"Mismatched inputs\" );  for (uint256 i; i < cTokenIdsLength; i++) {     _setSource(cTokenIds[i], underlyings[i], cTokens[i]); } ```  "}, {"title": "CTokenMultiOracle.sol - Add natspec documentation", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  # CTokenMultiOracle.sol - Add natspec documentation  ## Impact In `CTokenMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Recommended Mitigation Steps Add natspec documentation to describe the contract: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L11  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L14 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L16 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L18 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L24 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L73 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L91 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L109  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L29 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L36 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L51 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L64   "}, {"title": "FYTokenFactory.sol - fyToken.ROOT() can be stored in a variable", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In `FYTokenFactory.sol`, it is possible to avoid one sload by storing `fyToken.ROOT()` in a variable.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/77bc292601ba6cb6d35f9a1cb606f21ed94ad36e/contracts/FYTokenFactory.sol#L37-L38  ## Tools Used Manual analysis  ## Recommended Mitigation Steps ```   bytes4 rootRole = fyToken.ROOT();    fyToken.grantRole(rootRole, msg.sender);   fyToken.renounceRole(rootRole, address(this)); ```  "}, {"title": "improve safety of role constants ", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/9", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Wand"], "target": "2021-08-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The contract Wand defines a few role constants with bytes4(keccak256(\"...function...\")) However if the function template would change slightly, for example when uint128 is replaced by uint256, then this construction isn't valid anymore.  It is safer the use the function selector, as is done in EmergencyBrake.sol  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/main/contracts/Wand.sol#L27      bytes4 public constant JOIN = bytes4(keccak256(\"join(address,uint128)\"));     bytes4 public constant EXIT = bytes4(keccak256(\"exit(address,uint128)\"));     bytes4 public constant MINT = bytes4(keccak256(\"mint(address,uint256)\"));     bytes4 public constant BURN = bytes4(keccak256(\"burn(address,uint256)\"));  https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/EmergencyBrake.sol#L35   _grantRole(IEmergencyBrake.plan.selector, planner);  ## Tools Used  ## Recommended Mitigation Steps Use function selectors in Wand.sol   "}, {"title": "updateTime of get is 0", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In function get of CompositeMultiOracle the updateTime is not initialized, so it will be 0  Function _get has the following statement:    updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;      updateTimeIn ==0 ==>  (updateTimeOut < updateTimeIn)== false ==> result of the expression is updateTimeIn == 0 ==> updateTimeOut =0  So this means the function get will always return updateTime==0  The updateTime result of the function get doesn't seem to be used in the code so the risk is low. If would only be relevant for future code updates.   ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L94  function get(bytes32 base, bytes32 quote, uint256 amount)  external virtual override  returns (uint256 value, uint256 updateTime)  { ...         for (uint256 p = 0; p < path.length; p++) {             (price, updateTime) = _get(base_, path[p], price, updateTime);  function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)  private returns (uint priceOut, uint updateTimeOut) {     ...         (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit       ...         updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time     }  ## Tools Used  ## Recommended Mitigation Steps In function get, add the following in the beginning of the function: updateTime = block.timestamp;  "}, {"title": "gas improvement in schedule and cancel of TimeLock.sol", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions schedule and cancel of TimeLock.sol receive the parameters targets and data. This is not absolutely necessary. Receiving txHash would be enough, as txHash is verified in the function execute. This is like a commit and reveal scheme. It would save some gas and contract complexity.  This assumes that the parameters  targets and data are accessible offchain for verification, which I would think would be true anyway.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps You can use the following approach if you want to save some gas. Note: the parameters targets and data won't be available onchain in events (at least until execute has been performed)   function schedule(bytes32 txHash, uint256 eta) external override auth {         require(eta >= block.timestamp + delay, \"Must satisfy delay.\"); // This also prevents setting eta = 0 and messing up the state                 require(transactions[txHash] == 0, \"Transaction not unknown.\");         transactions[txHash] = eta;                ....     }      function cancel(bytes32 txHash) external override auth {         require(transactions[txHash] != 0, \"Transaction hasn't been scheduled.\");         delete transactions[txHash];        ....     }  "}, {"title": "double negative in comment", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact TimeLock.sol contains a comment with a double negative, which is confusing to read: Transaction not unknown.  ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/TimeLock.sol#L55  function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta)   external override auth returns (bytes32 txHash)  { ..         require(transactions[txHash] == 0, \"Transaction not unknown.\");  ## Tools Used  ## Recommended Mitigation Steps Replace: Transaction not unknown. with: Transaction already scheduled.  "}, {"title": "gas saving in `_processRentCollection`", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In `rcMarket._processRentCollection` it's possible to save a SLOAD by rewriting the lines: ``` uint256 _rentOwed = (card[_card].cardPrice *     (_timeOfCollection - card[_card].timeLastCollected)) / 1 days; uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); ``` into: ``` uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); uint256 _rentOwed = (card[_card].cardPrice * _timeHeldToIncrement) / 1 days; ```  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1060-L1063  ## Tools Used editor  ## Recommended Mitigation Steps Consider changing the code as illustrated.  "}, {"title": "add zero address validation in constructor", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter in the constructor are used to initialize the state variable , proper check up should be done , other wise error in these state variable  can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCLeaderboard.sol#L50  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCOrderbook.sol#L136  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L120  ## Tools Used manual review  ## Recommended Mitigation Steps add zero address validation  "}, {"title": "`RCLeaderboard.market` storage variable is not used", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  The `RCLeaderboard.market` storage variable is never used. Instead, the `MARKET` role seems to be used to implement authentication.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  "}, {"title": "No check for the referenceContractAddress in createMarket()", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact   referenceContractAddress  is used in createMarket() to create newAddress  for the market , a necessary check should be there that referenceContractAddress exist or not, because if createMarket() is called before setReferenceContractAddress() address(0) will be passed as referenceContractAddress , since addMarket() of treasury and nfthub does not have address validation for the market  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCFactory.sol#L714  ## Tools Used  manual review  ## Recommended Mitigation Steps  add a condition to check the referenceContractAddress  "}, {"title": "RCTreasury: Spelling Errors", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  - `seperate` \u2192 `separate` - `incase` \u2192 `in case`  "}, {"title": "RCTreasury: new hasRole() function with string role", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  It might be operationally easier (eg. reading permissions via etherscan, saves a few seconds having to search for the bytes32 constant and copy its value) to take in the role of type `string` instead of `bytes32`. It also has an added benefit of overloading the `hasRole()` function, where overriding was desired.  ### Recommended Mitigation Steps  Perhaps add it as an additional function to avoid having to change all `treasury.checkPermissions()` function calls (since the role input has to be modified too).  ```jsx // TODO: add to interface function hasRole(string memory role, address account)  external  view  override  returns (bool) {  bytes32 _role = keccak256(abi.encodePacked(role));  return AccessControl.hasRole(_role, account); } ```  "}, {"title": "RCTreasury: AccessControl diagram contains Leaderboard, but it has no role", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx /* setup AccessControl                   UBER_OWNER     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502           \u2502          \u2502            \u2502         \u2502   OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD     \u2502           \u2502  GOVERNOR     MARKET     \u2502  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  From this diagram, one might expect the existence of a `LEADERBOARD` role, but there is no such role. It should be removed from the diagram.  ### Recommended Mitigation Steps  ```jsx /* setup AccessControl                   UBER_OWNER     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502           \u2502          \u2502            \u2502            OWNER      FACTORY    ORDERBOOK   TREASURY     \u2502           \u2502  GOVERNOR     MARKET     \u2502  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  "}, {"title": "RCLeaderboard: Erroneous comment", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The comments above the event declarations were probably copied over from RCOrderbook. They should be modified to refer to the leaderboard.  ### Recommended Mitigation Steps  ```jsx /// @dev emitted every time a user is added to the leaderboard event LogAddToLeaderboard(address _user, address _market, uint256 _card); /// @dev emitted every time a user is removed from the leaderboard event LogRemoveFromLeaderboard(     address _user,     address _market,     uint256 _card ); ```  "}, {"title": "RCFactory: Solve stack too deep for getMarketInfo()", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `marketInfoResults` is a parameter used by `getMarketInfo()` to determine the length of results to return. As the `setMarketInfoResults()` comments state, \"(it) would be better to pass this as a parameter in getMarketInfo.. however we are limited because of stack too deep errors\".  This limitation can be overcome by defining the return array variables as the function output, as suggested below.  The need for `marketInfoResults` and its setter function is then made redundant, whilst making querying results of possibly varying lengths more convenient.  ### Recommended Mitigation Steps  ```jsx function getMarketInfo(   IRCMarket.Mode _mode,   uint256 _state,   uint256 _skipResults,   uint256 _numResults // equivalent of marketInfoResults )   external   view   returns (     address[] memory _marketAddresses,     string[] memory _ipfsHashes,     string[] memory _slugs,     uint256[] memory _potSizes  )  {    uint256 _marketIndex = marketAddresses[_mode].length;        _marketAddresses = new address[](_numResults);    _ipfsHashes = new string[](_numResults);    _slugs = new string[](_numResults);    _potSizes = new uint256[](_numResults);   ... } ```  "}, {"title": "RCFactory: Do multiplication instead of division for length checks", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/39", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Solidity division rounds down, so doing `M / 2 <= N` checks mean that `M` can be at most `2N + 1`.  This affects the following checks:  ```jsx require(  (_tokenURIs.length / 2) <= cardLimit,  \"Too many tokens to mint\" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length == (_tokenURIs.length / 2),   \"Card Affiliate Length Error\" ) ```  Note that with the current implementation, if `_tokenURIs` is of odd length, its last element will be  redundant, but market creation will not revert.  The stricter checks will partially mitigate `_tokenURIs` having odd length because `_cardAffiliateAddresses` is now required to be exactly twice that of `_tokenURIs`.  ### Recommended Mitigation Steps  These checks should be modified to   ```jsx require(  _tokenURIs.length <= cardLimit * 2,  \"Too many tokens to mint\" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length * 2 == _tokenURIs.length,   \"Card Affiliate Length Error\" ); ```  In addition, consider adding a check for `_tokenURIs` to strictly be of even length.  `require(_tokenURIs.length % 2 == 0, \"TokenURI Length Error\");`  "}, {"title": "transferCard should be done after treasury is updated.", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  0xImpostor   # Vulnerability details  ## Impact  When the current owner of the card is still the new owner of the card, `transferCard` is called before the treasury is updated. While this does not currently pose a risk, it is not aligned with best practices of [check-effect-interations](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and opens your code to a potential re-entrancy attack in the future.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```jsx // line 381 treasury.updateRentalRate(     _oldOwner,     _user,     user[_oldOwner][index[_oldOwner][_market][_card]].price,     _price,     block.timestamp ); transferCard(_market, _card, _oldOwner, _user, _price); ... // line 449 treasury.updateRentalRate(     _user,     _user,     _price,     _currUser.price,     block.timestamp ); transferCard(_market, _card, _user, _user, _currUser.price); ```  "}, {"title": "uint32 conversion doesn't work as expected.", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The uint32 conversion in setWinner of the RCMarket doesn't work as expected. The first statement: \"uint32(block.timestamp)\" already first the block.timestamp in a uint32. If it is larger than type(uint32).max it wraps around and starts with 0 again The testcode below shows this.  Check for \"<= type(uint32).max\" in the second statement is useless because _blockTimestamp is always  <= type(uint32).max  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L507  function setWinner(uint256 _winningOutcome) internal { ...             uint256 _blockTimestamp = uint32(block.timestamp);             require(_blockTimestamp <= type(uint32).max, \"Overflow\");   //Testcode: pragma solidity 0.8.7; contract Convert {    uint256 public a = uint256( type(uint32).max )+1; // a==4294967296    uint32  public b = uint32(a); // b==0    uint256 public c = uint32(a); // c==0 }     ## Tools Used  ## Recommended Mitigation Steps Do the require first (without a typecast to uint32):              require( block.timestamp <= type(uint32).max, \"Overflow\");             uint256 _blockTimestamp = uint32(block.timestamp);    "}, {"title": "findNewOwner edgecase", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/27", "labels": ["bug", "sponsor confirmed", "Resolved", "disagree with severity", "3 (High Risk)"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function findNewOwner of RCOrderbook, as loop is done which included the check  _loopCounter < maxDeletions Afterwards a check is done for  \"(_loopCounter != maxDeletions)\" to determine if the processing is finished. If _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.  However there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.  You can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549  function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  { ...         // delete current owner         do {             _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );             _loopCounter++;             // delete next bid if foreclosed         } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&                 _loopCounter < maxDeletions );          if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner             _newOwner = ....              ...         } else {             // we hit the limit, save the old owner, we'll try again next time            ...         }     }   ## Tools Used  ## Recommended Mitigation Steps Use a different way to determine that the processing is done. This could save some gas. Note: the additional check also costs gas, so you have the verify the end result.  Perhaps in setDeletionLimit doublecheck that _deletionLimit > 1.  "}, {"title": "Return Value is Not Validated", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact The `circuitBreaker()` function in `RCMarket.sol` is utilised in the event an oracle never provides a response to a RealityCards question. The function makes an external call to the `RCOrderbook.sol` contract through the `closeMarket()` function. If for some reason the orderbook was unable to be closed, this would never be checked in the `circuitBreaker()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1215-L1223  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Ensure this is intended behaviour, or otherwise validate the response of `orderbook.closeMarket()`. Another option would be to emit the result of the external call in the `LogStateChange` event, alongside the state change.  "}, {"title": "External Call Made Before State Change", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact There are a number of functions in `RCTreasury.sol` which make external calls to another contract before updating the underlying market balances. More specifically, these affected functions are `deposit()`, `sponsor()`, and `topupMarketBalance()`. As a result, these functions would be prone to reentrancy exploits. However, as `safeTransferFrom()` operates on a trusted ERC20 token (RealityCard's token), this issue is of low severity.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L385-L391 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L561-L563 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L459-L461  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Modify the aforementioned functions such that all state changes are made before a call to the ERC20 token using the `safeTransferFrom()` function.  "}, {"title": "msgSender() or _msgSender()", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The code has two implementations of msgSender:  -   msgSender() => uses meta transaction signer -  _msgSender() => maps to msg.sender  _msgSender() is used in a few locations - when using _setupRole, this seems legitimate - in function withdraw  (whereas the similar function withdrawWithMetadata uses msgSender() )  It is confusing to have multiple functions with almost the same name, this could easily lead to mistakes.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/lib/NativeMetaTransaction.sol#L105  function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             assembly {   sender := shr(96, calldataload(sub(calldatasize(), 20)))   }         } else {              sender = payable(msg.sender);         }         return sender;     }  // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol   function _msgSender() internal view virtual returns (address) {         return msg.sender;     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L164   function withdraw(uint256 tokenId) external override {         require(  _msgSender() == ownerOf(tokenId), \"ChildMintableERC721: INVALID_TOKEN_OWNER\" ); // _msgSender()          withdrawnTokens[tokenId] = true;         _burn(tokenId);     }      function withdrawWithMetadata(uint256 tokenId) external override {         require( msgSender() == ownerOf(tokenId), \"ChildMintableERC721: INVALID_TOKEN_OWNER\" );  // msgSender()          withdrawnTokens[tokenId] = true;         // Encoding metadata associated with tokenId & emitting event         emit TransferWithMetadata( ownerOf(tokenId), address(0), tokenId, this.encodeTokenMetadata(tokenId) );         _burn(tokenId);     }  RCNftHubL1.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCNftHubL2.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(UBER_OWNER,               _msgSender()); RCTreasury.sol:        _setupRole(OWNER,                         _msgSender()); RCTreasury.sol:        _setupRole(GOVERNOR,                   _msgSender()); RCTreasury.sol:        _setupRole(WHITELIST,                    _msgSender());  ## Tools Used grep  ## Recommended Mitigation Steps Doublecheck the use of  _msgSender() in withdraw and adjust if necessary.  Add comments when using  _msgSender()   Consider overriding _msgSender(), as is done in the example below: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol    "}, {"title": "rentAllCards: don't have to pay for card you already own", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards of RCMarket checks for _maxSumOfPrices to see you are not paying more that you want.  However the first part of the calculations (which calculate _actualSumOfPrices ), do not take in account the fact that you might  already own a card. (while the second part of the code does). If you already own the card you don't have to pay for it and you certainly don't have to pay the extra minimumPriceIncreasePercent.  The code at \"Proof of Concept\" shows a refactored version of the code (see other issue \"make code of rentAllCards easier to read\"). This immediately shows the issue.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691 ==> simplified version  function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);   // no check for  (ownerOf(i) != msgSender()) {         }         require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add \"if (ownerOf(i) != msgSender()) {\" also in the first part of the code of rentAllCards          uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {              if (ownerOf(i) != msgSender()) {              // extra if statement                  _actualSumOfPrices += calc(card[i].cardPrice);                 }         }         "}, {"title": "make code of rentAllCards easier to read and maintain", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards or RCMarket contains a similar piece of code twice (mainly the formula: (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100; )  The current code is somewhat difficult to read and maintain and hides potential issue (also see other issue about rentAllCards)  ## Proof of Concept //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691   function rentAllCards(uint256 _maxSumOfPrices) external override {         _checkState(States.OPEN);         // check that not being front run         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             if (card[i].cardPrice == 0) {                 _actualSumOfPrices += MIN_RENTAL_VALUE;             } else {                 _actualSumOfPrices += (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100;             }         }         require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice;                 if (card[i].cardPrice > 0) {                     _newPrice =                         (card[i].cardPrice *                             (minimumPriceIncreasePercent + 100)) /                         100;                 } else {                     _newPrice = MIN_RENTAL_VALUE;                 }                 newRental(_newPrice, 0, address(0), i);             }         }     }   ## Tools Used  ## Recommended Mitigation Steps Suggestion to make the code easier to read and maintain:   function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);         }         .....         for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }   "}, {"title": "Uninitialized Variable `marketWhitelist` in `RCTreasury.sol`", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/18", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Resolved", "disagree with severity"], "target": "2021-08-realitycards-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact The variable, `marketWhitelist`, is never initialized in the contract `RCTreasury.sol`. As a result, the function `marketWhitelistCheck()`  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return `true`, even if a market wishes to restrict its users to a specific role.   ## Proof of Concept  The initial state variable is defined in the link below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75  The state variable `marketWhitelist` is accessed in the function `RCTreasury.marketWhitelistCheck()` as per below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281  The function `RCTreasury.marketWhitelistCheck()` is called in `RCMarket.newRental()` as seen below. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in `RCTreasury` that allow a market creator to enable this functionality. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761  ## Tools Used  `npx hardhat coverage` `slither` Manual code review  ## Recommended Mitigation Steps  Ensure this behaviour is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.  "}, {"title": "Inaccurate Comment", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/16", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact This issue has no direct security implications, however, there may be some confusion when understanding what the `RCFactory.createMarket()` function actually does.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L625  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Update the line (linked above) to include the `SAFE_MODE` option outline in the `enum` type in `IRCMarket.sol`. For example, the line `/// @param _mode 0 = normal, 1 = winner takes all` could be updated to `/// @param _mode 0 = normal, 1 = winner takes all, 2 = SAFE_MODE`  "}, {"title": "Can't retrieve all data with getMarketInfo ", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/14", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getMarketInfo of RCFactory only can give results back in the range 0...marketInfoResults  Supplying _skipResults doesn't help, it then just skips the first _skipResults  records.  Assume marketInfoResults == 10 and _skipResults == 20: Then no result will be given back because \"_resultNumber < marketInfoResults\" will never allow _resultNumber  to be bigger than 10  Note: this is low risk because getMarketInfo is a backup function (although you maybe want the backup to function as expected)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L227   function getMarketInfo( IRCMarket.Mode _mode, uint256 _state, uint256 _skipResults  )  external view         returns ( address[] memory, string[] memory, string[] memory, uint256[] memory ) {            ..         uint256 _resultNumber = 0;        ..         while (_resultNumber < marketInfoResults && _marketIndex > 1) {            ...                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[_resultNumber] = _market;   // will never reach this part if _skipResults >= marketInfoResults                      ....                     _resultNumber++;                 }             }         }         return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);     }   ## Tools Used  ## Recommended Mitigation Steps Update the code to something like the following:       uint idx;  while (idx < marketInfoResults && _marketIndex > 1) {             _marketIndex--;             address _market = marketAddresses[_mode][_marketIndex];             if (IRCMarket(_market).state() == IRCMarket.States(_state)) {                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[idx] = _market;                     _ipfsHashes[idx] = ipfsHash[_market];                     _slugs[idx] = addressToSlug[_market];                     _potSizes[idx] = IRCMarket(_market).totalRentCollected();                     idx++;                 }             }         }        "}, {"title": "getMostRecentMarket can revert", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/13", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getMostRecentMarket of RCFactory.sol will revert if no markets of the specific mode are created yet.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L171     function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address)     {         return marketAddresses[_mode][marketAddresses[_mode].length - (1)];     }   ## Tools Used  ## Recommended Mitigation Steps Change the function getMostRecentMarket to something like:  function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address) {      if ( marketAddresses[_mode].length ==0) return address(0);      return marketAddresses[_mode][marketAddresses[_mode].length - (1)]; }   "}, {"title": "updateTokenURI doesn't call setTokenURI ", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function updateTokenURI of RCFactory.sol doesn't update the uris of RCNftHubL2. E.g. it doesn't call setTokenURI to try and update the already created NFT's. This way the URIs of already minted tokens are not updated.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L453  function updateTokenURI(  // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L101 function setTokenURI(uint256 _tokenId, string calldata _tokenURI) external onlyUberOwner {         _setTokenURI(_tokenId, _tokenURI);     }  ## Tools Used  ## Recommended Mitigation Steps Also call setTokenURI of RCNftHubL2 Or restrict updateTokenURI to the phase where no NFT's are minted yet. Or at least add comments to updateTokenURI   "}, {"title": "remove addMarket from RCNftHubL2", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The contract RCNftHubL2 contains a function addMarket and an array isMarket. This was useful in the previous version of the contract, but now it is no longer used. Note: isMarket() could be used to retrieve the markets from RCNftHubL2, but there are also other ways to do that.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L31 /// @dev so only markets can move NFTs     mapping(address => bool) public isMarket;   /// @dev so only markets can change ownership     function addMarket(address _newMarket) external override {         require(msgSender() == address(factory), \"Not factory\");         isMarket[_newMarket] = true;     }      // MARKET ONLY     function transferNft( address _currentOwner,  address _newOwner,   uint256 _tokenId ) external override {         require(marketTracker[_tokenId] == msgSender(), \"Not market\");         _transfer(_currentOwner, _newOwner, _tokenId);     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L636 function createMarket( ...  nfthub.addMarket(_newAddress);  ## Tools Used  ## Recommended Mitigation Steps Double check if isMarket and addMarket have any use left. If not remove them from RCNftHubL2 Also remove the call to nfthub.addMarket(_newAddress) from RCFactory.sol  "}, {"title": "remove unused modifiers", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Several modifiers are defined, but not used: - onlyTokenOwner in RCMarket.sol - onlyFactory in RCOrderbook.sol and RCLeaderboard.sol  This clutters the code base  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L328     modifier onlyTokenOwner(uint256 _token) {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L104   modifier onlyFactory() {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCLeaderboard.sol#L61   modifier onlyFactory() {   ...  ## Tools Used  ## Recommended Mitigation Steps Remove the unused modifiers   "}, {"title": "safer implementation of tokenExists", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/8", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function tokenExists does only limited checks on the existence of cards. It doesn't doublecheck that tokenIds[_card] != 0   This is relevant because 0 is the default value of empty array elements. Although this isn't a problem in the current code,  future changes might accidentally introduce vulnerabilities.  Also cards are only valid if they are below numberOfCards. This has led to vulnerabilities in previous versions of the contract (e.g. previous contest)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1139 function tokenExists(uint256 _card) internal view returns (bool) {         return tokenIds[_card] != type(uint256).max; }  ## Tools Used  ## Recommended Mitigation Steps Change the function to something like the following:  function tokenExists(uint256 _card) internal view returns (bool) {        if (_cardId >= numberOfCards) return false;        if (tokenIds[_card] == 0) return false;        return tokenIds[_card] != type(uint256).max; }   "}, {"title": "RCMarket.sol - Gas optimization in _payoutWinnings", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact  We can avoid 3 sload by storing `card[winningOutcome]` in a private variable.  We can also avoid 4 sload by storing `msgSender()` in a private variable.  We can also simplify the `_winningsToTransfer` calculation.  ## Proof of Concept  `card[winningOutcome]`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L589  `msgSender()`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L592  `_winningsToTransfer`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  `card[winningOutcome]`:  ``` Card storage _cardWinningOutcome = card[winningOutcome]; ```  [L574](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574): `_cardWinningOutcome.rentCollectedPerCard) *`  `msgSender()`:  ``` address _msgSender = msgSender(); ```  [L578](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578): `(rentCollectedPerUserPerCard[_msgSender][winningOutcome] *`  [L591 to L592](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591-L592):  ``` _payout(_msgSender, _winningsToTransfer); emit LogWinningsPaid(_msgSender, _winningsToTransfer); ```  `card[winningOutcome]` and `msgSender()`:  [L564](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564): `if (_cardWinningOutcome.longestOwner == _msgSender && winnerCut > 0) {`  [L585](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585): `uint256 _winnersTimeHeld = _cardWinningOutcome.timeHeld[_msgSender];`  `card[winningOutcome]` and `_winningsToTransfer`:  [L587 to L589](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589): `_winningsToTransfer += (_numerator / _cardWinningOutcome.totalTimeHeld);`   "}, {"title": "Cannot actually submit evidence", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/64", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  jmak   # Vulnerability details  ## Impact Detailed description of the impact of this finding.\u2028The SubmitBadSignatureEvidence is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless. This harms the security model of Gravity since validators have no disincentive to attempt to collude and take over the bridge.   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The SubmitBadSignatureEvidence handler is omitted from module/x/gravity/handler.go  ## Tools Used Visual inspection  ## Recommended Mitigation Steps Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go.   "}, {"title": "Incorrect accounting on transfer-on-fee/deflationary tokens in `Gravity`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `sendToCosmos` function of `Gravity` transfers `_amount` of `_tokenContract` from the sender using the function `transferFrom`. If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than `_amount`. However, since `_amount` is passed as a parameter of the `SendToCosmosEvent` event, the Cosmos side will think more tokens are locked on the Ethereum side.  ## Proof of Concept  Referenced code: [Gravity.sol#L535](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L535) [Gravity.sol#L541](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L541)  ## Recommended Mitigation Steps  Consider getting the received amount by calculating the difference of token balance (using `balanceOf`) before and after the `transferFrom`.  "}, {"title": "Direct usage of `ecrecover` allows signature malleability", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `verifySig` function of `Gravity` calls the Solidity `ecrecover` function directly to verify the given signatures. However, the `ecrecover` EVM opcode allows malleable (non-unique) signatures and thus is susceptible to replay attacks.  Although a replay attack seems not possible here since the nonce is increased each time, ensuring the signatures are not malleable is considered a best practice (and so is checking `_signer != address(0)`, where `address(0)` means an invalid signature).  ## Proof of Concept  Referenced code: [Gravity.sol#L153](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L153)  [SWC-117: Signature Malleability](https://swcregistry.io/docs/SWC-117) [SWC-121: Missing Protection against Signature Replay Attacks](https://swcregistry.io/docs/SWC-121)  ## Recommended Mitigation Steps  Use the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification.  "}, {"title": "SafeMath library is not always used in `Gravity`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  SafeMath library functions are not always used in the `Gravity` contract's arithmetic operations, which could cause integer underflow/overflows. Using SafeMath is considered a best practice that could completely prevent underflow/overflows and increase code consistency.  ## Proof of Concept  Referenced code: [Gravity.sol#L202](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L202) [Gravity.sol#L586](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L586)  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.  "}, {"title": "Lack of Validation Check", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that on the cosmos side Coin amount has not been checked on the token definition. That can use misfunctionality on the bridge.  Although zero amount definition fee will be calculated. That can cause lose of user funds.   ## Proof of Concept  1. Navigate to \"https://github.com/althea-net/cosmos-gravity-bridge/blob/main/module/x/gravity/types/ethereum.go\" Line #69. 2. On the following code, ValidateBasic function does not validate amount.  ``` // ValidateBasic permforms stateless validation func (e *ERC20Token) ValidateBasic() error {  if err := ValidateEthAddress(e.Contract); err != nil {   return sdkerrors.Wrap(err, \"ethereum address\")  }  // TODO: Validate all the things  return nil } ```  ## Tools Used  ## Recommended Mitigation Steps  Add the following validation steps on the ValidationBasic function.  ```  if !m.Amount.IsValid() {   return cosmos.ErrInvalidCoins(\"coins must be valid\")  }   if !m.Amount.IsAllPositive() {   return cosmos.ErrInvalidCoins(\"coins must be positive\")  } ```    "}, {"title": "The function `updateValset` does not have enough sanity checks", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/51", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ##  `updateValset` does not have enough sanity checks  In [updateValset](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L224) function, the current set of validators adds a new set.  It is missing the check that the combined power of all new validators is above the `state_powerThreshold`. If this is false, then the contract is effectively stuck. Consider adding an on-chain check for this.  It is also worth adding a that the size of the new validator check is less than a certain number.  Here is a rough calculation explaining how 10000 validators (an extreme example) is too much:  1.  Let us say that the new set of validators have the property that at     least, say, `N` validators are needed to get the total threshold     above `state_powerThreshold`. 2.  Since each validating signature requires a call to `ecrecover`,     costing at least `3000` gas, the minimum gas needed for getting a     proposal over `state_powerThreshold` would be `N * 3000` 3.  `N * 3000` cannot be more than the `block.gaslimit` Currently, this     puts `N` to be less than `10000`  Another approach to solve the above potential problems is to do the updating as a two step process:  1.  The current set of validators proposes a pending set of validators. 2.  And the pending set of validators need to do the transition to     become the new set of validators. Going through the same threshold     checks.  This guarantees that the new set of validators has enough power to pass threshold and doesn't have gas limit issues in doing so.   "}, {"title": "State Variables that can be changed to `immutable`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## State Variables that can be changed to `immutable`  [Solidity 0.6.5](https://blog.soliditylang.org/2020/04/06/solidity-0.6.5-release-announcement/) introduced `immutable` as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage.  Consider the following generic example:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public owner = msg.sender; } ```  In the above example, each call to the function `owner()` reads from storage, using a `sload`. After [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), this costs 2100 gas cold or 100 gas warm. However, the following snippet is more gas efficient:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public immutable owner = msg.sender; } ```  In the above example, each storage read of the `owner` state variable is replaced by the instruction `push32 value`, where `value` is set during contract construction time. Unlike the last example, this costs only 3 gas.  ### Examples  1.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L59> 2.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L60>    "}, {"title": "use of floating pragma ", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/42", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  https://swcregistry.io/docs/SWC-103  ## Proof of Concept https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L1  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  "}, {"title": "Why nonces are not incrementing by 1 ?", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I am concerned why invalidationId, invalidationNonce or valsetNonce are only required to be greater than the previous value. Why did you choose this approach instead of just simply asking for an incremented value? While this may not be a problem if the validators are honest, but otherwise, they may submit a nonce of MAX UINT and thus block the whole system as it would be no longer possible to submit a greater value. Again, just wanted you to be aware of this issue, not sure how likely this to happen is in practice, it depends on the honesty of validators so you better know.  ## Recommended Mitigation Steps I didn't receive an answer on Discord so decided to submit this FYI to decide if that's a hazard or no.  "}, {"title": "Validations of parameters", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are a few validations that could be added to the system: the constructor could check that _gravityId is not empty. state_powerThreshold should always be greater than 0, otherwise, anyone will be available to execute actions.  ## Recommended Mitigation Steps Consider implementing suggested validations.  "}, {"title": "Crash Eth Oracle On Any LogicCallEvent", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  **Severity: Medium** **Likelihood: High**  In `eth_oracle_main_loop`, `get_last_checked_block` is called. Followed by: ```rust= let logic_call_executed_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![LOGIC_CALL_EVENT_SIG],             )             .await; ``` and may hit the code path: ```rust=         for event in logic_call_executed_events {             match LogicCallExecutedEvent::from_log(&event) {                 Ok(call) => {                     trace!(                         \"{} LogicCall event nonce {} last event nonce\",                         call.event_nonce,                         last_event_nonce                     );                     if upcast(call.event_nonce) == last_event_nonce && event.block_number.is_some()                     {                         return event.block_number.unwrap();                     }                 }                 Err(e) => error!(\"Got ERC20Deployed event that we can't parse {}\", e),             }         } ```  But will panic at `from_log` here: ```rust= impl LogicCallExecutedEvent {     pub fn from_log(_input: &Log) -> Result<LogicCallExecutedEvent, GravityError> {         unimplemented!()     }     // snip... } ``` It can/will also be triggered here in `check_for_events`:  ```rust= let logic_calls = LogicCallExecutedEvent::from_logs(&logic_calls)?; ```  Attestations will be frozen until patched.  ## Recommendation Implement the method.  ## Recommended Mitigation Steps  "}, {"title": "Win all relayer rewards", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  \"Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayer\" can affect just the relayers & not affect the oracle in certain circumstances. This could result in valid attestations, but prevent any of the other relayers from being able to participate in the execution. While the other relayers are down from the other attack, the attacker can win all batch, logic, and valset rewards as their node is the only relayer running. This is possible because `find_latest_valset` is run in the main relayer loop and everytime tries for 5000 blocks of logs.  "}, {"title": "Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayers", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/6", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  In a similar vein to \"Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms\", a sufficiently large validator set or sufficiently rapid validator update could cause both the `eth_oracle_main_loop` and `relayer_main_loop` to fall into a state of perpetual errors. In `find_latest_valset`, [we call](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/relayer/src/find_latest_valset.rs#L33-L40): ```rust= let mut all_valset_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![VALSET_UPDATED_EVENT_SIG],             )             .await?; ```  Which if the validator set is sufficiently large, or sufficiently rapidly updated, which continuous return an error if the logs in a 5000 (see: `const BLOCKS_TO_SEARCH: u128 = 5_000u128;`) block range are in excess of 10mb. Cosmos hub says they will be pushing the number of validators up to 300 (currently 125). At 300, each log would produce 19328 bytes of data (4\\*32+64\\*300). Given this, there must be below 517 updates per 5000 block range otherwise the node will fall out of sync.   This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  "}, {"title": "Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/5", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  Ethereum Oracles watch for events on the `Gravity.sol` contract on the Ethereum blockchain. This is performed in the [`check_for_events`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L23) function, ran in the [`eth_oracle_main_loop`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/main_loop.rs#L94).   In this function, there is [the following code snippet](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L66-L73): ```rust=     let erc20_deployed = web3         .check_for_events(             starting_block.clone(),             Some(latest_block.clone()),             vec![gravity_contract_address],             vec![ERC20_DEPLOYED_EVENT_SIG],         )         .await; ``` This snippet leverages the `web30` library to check for events from the `starting_block` to the `latest_block`. Inside the `web30` library this nets out to calling: ```rust=     pub async fn eth_get_logs(&self, new_filter: NewFilter) -> Result<Vec<Log>, Web3Error> {         self.jsonrpc_client             .request_method(                 \"eth_getLogs\",                 vec![new_filter],                 self.timeout,                 Some(10_000_000),             )             .await     } ```  The `10_000_000` specifies the maximum size of the return in bytes and returns an error if the return is larger: ```rust=         let res: Response<R> = match res.json().limit(limit).await {             Ok(val) => val,             Err(e) => return Err(Web3Error::BadResponse(format!(\"Web3 Error {}\", e))),         }; ```  This can be triggered at will and keep the loop in a perpetual state of returning the `GravityError::EthereumRestError(Web3Error::BadResponse(             \"Failed to get logs!\".to_string()))` error. To force the node into this state, you just have to deploy ERC20s generated by the [public function in `Gravity.sol`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L546-L565): ```solidity=  function deployERC20(   string memory _cosmosDenom,   string memory _name,   string memory _symbol,   uint8 _decimals  ) public {   // Deploy an ERC20 with entire supply granted to Gravity.sol   CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);    // Fire an event to let the Cosmos module know   state_lastEventNonce = state_lastEventNonce.add(1);   emit ERC20DeployedEvent(    _cosmosDenom,    address(erc20),    _name,    _symbol,    _decimals,    state_lastEventNonce   );  } ```  And specify a large string as the denom, name, or symbol. If an attacker uses the denom as the attack vector, they save significant gas costing just 256 per additional 32 bytes. For other cases, to avoid gas overhead, you can have the string be mostly 0s resulting in just 584 gas per additional 32 bytes. This leaves it feasible to surpass the 10mb response data in the 6 block buffer. This would throw every ethereum oracle into a state of perpetual errors and all would fall out of sync with the ethereum blockchain. This would result in the batches, logic calls, deposits, ERC20 creations, and valset updates to never receive attestations from other validators because their ethereum oracles would be down; the bridge would be frozen and remain frozen until the bug is fixed due to `get_last_checked_block`.  This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  Additionally, you could require that validators sign ERC20 creation requests.  "}, {"title": "Freeze Bridge via Non-UTF8 Token Name/Symbol/Denom", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/4", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  Manual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. The fix is non-trivial and likely requires significant redesign.  # Proof of Concept Note the `c0` in the last argument of the call data (invalid UTF8).  It can be triggered with: ```solidity= data memory bytes = hex\"f7955637000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000461746f6d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000673796d626fc00000000000000000000000000000000000000000000000000000\"; gravity.call(data); ``` The log output is as follows: ``` ERC20DeployedEvent(\"atom\", \"name\", \u276eutf8 decode failed\u276f: 0x73796d626fc0, 18, 2) ```  Which hits [this code path](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/gravity_utils/src/types/ethereum_events.rs#L431-L438): ```rust=             let symbol = String::from_utf8(input.data[index_start..index_end].to_vec());             trace!(\"Symbol {:?}\", symbol);             if symbol.is_err() {                 return Err(GravityError::InvalidEventLogError(format!(                     \"{:?} is not valid utf8, probably incorrect parsing\",                     symbol                 )));             } ```  And would cause an early return [here](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L99): ```rust= let erc20_deploys = Erc20DeployedEvent::from_logs(&deploys)?; ```  Never updating last checked block and therefore, this will freeze the bridge by disallowing any attestations to take place. This is an extremely low cost way to bring down the network.  ## Recommendation This is a hard one. Resyncing is permanently borked because on the Go side, there is seemingly no way to ever process the event nonce because protobufs do not handle non-utf8 strings. The validator would report they need event nonce `N` from the orchestrator, but they can never parse the event `N`. Seemingly, validators & orchestrators would have to know to ignore that specific event nonce. But it is a permissionless function, so it can be used to effectively permanently stop attestations & the bridge until a new `Gravity.sol` is deployed.  One potential fix is to check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. This likely will be expensive though. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent.   "}, {"title": "Smart Contract Gas Optimization", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  ElliotFriedman   # Vulnerability details  ## Impact Currently, submitBatch, updateValset, deployERC20 and submitLogicCall all have arguments that are in memory. This causes calls to these functions to be more expensive than they need to be. By moving to external functions and upgrading the compiler version, there will be gas savings. The larger the amount of data being submitted to the contracts, the greater the savings as the cost of memory in the EVM goes up quadratically with the amount of data stored.  ## Tools Used Hardhat  ## Recommended Mitigation Steps Make all functions that you can external instead of public, especially the ones mentioned above that will see large transaction volumes, and change the data types from memory to external. This may involve changing compiler versions to 0.8.0 or greater to support using structs as external types.  "}, {"title": "Caching `totalPoints` during `setPoints` method", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching `totalPoints` during `setPoints` method  Instead of constantly writing to the same slot in a for loop, write it once at the end. This would save `100` gas for each iteration of the for loop. (Since [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), the cost of writing to a dirty storage slot is 100 gas)  ``` diff modified   contracts/Access/PointList.sol @@ -65,6 +65,7 @@ contract PointList is IPointList, MISOAccessControls {     function setPoints(address[] memory _accounts, uint256[] memory _amounts) external override {          require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PointList.setPoints: Sender must be operator\");          require(_accounts.length != 0, \"PointList.setPoints: empty array\");          require(_accounts.length == _amounts.length, \"PointList.setPoints: incorrect array length\"); +        uint totalPointsCache = totalPoints;          for (uint i = 0; i < _accounts.length; i++) {              address account = _accounts[i];              uint256 amount = _amounts[i]; @@ -72,9 +73,10 @@ contract PointList is IPointList, MISOAccessControls {               if (amount != previousPoints) {                  points[account] = amount; -                totalPoints = totalPoints.sub(previousPoints).add(amount); +                totalPointsCache = totalPointsCache.sub(previousPoints).add(amount);                  emit PointsUpdated(account, previousPoints, amount);              }          } +        totalPoints = totalPointsCache;      }  } ```   "}, {"title": " Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from `memory` to `calldata` may cause \"unimplemented feature error\". This can be avoided by using a newer (`0.8.*`) Solidity compiler.  ### (non-exhaustive) List of Examples  1.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/PointList.sol#L64> 2.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/ListFactory.sol#L151> 3.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/ListFactory.sol#L152> 4.  <https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/PointList.sol#L64>    "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/130", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * Misleading comment here (similarly with launcherInfo):   /// @notice Mapping from auction address created through this contract to Auction struct.   mapping(address => Token) public tokenInfo;  * In function deployToken this check should have an error message to indicate the user what's wrong:   require(tokenTemplates[_templateId] != address(0)); something like \"MISOTokenFactory: incorrect _templateId\". Also a meaningful revert message is missing here as regular user may not understand that token2 decimals should be >= token1 decimals:   require(d2 >= d1);  * There are a few copypasted misleading error messages, e.g. in function setCurrentTemplateId:      require(tokenTemplates[_templateId] != address(0), \"MISOMarket: incorrect _templateId\");      require(IMisoToken(tokenTemplates[_templateId]).tokenTemplate() == _templateType, \"MISOMarket: incorrect _templateType\"); should be MISOTokenFactory, not MISOMarket. Here also indicates the wrong location:    require(templateType > 0, \"MISOLauncher: Incorrect template code \"); You should consider revisiting and fixing them.  * There are hardcoded magic numbers, e.g. in MISOTokenFactory 1000 is indicating 100%. It would make code more readable and maintainable if you extract such numbers as constants.  * There is so much duplicated code across Auction contracts. Consider introducing an abstract BaseAuction (or similar name) contract that has common functions that specific auctions can inherit, e.g. ETH_ADDRESS, marketParticipationAgreement, revertBecauseUserDidNotProvideAgreement, etc.    "}, {"title": "_startTime is always < 10000000000 when _endTime < 10000000000 (_endTime > _startTime)", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact No need to check that _startTime < 10000000000 as it is later checked against _endTime which is also < 10000000000 :         require(_startTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");         require(_endTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");         ...         require(_endTime > _startTime, \"Crowdsale: end time must be older than start price\");  ## Recommended Mitigation Steps Remove this line:     require(_startTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");  "}, {"title": "Dead code", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact WETH state variable in MISOLauncher is practically useless as it is not used in any meaningful way. Similarly, SECONDS_PER_DAY is not used in PostAuctionLauncher.  ## Recommended Mitigation Steps Consider removing unused variables.  "}, {"title": "Useless initialization to default value", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact No need for this line in function initMISOMarket as it gets this value by default:   auctionTemplateId = 0;  ## Recommended Mitigation Steps Consider removing useless initialization.  "}, {"title": "The first escrow index underflows", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/110", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function createEscrow first assigns an index for the new isChildEscrow and only then pushes the struct to the array. When first escrow is being created, the array contains 0 elements so escrows.length-1 will underflow and return a max uint value:    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length-1);    escrows.push(newEscrow);  ## Recommended Mitigation Steps    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length);    escrows.push(newEscrow);  "}, {"title": "Loss of price precision", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  The `DutchAuction._currentPrice()` is computed by multiplying with `priceDrop()`. However, `priceDrop()` already performs a division and the final current price, therefore, loses precision.  Note that `priceDrop()` could even return `0` for ultra-low prices or very long auctions.  Imagine the actual payment per auction token price is `10^-12` => `startPrice` and `endPrice` are set with 18 decimals as ~`10^6`, but for auctions over a year (31,536,000 seconds > `10^6`) it'll then return 0.  ## Impact Precision can be lost leading to less accurate token auction results or even completely breaking the auction if the price is very low and the auctions are very long.  ## Recommended Mitigation Steps Perform all multiplications before divisions:  ```solidity uint256 priceDiff = block.timestamp.sub(uint256(marketInfo.startTime)).mul(     uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice))   ) / uint256(_marketInfo.endTime.sub(_marketInfo.startTime)); ```   "}, {"title": "TokenInitialized token parameter is always empty", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/106", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function createToken emits TokenInitialized event, however, it does it before actually deploying the token so address(token) will always be empty (0x0):    emit TokenInitialized(address(token), _templateId, _data);    token = deployToken(_templateId, _integratorFeeAccount); This may confuse external consumers of this event.  ## Recommended Mitigation Steps Usually, a good practice is to emit events in the end after all the actions are done.  "}, {"title": "Gas: Cache auction prices", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/105", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  The `DutchAuction.clearingPrice` function can save gas by caching the computed prices instead of recomputing it.  ## Recommended Mitigation Steps Cache the values:  ```solidity function clearingPrice() public view returns (uint256) {     /// @dev If auction successful, return tokenPrice     uint256 _tokenPrice = tokenPrice();     uint256 _currentPrice = priceFunction();     return _tokenPrice > _currentPrice ? _tokenPrice : _currentPrice; } ```   "}, {"title": "Use constant named variable for auction decimals", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/103", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  The `CrowdSale.initCrowdsale` function checks that the auction token has 18 decimals through `IERC20(_token).decimals() == 18`. This seems to be related to `AUCTION_TOKEN_DECIMALS` and these values should not get ouf of sync.  ## Impact These values can easily get out of sync.  ## Recommended Mitigation Steps Create another named constant and set it to `18` decimals:  ```solidity uint256 private constant AUCTION_TOKEN_DECIMAL_PLACES = 18; uint256 private constant AUCTION_TOKEN_DECIMALS = 10 ** AUCTION_TOKEN_DECIMAL_PLACES; ```   "}, {"title": "No ERC20 `safeApprove` versions called", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  Some tokens don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  Calls to `.approve` with user-defined tokens are made in: - `MISOLauncher.createLauncher` - `MISOMarket.createMarket`  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the mentioned contracts as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  "}, {"title": "lockTokens should validate withdrawer", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/92", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function lockTokens in contract TokenVault should check that _withdrawer is not empty (0x0) to prevent accidentally locked forever (burned) tokens.  ## Recommended Mitigation Steps require(_withdrawer != address(0));  "}, {"title": "Event parameters interchanged for emit of access control template addition", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Emission of the event AccessControlTemplateAdded(address oldAccessControl, address newAccessControl) has the old and new addresses interchanged which could confuse/trigger offchain monitoring tools or interfaces.   This is of medium severity (instead of low) because it is related to access control template updation and critical to security of all contracts that rely on MISOAccessFactory.  The actual emit is emit AccessControlTemplateAdded(_template, accessControlTemplate); which has the parameter used in the oldAccessControl place instead of being used for the second argument, and vice-versa.  ## Proof of Concept https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L36-L37  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L100   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Interchange the arguments in the emit.  "}, {"title": "Avoiding unnecessary external call will save > 2600 gas", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Market is guaranteed to be finalized by checking and calling finalize if not finalized. So the subsequent require()  by again checking market.finalized() is redundant and can save 2600+ gas by removing the external call. External calls cost 2600 gas after Berlin upgrade.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L226-L229  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove the require().  "}, {"title": "`currentTemplateId` is Not Actively Removed by `MISOLauncher.removeLiquidityLauncherTemplate()`", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  If the current template ID is removed from `MISOLauncher.sol`, the function `removeLiquidityLauncherTemplate()` does not accurately reflect this by deleting `currentTemplateId[_templateId]`. This may lead to users actively using a removed template, expecting the `deployLauncher()` function to succeed when it will revert instead.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/master/contracts/MISOLauncher.sol#L323-L334  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider removing `currentTemplateId[_templateId]` if the template to be removed by `removeLiquidityLauncherTemplate()` is the same template.  "}, {"title": "Missing SPDX Identifier", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  There are several contracts missing SPDX identifiers which correctly license the contract for open source development: `MISOAccessFactory.sol` `MISOAccessControls.sol` `MISOAdminAccess.sol` `PointList.sol` `TokenList.sol` `MISOMasterChef.sol` `CalculationsSushiswap.sol` `MISOHelper.sol` `PairsHelper.sol` `USDC.sol`  ## Proof of Concept  Refer to listed contracts.  ## Tools Used  Compiler warnings  ## Recommended Mitigation Steps  Consider adding `// SPDX-License-Identifier: GPL-3.0-only` to the top of the aforementioned files.  "}, {"title": "Outdated and Vulnerable `TimelockController.sol` Contract", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockController.sol` acts as an auxiliary contract to the MISO platform's core contracts. Therefore, this issue is not of high risk as not all users wanting to auction tokens will use this contract for governance behaviour. The `TimelockController.sol` enables a governance framework to enforce a timelock on any proposals, giving users time to exit before a potentially dangerous maintenance operation is applied. However, the `executeBatch()` is vulnerable to reentrancy, enabling privilege escalation for any account with the `EXECUTOR` role to `ADMIN`.  ## Proof of Concept  Bug outlined [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/access/TimelockController.sol#L244-L269). Fix is outlined in this [commit](https://github.com/OpenZeppelin/openzeppelin-contracts/commit/cec4f2ef57495d8b1742d62846da212515d99dd5#diff-8229f9027848871a1706845a5a84fa3e6591445cfac6e16cfb7d652e91e8d395R307).  ## Tools Used  Sourced from publicly disclosed post by [Immnuefi](https://medium.com/immunefi/openzeppelin-bug-fix-postmortem-66d8c89ed166).  ## Recommended Mitigation Steps  Update `Openzeppelin` library to a version containing the commit fixing the bug (mentioned above). Tag `v3.4.2-solc-0.7` in `Openzeppelin`'s Github repository is an example of a compatible library that contains the aforementioned bug fix.  "}, {"title": "finalize() can be succesfully called before initMarket()", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/16", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function finalize() of all the auction contracts can be called by everyone before initMarket() is called. This will set status.finalized = true, which will probably not be detected until the auction is over (because it is only used in a few locations).  If this would happen then the auction cannot be finalized again. Also cancelAuction cannot be called.  Luckily the deployment of the auction contracts is done from createMarket in MISOMarket.sol, which directly calls initMarket(). So in practice this won't pose a problem, however future developers or forks might not be aware of this and deploy the contract differently.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender)              || finalizeTimeExpired(),                         // initially  true             \"Crowdsale: sender must be an admin\"         );         MarketStatus storage status = marketStatus;         require(!status.finalized, \"Crowdsale: already finalized\");  // initially status.finalized==false         MarketInfo storage info = marketInfo;         require(auctionEnded(), \"Crowdsale: Has not finished yet\");   // initially  true          if (auctionSuccessful()) {  // initially  true             /// @dev Successful auction             /// @dev Transfer contributed tokens to wallet.             _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));             /// @dev Transfer unsold tokens to wallet.             uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));             uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);             if(unsoldTokens > 0) {                 _safeTokenPayment(auctionToken, wallet, unsoldTokens);             }         } else {             /// @dev Failed auction             /// @dev Return auction tokens back to wallet.             _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));         }          status.finalized = true;    // will end up here          emit AuctionFinalized();     }  function finalizeTimeExpired() public view returns (bool) {            return uint256(marketInfo.endTime) + 7 days < block.timestamp;  // initially  true (0 + 7 days <  block.timestamp)     }       function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); // initially  true  (0>=0)     }   function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||                              // // initially  true  (block.timestamp>0)         _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);     }  // https://github.com/sushiswap/miso/blob/master/contracts/MISOMarket.sol#L273 function createMarket(...)     {         newMarket = deployMarket(_templateId, _integratorFeeAccount);         ...         IMisoMarket(newMarket).initMarket(_data);  ## Tools Used  ## Recommended Mitigation Steps In function finalize() add something like:     require(isInitialized(),\"Not initialized\");   "}, {"title": "Last person to withdraw his tokens might not be able to do this, in Crowdsale (edge case)", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/15", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose a Crowdsale is successful and enough commitments are made before the marketInfo.endTime. Suppose marketStatus.commitmentsTotal  == marketInfo.totalTokens -1      // note this is an edge case, but can be constructed by an attacker Then the function auctionEnded() returns true Assume auctionSuccessful() is also true (might depend on the config of marketPrice.goal and marketInfo.totalTokens) Then an admin can call finalize() to finalize the Crowdsale. The function finalize distributes the funds and the unsold tokens and sets status.finalized = true so that finalized cannot be called again. Now we have \"marketInfo.totalTokens -1\" tokens left in the contract  However commitEth() or commitTokens() can still be called (they give no error message that the auction has ended) Then functions call calculateCommitment, which luckily prevent from buying too much, however 1 token can still be bought These functions also call _addCommitment(), which only checks for marketInfo.endTime, which hasn't passed yet.  Now an extra token is sold and the contract has 1 token short. So the last person to withdraw his tokens cannot withdraw them (because you cannot specify how much you want to withdraw)  Also the revenues for the last token cannot be retrieved as finalize() cannot be called again.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374 ```JS  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender) || finalizeTimeExpired(),\"Crowdsale: sender must be an admin\"); // can be called by admin         MarketStatus storage status = marketStatus;         require(!status.finalized, \"Crowdsale: already finalized\");         MarketInfo storage info = marketInfo;         require(auctionEnded(), \"Crowdsale: Has not finished yet\");    // is true if enough sold, even if this is before marketInfo.endTime          if (auctionSuccessful()) {                       /// @dev Transfer contributed tokens to wallet.             /// @dev Transfer unsold tokens to wallet.         } else {             /// @dev Return auction tokens back to wallet.         }         status.finalized = true;  function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||          _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens); // is true if enough sold, even if this is before marketInfo.endTime     }  function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); }  function commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement ) public payable nonReentrant  {        ...         uint256 ethToTransfer = calculateCommitment(msg.value);        ...        _addCommitment(_beneficiary, ethToTransfer);      function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) { // this prevents buying too much         uint256 tokens = _getTokenAmount(_commitment);         uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));         if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {             return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));         }         return _commitment;     }  function _addCommitment(address _addr, uint256 _commitment) internal {         require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"Crowdsale: outside auction hours\"); // doesn't check auctionEnded() nor status.finalized         ...         uint256 newCommitment = commitments[_addr].add(_commitment);         ...         commitments[_addr] = newCommitment;  function withdrawTokens(address payable beneficiary) public   nonReentrant  {             if (auctionSuccessful()) {             ...             uint256 tokensToClaim = tokensClaimable(beneficiary);             ...             claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);             _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);    // will fail is last token is missing         } else {    ## Tools Used  ## Recommended Mitigation Steps In the function _addCommitment, add a check on auctionEnded() or status.finalized  "}, {"title": "`PostAuctionLauncher.sol#finalize()` Adding liquidity to an existing pool may allows the attacker to steal most of the tokens", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/14", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  WatchPug   # Vulnerability details  `PostAuctionLauncher.finalize()` can be called by anyone, and it sends tokens directly to the pair pool to mint liquidity, even when the pair pool exists.  An attacker may control the LP price by creating the pool and then call `finalize()` to mint LP token with unfair price (pay huge amounts of tokens and get few amounts of LP token), and then remove the initial liquidity they acquired when creating the pool and takeout huge amounts of tokens.  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L257  ```solidity=216 /**  * @notice Finalizes Token sale and launches LP.  * @return liquidity Number of LPs.  */ function finalize() external nonReentrant returns (uint256 liquidity) {     // GP: Can we remove admin, let anyone can finalise and launch?     // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");     require(marketConnected(), \"PostAuction: Auction must have this launcher address set as the destination wallet\");     require(!launcherInfo.launched);      if (!market.finalized()) {         market.finalize();     }     require(market.finalized());      launcherInfo.launched = true;     if (!market.auctionSuccessful() ) {         return 0;     }      /// @dev if the auction is settled in weth, wrap any contract balance      uint256 launcherBalance = address(this).balance;     if (launcherBalance > 0 ) {         IWETH(weth).deposit{value : launcherBalance}();     }          (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();      /// @dev cannot start a liquidity pool with no tokens on either side     if (token1Amount == 0 || token2Amount == 0 ) {         return 0;     }      address pair = factory.getPair(address(token1), address(token2));     if(pair == address(0)) {         createPool();     }      /// @dev add liquidity to pool via the pair directly     _safeTransfer(address(token1), tokenPair, token1Amount);     _safeTransfer(address(token2), tokenPair, token2Amount);     liquidity = IUniswapV2Pair(tokenPair).mint(address(this));     launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));      /// @dev if unlock time not yet set, add it.     if (launcherInfo.unlock == 0 ) {         launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));     }     emit LiquidityAdded(liquidity); } ```   In line 257, `PostAuctionLauncher` will mint LP with token1Amount and token2Amount. The amounts (token1Amount and token2Amount) are computed according to the auction result, without considering the current price (reserves) of the existing `tokenPair`.  See [PostAuctionLauncher.getTokenAmounts()](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L268)  `PostAuctionLauncher` will receive an unfairly low amount of lp token because the amounts sent to `tokenPair` didn't match the current price of the pair.  See [UniswapV2Pair.mint(...)](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/UniswapV2/UniswapV2Pair.sol#L135) ```solidity=135 liquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); ```  ## Impact  Lose a majority share of the tokens.  ## Proof of Concept  1. The attacker creates LP with 0.0000001 token1 and 1000 token2, receives 0.01 LP token; 2. Call `PostAuctionLauncher.finalize()`. PostAuctionLauncher will mint liquidity with 2000 token1 and 1000 token2 for example, receives only  0.01 LP token; 3. The attacker removes all his LP, receives 1000 token1 (most of which come from PostAuctionLauncher).  ## Recommended Mitigation Steps  To only support tokenPair created by PostAuctionLauncher or check for the token price before mint liquidity.  "}, {"title": "Division by zero in `_computeLiquidityFromAdjustedBalances` of `HybridPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/185", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeLiquidityFromAdjustedBalances` function of `HybridPool` should return in the `if (s == 0)` statement, or it will cause a divison-by-zero error otherwise.  ## Proof of Concept  Referenced code: [HybridPool.sol#L350-L352](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L350-L352)  ## Recommended Mitigation Steps  Add `return computed;` after `computed = 0;`.  "}, {"title": "No bar fees for IndexPools?", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/181", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact IndexPool doesn't collect fees for `barFeeTo`. Since this Pool contains also a method `updateBarFee()`, probably this is an unintended behavior. Also without a fee, liquidity providers would probably ditch ConstantProductPool in favor of IndexPool (using the same two tokens with equal weights), since they get all the rewards. This would constitute an issue for the ecosystem.  ## Recommended Mitigation Steps Add a way to send barFees to barFeeTo, same as the other pools.  "}, {"title": "Users are susceptible to back-running when depositing ETH to `TridenRouter`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_depositToBentoBox` and `_depositFromUserToBentoBox` allow users to provide ETH to the router, which is later deposited to the `bento` contract for swapping other assets or providing liquidity. However, in these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation.  ## Proof of Concept  1. A user wants to swap ETH to DAI. He calls `exactInputSingleWithNativeToken` on the router with the corresponding parameters and `params.amountIn` being 10. Before calling the function, he calculates `bento.toAmount(wETH, 10, true) = 15` and thus send 15 ETH to the router. 2. However, at the time when his transaction is executed, `bento.toAmount(wETH, amount, true)` becomes to `14`, which could happen if someone calls `harvest` on `bento` to update the `elastic` value of the `wETH` token. 3. As a result, only 14 ETH is transferred to the pool, and 1 ETH is left in the router. Anyone could back-run the user's transaction to retrieve the remaining 1 ETH from the router by calling the `refundETH` function.  Referenced code: [TridentRouter.sol#L318-L351](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L318-L351)  ## Recommended Mitigation Steps  Directly push the remaining ETH to the sender to prevent any ETH left in the router.  "}, {"title": "Funds in the pool could be stolen by exploiting `flashSwap` in `HybridPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/167", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  An attacker can call the `bento.harvest` function during the callback function of a flash swap of the `HybridPool` to reduce the number of input tokens that he has to pay to the pool, as long as there is any unrealized profit in the strategy contract of the underlying asset.  ## Proof of Concept  1. The `HybridPool` accounts for the reserve and balance of the pool using the `bento.toAmount` function, which represents the actual amount of assets that the pool owns instead of the relative share. The value of `toAmount` could increase or decrease if the `bento.harvest` function is called (by anyone), depending on whether the strategy contract earns or loses money. 2. Supposing that the DAI strategy contract of `Bento` has a profit not accounted for yet. To account for the profit, anyone could call `harvest` on `Bento` with the corresponding parameters, which, as a result, increases the `elastic` of the DAI token. 3. Now, an attacker wants to utilize the unrealized profit to steal funds from a DAI-WETH hybrid pool. He calls `flashSwap` to initiate a flash swap from WETH to DAI. First, the pool transfers the corresponding amount of DAI to him, calls the `tridentSwapCallback` function on the attacker's contract, and expects that enough DAI is received at the end. 4. During the `tridentSwapCallback` function, the attacker calls `bento.harvest` to realize the profit of DAI. As a result, the pool's `bento.toAmount` increases, and the amount of DAI that the attacker has to pay to the pool is decreased. The attacker could get the same amount of ETH but paying less DAI by exploiting this bug.  Referenced code: [HybridPool.sol#L218-L220](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L218-L220) [HybridPool.sol#L249-L250](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L249-L250) [HybridPool.sol#L272-L285](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L272-L285) [BentoBoxV1Flat.sol#L1105](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L1105) [BentoBoxV1Flat.sol#L786-L792](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L786-L792) [BentoBoxV1Flat.sol#L264-L277](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L264-L277)  ## Recommended Mitigation Steps  Consider not using `bento.toAmount` to track the reservers and balances, but use `balanceOf` instead (as done in the other two pools).   "}, {"title": "Incorrect multiplication in `_computeSingleOutGivenPoolIn` of `IndexPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/166", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the raw multiplication (i.e., `*`) to calculate the `zaz` variable. However, since both `(BASE - normalizedWeight)` and `_swapFee` are in `WAD`, the `_mul` function should be used instead to calculate the correct value of `zaz`. Otherwise, `zaz` would be `10 ** 18` times larger than the expected value and causes an integer underflow when calculating `amountOut`. The incorrect usage of multiplication prevents anyone from calling the function successfully.  ## Proof of Concept  Referenced code: [IndexPool.sol#L282](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L282)   ## Recommended Mitigation Steps  Change `(BASE - normalizedWeight) * _swapFee` to `_mul((BASE - normalizedWeight), _swapFee)`.  "}, {"title": "Incorrect usage of `_pow` in `_computeSingleOutGivenPoolIn` of `IndexPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/165", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the `_pow` function to calculate `tokenOutRatio` with the exponent in `WAD` (i.e., in 18 decimals of precision). However, the `_pow` function assumes that the given exponent `n` is not in `WAD`. (for example, `_pow(5, BASE)` returns `5 ** (10 ** 18)` instead of `5 ** 1`). The misuse of the `_pow` function could causes an integer overflow in the `_computeSingleOutGivenPoolIn` function and thus prevent any function from calling it.  ## Proof of Concept  Referenced code: [IndexPool.sol#L279](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L279)   ## Recommended Mitigation Steps  Change the `_pow` function to the `_compute` function, which supports exponents in `WAD`.  "}, {"title": "Follow Curve's convention: `_getYD` and `_getY`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/156", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In HybridPool.sol, functions `_getY` and `_getYD` are identical (only differences are variables' names), and only `_getY` is used in the contract.  Since these functions are supposed to mimic those of Curve, it would make more sense to follow their naming conventions. In particular, `_getYD` correctly mimics Curve's `_get_y_D` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L614)), while `_getY` does not mimic Curve's `_get_y` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L379)).  ## Recommended Mitigation Steps Consider eliminating `_getY` and using `_getYD` instead in the contract.  "}, {"title": "Using interfaces instead of selectors is best practice", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/150", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  tensors   # Vulnerability details  Throughout the code function selectors are often used instead of interfaces.  It is considered best practice to use interfaces instead of selectors for code readability.  "}, {"title": "Using 10**X for constants isn't gas efficient", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  tensors   # Vulnerability details  Constants of form 10**X can be rewritten as 1eX and this will save gas.  "}, {"title": "absolute difference is not calculated properly when a > b in MathUtils", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/139", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/libraries/MathUtils.sol#L22 the difference is computed incorrectly when a > b.  As it only used in within1 function, scope narrows down to where `difference(a, b) <= 1;` is exploitable.  cases where `difference(a, b) <= 1` should be true but is reported false: - where b = a-1 (returned value is type(uint256).max)  cases where `difference(a, b) <= 1` should be false but is reported true: - where a = type(uint256).max and b = 0, it returns 1 but it should ideally return type(uint256).max  within1 is used at the following locations: - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L359 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L383 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L413  It is possible to decrease the denominator and increase the value of the numerator (when calculating y) using constants and input to make within1 fail  Mitigation:  Add `else` condition to mitigate it.  ``` unchecked {           if (a > b) {               diff = a - b;           }           else {               diff = b - a;              }       } ```  (re-submitting this issue after withdrawing past one since I forgot to add more  details and POC)  "}, {"title": "Cache storage variable in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  WatchPug   # Vulnerability details  Cache storage variable in the stack can save gas.  For instance:  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L140-L155  `outRecord.reserve` is accessed 2 times.   https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L158-L179 https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L182-L205  `inRecord.reserve` is accessed 3 times.  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  https://github.com/sushiswap/trident/blob/master/contracts/TridentRouter.sol#L214-L234  - minWithdrawals.length - withdrawnLiquidity.length  https://github.com/sushiswap/trident/blob/master/contracts/TridentRouter.sol#L274  - tokenInput.length  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L114-L136  - tokens.length  "}, {"title": "Consider avoiding low level calls to MasterDeployer", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/121", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Consider avoiding low level calls to MasterDeployer  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L64)  The constructor uses low-level calls to the master deployer. It is more idiomatic to rely on high level solidity to deal with the calls. The difference would be additional checks on whether there is code at the specified address (additional `100` gas) and automatically performing the ABI decoding (may actually be more efficient than the manual implementation.) (Note that this call will still be `staticcall`, since `barFee` is a view function in the interface.)  Example:  ``` diff modified   contracts/pool/ConstantProductPool.sol @@ -61,7 +61,7 @@ contract ConstantProductPool is IPool, TridentERC20 {          require(_token1 != address(this), \"INVALID_TOKEN\");          require(_swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");  -        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector)); +        barFee = IMasterDeployer(_masterDeployer).barFee();          (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));          (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));  @@ -72,7 +72,6 @@ contract ConstantProductPool is IPool, TridentERC20 {          unchecked {              MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;          } -        barFee = abi.decode(_barFee, (uint256));          barFeeTo = abi.decode(_barFeeTo, (address));          bento = abi.decode(_bento, (address));          masterDeployer = _masterDeployer; ```   "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from `memory` to `calldata` may cause \"unimplemented feature error\". This can be avoided by using a newer (`0.8.*`) Solidity compiler.  ### Examples  ****Note****: The following pattern is prevalent in the codebase:  ``` solidity function f(bytes memory data) external {     (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to `bytes calldata` will decrease the gas. The total savings for this change across all such uses would be *quite significant.*  Examples:  ``` text ./contracts/examples/PoolFactory.sol:15:    function deployPool(bytes memory _deployData) external override returns (address) { ./contracts/examples/PoolTemplate.sol:12:    constructor(bytes memory _data) { ./contracts/flat/BentoBoxV1Flat.sol:603:    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) { ./contracts/pool/HybridPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/IndexPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/franchised/FranchisedConstantProductPool.sol:54:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/franchised/FranchisedHybridPool.sol:60:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/franchised/FranchisedIndexPool.sol:61:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/HybridPool.sol:60:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/ConstantProductPoolFactory.sol:13:    function deployPool(bytes memory _deployData) external returns (address pool) { ./contracts/pool/ConstantProductPool.sol:54:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/pool/IndexPool.sol:61:    constructor(bytes memory _deployData, address _masterDeployer) { ./contracts/utils/TridentHelper.sol:143:    function getSelector(bytes memory _data) internal pure returns (bytes4 sig) { ```  Other examples:  1.  <https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L174> 2.  <https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L218>   "}, {"title": " Consider putting some parts of `_div` in unchecked", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Consider putting some parts of `_div` in unchecked  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L335)  ``` diff modified   contracts/pool/IndexPool.sol @@ -332,7 +332,8 @@ contract IndexPool is IPool, TridentERC20 {       function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {          uint256 c0 = a * BASE; -        uint256 c1 = c0 + (b / 2); +        unchecked { uint256 tmp =  b / 2; } +        uint256 c1 = c0 + tmp;          c2 = c1 / b;      } ```  Looking at the optimized assembly generated, the unchecked version doesn't seem to have the additional check for division by zero. I'm not entirely sure why, but my guess is because of inlining. Also consider replacing the division by inline assembly.  ``` solidity uint tmp; assembly {     tmp := div(b, 2) } uint256 c1 = c0 + tmp; ```  The change avoids an `if` condition which checks if the divisor is zero, which the optimizer is currently unable to optimize out. The gas savings would be around 16 (reduces a `jumpi`, `push 0` and `dupN`). Since the `_div` function is called from throughout the code (also present in other contracts), this may be worth considering, although I admit this might be too much of a micro-optimization.   "}, {"title": "Caching a storage load in TridentERC20", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching a storage load in TridentERC20  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/TridentERC20.sol#L76)  This avoids an unnecessary `sload`.  ``` diff modified   contracts/pool/TridentERC20.sol @@ -73,8 +73,9 @@ abstract contract TridentERC20 {          address recipient,          uint256 amount      ) external returns (bool) { -        if (allowance[sender][msg.sender] != type(uint256).max) { -            allowance[sender][msg.sender] -= amount; +        uint _allowance = allowance[sender][msg.sender]; +        if (_allowance != type(uint256).max) { +            allowance[sender][msg.sender] = _allowance - amount;          }          balanceOf[sender] -= amount;          // @dev This is safe from overflow - the sum of all user ```   "}, {"title": "Caching the storage read to `tokens.length`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching the storage read to `tokens.length`  Ignoring the caching for the for-loop condition (see my other issue \"Caching the length in for loops\"), this would save an additional `sload`, around `100` gas.  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L129).  ``` diff modified   contracts/pool/IndexPool.sol @@ -121,12 +121,12 @@ contract IndexPool is IPool, TridentERC20 {          (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));           uint256 ratio = _div(toBurn, totalSupply); -        withdrawnAmounts = new TokenAmount[](tokens.length); +        uint length = tokens.length; +        withdrawnAmounts = new TokenAmount[](length);           _burn(address(this), toBurn);  -        for (uint256 i = 0; i < tokens.length; i++) { +        for (uint256 i = 0; i < length; i++) {              address tokenOut = tokens[i];              uint256 balance = records[tokenOut].reserve;              uint120 amountOut = uint120(_mul(ratio, balance)); ```   "}, {"title": "Caching the length in for loops", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching the length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is,  1.  if it is a `storage` array, this is an extra `sload` operation (100     additional extra gas     ([EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)) for each     iteration except for the first), 2.  if it is a `memory` array, this is an extra `mload` operation (3     additional gas for each iteration except for the first), 3.  if it is a `calldata` array, this is an extra `calldataload`     operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` or `calldataload` operation is only called once and subsequently replaced by a cheap `dupN` instruction. Even though `mload`, `calldataload` and `dupN` have the same gas cost, `mload` and `calldataload` needs an additional `pushX value` to put the offset in the stack, i.e., an extra 3 gas.  This optimization is especially important if it is a storage array or if it is a lengthy for loop. Note: this especially relevant for the IndexPool contract.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project. [Reference](https://forum.soliditylang.org/t/solidity-team-ama-2-on-wed-10th-of-march-2021/152/15?u=hrkrshnn).  ### Examples  ``` text ./contracts/flat/BentoBoxV1Flat.sol:626:        for (uint256 i = 0; i < calls.length; i++) { ./contracts/pool/PoolDeployer.sol:34:            for (uint256 i; i < tokens.length - 1; i++) { ./contracts/pool/PoolDeployer.sol:36:                for (uint256 j = i + 1; j < tokens.length; j++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:73:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:104:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:132:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/WhiteListManager.sol:105:        for (uint256 i = 0; i < merkleProof.length; i++) { ./contracts/pool/IndexPool.sol:71:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/IndexPool.sol:102:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/IndexPool.sol:129:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/utils/TridentHelper.sol:27:        for (uint256 i = 0; i < data.length; i++) { ./contracts/TridentRouter.sol:65:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:83:        for (uint256 i; i < path.length; i++) { ./contracts/TridentRouter.sol:123:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:139:        for (uint256 i; i < params.initialPath.length; i++) { ./contracts/TridentRouter.sol:149:        for (uint256 i; i < params.percentagePath.length; i++) { ./contracts/TridentRouter.sol:157:        for (uint256 i; i < params.output.length; i++) { ./contracts/TridentRouter.sol:181:        for (uint256 i; i < tokenInput.length; i++) { ./contracts/TridentRouter.sol:223:        for (uint256 i; i < minWithdrawals.length; i++) { ./contracts/TridentRouter.sol:225:            for (; j < withdrawnLiquidity.length; j++) { ./contracts/TridentRouter.sol:274:        for (uint256 i; i < tokenInput.length; i++) { ```   "}, {"title": "Gas: `HybridPool._computeLiquidityFromAdjustedBalances` should return early", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool._computeLiquidityFromAdjustedBalances` function should return early if `s == 0` as it will always return zero. Currently, it still performs an expensive loop iteration.  ```solidity if (s == 0) {   // gas: should do an early return here   computed = 0;   // return 0; } ```  ## Recommended Mitigation Steps Return early with a value of `0` if `s == 0`.   "}, {"title": "Gas: `HybridPool` unnecessary `balance` computations", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool.burn` function subtracts some computation from `balance0`/`balance1`, but the result is never used.  ```solidity balance0 -= _toShare(token0, amount0); balance1 -= _toShare(token1, amount1); ```  ## Recommended Mitigation Steps Unless it is used as an underflow check, the computation should be removed the result is not used.   "}, {"title": "`HybridPool`'s reserve is converted to \"amount\" twice", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/101", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool`'s reserves are stored as Bento \"amounts\" (not Bento shares) in `_updateReserves` because `_balance()` converts the current share balance to amount balances. However, when retrieving the `reserve0/1` storage fields in `_getReserves`, they are converted to amounts a second time.  ## Impact The `HybridPool` returns wrong reserves which affects all minting/burning and swap functions. They all return wrong results making the pool eventually economically exploitable or leading to users receiving less tokens than they should.  ## POC Imagine the current Bento amount / share price being `1.5`. The pool's Bento _share_ balance being `1000`. `_updateReserves` will store a reserve of `1.5 * 1000 = 1500`. When anyone trades using the `swap` function, `_getReserves()` is called and multiplies it by `1.5` again, leading to using a reserve of 2250 instead of 1500. A higher reserve for the output token leads to receiving more tokens as the swap output. Thus the pool lost tokens and the LPs suffer this loss.  ## Recommended Mitigation Steps Make sure that the reserves are in the correct amounts.   "}, {"title": "`HybridPool`'s `flashSwap` does not always call callback", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/100", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function skips the `tridentSwapCallback` callback call if `data.length == 0`.  ## Impact It should never skip the callback, otherwise the `flashSwap` function is useless. Note that this behavior of the `HybridPool` is not in alignment with the `flashSwap` behavior of all other pools that indeed always call the callback.  ## Recommended Mitigation Steps Always make the call to `ITridentCallee(msg.sender).tridentSwapCallback(data);`, regardless of the `data` variable.  "}, {"title": "`HybridPool`'s `flashSwap` sends entire fee to `barFeeTo`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function sends the entire trade fees `fee` to the `barFeeTo`. It should only send `barFee * fee` to the `barFeeTo` address.  ## Impact LPs are not getting paid at all when this function is used. There is no incentive to provide liquidity.  ## Recommended Mitigation Steps The `flashSwap` function should use the same fee mechanism as `swap` and only send `barFee * fee / MAX_FEE` to the `barFeeTo`. See `_handleFee` function.   "}, {"title": "`ConstantProductPool.burnSingle` swap amount computations should use balance", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/96", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.burnSingle` function is basically a `burn` followed by a `swap` and must therefore act the same way as calling these two functions sequentially.  The token amounts to redeem (`amount0`, `amount1`) are computed on the **balance** (not the reserve). However, the swap amount is then computed on the **reserves** and not the balance. The `burn` function would have updated the `reserve` to the balances and therefore `balance` should be used here:  ```solidity amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1); ```  > \u26a0\ufe0f The same issue occurs in the `HybridPool.burnSingle`.  ## Impact For a burn, usually the `reserve` should equal the `balance`, however if any new tokens are sent to the contract and `balance > reserve`, this function will return slightly less swap amounts.  ## Recommended Mitigation Steps Call `_getAmountOut` with the balances instead of the reserves: `_getAmountOut(amount0, balance0 - amount0, balance1 - amount1)`   "}, {"title": "`ConstantProductPool` mint liquidity computation should include fees", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/95", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConstantProductPool` computes optimal balanced LP using `_nonOptimalMintFee`, which performs something like a swap. The returned swap fees should be included in the \"`k`\" computation as `_handleFees` uses the growth in `k` to estimate the swap fees.  ```solidity // should not reduce fee0 and fee1 uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1)); ```  > \u26a0\ufe0f The same issue occurs in the `HybridPool.mint`.  ## Impact The non-optimal mint swap fees are not taken into account.  ## Recommended Mitigation Steps Compute `sqrt(k)` on the `balance0 * balance1` without deducting the swap fees.   "}, {"title": "`ConstantProductPool.getAmountOut` does not verify token", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/93", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.getAmountOut` function does not verify that `tokenIn == token1` in the `else` branch. This is done everywhere else though (see `swap` and `flashSwap`) and should be done here as well.  ## Impact The function can be called with a token that is not any of the pool tokens.  ## Recommended Mitigation Steps Add the missing check.  "}, {"title": "`withdrawFromWETH` always reverts ", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TridentHelper.withdrawFromWETH` (used in `TridentRouter.unwrapWETH`) function performs a low-level call to `WETH.withdraw(amount)`.  It then checks if the return `data` length is more or equal to `32` bytes, however `WETH.withdraw` returns `void` and has a return value of `0`. Thus, the function always reverts even if `success == true`.  ```solidity function withdrawFromWETH(uint256 amount) internal {     // @audit WETH.withdraw returns nothing, data.length always zero. this always reverts     require(success && data.length >= 32, \"WITHDRAW_FROM_WETH_FAILED\"); } ```  ## Impact The `unwrapWETH` function is broken and makes all transactions revert. Batch calls to the router cannot perform any unwrapping of WETH.  ## Recommended Mitigation Steps Remove the `data.length >= 32` from the require and only check if `success` is true.  "}, {"title": "IndexPool initial LP supply computation is wrong", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/78", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `IndexPool.constructor` function already mints `INIT_POOL_SUPPLY = 100 * 1e18 = 1e20` LP tokens to the zero address.  When trying to use the pool, someone has to provide the actual initial reserve tokens in `mint`. On the first `mint`, the pool reserves are zero and the token amount required to mint is just this `ratio` itself: `uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;`  Note that the `amountIn` is **independent of the token** which does not make much sense. This implies that all tokens must be provided in equal \"raw amounts\", regardless of their decimals and value.  ## POC #### Issue 1 Imagine I want to create a DAI/WBTC pool. If I want to initialize the pool with 100$ of DAI, `amountIn = ratio` needs to be `100*1e18=1e20` as DAI has 18 decimals. However, I now also need to supply `1e20` of WBTC (which has 8 decimals) and I'd need to pay `1e20/1e8 * priceOfBTC`, over a quadrillion dollars to match it with the 100$ of DAI.  #### Issue 2 Even in a pool where all tokens have the same decimals and the same value, like `USDC <> USDT`, it leads to issues: - Initial minter calls `mint` with `toMint = 1e20` which sets `ratio = 1e20 * 1e18 / 1e20 = 1e18` and thus `amountIn = 1e18` as well. The total supply increases to `2e20`. - Second minter needs to pay **less** tokens to receive the same amount of `1e18` LP tokens as the first minter. This should never be the case. `toMint = 1e20` => `ratio = 1e20 * 1e18 / 2e20 = 0.5e18`. Then `amountIn = ratio * reserve / 1e18 = 0.5*reserve = 0.5e18`. They only pay half of what the first LP provider had to pay.  ## Impact It's unclear why it's assumed that the pool's tokens are all in equal value - this is _not_ a StableSwap-like pool.  Any pool that uses tokens that don't have the same value and share the same decimals cannot be used because initial liquidity cannot be provided in an economically justifiable way.  It also leads to issues where the second LP supplier has to pay **less tokens** to receive the exact same amount of LP tokens that the initial minter receives. They can steal from the initial LP provider by burning these tokens again.  ## Recommended Mitigation Steps Do not mint the initial token supply to the zero address in the constructor.  Do it like Uniswap/Balancer and let the first liquidity provider provide arbitrary token amounts, then mint the initial pool supply. If `reserve == 0`, `amountIn` should just take the pool balances that were transferred to this account.  In case the initial mint to the zero address in the constructor was done to prevent the \"Uniswap-attack\" where the price of a single wei of LP token can be very high and price out LPs, send a small fraction of this initial LP supply (~1000) to the zero address **after** it was minted to the first supplier in `mint`.   "}, {"title": "Router would fail when adding liquidity to index Pool", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  TridentRouter is easy to fail when trying to provide liquidity to an index pool.  Users would not get extra lp if they are not providing lp at the pool's spot price. It's the same design as uniswap v2. However, uniswap's v2 handle's the dirty part.   [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76) Users would not lose tokens if they use the router.  However, the router wouldn't stop users from transferring extra tokens. [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  Second, the price would possibly change when the transaction is confirmed. This would be reverted in the index pool.   Users would either transfer extra tokens or fail. I consider this is a medium-risk issue.   ## Proof of Concept  [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  A possible scenario:  There's a BTC/USD pool. BTC = 50000 USD. 1. A user sends a transaction to transfer 1 BTC and 50000 USD. 2. After the user send a transaction, a random bot buying BTC with USD. 3. The transaction at step 1 is mined. Since the BTC price is not 50000 USD, the transaction fails.   ## Tools Used  None  ## Recommended Mitigation Steps  Please refer to the uniswap v2 router. [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)  The router should calculate the optimal parameters for users.    "}, {"title": "Unused constants could indicate missing logic or redundant code", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/43", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Constants MAX_FEE_SQUARE and E18 are declared but never used. Unused constants could indicate missing logic or redundant code. In this case, they are likely to be redundant code that can be removed.  ## Proof of Concept  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L25  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L26  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Evaluate the use of the declared constants or remove them.  "}, {"title": "ConstantProductPool: Unnecessary mod before casting to uint32", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  Gas optimisation. Casting something of uint256 to uint32 has the same effect as mod since it will wrap around when it overflows. You need to ensure that unchecked math is used otherwise it will revert.  ## Recommended Mitigation Steps  [Line 294 of ConstantProductPool.sol](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L294)  ```jsx function _update(         uint256 balance0,         uint256 balance1,         uint112 _reserve0,         uint112 _reserve1,         uint32 _blockTimestampLast     ) internal {         require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, \"OVERFLOW\");         if (blockTimestampLast == 0) {             // @dev TWAP support is disabled for gas efficiency.             reserve0 = uint112(balance0);             reserve1 = uint112(balance1);         } else {       unchecked { // changes starts here        uint32 blockTimestamp = uint32(block.timestamp);       } // changes end here             ...         }         emit Sync(balance0, balance1);     } ```  "}, {"title": "ConstantProductPool: Move minting of MIN_LIQUIDITY after checks", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/35", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  GreyArt   # Vulnerability details  ### Impact  L102: `_mint(address(0), MINIMUM_LIQUIDITY);` should be shifted after the if / else block to L110 because of further checks done in L106, and L108-L109.  This would help save gas should the checks mentioned fail.  ### Recommended Mitigation Steps  ```jsx if (msg.sender == migrator) {   liquidity = IMigrator(migrator).desiredLiquidity();   require(liquidity != 0 && liquidity != type(uint256).max, \"BAD_DESIRED_LIQUIDITY\"); } else {   require(migrator == address(0), \"ONLY_MIGRATOR\");   liquidity = computed - MINIMUM_LIQUIDITY; } _mint(address(0), MINIMUM_LIQUIDITY); ```  "}, {"title": "ConstantProductPool & HybridPool: Adding and removing unbalanced liquidity yields slightly more tokens than swap", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/34", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  GreyArt   # Vulnerability details  ### Impact  A mint fee is applied whenever unbalanced liquidity is added, because it is akin to swapping the excess token amount for the other token.  However, the current implementation distributes the minted fee to the minter as well (when he should be excluded). It therefore acts as a rebate of sorts.  As a result, it makes adding and removing liquidity as opposed to swapping directly (negligibly) more desirable. An example is given below using the Constant Product Pool to illustrate this point. The Hybrid pool exhibits similar behaviour.  ### Proof of Concept  1. Initialize the pool with ETH-USDC sushi pool amounts. As of the time of writing, there is roughly 53586.556 ETH and 165143020.5295 USDC. 2. Mint unbalanced LP with 5 ETH (& 0 USDC). This gives the user `138573488720892 / 1e18` LP tokens. 3. Burn the minted LP tokens, giving the user 2.4963 ETH and 7692.40 USDC. This is therefore equivalent to swapping 5 - 2.4963 = 2.5037 ETH for 7692.4044 USDC. 4. If the user were to swap the 2.5037 ETH directly, he would receive 7692.369221 (0.03 USDC lesser).  ### Recommended Mitigation Steps  The mint fee should be distributed to existing LPs first, by incrementing `_reserve0` and `_reserve1` with the fee amounts. The rest of the calculations follow after.  ConstantProductPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); unchecked {     _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply); } uint256 computed = TridentMath.sqrt(balance0 * balance1); ... kLast = computed; ```  HybridPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); uint256 newLiq = _computeLiquidity(balance0, balance1); ... ```  "}, {"title": "hybrid pool uses wrong `non_optimal_mint_fee`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/31", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  When an lp provider deposits an imbalance amount of token, a swap fee is applied. HybridPool uses the same `_nonOptimalMintFee` as `constantProductPool`; however, since two pools use different AMM curve, the ideal balance is not the same.  ref: [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  Stable swap Pools are designed for 1B+ TVL. Any issue related to pricing/fee is serious. I consider this is a high-risk issue  ## Proof of Concept  [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  [HybridPool.sol#L425-L441](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L425-L441)  ## Tools Used  None  ## Recommended Mitigation Steps Calculate the swapping fee based on the stable swap curve. Please refer to [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337).  "}, {"title": "IndexPool pow overflows when `weightRatio` > 10.", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/28", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  In the IndexPool contract, pow is used in calculating price. [IndexPool.sol#L255-L266](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L255-L266) However, Pow is easy to cause overflow. If the `weightRatio` is large (e.g. 10), there's always overflow.  Lp providers can still provide liquidity to the pool where no one can swap. All pools need to redeploy. I consider this a high-risk issue.   ## Proof of concept  It's easy to trigger this bug by deploying a 1:10 IndexPool.  ```python     deployed_code = encode_abi([\"address[]\",\"uint136[]\",\"uint256\"], [         (link.address, dai.address),         (10**18, 10 * 10**18),         10**13     ])     tx_hash = master_deployer.functions.deployPool(index_pool_factory.address, deployed_code).transact() ```  Transactions would be reverted when buying `link` with `dai`. ## Tools Used  None  ## Recommended Mitigation Steps  The `weightRatio` is an 18 decimals number. It should be divided by `(BASE)^exp`. The scale in the contract is not consistent. Recommend the dev to check all the scales/ decimals.   "}, {"title": "Use parameter _blockTimestampLast in _update() ", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _update() of ConstantProductPool.sol verifies if blockTimestampLast == 0. The value of blockTimestampLast is also passed in the parameter _blockTimestampLast  (note: with extra _ ) So _blockTimestampLast could also be used, which saves a bit of gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/master/contracts/pool/ConstantProductPool.sol#L264  function _update(...        uint32 _blockTimestampLast) internal {         ...         if (blockTimestampLast == 0) {    // could also use _blockTimestampLast  ## Tools Used  ## Recommended Mitigation Steps replace    if (blockTimestampLast == 0) {    with    if (_blockTimestampLast == 0) {      "}, {"title": "`tokens[i]` can be memorized", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In `StablesConverter.convert` there are multiple storage reads of `tokens[i]` that add up gas. Consider saving the variable in memory.   ## Tools Used editor  ## Recommended Mitigation Steps Rewrite  ```js IERC20 _token;    // add this for (uint8 i = 0; i < 3; i++) {  _token = tokens[i];  // add this     //if (_output == address(tokens[i])) {     if (_output == address(_token)) {         //uint256 _before = tokens[i].balanceOf(address(this));         uint256 _before = _token.balanceOf(address(this));         stableSwap3Pool.remove_liquidity_one_coin(             _inputAmount,             i,             _estimatedOutput         );         //uint256 _after = tokens[i].balanceOf(address(this));         uint256 _after = _token.balanceOf(address(this));         _outputAmount = _after.sub(_before);         //tokens[i].safeTransfer(msg.sender, _outputAmount);         _token.safeTransfer(msg.sender, _outputAmount);         return _outputAmount;     } } ```  "}, {"title": "Unnecessary `balanceOfWant() > 0`", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact During the `_harvest` function in NativeStrategyCurve3Crv.sol, there's a call to `_deposit()` only `if (balanceOfWant() > 0)`. This if-statement can be removed since `_deposit` calculates again `balanceOfWant()` and makes the same check. This way the function saves a `.balanceOf` call.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L123  ## Tools Used editor  "}, {"title": "`getMostPremium()` can be wrong", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed", "disagree with severity"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact `NativeStrategyCurve3Crv._harvest` calls `getMostPremium` to get the best stablecoin to convert to. This function however is wrong in the case of `balancesUSDC = balancesUSDT < balancesDAI`, because it returns DAI, when it should be USDC or USDT. This is naturally a rare occasion, but a bad actor can set the balances (by depositing/withdrawing the Curve pool) like this just before the harvest function is called. Since this would imbalance even more the pool, the bad actor could also gain a profit by making the right swaps after the harvest.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L83  ## Tools Used editor  ## Recommended Mitigation Steps Convert all `<` into `<=` inside `getMostPremium()`.  "}, {"title": "Earn process emits two events that can be arranged into one", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/138", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The harvester can initiate the earn process by calling the `Vault.earn`. At the end of this function an `Earn(_token, _balance)` event is emitted. Before this, the execution is passed to the `Controller.earn` function, which emits another event `Earn(_token, _strategy)`. Since these two events are emitted _always_ together (`Controller.earn` can be called only inside `Vault.earn`), it's more efficient to emit a single event `Earn(_token, _strategy, _amount)` at the end of `Controller.earn`. This should gain a little gas (one less indexed data) and it's less confusing.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L437 https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L157  ## Tools Used editor  "}, {"title": "Gas: Timestamp in router swap can be hardcoded", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  cmichel   # Vulnerability details  When doing swaps with a Uniswap router from within a contract, there's no need to compute any offset from the current block for the `deadline` parameter. The router just checks if `deadline >= block.timestamp`.  See `BaseStrategy._swapTokens` which does an unnecessary `block.timestamp` read and another unnecessary addition of `1800`.  ## Recommended Mitigation Steps The most efficient way to provide deadlines for a router swap is to use a hardcoded value that is far in the future, for example, `1e10`.   "}, {"title": "Withdraw event uses wrong parameter", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/122", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Withdraw` event in `LegacyController.withdraw` emits the `_amount` variable which is the _initial, desired_ amount to withdraw. It should emit the actual withdrawn amount instead, which is transferred in the last `token.balanceOf(address(this))` call.  ## Impact The actual withdrawn amount, which can be lower than `_amount`, is part of the event. This is usually not what you want (and it can already be decoded from the function argument).  ## Recommended Mitigation Steps Use it or remove it.   "}, {"title": "Join _checkToken function and modifier together", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _checkToken can be moved to modifier checkToken as it is a private function that is only used by this modifier. This will reduce the number of extra calls and thus reduce the gas.  ## Recommended Mitigation Steps Consider moving this function inside the modifier to reduce gas usage.  "}, {"title": "VaultHelper could validate that amount is greater than 0", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions depositVault, depositMultipleVault and withdrawVault in VaultHelper could require _amount > 0 to prevent useless transfers.  ## Recommended Mitigation Steps Add require _amount > 0 statements to mentioned functions.  "}, {"title": "Decimals of upgradeable tokens may change", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact A theoretical issue is that the decimals of USDC may change as they use an upgradeable contract so you cannot assume that it stays 6 decimals forever:   balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC  ## Recommended Mitigation Steps A simple solution would be to call .decimals() on token contract to query it on the go. Then you will not need to hardcode it but gas usage will increase.  "}, {"title": "setMinter should check that _minter is not empty", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/81", "labels": ["bug", "sponsor acknowledged", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setMinter should validate that _minter is not an empty (0x0) address.  ## Recommended Mitigation Steps require(_minter != address(0), \"!_minter\");  "}, {"title": "Vault: Redundant notHalted modifier in depositMultiple()", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `notHalted` modifier in `depositMultiple()` is redundant because it is checked (multiple times) by the underlying function call to `deposit()`.  Further optimizations may be done to implement an internal `_deposit()` function that will be called by both `deposit()` and `depositMultiple()` so that `notHalted` is only checked once.  ### Recommended Mitigation Steps  Remove the `notHalted` modifier in `depositMultiple()`.  "}, {"title": "Harvester: Simpler implementation for canHarvest()", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  The negation of the disjunction form of the `canHarvest()` function will help save gas. In other words, instead of `!(A || B)`, return `(!A && !B)`.  ```jsx function canHarvest(  address _vault )   public   view   returns (bool) {   Strategy storage strategy = strategies[_vault];   // only can harvest if there are strategies, and when sufficient time has elapsed   // solhint-disable-next-line not-rely-on-time  return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout)); } ```  "}, {"title": "Controller: Extra sload of _vaultDetails[_vault].balance", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `_vaultDetails[_vault].balance` in L367 can be changed to the already fetched value `_balance`.  ### Recommended Mitigation Steps  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_amount);`  "}, {"title": "safeApprove may revert for non-zero to non-zero approvals", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact\u2028 OpenZeppelin\u2019s safeApprove reverts for non-0 to non-0 approvals. This is considered in a few places where safeApprove is performed twice with the first one for 0 and then for the desired allowance. However, there are uses of safeApprove where it is called only once for the desired allowance but it is not clear that the current allowance is guaranteed to be zero. In such cases, safeApprove may revert.  ## Proof of Concept  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6241995ad323952e38f8d405103ed994a2dcde8e/contracts/token/ERC20/utils/SafeERC20.sol#L49-L55  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/converters/StablesConverter.sol#L78  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/strategies/BaseStrategy.sol#L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Approve to 0 first while using safeApprove or use increaseAllowance instead.  "}, {"title": "manager.allowedVaults check missing for add/remove strategy", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact The manager.allowedVaults check is missing for add/remove strategy like how it is used in reorderStrategies(). This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.  Given the critical access control that is missing on vaults here, this is classified as medium severity.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L101-L130  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L172-L207  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L224  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L210-L221   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add manager.allowedVaults check in addStrategy() and removeStrategy()  "}, {"title": "Unused event may be unused code or indicative of missed emit/logic", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/49", "labels": ["bug", "sponsor acknowledged", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Events that are declared but not used may be indicative of unused declarations where it makes sense to remove them for better readability/maintainability/auditability, or worse indicative of a missing emit which is bad for monitoring or missing logic that would have emitted that event.  Event InsuranceClaimed is missing an emit.  Event ControllerSet is missing an emit.  Event VaultManagerSet is missing an emit.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L56  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L44  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L72  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emit or remove event declaration.  "}, {"title": "Rearranging declaration of state variables will save storage slots because of packing", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Storage slots are allocated based on the declaration order of state variables in contract definitions. For types less than 256 bits, they can be packed by the compiler if more than one fit into the same 32B storage slot. This reduces the number of storage slots but may increase runtime gas consumption because of masking the other shared variables in slot. However, if variables used together in function logic are packed in the same slot, it allows the compiler to optimize SLOADs/SSTOREs.  Example: An example of this is the declaration of the halted boolean state variable. Given the current declaration order, this occupies a full slot because booleans are internally represented by uint8 and the neighbouring declarations are uint256 which need a full slot for themselves.  Moving the halted bool next to governance address variable declaration will allow those two to share a slot. This reduces one slot and also should not incur extra masking gas overhead at runtime because governor and halted are used in onlyGovernance and notHalted modifiers respectively which are typically used together.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L33-L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move halted declaration to immediately after governance declaration. Also, consider the declaration order of all state variables across contracts for such packing possibilities.  "}, {"title": "missing safety check in addStrategy", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in controller's `addStrategy`. When the same strategy is added to a vault twice, the protocol breakdowns in several ways.   1. Removing that strategy would always raise errors. 2. `_vaultDetails[_vault].balances[_strategy]` would not track strategy's balance correctly; `getBestStrategyWithdraw` would have a wrong answer and makes withdrawing from the strategy to raise error in certain scenarios.  I consider this a low-risk issue.  ## Proof of Concept This is the web3.py script: ```python controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact() controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact()  # would not be able to removestrategy controller.functions.removeStrategy(vault.address, strategy.address, 0).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps  The controller should raise an error if the strategy has been added to the protocol(any vault). As adding the same strategy to two different vaults would have worse results, the controller can maintain a map to record each strategy's status.  "}, {"title": "extra array length check in depositMultipleVault ", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function depositMultipleVault of VaultHelper doesn't check the array size of _tokens and _amounts are the same length. In previous version of solidity there were bugs with giving an enormous large array to a function which accepted memory arrays.  Although depositMultipleVault uses calldata arrays, it is probably better to add a check on the length.  On the other hand the function depositMultiple of Vault.sol does check it.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/VaultHelper.sol#L57 ```JS  function depositMultipleVault(         address _vault,         address[] calldata _tokens,         uint256[] calldata _amounts     )  external {         for (uint8 i = 0; i < _amounts.length; i++) {         ... ```  https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L188 ```JS  function depositMultiple(         address[] calldata _tokens,         uint256[] calldata _amounts     )  external override notHalted returns (uint256 _shares) {         require(_tokens.length == _amounts.length, \"!length\");          for (uint8 i; i < _amounts.length; i++) {            ...  ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following in depositMultipleVault:    require(_tokens.length == _amounts.length, \"!length\");  "}, {"title": "Harvesting and Funding Is Not Checked When the Contract Is Halted", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that harvesting and fundings progress is not checked when the contract is halted. This can cause misfunctionality and locking user funds during the halt progress.  ## Proof of Concept  1-) Navigate to \"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol\" contract. 2-) Observe the following code on the Controller.sol.  Functions earn and HarvestStrategy ```     function harvestStrategy(address _strategy,uint256 _estimatedWETH,uint256 _estimatedYAXIS)         external         override         onlyHarvester         onlyStrategy(_strategy)              function earn(         address _strategy,         address _token,         uint256 _amount     )         external         override         onlyStrategy(_strategy)         onlyVault(_token)  ```  ## Tools Used  None   ## Recommended Mitigation Steps  Implement the notHalt modifier into the functions. Only withdraw functions should be allowed on the contract.   "}, {"title": "removeToken would break the vault/protocol.", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/4", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## removeToken would break the vault.   ## Impact There's no safety check in Manager.sol's removeToken. [Manager.sol#L454-L487](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L454-L487) 1. The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost. 2. Controller's balanceOf would no longer reflects the real value. [Controller.sol#L488-L495](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L488-L495) While `_vaultDetails[msg.sender].balance;` remains the same, user can nolonger withdraw those amount. 3. Share price in the vault would decrease drastically. The share price is calculated as `totalValue / totalSupply` [Vault.sol#L217](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217). While the `totalSupply` of the share remains the same, the total balance has drastically decreased.  Calling removeToken way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.   ## Proof of Concept  We can see how the vault would be affected with below web3.py script. ```python print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) manager.functions.removeToken(vault.address, dai.address).transact() print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) ```  output ``` 100000000000000000000000 100000000000000000000000 0 100000000000000000000000 ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps Remove tokens from a vault would be a really critical job. I recommend the team cover all possible cases and check all components' states (all vault/ strategy/ controller's state) in the test.   Some steps that I try to come up with that is required to remove TokenA from a vault.  1. Withdraw all tokenA from all strategies (and handle it correctly in the controller).  2. Withdraw all tokenA from the vault.  3. Convert all tokenA that's collected in the previous step into tokenB.  4. Transfer tokenB to the vault and compensate the transaction fee/slippage cost to the vault.    "}, {"title": "No safety check in addToken", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/3", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in `Manager.sol` `addToken`. There are two possible cases that might happen. 1. One token being added twice in a Vault. Token would be counted doubly in the vault. Ref: [Vault.sol#L293-L303](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303). There would be two item in the array when querying `manager.getTokens(address(this));`.  2. A token first being added to two vaults. The value calculation of the first vault would be broken. As `vaults[_token] = _vault;` would point to the other vault.  Permission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there's likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.   ## Proof of Concept Adding same token twice would not raise any error here. ``` manager.functions.addToken(vault.address, dai.address).transact() manager.functions.addToken(vault.address, dai.address).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps I recommend to add two checks ```solidity require(vaults[_token] == address(0)); bool notFound = True; for(uint256 i; i < tokens[_vault].length; i++) {     if (tokens[_vault] == _token) {         notFound = False;     } } require(notFound, \"duplicate token\"); ```  "}, {"title": " set cap breaks vault's Balance", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/1", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact In controller.sol's function `setCap`, the contract wrongly handles `_vaultDetails[_vault].balance`. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);`  This would result in `vaultDetails[_vault].balance` being far smaller than the strategy's value. A user would trigger the assertion at [Contreller.sol#475](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L475) and the fund would be locked in the strategy.  Though `setCap` is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.  ## Proof of Concept We can trigger the issue by setting the cap 1 wei smaller than the strategy's balance.   ```python strategy_balance = strategy.functions.balanceOf().call() controller.functions.setCap(vault.address, strategy.address, strategy_balance - 1, dai.address).transact()  ## this would be reverted vault.functions.withdrawAll(dai.address).transact() ```   [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  ## Tools Used Hardhat  ## Recommended Mitigation Steps  I believe the dev would spot the issue in the test if `_vaultDetails[_vault].balance` is a public variable.  One possile fix is to subtract the difference of the balance. ```solidity uint previousBalance = IStrategy(_strategy).balanceOf(); _vaultDetails[_vault].balance.sub(previousBalance.sub(_amount)); ```   "}, {"title": "lack of emission of events while setting fees ", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact setWithdrawalFee(), setPerformanceFeeStrategist()  has no event, so it is difficult to track off-chain changes in the fee   ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/deps/BaseStrategy.sol#L126  ## Tools Used manual review  ## Recommended Mitigation Steps add event to above function  "}, {"title": "`CvxLocker.setBoost` wrong validation", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setBoost` function does not validate the `_max, _rate` parameters, instead it validates the already set **storage** variables.  ```solidity // @audit this is checking the already-set storage variables, not the parameters require(maximumBoostPayment < 1500, \"over max payment\"); //max 15% require(boostRate < 30000, \"over max rate\"); //max 3x ```  ## Impact Once wrong boost values are set (which are not validated when they are set), they cannot be set to new values anymore, breaking core contract functionality.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_max < 1500, \"over max payment\"); //max 15% require(_rate < 30000, \"over max rate\"); //max 3x ```   "}, {"title": "`CvxLocker.setStakeLimits` missing validation", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setStakeLimits` function does not check `_minimum <= _maximum`.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_minimum <= _maximum, \"min range\"); require(_maximum <= denominator, \"max range\"); ```  "}, {"title": "`veCVXStrategy.manualRebalance` has wrong logic", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/47", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `veCVXStrategy.manualRebalance` function computes two ratios `currentLockRatio` and `newLockRatio` and compares them.  However, these ratios compute different things and are not comparable: - `currentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance)` is a **percentage value** with 18 decimals (i.e. `1e18 = 100%`). Its max value can at most be `1e18`. - `newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS)` is a **CVX token amount**. It's unbounded and just depends on the `totalCVXBalance` amount.  The comparison that follows does not make sense:  ```solidity if (newLockRatio <= currentLockRatio) {   // ... } ```  ## Impact The rebalancing is broken and does not correctly rebalance. It usually leads to locking nearly everything if `totalCVXBalance` is high.  ## Recommended Mitigation Steps Judging from the `cvxToLock = newLockRatio.sub(currentLockRatio)` it seems the desired computation is that the \"ratios\" should actually be in CVX amounts and not in percentages. Therefore, `currentLockRatio` should just be `balanceInLock`. (The variables should be renamed as they aren't really ratios but absolute CVX balance amounts.)   "}, {"title": "Unused event `veCVXStrategy.Debug`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Debug` event in `veCVXStrategy` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  "}, {"title": "Unused event `StrategyCvxHelper.TendState`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TendState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   "}, {"title": "Unused event `StrategyCvxHelper.HarvestState`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/41", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `HarvestState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   "}, {"title": "veCVXStrategy: Sub-optimal trading path", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `_swapcvxCRVToWant()` swaps `cvxCRV -> ETH -> CVX` via sushiswap.  Looking at sushiswap analytics, this may also not be the most optimal trading path. The cvxCRV-CRV pool seems to have substantially better liquidity than the cvxCRV-ETH pool as r[eported here](https://www.notion.so/6a2dc64a1969e19c23e4f579f9810aa7) (Note that cvxCRV-CRV's liquidity is overstated, [clicking into the pool](https://www.notion.so/a2a8a54062e021873bcaee006cdf4007) gives a more reasonable amount). It is therefore better to do `cvxCRV -> CRV -> ETH -> CVX`, though this comes at the cost of higher gas usage.  ### Recommended Mitigation Steps  Switch the trading path to `cvxCRV -> CRV -> ETH -> CVX`, as it means more CVX tokens received, translating to higher APY, while the higher gas cost is borne by the caller.  Additionally, given how liquidity can shift between pools over time, the most optimal trade path may change accordingly. Hence, it may be beneficial to make the pool path configurable.  "}, {"title": "veCVXStrategy: Extra functions can be external instead of public", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `setWithdrawalSafetyCheck()`, `setHarvestOnRebalance()`, `setProcessLocksOnReinvest()` and `setProcessLocksOnRebalance()` functions are unused internally but have `public` visibility. Their visibility can be changed to `external`.  "}, {"title": "veCVXStrategy: Erroneous Comments", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  - L211: `// We receive bCVX -> Convert to bCVX` \u2192 `We receive bCVX -> Convert to CVX` - L443: `/// @notice toLock = 100, lock everything (CVX) you have` \u2192 `/// @notice toLock = MAX_BPS, lock everything (CVX) you have` since MAX_BPS (10_000) is the base used  "}, {"title": "StrategyCvxHelper: safeApprove instead of approve", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  This was probably an oversight since  - the veCVXStrategy contract used `safeApprove()` for token approvals - `using SafeERC20Upgradeable for IERC20Upgradeable;` was declared  ### Recommended Mitigation Steps  Change  `cvxToken.approve(address(cvxRewardsPool), MAX_UINT_256);`  to  `cvxToken.safeApprove(address(cvxRewardsPool), MAX_UINT_256);`  "}, {"title": "Delete function setKeepReward", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact even the comment says it, delete to save some gas:     /// @notice Delete if you don't need!     function setKeepReward(uint256 _setKeepReward) external {         _onlyGovernance();     }   "}, {"title": "public functions that can be external", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions setWithdrawalSafetyCheck, setHarvestOnRebalance, setProcessLocksOnReinvest, and setProcessLocksOnRebalance are public but can be external as they are only supposed to be invoked from the outside.   "}, {"title": "tend() can be simplified", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact because function tend() always reverts, you can remove authorization checks and modifiers to save some gas.   "}, {"title": "Immutable variables", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Variables that do not change can be marked as immutable. This greatly reduces gas cots. Examples of such variables are:   ICvxLocker public LOCKER;   uint256 MAX_BPS = 10_000;   address public lpComponent;   address public reward;   "}, {"title": "_processPerformanceFees is useless now", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _processPerformanceFees is not used. functions _processPerformanceFees and _processRewardsFees are way too similar. _processPerformanceFees can be eliminated and _processRewardsFees used by passing want as a _token parameter.  "}, {"title": "Functions not returning declared values", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function withdrawAll in BaseStrategy declares 'returns (uint256 balance)', however, no actual value is returned. function reinvest in MyStrategy declares to return 'uint256 reinvested', however, it also actually does not return anything so they always get assigned a default value of 0.  ## Recommended Mitigation Steps Either remove the return declarations or return the intended values. Otherwise, it may confuse other protocols that later may want to integrate with you.  "}, {"title": "The comments incorrectly indicate the range in which `toLock` input should be given.", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The input `toLock` in the `manualRebalance` function should in terms of BPS else `toLock` should be changed accordingly in the function. The comments incorrectly indicate the range in which the input `toLock` should be given. https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L443  ## Recommended Mitigation Steps In the comments `toLock` should be = 10_000 as we are comparing with `MAX_BPS` https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L446  "}, {"title": "Declare CvxLocker erc20 contract variables as immutable", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  patitonar   # Vulnerability details  ## Impact Gas optimization to store variables as immutable instead of storage similar to `_decimals`  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/locker/CvxLocker.sol#L112-L114  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare as following: string private immutable _name; string private immutable _symbol;   "}, {"title": "Make variable veCVXStrategy::MAX_BPS constant", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `MAX_BPS` in the veCVXStrategy is never reset after initialization. Declaring it as a constant saves gas.  ## Tools Used slither  "}, {"title": "Faulty return value in veCVXStrategy::reinvest()", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `reinvest` in the veCVXStrategy always returns 0 as the return variable `reinvested` is never updated.  The function is `onlyGovernance` and the return value probably does not matter if the caller is a multi-sig. However, if a protocol is set as `onlyGovernance` the faulty return value would have to be ignored by the caller to not transition into an incorrect state.  ## Proof of Concept The variable `reinvested` is declared as return variable (line 400) but not updated to reflect the actual amount reinvested which is saved in variable `toDeposit`.  Therefore always the default value is returned (0).  Link: https://github.com/code-423n4/2021-09-bvecvx/blob/32ecfd005d421f29c3846f4609fec33eaad388b9/veCVX/contracts/veCVXStrategy.sol#L400  ## Recommended Mitigation Steps  Add `reinvested = toDeposit;` after line 412.  "}, {"title": "ManualRebalance will be frontrun for most of the tokens.", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/5", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact We have previously seen that the harvest function can be exploited for almost all the tokens at stake. Since ManualRebalance calls harvest, it is also unsafe and funds swapped using it will likely be lost.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L444-L453  ## Recommended Mitigation Steps Adding an amount out minimum here will work that should be passed on to the harvest method.  "}, {"title": "Don't include unused functions", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact The code includes unused functions, like tend(), L319. It's best practice to remove these. It will also save gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L319  ## Recommended Mitigation Steps Remove the unused function.  "}, {"title": "setKeepReward function is unfinished", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/1", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact The setKeepReward function is unfinished.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L203  ## Recommended Mitigation Steps Either complete the function or follow the comment above the code and remove it.  "}, {"title": "Inaccurate Revert Message", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `_decreaseUserTwab()` function is used to decrease an account's TWAB balance when Ticket tokens are transferred between users or delegated to other users. If the amount to decrease exceeds the account's TWAB balance, the function will revert. However, this message does not fully reflect the function's behaviour.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L364  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the aforementioned revert message to correctly the function behaviour instead of a generic message.  "}, {"title": "`PrizePool.awardExternalERC721()` Erroneously Emits Events", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `awardExternalERC721()` function uses solidity's try and catch statement to ensure a single tokenId cannot deny function execution. If the try statement fails, an `ErrorAwardingExternalERC721` event is emitted with the relevant error, however, the failed tokenId is not removed from the list of tokenIds emitted at the end of function execution. As a result, the `AwardedExternalERC721` is emitted with the entire list of tokenIds, regardless of failure.  An off-chain script or user could therefore be tricked into thinking an ERC721 tokenId was successfully awarded.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L250-L270  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider emitting only successfully transferred tokenIds in the `AwardedExternalERC721` event.  "}, {"title": "Comment Typos", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/59", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  There are a couple of typos found within the `Reserve.sol` contract.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L20 https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L21  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the typo in `Reserve.sol:L20` from `speicific` to `specific` and the typo in `Reserve.sol:L21` from `determininstially` to `deterministically`.  "}, {"title": "`YieldSourcePrizePool._canAwardExternal()` Does Not Prevent the Deposit Token From Being Withdrawn", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/58", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `_canAwardExternal()` function is used to prevent the `onlyPrizeStrategy` role from moving a yield source's deposit tokens. However, the `YieldSourcePrizePool.sol` contract only restricts the movement of tokens from the `yieldSource` address instead of the actual deposit token. As a result, the `onlyOwner` role could escalate its role by calling `PrizePool.setPrizeStrategy()` and setting the prize strategy to its own address. Once it has taken over this role, they could effectively transfer out the yield source's deposit tokens, thereby draining the contract.   This is in direct contrast to PoolTogether's ethos, whereby their docs state that the multisig account used to represent the `onlyOwner` role has no custody over deposited assets.  ## Proof of Concept  https://v4.docs.pooltogether.com/protocol/reference/launch-architecture#progressive-decentralization https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/YieldSourcePrizePool.sol#L55-L57 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L329-L343 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L228-L236 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L300-L302  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the `YieldSourcePrizePool._canAwardExternal()` function to restrict the prize strategy from withdrawing `yieldSource.depositToken()` instead.  "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/52", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * function controllerBurnFrom could also skip _approve decrease if the current approval is uint max (unlimited).  * hardcoded number 1000 in PrizeSplit could be extracted to a constant variable to improve readability and maintainability.  "}, {"title": "unchecked arithmetics", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact You can save some gas by using the 'unchecked' keyword to avoid redundant arithmetic checks when an underflow/overflow cannot happen. For example, here:   while (_prizeSplits.length > newPrizeSplitsLength) {     uint256 _index = _prizeSplits.length - 1; or here:         require(_accountDetails.balance >= _amount, _revertMessage);         ...         accountDetails.balance = _accountDetails.balance - _amount;  ## Recommended Mitigation Steps Consider applying 'unchecked' keyword where overflows/underflows are not possible.  "}, {"title": "Unnecessary imports", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/50", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "disagree with severity", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are imports that are not necessary. They will increase the size of deployment with no real benefit. Consider removing them to save some gas.  Examples of such imports are: in contract DrawBuffer imported twice: import \"./interfaces/IDrawBeacon.sol\";  in contract DrawCalculator: import \"./libraries/DrawRingBufferLib.sol\"; import \"./PrizeDistributor.sol\";  in contract PrizeDistributor: import \"./interfaces/IDrawBeacon.sol\";  ## Recommended Mitigation Steps Consider removing imports that are not actually used in the contract.  "}, {"title": "function _getPrizeSplitAmount can be refactored", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact If you want to save some gas you can get rid of _getPrizeSplitAmount and calculate the split directly in _distributePrizeSplits as this function is internal and is only called once so there is no actual need for reusability here and removing this extra call will make the execution cheaper.  ## Recommended Mitigation Steps Consider moving the logic of _getPrizeSplitAmount  directly to _distributePrizeSplits.  "}, {"title": "Immutable variables", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact 'immutable' greatly reduces gas costs. There are variables that do not change so they can be marked as immutable to greatly improve the gas costs.  Examples of such variables are:  yieldSource in YieldSourcePrizePool.  prizePool in PrizeSplitStrategy.  controller in ControlledToken.  ## Recommended Mitigation Steps Consider applying immutable keyword to the variables that are assigned only once.  "}, {"title": "staticcall may return true for an invalid _yieldSource", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Low-level calls like staticcall return true even if the account called is non-existent (per EVM design) so this hack in YieldSourcePrizePool constructor will not work in certain cases:         // A hack to determine whether it's an actual yield source         (bool succeeded, ) = address(_yieldSource).staticcall(             abi.encodePacked(_yieldSource.depositToken.selector)         );  You can try to pass an EOA address and see that it will return true.  ## Recommended Mitigation Steps Account existence must be checked prior to calling. A similar issue was submitted in a previous contest and assigned a severity of low, you can find more details here: https://github.com/code-423n4/2021-04-basedloans-findings/issues/16  "}, {"title": "calculateNextBeaconPeriodStartTime casts timestamp to uint64", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function calculateNextBeaconPeriodStartTime accepts _time as a type of uint256 but later explicitly casts it to uint64. While this function is not used internally, it behaves incorrectly when passed a value that uint64 does not hold (for such values it will return a max value of uint64). I don't see a reason why you can't directly accept uint64 here.  ## Recommended Mitigation Steps Change parameter type to uint64.  "}, {"title": "`PrizeSplit.sol#_totalPrizeSplitPercentageAmount()` Avoid unnecessary copy from storage to memory can save gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplit.sol#L135-L136  ```solidity PrizeSplitConfig memory split = _prizeSplits[index]; _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  Only `percentage` of the `PrizeSplitConfig` struct is accessed, however, the current implementation created a memory variable that will load `_prizeSplits[index]` and copy to memory, this is unnecessary and gas inefficient.  ### Recommendation  Change to:  ```solidity _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  ## Adding unchecked directive can save gas  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. `PrizePool.sol#award()`  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L210-L225  ```solidity function award(address _to, uint256 _amount) external override onlyPrizeStrategy {     if (_amount == 0) {         return;     }      uint256 currentAwardBalance = _currentAwardBalance;      require(_amount <= currentAwardBalance, \"PrizePool/award-exceeds-avail\");     _currentAwardBalance = currentAwardBalance - _amount;      ITicket _ticket = ticket;      _mint(_to, _amount, _ticket);      emit Awarded(_to, _ticket, _amount); } ```  `currentAwardBalance - _amount;` will never underflow.   2. `PrizeDistributor.sol#claim()`  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/PrizeDistributor.sol#L74-L77  ```solidity if (payout > oldPayout) {     payoutDiff = payout - oldPayout;     _setDrawPayoutBalanceOf(_user, drawId, payout); } ```  `payout - oldPayout` will never underflow.  "}, {"title": "`PrizePool.sol#_canDeposit()` Remove redundant code can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L361-L368  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {     ITicket _ticket = ticket;     uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (_ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  `ITicket _ticket = ticket;` is redundant, removing it will also avoid a `sload` if returned when `_balanceCap == type(uint256).max`.  ### Recommendation  Change to:  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {      uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  "}, {"title": "`PrizePool.sol#setTicket()` Remove unnecessary variable can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L284-L297  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     address _ticketAddress = address(_ticket);      require(_ticketAddress != address(0), \"PrizePool/ticket-not-zero-address\"); ... ```  `_ticketAddress` is unnecessary as it's being used only once.  ### Recommendation  Change to:  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     require(address(_ticket) != address(0), \"PrizePool/ticket-not-zero-address\"); ... ```  "}, {"title": "`PrizeSplit.sol#distribute()` The value of the event parameter is wrong", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplitStrategy.sol#L51-L61  ```solidity function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      _distributePrizeSplits(prize);      emit Distributed(prize);      return prize; } ```  Based on the context, the value of the parameter of the `Distributed` event should be the distributed prize amount, which can be calculated based on the return value of `_distributePrizeSplits`.  ### Recommendation  Change to:  ```solidity  event Distributed(uint256 totalPrizeCaptured, uint256 totalPrizeDistributed);  function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      uint remainingPrize = _distributePrizeSplits(prize);      emit Distributed(prize, prize - remainingPrize);      return prize; } ```  "}, {"title": "The formula of number of prizes for a degree is wrong", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/33", "labels": ["bug", "sponsor confirmed", "3 (High Risk)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  The formula of the number of prizes for a degree per the document: https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizes is: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) - (2^bit range)^(degree-2) - ... ``` Should be changed to: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) ``` or ``` Number of prizes for a degree = 2^(bit range * degree) - 2^(bit range * (degree-1)) ```  ### Impact  Per the document:  > prize for a degree = total prize * degree percentage / number of prizes for a degree  Due to the miscalculation of `number of prizes for a degree`, it will be smaller than expected, as a result, `prize for a degree` will be larger than expected. Making the protocol giving out more prizes than designed.  ### Proof  > We will use `f(bitRange, degree)` to represent `numberOfPrizesForDegree(bitRangeSize, degree)`.  #### Proof: (method 1)  ```tex 2 ^ {bitRange \\times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) f(bitRange, n) = 2 ^ {bitRange \\times n} - ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) ) f(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )  Because:  2 ^ {bitRange \\times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) 2 ^ {bitRange \\times (n-1)} - f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)  Therefore:  f(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - ( 2 ^ {bitRange \\times (n-1)} - f(bitRange, n-1) ) f(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - 2 ^ {bitRange \\times (n-1)} + f(bitRange, n-1) f(bitRange, n) = 2 ^ {bitRange \\times n} - 2 ^ {bitRange \\times (n-1)} ```  Because `2^x = 1 << x`  Therefore, when `n > 0`:  ``` f(bitRange, n) = ( 1 << bitRange * n ) - ( 1 << bitRange * (n - 1) ) ```  QED.  #### Proof: (method 2)  By definition, `degree n` is constructed by 3 chunks:  -  The first N numbers, must equal the matching numbers. Number of possible values: `1`; -  The N-th number, must not equal the N-th matching number. Number of possible values: `2^bitRange - 1` -  From N (not include) until the end. Number of possible values: `2 ^ (bitRange * (n-1))`  Therefore, total `numberOfPrizesForDegree` will be:  ```tex f(bitRange, n) = (2 ^ {bitRange} - 1) \\times 2 ^ {bitRange \\times (n - 1)} f(bitRange, n) = 2 ^ {bitRange} \\times 2 ^ {bitRange \\times (n - 1)} - 2 ^ {bitRange \\times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \\times (n - 1)} - 2 ^ {bitRange \\times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \\times n - bitRange} - 2 ^ {bitRange \\times (n - 1)} f(bitRange, n) = 2 ^ {bitRange \\times n} - 2 ^ {bitRange \\times (n - 1)} ```  QED.  ### Recommendation  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431   ```solidity=412{423-431} /**     * @notice Calculates the number of prizes for a given prizeDistributionIndex     * @param _bitRangeSize Bit range size for Draw     * @param _prizeTierIndex Index of the prize tier array to calculate     * @return returns the fraction of the total prize (base 1e18)     */ function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)     internal     pure     returns (uint256) {     uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);     uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;      while (_prizeTierIndex > 0) {         numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);         _prizeTierIndex--;     }      return numberOfPrizesForIndex; } ```  L423-431 should change to:  ```solidity if (_prizeTierIndex > 0) {     return ( 1 << _bitRangeSize * _prizeTierIndex ) - ( 1 << _bitRangeSize * (_prizeTierIndex - 1) ); } else {     return 1; } ```  BTW, the comment on L416 is wrong:  - seems like it's copied from _calculatePrizeTierFraction() - plus, it's not base 1e18 but base 1e9  "}, {"title": "Gas: `PrizePool.captureAwardBalance` computation can be simplified", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PrizePool.captureAwardBalance` function always sets `_currentAwardBalance = currentAwardBalance` where `currentAwardBalance = currentAwardBalance + unaccountedPrizeBalance = currentAwardBalance + totalInterest - currentAwardBalance = totalInterest`.  Save a checked math addition by just setting `_currentAwardBalance = totalInterest` immediately.  "}, {"title": "`PrizePool` uses `ERC20` for `ERC721`", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PrizePool` defines `using SafeERC20 for IERC721;` which means the `SafeERC20.safeTransferFrom` function will be used in `awardExternalERC721`. However, this function is just a wrapper for `contract.transferFrom` with a return-value and success check.  Thus this call actually calls `ERC721.transferFrom` instead of `ERC721.safeTransferFrom` and does not call the important `onERC721Received` check for contracts.  ## Impact ERC721s can be awarded to contracts that don't know how to handle it and they can get stuck.  ## Recommended Mitigation Steps Remove the `using SafeERC20 for IERC721;` line.   "}, {"title": "Reserve does not correctly implement RingBuffer", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Reserve` does not correctly use ring buffers to get the oldest / newest elements if the array is full (observations larger than cardinality) in which case it should wrap around.  `getReserveAccumulatedBetween` always picks `reserveAccumulators[_cardinality - 1]`. `_checkpoint` tries to write to `reserveAccumulators[cardinality++]` which will break once `cardinality` reaches `MAX_CARDINALITY`.  The `TwabLib` library has a correct `oldestTwab/newestTwab` implementation using the `RingBufferLib` that wraps around if needed.  ## Impact Anyone can send 1 wei to the reserve and call `checkpoint` on it until the `MAX_CARDINALITY` is reached. Afterwards, trying to write any new checkpoints will fail as `_checkpoint` now tries to write to `cardinality=MAX_CARDINALITY+1` which is out of bounds of the `reserveAccumulators`.  The reserve is broken and cannot withdraw funds anymore. The gas costs for such an attack are very high and would take ~7 years if writing every block, making it probably not worth fixing.  ## Recommended Mitigation Steps Correctly implement the ring buffer usage like in `TwabLib`.   "}, {"title": "Wrong comment regarding decimal precision of `_calculatePrizeTierFraction`", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/22", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `_calculatePrizeTierFraction` docs say \"returns the fraction of the total prize (base 1e18)\", but it's base 1e9. Code seems to be correct.  "}, {"title": "Gas: Bitmasks creation can be simplified", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  In `DrawCalculator._createBitMasks`, the bit masks can just be created by shifting the previous (potentially already shifted) masks by the bit range. It saves on multiplications and, for me, this is also more intuitive than the current algorithm.  Some pseudocode: ```solidity function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)     internal     pure     returns (uint256[] memory) {     uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);     uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize, for example 0xF for bitRangeSize = 4      if(_prizeDistribution.matchCardinality == 0) return masks;      masks[0] = _bitRangeMaskValue;     for (uint8 maskIndex = 1; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {         // shift by the \"size\" of the bit mask each time, 0xF, 0xF0, 0xF00, 0xF000, etc.         masks[maskIndex] = masks[maskIndex - 1] << _prizeDistribution.bitRangeSize;     }      return masks; } ```  "}, {"title": "Gas: Default case of `_calculateTierIndex` can return `0`", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  If all masks match the `DrawCalculator._calculateTierIndex` function returns `masksLength - numberOfMatches` but it will always be zero at this point as `masksLength == numberOfMatches`. So just returning zero here would lead to saving a checked subtraction.  "}, {"title": "Usage of deprecated `safeApprove`", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  Description: `safeApprove` is now deprecated, see [this comment](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38).  ## Impact When using one of these unsupported tokens, all transactions revert and the protocol cannot be used.  ## Recommended Mitigation Steps As per OpenZepplin documentation \u201cwhenever possible, use `safeIncreaseAllowance` and `safeDecreaseAllowance` instead\u201d.   "}, {"title": "PrizeSplit uint8 limits", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/17", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the contract PrizeSplit.sol, uint8 is used in a few places. This limits the addressable size of _prizeSplits.  In practice you would probably not split prizes in more than 256 ways, but checking for this is safer.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L86-L87  function setPrizeSplit(PrizeSplitConfig memory _prizeSplit, uint8 _prizeSplitIndex)  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L130-L140  for (uint8 index = 0; index < prizeSplitsLength; index++) {  ## Tools Used  ## Recommended Mitigation Steps Add the following  to function setPrizeSplits:    require(newPrizeSplitsLength <= type(uint8).max))  or replace uint8 with uint256 in PrizeSplit.sol   "}, {"title": "Gas improvement _transferTwab", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact I've found some gas improvements for _transferTwab, see below.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L296-L313  ## Tools Used  ## Recommended Mitigation Steps   function _transferTwab(address _from, address _to, uint256 _amount) internal {         if (_from==_to) return; // no need to transfer if both are the same         if (_from != address(0)) {             _decreaseUserTwab(_from, _amount);             if (_to == address(0)) _decreaseTotalSupplyTwab(_amount);         }                 if (_to != address(0)) {                     _increaseUserTwab(_to, _amount);             if (_from == address(0)) _increaseTotalSupplyTwab(_amount);         }     }  "}, {"title": "Unnecessary Multiple Return Statements (PrizePool.sol)", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings and code clarity  ## Proof of Concept  PrizePool.sol: https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Replace this https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387 with <code> return (ticket == _controlledToken)  </code>  "}, {"title": "double reading from memory inside a for loop.", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pants   # Vulnerability details  At lines 197,199 PrizeDistributionHistory for example, the value _prizeDistribution.distributions[index] is read twice from memory instead of caching it as a local variable distributions_index = _prizeDistribution.distributions[index]; and using it instead.  Same at DrawCalculator.sol at lines 312, 315, 319 (here _picks[index] is read 3 times)   "}, {"title": "Unnecessary require check", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/273", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact In L92 of Basket.sol there is an unnecessary require check that the user balance is greater than or equal to amount. If the amount is larger than user balance then the _burn() method will fail, causing the function to revert anyway.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92  ## Recommended Mitigation Steps Remove the unnecessary check.  "}, {"title": "Add nonreentrant modifiers to external methods in 2 files", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/270", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  tensors   # Vulnerability details  I recommend adding reentrancy checks throughout Basket.sol and Auction.sol using a mutex lock. Many external calls are made to potentially unsafe token contracts. In the case that not all token contracts are properly vetted, this preventative step could be worthwhile.  "}, {"title": "Owner can steal all Basket funds during auction", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/265", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The owner of Factory contract can modify the values of `auctionMultiplier` and `auctionDecrement` at any time. During an auction, these values are used to calculate `newRatio` and thereby `tokensNeeded`: specifically, it's easy to set the factory parameters so that `tokensNeeded = 0` (or close to zero) for every token. This way the owner can participate at an auction, change the parameters, and get the underlying tokens from a Basket without transferring any pending tokens.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L99  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a Timelock to these Factory functions. Otherwise a way to not modify them if an auction is ongoing (maybe Auction saves the values it reads when `startAuction` is called).  "}, {"title": "`handleFees` reverts if supply is zero", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/264", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, `handleFees` computes the following: `uint256 newIbRatio = ibRatio * startSupply / totalSupply()`.  In the case that `totalSupply() = 0` (every holder burned their basket), the function reverts since there's a 0/0. This issue won't let new people mint, since `handleFees` is called before any minting.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L124  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a check before the division. ``` if (startSupply == 0) {  return; } ```  "}, {"title": "Event BasketLicenseProposed needs an idNumber", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/263", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The function `Factory.proposeBasketLicense` at the end emits `BasketLicenseProposed(msg.sender, tokenName)` and returns the id of the proposal. This `id` should also be written to the log, since it's needed by the proposer (for createBasket), and they may not see the return value of an external function.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87-L90  ## Tools Used editor  ## Recommended Mitigation Steps Consider redefining the event to contain the id of the proposal.  "}, {"title": "`mintTo` arguments order", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/257", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, there is a function `mintTo(uint256 amount, address to)`. It's best practice to use as first argument `to`, and as second `amount`; see also the order used in L84 (_mint(to, amount)) and L86 (Minted(to, amount)).  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L76  ## Tools Used editor  ## Recommended Mitigation Steps Consider switching the arguments (also don't forget to change the calls to the function).  "}, {"title": "Set functions to external.", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/240", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  goatbug   # Vulnerability details  ## Impact Long list of functions should be set from public to external since they are not called anywhere by the contract itself.     ## Proof of Concept  There are too many to list them all from all the contracts.  Just some examples in the Factory contract.  There are lots in every contract that should rather be external.      function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {         minLicenseFee = newMinLicenseFee;     }      function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {         auctionDecrement = newAuctionDecrement;     }      function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {         auctionMultiplier = newAuctionMultiplier;     }      function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {         bondPercentDiv = newBondPercentDiv;     }      function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {         require(newOwnerSplit <= 2e17); // 20%          ownerSplit = newOwnerSplit;     }  ## Tools Used  ## Recommended Mitigation Steps  "}, {"title": "Gas optimation proposal struct", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/238", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  goatbug   # Vulnerability details  ## Impact Use less storage slots  ## Proof of Concept     struct Proposal {         uint256 licenseFee;         string tokenName;         string tokenSymbol;         address proposer;         address[] tokens;         uint256[] weights;         address basket;     } License fee is a smaller number does not need to be uint256.   Could use an 8 bit value and pack it comfortable with one of the addresses to save a full storage slot.   ## Tools Used  ## Recommended Mitigation Steps  "}, {"title": "Replace `tokenList.length` by existing variable `length`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/230", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Replace `tokenList.length` by existing variable `length`  ``` diff modified   contracts/contracts/Basket.sol @@ -61,7 +61,7 @@ contract Basket is IBasket, ERC20Upgradeable {              require(_tokens[i] != address(0));              require(_weights[i] > 0);  -            for (uint256 x = 0; x < tokenList.length; x++) { +            for (uint256 x = 0; x < length; x++) {                  require(_tokens[i] != tokenList[x]);              } ```  Context: <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L64>  The value `tokenList.length` is read from memory and therefore requires a `mload(...)` (6 gas for `push memory_offset` + `mload`). On the other hand, this value is already available in the stack as `length` and could just be `dup-ed` (3 gas). Saves 3 gas for each loop iteration of the interior loop.   "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/229", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use `calldata` instead of `memory` for function parameters  In some cases, having function arguments in `calldata` instead of `memory` is more optimal.  Consider the following generic example:  ``` solidity contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above example, the dynamic array `arr` has the storage location `memory`. When the function gets called externally, the array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). And during the for loop, `arr[i]` accesses the value in memory using a `mload`. However, for the above example this is inefficient. Consider the following snippet instead:  ``` solidity contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } ```  In the above snippet, instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  **Gas savings**: In the former example, the ABI decoding begins with copying value from `calldata` to `memory` in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  *In short*, use `calldata` instead of `memory` if the function argument is only read.  ### Examples  1.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L65> 2.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69> 3.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L140> 4.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36> 5.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53> 6.  <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L170>   "}, {"title": "Gas: Can save an sload in `changeLicenseFee`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/228", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changeLicenseFee` function ensures that `pendingLicenseFee.licenseFee == newLicenseFee` which means setting `licenseFee = newLicenseFee` is equivalent to `licenseFee = pendingLicenseFee.licenseFee` but the former saves an expensive storage load operation.  "}, {"title": "Gas: Can save an sload in `changePublisher`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/227", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changePublisher` function ensures that `pendingPublisher.publisher == newPublisher` which means setting `publisher = newPublisher` is equivalent to `publisher = pendingPublisher.publisher` but the former saves an expensive storage load operation.  "}, {"title": "Gas: Factory parameter can be removed from Auction", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/225", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Auction.initialize` function accepts a `factory_` parameter. However, as this contract is always initialized directly from the factory, it can just use `msg.sender`.  ## Recommended Mitigation Steps Removing the additional `factory_` parameter and using `msg.sender` instead will save gas. This is already done for the other `Basket` contract.   "}, {"title": "Re-entrancy in `settleAuction` allow stealing all funds", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/223", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  Note that the `Basket` contract approved the `Auction` contract with all tokens and the `settleAuction` function allows the auction bonder to transfer all funds out of the basket to themselves. The only limiting factor is the check afterwards that needs to be abided by. It checks if enough tokens are still in the basket after settlement:  ``` // this is the safety check if basket still has all the tokens after removing arbitrary amounts for (uint256 i = 0; i < pendingWeights.length; i++) {     uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;     require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded); } ```  The bonder can pass in any `inputTokens`, even malicious ones they created. This allows them to re-enter the `settleAuction` multiple times for the same auction.  Calling this function at the correct time (such that `bondTimestamp - auctionStart` makes `newRatio < basket.ibRatio()`), the attacker can drain more funds each time, eventually draining the entire basket.  ## POC Assume that the current `basket.ibRatio` is `1e18` (the initial value). The basket publisher calls `basket.publishNewIndex` with some tokens and weights. For simplicity, assume that the pending `tokens` are the same as tokens as before, only the weights are different, i.e., this would just rebalance the portfolio. The function call then starts the auction.  The important step to note is that the `tokensNeeded` value in `settleAuction` determines how many tokens need to stay in the `basket`. If we can continuously lower this value, we can keep removing tokens from the `basket` until it is empty.  The `tokensNeeded` variable is computed as `basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE`. The only variable that changes in the computation when re-entering the function is `newRatio` (no basket tokens are burned, and the pending weights are never cleared).  Thus if we can show that `newRatio` decreases on each re-entrant call, we can move out more and more funds each time.  #### newRatio decreases on each call After some time, the attacker calls `bondForRebalance`. This determines the `bondTimestamp - auctionStart` value in `settleAuction`. The attack is possible as soon as `newRatio < basket.ibRatio()`. For example, using the standard parameters the calculation would be:  ```solidity // a = 2 * ibRatio uint256 a = factory.auctionMultiplier() * basket.ibRatio(); // b = (bondTimestamp - auctionStart) * 1e14 uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); // newRatio = a - b = 2 * ibRatio - (bondTimestamp - auctionStart) * 1e14 uint256 newRatio = a - b; ```  With our initial assumption of `ibRatio = 1e18` and calling `bondForRebalance` after 11,000 seconds (~3 hours) we will get our result that `newRatio` is less than the initial `ibRatio`:  ```python newRatio = a - b = 2 * 1e18 - (11000) * 1e14 = 2e18 - 1.1e18 = 0.9e18 < 1e18 = basket.ibRatio ```  > This seems to be a reasonable value (when the pending tokens and weights are equal in value to the previous ones) as no other bonder would want to call this earlier such when `newRatio > basket.ibRatio` as they would put in more total value in tokens as they can take out of the basket.  #### re-enter on settleAuction The attacker creates a custom token `attackerToken` that re-enters the `Auction.settleAuction` function on `transferFrom` with parameters we will specify.  They call `settleAuction` with `inputTokens = [attackerToken]` to re-enter several times.  In the inner-most call where `newRatio = 0.9e18`, they choose the `inputTokens`/`outputTokens` parameters in a way to pass the initial `require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);` check - transferring out any other tokens of `basket` with `outputTokens`.  The function will continue to run and call `basket.setNewWeights();` and `basket.updateIBRatio(newRatio);` which will set the new weights (but not clear the pending ones) and set the new `basket.ibRatio`.  Execution then jumps to the 2nd inner call after the `IERC20(inputTokens[i]=attackerToken).safeTransferFrom(...)` and has the chance to transfer out tokens again. It will compute `newRatio` with the new lowered `basket.ibRatio` of `0.9e18`: `newRatio = a - b = 2 * 0.9e18 - 1.1e18 = 0.7e18`. Therefore, `tokensNeeded` is lowered as well and the attacker was allowed to transfer out more tokens having carefully chosen `outputWeights`.  This repeats with `newRatio = 0.3`.  The attack is quite complicated and requires carefully precomputing and then setting the parameters, as well as sending back the `bondAmount` tokens to the `auction` contract which are then each time transferred back in the function body. But I believe this should work.  ## Impact The basket funds can be stolen.  ## Recommended Mitigation Steps Add re-entrancy checks (for example, OpenZeppelin's \"locks\") to the `settleAuction` function.    "}, {"title": "Setting wrong publisher cannot be undone", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Basket.changePublisher` function is used for both setting a new pending publisher as well as accepting the publisher transfer **from** the pending publisher.  ## Impact Once a pending publisher has been set, no other publisher can be set and if the pending publisher does not accept it, the contract is locked out of setting any other publishers. Setting a wrong publisher can naturally occur.  ## Recommended Mitigation Steps Add an option to set a new pending publisher even if there already is a pending publisher.   "}, {"title": "Re-entrancy in `Factory.createBasket`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/219", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  A basket creator can specify a custom token that allows them to re-enter in `Factory.createBasket`.  ## Impact As new auction and basket contracts are created every time, no cross-basket issues arise. However, note that the official `BasketCreated` event is emitted for all of them, but only the last basket is stored for the `idNumber`. This could lead to issues for some backend / frontend scripts that use the `BasketCreated` event.  ## Recommended Mitigation Steps Set `_proposals[idNumber].basket = address(newBasket);` immediately after the `newBasket` contract clone has been created to avoid the re-entrancy.   "}, {"title": "newIbRatio is not really useful", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/215", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why you need this new local variable called newIbRatio if you instantly update and use the storage variable afterwards:   uint256 newIbRatio = ibRatio * startSupply / totalSupply();   ibRatio = newIbRatio;  ## Recommended Mitigation Steps   ibRatio = ibRatio * startSupply / totalSupply();  "}, {"title": "Mint fees can be simplified", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This can be refactored to improve precision and gas usage:   _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);   _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);  ## Recommended Mitigation Steps Proposed solution:   uint256 factoryOwnerFee = fee * factory.ownerSplit() / BASE;   uint256 publisherFee = fee - factoryOwnerFee;   _mint(Ownable(address(factory)).owner(), factoryOwnerFee);   _mint(publisher, publisherFee); This will result in fewer math operations and better precision cuz multiplication and division are replaced with subtraction.  "}, {"title": "Dead code", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/211", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact BLOCK_DECREMENT state variable in Auction is not used anywhere.  ## Recommended Mitigation Steps Consider removing unused variables.  "}, {"title": "Double division by BASE", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This double division by BASE can be eliminated to improve precision and reduce gas costs:    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps if you introduce a constant variable, e.g.:    uint256 private constant BASE_2X = BASE * 2;    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE_2X;  "}, {"title": "emit NewIBRatio in function initialize", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I think function initialize should also emit NewIBRatio event as it sets the initial value:  ibRatio = BASE;  ## Recommended Mitigation Steps emit NewIBRatio(ibRatio) in function initialize.  "}, {"title": "Hardcoding numbers is error-prone", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/203", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Hardcoding numbers that depend on other variables is error-prone, e.g.     require(newOwnerSplit <= 2e17); // 20% You must not forget to update this if you decide to change the BASE value.  ## Recommended Mitigation Steps  Better define a separate constant that directly depends on the BASE, e.g.:     uint256 private constant MAX_OWNER_SPLIT = BASE / 5; // 20%     require(newOwnerSplit <= MAX_OWNER_SPLIT);  "}, {"title": "Inconvenient to find bounty ids", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/202", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In function settleAuction user needs to decide what bounties he/she wants to claim:     function settleAuction(         uint256[] memory bountyIDs     ...     withdrawBounty(bountyIDs); but bounties are stored in a private variable:    Bounty[] private _bounties; and there are no getter (view) functions to view bounties so I think that makes it very inconvenient for the end-user to find the appropriate ids that are relevant, especially considering there could be SPAM bounties as anyone can call addBounty.  ## Recommended Mitigation Steps Consider exposing public view functions to view bounties.  "}, {"title": "redundant code (unused variables)", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/198", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L14  BLOCK_DECREMENT is never used.  "}, {"title": "Use safeTransfer instead of transfer", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/196", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L146   `transfer()` might return false instead of reverting, in this case, ignoring return value leads to considering it successful.  use `safeTransfer()` or check the return value if length of returned data is > 0.  "}, {"title": "Recognize the risk of using approve", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/190", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  While safeApprove is used in the Factory contract, the use of ERC20 approve in approveUnderlying() (instead of safeApprove) is presumably to handle the reapprovals during changing of index but is susceptible to the historical ERC20 approve() race condition.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L106  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Be aware that this is susceptible to race-condition but this it unlikely a concern because the spender is always the auction contract which is cloned and therefore trusted.  "}, {"title": "2-step change of publisher address and licenseFee does not generate warning event\u2028", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/188", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact Another big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to generate an event when the new address or license fee is registered for change, pending the timelock duration. This is to warn protocol users that a pending change is upcoming (after the timelock) via offchain signalling so they can monitor/notice and decide to engage/exit based on their perception of the impact from the change.  The current implementation only emits an event when the pending change is enforced but not when it is made pending which does not provide one of the biggest benefits of a 2-step change.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L143-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L161-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add another event when the new publisher or licenseFee is made pending.  "}, {"title": " Incorrectly used new publisher and new licenseFee cannot be changed", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/186", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact A big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to allow any incorrectly used new addresses/values to be changed during the timelock period. This requires allowing the newPublisher or newLicenseFee to be a different value from the one used during the earlier approve and resetting the timelock again.  The current implementation only allows setting it once to a non-zero address/value and prevents any such corrections from being made (by checking that the address/value used is the same as that used during the first approve) which enforces the timelock to prevent surprises to users but does not provide the other accident benefits of using a timelock.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L137  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L155  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Recommend adding \"&& pendingPublisher.publisher == newPublisher\u201d and \"&& pendingLicenseFee.licenseFee == newLicenseFee\" to the if conditional predicate expression along with removing of the require() statement for equality check inside the conditional, to allow resetting the pending address/value to a new one if previously used one was incorrect.  "}, {"title": "Publisher role cannot be renounced", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/185", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Renouncing ownership is desirable in certain scenarios and is typically allowed by libraries such as Ownable.  The same may be true of the publisher role in this protocol as well to prevent changing the license fee or re-indexing the basket forever.   This is typically done by assigning a zero address to such a role i.e. burning it. However, by requiring any new proposed publisher address to be != zero address, the current implementation does not provide an option to renounce a publisher role by burning it.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L134  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support to renounce the publisher role or specify why this is not a desirable requirement for the protocol.  "}, {"title": "Hardcoded constants are risky", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/174", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Hardcoded constants in code is risky for auditability/readability/maintainability. The Factory contract uses 2e17 as a threshold check for ownerSplit instead of using a contract constant as done in other places.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L56  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Create a contract constant and use that as done in other places.  "}, {"title": "Missing events for critical protocol parameter setters by owner", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/171", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  None of the Factory owner setter functions emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  The impact of this is that a malicious/compromised/careless owner can intentionally/accidentally changes the minLicenseFee, auctionDecrement, auctionMultiplier, bondPercentDiv or ownerSplit values that significantly change the security/financial posture/perception of the protocol. No events are emitted and users may lose funds/confidence without being a chance to exit/engage protocol. The protocol takes a reputation hit.   See similar high-severity finding in\u00a0OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high)\u00a0and medium-severity finding\u00a0OpenZeppelin\u2019s Audit of UMA Phase 4: https://blog.openzeppelin.com/uma-audit-phase-4/.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L39-L41  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L47-L49  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L51-L53  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L55-L59   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend to consider emitting events when protocol critical values are updated by owner. This will be more transparent and it will make it easier to keep track of the status of the system.  "}, {"title": "Incorrect data location specifier can be abused to cause DoS and fund loss", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawBounty() loops through the _bounties array looking for active bounties and transferring amounts from active ones. However, the data location specifier used for bounty is memory which makes a copy of the _bounties array member instead of a reference. So when bounty.active is set to false, this is changing only the memory copy and not the array element of the storage variable. This results in bounties never being set to inactive, keeping them always active forever and every withdrawBounty() will attempt to transfer bounty amount from the Auction contract to the msg.sender.  Therefore, while the transfer will work the first time, subsequent attempts to claim this bounty will revert on transfer (because the Auction contract will not have required amount of bounty tokens) causing withdrawBounty() to always revert and therefore preventing settling of any auction.   A malicious attacker can add a tiny bounty on any/every Auction contract to prevent any reindexing on that contract to happen because it will always revert on auction settling. This can be used to cause DoS on any auctionBonder so as to make them lose their bondAmount because their bonded auction cannot be settled.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143-L147  https://docs.soliditylang.org/en/v0.8.7/types.html#data-location-and-assignment-behaviour  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend changing storage specifier of bounty to \"storage\" instead of \u201cmemory\".  "}, {"title": "Bounty list is never pruned to remove inactive bounties", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/165", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Given that there is no removal of claimed/inactive bounties, the bounty list could grow very long over time requiring a lot of gas for traversal.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L126-L151  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend pruning the claimed bounties by deleting them from the list.  "}, {"title": "Event params are of no practical value", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/163", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87  ``` emit BasketLicenseProposed(msg.sender, tokenName); ```  same event can be emitted with excat same parameters multiple times causing confusion to actors relying on it.   Mitigation:  Add proposal id or some other parameter  "}, {"title": "Gas Optimization Wrt. Token Uniqueness", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/160", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `validateWeights()` function can be better optimised by using a hashmap to measure token uniqueness. Currently, the function utilises an `O(n^2)` solution. By first iterating through each hashmap index for `_tokens`, any previously set tokens can be first cleared . This improves the current solution to `O(n)`.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53-L70  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using a hashmap to measure token uniqueness. However, this hashmap needs to first be cleared out before using it each time in `validateWeights()`.  "}, {"title": "Missing check for auctionOngoing is risky", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  killAuction() is missing a require() to check that auctionOngoing == true before setting it to false. While currently, the caller publishNewIndex() in Basket has this condition checked, any other usages may accidentally call this when auction is not ongoing.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L175-L187  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add require(auctionOngoing == true)  "}, {"title": "Unused constant", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Unused constant BLOCK_DECREMENT may be an indication of missing logic or redundant code. In this case, this appears to be a redundant constant same as Factory.auctionDecrement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L14  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Use the constant or remove it.  "}, {"title": "Choose either explicit return or named return, not both", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Choosing either named return or explicit instead of specifying both may reduce gas due to unnecessary bytecode introduced. proposeBasketLicense() uses a named return variable which is never assigned and instead uses an explicit return statement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L71  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L90  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Choose either explicit return or named return, not both  "}, {"title": "Avoiding unnecessary return can save gas", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact Unnecessary return of argument value via state variable which costs a SLOAD, returns the same value as argument back to caller where the return value is ignored.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L221  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L216-L222  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L104  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove return value for this function.  "}, {"title": "Caching return values of external calls in local/memory variables avoids CALLs to save gas\u2028", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There are places across contracts where the same external calls are made multiple times within a function. Caching return values of such calls in local/memory variables avoids CALLs to save gas. CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache factory.ownerSplit() return value to save 2600 gas in this function which gets called at every mint/burn.: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Hoist basketAsERC20.totalSupply() external call out of the loop because it remains the same and each call costs 2600 gas: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L96-L99  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache return values of external calls in local/memory variables  "}, {"title": "Caching state variables in local/memory variables avoids SLOADs to save gas", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/145", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There are numerous places across contracts where the same state variables are read multiple times within a function. Caching state variables in local/memory variables avoids SLOADs to save gas. Warm SLOADs cost 100 gas after Berlin upgrade. MLOADs cost only 3 gas units.\u2028 ## Proof of Concept  bondAmount: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L62-L66  Cache basket, bondTimestamp, factory: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L78-L99  Cache basket and bondAmount: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L116-L121  Cache pendingWeights: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L50  Cache lastFee: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L111-L116  Cache factory: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Cache pendingPublisher: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L139  Cache pendingLicenseFee: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L157  Cache auction & pendingWeights: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L173-L182  Cache publisher and auction: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208-L213  Cache proposals: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L62   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache state variables in local/memory variables to save gas.  "}, {"title": "`Auction.sol#initialize()` Use msg.sender rather than factory_ parameter can save gas", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/137", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L47-L52  `Auction.sol#initialize()` is using the factory_ parameter as the value of `factory`, while `Basket.sol#initialize()` uses `msg.sender`.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L39  Consider changing to `msg.sender` and remove the `factory_` parameter for the purpose of consistency and gas saving.  "}, {"title": "`Auction.sol#settleAuction()` Mishandling bounty state could potentially disrupt `settleAuction()`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L143  ```solidity=140 function withdrawBounty(uint256[] memory bountyIds) internal {     // withdraw bounties     for (uint256 i = 0; i < bountyIds.length; i++) {         Bounty memory bounty = _bounties[bountyIds[i]];         require(bounty.active);          IERC20(bounty.token).transfer(msg.sender, bounty.amount);         bounty.active = false;          emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);     } } ```  In the `withdrawBounty` function, `bounty.active` should be set to `false` when the bounty is claimed.  However, since `bounty` is stored in memory, the state update will not succeed.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled if they passed seemly active bountyIds, and the bonder will lose the bond.   ### Proof of Concept  1. Create an auction; 2. Add a bounty; 3. Auction settled with bounty claimed; 4. Create a new auction; 5. Add a new bounty; 6. Calling `settleAuction()` with the bountyIds of the 2 seemly active bounties always reverts.  ### Recommended Mitigation Steps  Change to:  ```solidity= Bounty storage bounty = _bounties[bountyIds[i]]; ```  "}, {"title": "`Basket.sol#auctionBurn()` A failed auction will freeze part of the funds", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/134", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L102-L108  Given the `auctionBurn()` function will `_burn()` the auction bond without updating the `ibRatio`. Once the bond of a failed auction is burned, the proportional underlying tokens won't be able to be withdrawn, in other words, being frozen in the contract.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.bondPercentDiv = 400 basket.totalSupply = 400 basket.tokens = [BTC, ETH] basket.weights = [1, 1]  1. Create an auction; 2. Bond with 1 BASKET TOKEN; 3. Wait for 24 hrs and call `auctionBurn()`;  `basket.ibRatio` remains to be 1e18; basket.totalSupply = 399.  Burn 1 BASKET TOKEN will only get back 1 BTC and 1 ETH, which means, there are 1 BTC and 1 ETH frozen in the contract.  ### Recommended Mitigation Steps  Change to:  ```solidity= function auctionBurn(uint256 amount) onlyAuction external override {     handleFees();     uint256 startSupply = totalSupply();     _burn(msg.sender, amount);      uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);     ibRatio = newIbRatio;      emit NewIBRatio(newIbRatio);     emit Burned(msg.sender, amount); } ```  "}, {"title": "Fee calculation is potentially incorrect", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact More fees are actually charged than intended   ## Mitigation Steps  [Basket.sol line 118](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L118)   Assume that license fee is 10% i.e. 1e17 and time diff = half a year.   When you calculate `feePct`, you expect to get 5e16 since that's 5% and the actual amount of fee to be charged should be totalSupply * feePct (5) / BASE (100) but on line 118, we are actually dividing by BASE - feePct i.e. 95.   5 / 95 = 0.052 instead of the intended 0.05.  Solution is to replace `BASE - feePct` in the denominator with `BASE`.  "}, {"title": "Variable assignment has no effect", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  nikitastupin   # Vulnerability details  Here https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L143-L143 the `bounty` variable is copied from Storage to Memory. Later it's assigned to false https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147. However, this assignment has no effect because `bounty` variable located at Memory so it's basically just thrown away when loop iteration finishes.  I think the intention was to make the `bounty.active` false so the same bounty isn't claimed twice or more times https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L144. However, the `bounty.active` will always be true because it never changes to false except for https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147 (which has no effect).  ## Impact  I don't see the direct impact here, however it may arise with the future changes to the contracts.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Do `_bounties[bountyIds[i]].active = false` instead of `bounty.active = false` if you need this check or just remove `bounty.active = false` and `require(bounty.active)` lines to save a gas otherwise.  "}, {"title": "Timelocked functions doesn't emit proposal events", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/123", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  nikitastupin   # Vulnerability details  Usually timelock is used in order to give a users of a protocol time to react on protocol changes (e.g. to withdraw their funds). Thus timelock implementations have Proposal and Execution steps. The main way to monitor blockchain changes and react to them is to listen for emitted events. However, none of the timelocked functions (`changePublisher`, `changeLicenseFee`, `publishNewIndex`) emits an event on Proposal step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L144-L147), they emit an event only on Execution step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L143-L143).  ## Impact  Events aren't emitted at critical functions.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Add events after (1) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L145-L146, (2) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L163-L164, (3) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L189-L192 and https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L182-L186.  "}, {"title": "use of approve() instead of safeApprove()", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/114", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact by using approve() , we are not checking the value returned by the approve ,wether it got failed or successfully executed. so it is safe to use safeApproval()  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  ## Tools Used manual review  ## Recommended Mitigation Steps use safeApprove()  "}, {"title": "lack of checking of array length", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/111", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking of array parameters in settleAuction()  , these array parameters can have different length which can lead to error.  inputWeight is iterated over the length of inputToken if one of the parameter have less length than other one will become inaccessible   which can lead to error  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  ## Tools Used  manual review  ## Recommended Mitigation Steps  "}, {"title": "settleAuction should be external and arguments should use calldata", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  t11s   # Vulnerability details  ## Impact Gas is wasted making `settleAuction` public, and using `memory` Instead of calldata for its arguments.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  "}, {"title": "tokensNeeded can potentially be 0", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/101", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  If tokensNeeded is 0, it is possible to remove all the funds in the basket since no tokens are required to pass the balanceOf checks. The chances of this happening is very unlikely however it is better to be safe than sorry.   ## Recommended Mitigation Steps  Add a require statement to check that the numerator (`basketAsERC20.totalSupply() * pendingWeights[i] * newRatio`) is greater than or eq to the denominator (`BASE * BASE`). This will ensure that it can never round down i.e. tokensNeeded can never be 0.  "}, {"title": "set lastFee in initialize() function", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation  ## Recommended Mitigation Steps  The if branch in the handleFee() function is only there to handle the very first time handleFees are called. Thereafter, this condition will always fail so it makes more sense to initialize it with the initialize() function.  ```jsx function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {     publisher = proposal.proposer;     licenseFee = proposal.licenseFee;     factory = IFactory(msg.sender);     auction = auction_;     ibRatio = BASE;     tokens = proposal.tokens;     weights = proposal.weights;   lastFee = block.timestamp;      // updated lastFee here     approveUnderlying(address(auction));      __ERC20_init(proposal.tokenName, proposal.tokenSymbol); } ...  function handleFees() private {     // if (lastFee == 0) {            // delete this     //     lastFee = block.timestamp; // delete this     // } else {                       // delete this     uint256 startSupply = totalSupply();      uint256 timeDiff = (block.timestamp - lastFee);     uint256 feePct = timeDiff * licenseFee / ONE_YEAR;     uint256 fee = startSupply * feePct / (BASE - feePct);      _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);     _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);     lastFee = block.timestamp;      uint256 newIbRatio = ibRatio * startSupply / totalSupply();     ibRatio = newIbRatio;      emit NewIBRatio(ibRatio);     // }                              // delete this } ```  "}, {"title": "`Auction.sol#settleAuction()` late auction bond could potentially not being able to be settled, cause funds loss to bonder", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  The `newRatio` that determines `tokensNeeded` to settle the auction is calculated based on `auctionMultiplier`, `bondTimestamp - auctionStart` and `auctionDecrement`.  ```solidity= uint256 a = factory.auctionMultiplier() * basket.ibRatio(); uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); uint256 newRatio = a - b; ```  However, if an auction is bonded late (`bondTimestamp - auctionStart` is a large number), and/or the `auctionMultiplier` is small enough, and/or the `auctionDecrement` is small enough, that makes `b` to be greater than `a`, so that `uint256 newRatio = a - b;` will revert on underflow.  This might seem to be an edge case issue, but considering that a rebalance auction of a bag of shitcoin to high-value tokens might just end up being bonded at the last minute, with a `newRatio` near zero. When we take the time between the bonder submits the transaction and it got packed into a block, it's quite possible that the final `bondTimestamp` gets large enough to revet `a - b`.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled, and the user will lose the bond.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.auctionDecrement = 5760 (Blocks per day) factory.auctionMultiplier = 2  1. Create an auction; 2. The auction remain inactive (not get bonded) for more than 2 days (>11,520 blocks); 3. Call `bondForRebalance()` and it will succeed; 4. Calling `settleAuction()` will always revert.  ### Recommended Mitigation Steps  Calculate and require `newRatio > 0` in `bondForRebalance()`, or limit the max value of decrement and make sure newRatio always > 0 in `settleAuction()`.  "}, {"title": "Redundant Balance Check", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  shenwilly   # Vulnerability details  ## Impact OpenZeppelin ERC20Upgradeable `_burn` already checks for account balance, so another check is unnecessary.   ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92   ## Recommended Mitigation Steps Remove the require statement  "}, {"title": "Lack of zero ratio validation", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that zero value has not been checked on that \"ibRatio\" variable. That can cause  miscalculation of the liquidity.   ## Proof of Concept  1. Navigate to \"https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol\" 2. Go to the line #217.  \"\"\"         ibRatio = newRatio; \"\"\"  3. Onlyauction modifier can assign ibRation to 0. 4. That can affect tokenAmount on the function.   \"\"\"     function pushUnderlying(uint256 amount, address to) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransfer(to, tokenAmount);         }     } \"\"\"  ## Tools Used  None  ## Recommended Mitigation Steps  Validate to ibRatio variable is more than zero.  \"\"\" require(ibRation > 0 , \"ibRatio should be more than zero\"); \"\"\"  "}, {"title": "User can mint miniscule amount of shares, later withdraw miniscule more than deposited", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/81", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  If a user is minting small amount of shares (like 1 - amount depends on baskets weights), the calculated amount of tokens to pull from the user can be less than 1, and therefore no tokens will be pulled. However the shares would still be minted. If the user does this a few times, he could then withdraw the total minted shares and end up with more tokens than he started with - although a miniscule amount.  ## Impact User can end up with more tokens than he started with. However, I didn't find a way for the user to get an amount to make this a feasible attack. He gets dust. However he can still get more than he deserves. If for some reason the basket weights grow in a substantial amount, this could give the user more tokens that he didn't pay for.  ## Proof of Concept Add the following test to Basket.test.js. The user starts with 5e18 UNI, 1e18 COMP, 1e18 AAVE, and ends with 5e18+4, 1e18+4, 1e18+4. ``` it(\"should give to user more than he deserves\", async () => {         await UNI.connect(owner).mint(ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).mint(ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).mint(ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            await UNI.connect(owner).approve(basket.address, ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).approve(basket.address, ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).approve(basket.address, ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            console.log(\"User balance before minting:\");         console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());         console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());         console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());                   await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));          console.log(\"\\nUser balance after minting 1 share 5 times:\");         console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());         console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());         console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());          await basket.connect(owner).burn(await basket.balanceOf(owner.address));         console.log(\"\\nUser balance after burning all shares:\");         console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());         console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());         console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());     }); ```  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to ```pullUnderlying```: ``` require(tokenAmount > 0); ``` I think it makes sense that if a user is trying to mint an amount so small that no tokens could be pulled from him, the mint request should be denied. Per my tests, for an initial ibRatio, this number (the minimal amount of shares that can be minted) is 2 for weights in magnitude of 1e18, and if the weights are eg. smaller by 100, this number will be 101.  "}, {"title": "`Basket.sol#handleFees()` could potentially cause disruption of minting and burning", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110-L129  ```solidity= function handleFees() private {     if (lastFee == 0) {         lastFee = block.timestamp;     } else {         uint256 startSupply = totalSupply();          uint256 timeDiff = (block.timestamp - lastFee);         uint256 feePct = timeDiff * licenseFee / ONE_YEAR;         uint256 fee = startSupply * feePct / (BASE - feePct);          _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);         _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);         lastFee = block.timestamp;          uint256 newIbRatio = ibRatio * startSupply / totalSupply();         ibRatio = newIbRatio;          emit NewIBRatio(ibRatio);     } } ```  `timeDiff * licenseFee` can be greater than `ONE_YEAR` when `timeDiff` and/or `licenseFee` is large enough, which makes `feePct` to be greater than `BASE` so that `BASE - feePct` will revert on underflow.   ## Impact  Minting and burning of the basket token are being disrupted until the publisher update the `licenseFee`.  ## Proof of Concept  1. Create a basket with a `licenseFee` of `1e19` or 1000% per year and mint 1 basket token; 2. The basket remain inactive (not being minted or burned) for 2 months; 3. Calling `mint` and `burn` reverts at `handleFees()`.  ## Recommended Mitigation Steps  Limit the max value of `feePct`.  "}, {"title": "Use calldata instead of memory in function parameter declarations", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  chasemartin01   # Vulnerability details  ## Impact Gas optimisation  ## Example As an example, you can change the declaration of `inputTokens`, `inputWeights`, `outputTokens`, `outputWeights` to be `calldata` as a gas optimisation  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69-L75  There's other instances of this in `Basket.sol` and`Factory.sol` ## Explanation When you specify `memory` for a function param for an external function, the following happens: the compiler copies elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change all instances of `memory` to `calldata` where the function parameter isn't being modified  "}, {"title": "Not handling approve return value", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  As defined in the ERC20 Specification, the approve function returns a bool that signals the success of the call. However, in `Basket.sol#approveUnderlying()` the value returned from calls to approve is ignored.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L224-L228  ## Recommended Mitigation Steps  To handle calls to approve safely, consider using the safeApprove function in OpenZeppelin\u2019s SafeERC20 contract for all approvals.  "}, {"title": "`proposal` declared as both a function and a Proposal in Factory", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  loop   # Vulnerability details  `proposal` is declared as both a function name and the name for a Proposal object.  ## Proof of Concept Factory.sol line 35: `function proposal(uint256 proposalId) external override view returns (Proposal memory) {` Factory.sol line 77: `Proposal memory proposal = Proposal({`  ## Tools Used Remix  ## Recommended Mitigation Steps Change function name to `getProposal` to avoid double naming and be more in line with other getter/setter functions used.  "}, {"title": "Use of uint rather than uint256", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  loop   # Vulnerability details  In basket.sol there is one use of `uint` rather than `uint256`, which is used in the rest of the codebase.  ## Impact No real impact considering `uint` functions as a `uint256`.  ## Proof of Concept Basket.sol - line 60: `for (uint i = 0; i < length; i++) {`  "}, {"title": "Basket becomes unusable if everybody burns their shares", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts: it(\"should divide by 0\", async () => {       await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));       await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));        await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));       await basket.connect(addr1).mint(ethers.BigNumber.from(1));   });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  "}, {"title": "Basket will break and lock all user funds if not used in 100 years", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  The ```handleFees``` function divides by ```(BASE - ((block.timestamp - lastFee)* licenseFee / ONE_YEAR))```. For initial BASE of 1e18 and licenseFee of 1e16, it means that if nobody calls this function in 100 years, the function will divide by 0.  ## Impact After 100 years of no usage, handleFees will always revert and nobody will be able to mint, burn etc'.  ## Proof of Concept Vulnerable line which will divide by 0: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L118 To test this, you can deploy to testnet a contract, then use a time machine to travel to 100 years in the future and try to use mint(). If for some reason you don't want to use your time machine, you may use this function to simulate the passage of time: ``` async function skipTime(seconds) {   let blockNumber = await hre.network.provider.request({     method: \"eth_blockNumber\",     params: [],   });   let block = await ethers.provider.getBlock(blockNumber[\"result\"]);   await hre.network.provider.request({     method: \"evm_mine\",     params: [block[\"timestamp\"]+seconds],   }); } ```  ## Tools Used Manual analysis, hardhat, time machine.  ## Recommended Mitigation Steps Tell your grandchildren to call mint(1) in 99 years.  "}, {"title": "Inaccurate log emitted at deleteNewIndex", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  The DeletedNewIndex log emits \"publisher\", but it might be the auction that called the function. Note: the event is defined as: event DeletedNewIndex(address _publisher); So if you wanted to anyway emit just the publisher, this is not a bug. However as this function call be called from both publisher and auction, I have a feeling you wanted to emit the msg.sender.  ## Impact Inaccurate data supplied.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Emit msg.sender instead of publisher.  "}, {"title": "handleFees() only mint when necessary", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact If the functions mintTo and burn of Basket.sol are called twice in the same block then block.timestamp will stay the same and timeDiff ==0. Then it is not necessary to _mint () tokens, as this will be 0 tokens anyway.  So checking for timeDiff ==0 could save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110  function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();              uint256 timeDiff = (block.timestamp - lastFee);             uint256 feePct = timeDiff * licenseFee / ONE_YEAR;             uint256 fee = startSupply * feePct / (BASE - feePct);              _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);             _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);             lastFee = block.timestamp;             uint256 newIbRatio = ibRatio * startSupply / totalSupply();             ibRatio = newIbRatio;              emit NewIBRatio(ibRatio);         }     } ## Tools Used  ## Recommended Mitigation Steps Add an extra if in the following way:   function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();             uint256 timeDiff = (block.timestamp - lastFee);             if (timeDiff !=0) {                                                                      // ===> extra if                 uint256 feePct = timeDiff * licenseFee / ONE_YEAR;                 uint256 fee = startSupply * feePct / (BASE - feePct);                 _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);                 _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);                 lastFee = block.timestamp;                 uint256 newIbRatio = ibRatio * startSupply / totalSupply();                 ibRatio = newIbRatio;                 emit NewIBRatio(ibRatio);            }         }     }     "}, {"title": "initialize of Basket.sol is missing initializer ", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/50", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When using the Openzeppelin upgradability pattern, the initialize() function should you the modifier initializer. However the initialize() function of Basket.sol doesn't have this modifier.  This won't give problems in practice because __ERC20_init() does have this modifier and prevents initialize() from being called twice. However forks of the projects or future developers might not be aware of this any make risky changes.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36 import { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";  contract Basket is IBasket, ERC20Upgradeable { ..  function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {        ...          __ERC20_init(proposal.tokenName, proposal.tokenSymbol);     }  ## Tools Used  ## Recommended Mitigation Steps Add the modifier initializer to the function initialize()  "}, {"title": "Auction settler can steal user funds if bond timestamp is high enough", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondTimestamp, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L89:#L99 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondTimestamp increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ```  "}, {"title": "Redundant call to external contract, result can be saved", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  When using few times an unchanging value from external contract call, the result can be saved and used without recalling the external contract.  ## Impact Some gas can be saved.  ## Proof of Concept In settleAuction, the basket's totalSupply stays constant through the loop's iterations. ``` for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L97  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Save basketAsERC20.totalSupply() to a local variable outside the loop, and use that variable inside the loop.  "}, {"title": "No minimum rate in the auction may break the protocol under network failure", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  There's a chance that `newRatio` would be really close to zero. This imposes too much risk on the protocol. The network may not really be healthy all the time. Solana and Arbitrum were down and Ethereum was suffered a forking issue recently. Also, the network may be jammed from time to time. This could cause huge damage to a protocol. Please refer to [Black Thursday for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6)  Given the chance that all user may lose their money, I consider this is a medium-risk issue.   ## Proof of Concept [Black Thursfay for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6) [bug-impacting-over-50-of-ethereum-clients-leads-to-fork](https://www.theblockcrypto.com/post/115822/bug-impacting-over-50-of-ethereum-clients-leads-to-fork)  ## Tools Used None  ## Recommended Mitigation Steps  I recommend setting a minimum `ibRatio` when a publisher publishes a new index. The auction should be killed if the `ibRatio` is too low.  "}, {"title": " settleAuction may be impossible if locked at a wrong time.", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/41", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  In this equation, `a` would not always be greater than `b`. The ` auctionBonder` may lock the token in `bondForRebalance()` at a point that `a-b` would always revert.  The contract should not allow users to lock the token at the point that not gonna succeed. Given the possible (huge) loss of the user may suffer, I consider this is a medium-risk issue.   ## Proof of Concept Here's a web3.py script to trigger this bug. ```python basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  for i in range(4 * 60 * 24):     w3.provider.make_request('evm_mine', []) basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  print('auction on going', auction.functions.auctionOngoing().call()) for i in range(20000):     w3.provider.make_request('evm_mine', [])  all_token = basket.functions.balanceOf(user).call() basket.functions.approve(auction.address, all_token).transact() auction.functions.bondForRebalance().transact() # error Log # {'code': -32603, 'message': 'Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'} auction.functions.settleAuction([], [], [], [], []).transact() ```   ## Tools Used None  ## Recommended Mitigation Steps Recommend to calculate the new irate in `bondForRebalance`. I understand the `auctionBonder` should take the risk to get the profit. However, the contract should protect the user in the first place when this auction is doomed to fail.  "}, {"title": "Restore state to 0 if not needed anymore", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  In some places where data is discarded such as ```bondBurn```, part of the data is set to 0 (```auctionBonder```), and other parts are not (```bondTimestamp```). Setting unnecessary data back to 0 will save gas.  ## Impact Almost 2000 gas saved for each variable reset. In some places, like ```createBasket``` (which only needs to save the proposal's \"basket\" field after creating the basket), this can save almost 15000 gas.  ## Proof of Concept Places where data is not reset: Factory's createBasket (set all _proposals[idNumber]'s fields to be 0 except basket) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L112 Basket's changePublisher: (set pendingPublisher.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L141 Basket's changeLicenseFee: (set pendingLicenseFee.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L159 Basket's setNewWeights and deleteNewIndex: (set pendingWeights.tokens and pendingWeights.weights to empty arrays) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L200 https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L212 Auction's killAuction: (set auctionStart = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L44 Auction's settleAuction: (set bondTimestamp, auctionBonder = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L107 Auction's bondBurn: (set bondTimestamp = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L120 Auction's withdrawBounty: (set bounty.token, bounty.token = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L148  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Detailed above.  "}, {"title": "Reentrancy in settleAuction(): malicious publisher can bypass index timelock mechanism, inject malicious index, and rug the basket", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/31", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  The settleAuction() function calls withdrawBounty() before setting auctionOngoing = false, thereby allowing reentrancy.  ## Impact A malicious publisher can bypass the index timelock mechanism and publish new index which the basket's users won't have time to respond to. At worst case, this means setting weights that allow the publisher to withdraw all the basket's underlying funds for himself, under the guise of a valid new index.  ## Proof of Concept 1. The publisher (a contract) will propose new valid index and bond the auction. To settle the auction, the publisher will execute the following steps in the same transaction: 2. Add a bounty of an ERC20 contract with a malicious transfer() function. 3. Settle the valid new weights correctly (using settleAuction() with the correct parameters, and passing the malicious bounty id). 4. settleAuction() will call withdrawBounty() which upon transfer will call the publisher's malicious ERC20 contract. 5. The contract will call settleAuction() again, with empty parameters. Since the previous call's effects have already set all the requirements to be met, settleAuction() will finish correctly and call setNewWeights() which will set the new valid weights and set pendingWeights.pending = false. 6. Still inside the malicious ERC20 contract transfer function, the attacker will now call the basket's publishNewIndex(), with weights that will transfer all the funds to him upon his burning of shares. This call will succeed to set new pending weights as the previous step set pendingWeights.pending = false. 7. Now the malicious withdrawBounty() has ended, and the original settleAuction() is resuming, but now with malicious weights in pendingWeights (set in step 6). settleAuction() will now call setNewWeights() which will set the basket's weights to be the malicious pending weights. 8. Now settleAuction has finished, and the publisher (within the same transaction) will burn() all his shares of the basket, thereby transferring all the tokens to himself.  POC exploit: Password to both files: \"exploit\". AttackPublisher.sol , to be put under contracts/contracts/Exploit: https://pastebin.com/efHZjstS ExploitPublisher.test.js , to be put under contracts/test: https://pastebin.com/knBtcWkk  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps In settleAuction(), move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern.  "}, {"title": "Cannot change pending while timelocked", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  joeysantoro   # Vulnerability details  ## Impact If any of the timelocked variables of a basket are pending a change, a transaction to change the target will revert during the timelock window.  ## Proof of Concept Publisher wants to change license fee. They submit a change request but fat finger with the wrong value. The only way to change the pending licenseFee is to complete the change to the incorrect value (after timelock period) then resubmit a new request.  In the case of changing index this can be mitigated by using deleteNewIndex(), however changePublisher and changeLicenseFee cannot be mitigated.  ## Recommended Mitigation Steps Introduce a \"setPendingX\" method for each of  liscenceFee, publisher, and index. This cleanly separates the logic and allows for overwrite of pending during timelock window.  "}, {"title": "Global bounties variable and 0 bounty allow dos in bounty functionality of basket", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that _bounties variable is global per basket. Also you are allowed to add 0 amount in bounty. This means if user adds uint256 max times bounty with amount 0, no one can add further bounty on this basket  ## Proof of Concept 1. User calls addBounty function with amount 0 uint256 max times  ```     function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {         // add bounty to basket         token.safeTransferFrom(msg.sender, address(this), amount);         _bounties.push(Bounty({             token: address(token),             amount: amount,             active: true         }));          uint256 id = _bounties.length - 1;         emit BountyAdded(token, amount, id);         return id;     } ```  2. Now noone can call bounty on this basket anymore  ## Recommended Mitigation Steps _bounties should be cleared once auction has been settled  "}, {"title": "Zero weighted baskets are allowed to steal funds", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that Publisher is allowed to create a basket with zero token and weight. This can lead to user fund stealing as described in below poc The issue was discovered in validateWeights function of Basket contract   ## Proof of Concept 1. User proposes a new Basket with 0 tokens and weights using proposeBasketLicense function in Factory contract  ```  Proposal memory proposal = Proposal({             licenseFee: 10,             tokenName: abc,             tokenSymbol: aa,             proposer: 0xabc,             tokens: {},             weights: {},             basket: address(0)         }); ```  2. validateWeights function is called and it returns success as the only check performed is _tokens.length == _weights.length (0=0)  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length == _weights.length);         uint256 length = _tokens.length;         address[] memory tokenList = new address[](length);          // check uniqueness of tokens and not token(0)          for (uint i = 0; i < length; i++) {            ...         }     } ```  3. A new proposal gets created  ``` _proposals.push(proposal); ```  4. User creates new Basket with this proposal using createBasket function  ``` function createBasket(uint256 idNumber) external override returns (IBasket) {         Proposal memory bProposal = _proposals[idNumber];         require(bProposal.basket == address(0));          ....          for (uint256 i = 0; i < bProposal.weights.length; i++) {             ...         }   ...         return newBasket;     } ```  5. Since no weights and tokens were in this proposal so no token transfer is required (bProposal.weights.length will be 0 so loop won't run)  6. Basket gets created and user becomes publisher for this basket  ```         newBasket.mintTo(BASE, msg.sender);         _proposals[idNumber].basket = address(newBasket); ```  7. Publisher owned address calls the mint function with say amount 10 on Basket.sol contract  ```     function mint(uint256 amount) public override {         mintTo(amount, msg.sender);     }      function mintTo(uint256 amount, address to) public override {         ...          pullUnderlying(amount, msg.sender);          _mint(to, amount);          ...     } ```  8. Since there is no weights so pullUnderlying function does nothing (weights.length is 0)  ```     function pullUnderlying(uint256 amount, address from) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);         }     } ```  9. Full amount 10 is minted to Publisher owned address setting balanceOf(msg.sender) = 10  ``` _mint(to, amount); ```  10. Now Publisher calls the publishNewIndex to set new weights. Since pendingWeights.pending is false, else condition gets executed  ```     function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {         validateWeights(_tokens, _weights);          if (pendingWeights.pending) {             require(block.number >= pendingWeights.block + TIMELOCK_DURATION);             if (auction.auctionOngoing() == false) {                 auction.startAuction();                  emit PublishedNewIndex(publisher);             } else if (auction.hasBonded()) {              } else {                 auction.killAuction();                  pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.block = block.number;             }         } else {             pendingWeights.pending = true;             pendingWeights.tokens = _tokens;             pendingWeights.weights = _weights;             pendingWeights.block = block.number;         }     } ```   11. Publisher calls the publishNewIndex again which starts the Auction. This auction is later settled using the settleAuction function in Auction contract  12. Publisher owned address can now call burn and get the amount 10 even though he never made the payment since his balanceOf(msg.sender) = 10 (Step 9)  ```     function burn(uint256 amount) public override {         require(auction.auctionOngoing() == false);         require(amount > 0);         require(balanceOf(msg.sender) >= amount);          handleFees();          pushUnderlying(amount, msg.sender);         _burn(msg.sender, amount);                  emit Burned(msg.sender, amount);     } ```  ## Recommended Mitigation Steps Change validateWeights to check for 0 length token  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length>0);   ...     } ```  "}, {"title": "Require statement can be moved to start of function", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  bw   # Vulnerability details  ## Impact  A [require](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74) statement in `Factory.sol` could be performed prior to an expensive cross contract call, reducing the amount of gas wasted if the validation fails.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74  ## Tools Used  N/A  ## Recommended Mitigation Steps  Move the require statement before `basketImpl.validateWeights(tokens, weights);`  "}, {"title": "Uninitialized Implementation Contracts", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/18", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  bw   # Vulnerability details  ## Impact  The implementation contracts that are used by proxies are not initialized by default, this creates the possibility that the contracts will not be initialized after deployment.  Uninitialized implementations could result in Denial of Service exploits. This often involves initializing the contract so that it is possible to `delegatecall` into a contract that has the `selfdestruct` opcode.   The contracts in-scope did not contain any `delegatecalls` that could be exploited. However, it is still regarded as best practice to ensure that the contracts cannot be initialized after deployment.  ## Proof of Concept  As a defence in-depth measure, the implementations should be initialized during deployed by adding the following: ```diff diff --git a/contracts/contracts/Auction.sol b/contracts/contracts/Auction.sol index f07df8b..f7c21eb 100644 --- a/contracts/contracts/Auction.sol +++ b/contracts/contracts/Auction.sol @@ -44,6 +44,10 @@ contract Auction is IAuction {          auctionOngoing = false;      }   +    constructor() { +        initialized = true; +    } +      function initialize(address basket_, address factory_) public override {          require(!initialized);          basket = IBasket(basket_); diff --git a/contracts/contracts/Basket.sol b/contracts/contracts/Basket.sol index 5fef21b..4549365 100644 --- a/contracts/contracts/Basket.sol +++ b/contracts/contracts/Basket.sol @@ -33,6 +33,10 @@ contract Basket is IBasket, ERC20Upgradeable {        uint256 public override lastFee;   +    constructor() { +        __ERC20_init(\"\",  \"\"); +    } +      function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {          publisher = proposal.proposer;          licenseFee = proposal.licenseFee; ```  * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L9 * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L12  ## Tools Used  N/A  ## Recommended Mitigation Steps  Initialize implementations during deployment by adding a constructor.     "}, {"title": "Runtime constants not defined as immutable", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/15", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  bw   # Vulnerability details  ## Impact The [`Factory.sol`](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L19) contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  For more information regarding the `immutable` keyword: https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Proof of Concept  ### Code Diff  ```diff diff --git a/contracts/contracts/Factory.sol b/contracts/contracts/Factory.sol index 271945d..3bbdd4f 100644 --- a/contracts/contracts/Factory.sol +++ b/contracts/contracts/Factory.sol @@ -23,8 +23,8 @@ contract Factory is IFactory, Ownable {        Proposal[] private _proposals;   -    IAuction public override auctionImpl; -    IBasket public override basketImpl; +    IAuction public immutable override auctionImpl; +    IBasket public immutable override basketImpl;        uint256 public override minLicenseFee = 1e15; // 1e15 0.1%      uint256 public override auctionDecrement = 10000; ```  ### Gas Improvement  ```diff diff --git a/base.gas b/factory-immutable.gas index 9d48ade..1447433 100644 --- a/base.gas +++ b/factory-immutable.gas @@ -23,9 +23,9 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  ERC20Upgradeable  \u00b7  approve               \u00b7          -  \u00b7          -  \u00b7    48900  \u00b7            3  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  Factory           \u00b7  createBasket          \u00b7     880031  \u00b7     908831  \u00b7   882911  \u00b7           10  \u00b7          -  \u2502 +|  Factory           \u00b7  createBasket          \u00b7     875780  \u00b7     904580  \u00b7   878660  \u00b7           10  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  Factory           \u00b7  proposeBasketLicense  \u00b7     335488  \u00b7     335512  \u00b7   335505  \u00b7           12  \u00b7          -  \u2502 +|  Factory           \u00b7  proposeBasketLicense  \u00b7     333388  \u00b7     333412  \u00b7   333405  \u00b7           12  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Factory           \u00b7  setOwnerSplit         \u00b7          -  \u00b7          -  \u00b7    46173  \u00b7            1  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 @@ -39,7 +39,7 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Basket                                     \u00b7          -  \u00b7          -  \u00b7  2390793  \u00b7          8 %  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  Factory                                    \u00b7          -  \u00b7          -  \u00b7  1706801  \u00b7        5.7 %  \u00b7          -  \u2502 +|  Factory                                    \u00b7          -  \u00b7          -  \u00b7  1684215  \u00b7        5.6 %  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  TestToken                                  \u00b7     653145  \u00b7     653193  \u00b7   653163  \u00b7        2.2 %  \u00b7          -  \u2502  \u00b7---------------------------------------------|-------------|-------------|-----------|---------------|-------------\u00b7  ```  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the immutable key word to all variables that are only set during the constructor.   "}, {"title": "Gas Saving by changing the visibility of initialize function from public to externa in basket.sol", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  jah   # Vulnerability details  ## Impact the initialize function will not be called from the contract and  it  doesn't require public visibility so the visibility should be changed to external to save gas as  described in https://mudit.blog/solidity-gas-optimization-tips/: \u201cFor all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function\u2019s parameters are not copied into memory but are read from calldata directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.\u201d     ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L36  ## Tools Used manual analysis  ## Recommended Mitigation Steps change the visibility to external  "}, {"title": "Sanity check on the lower and upper ticks", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/93", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  In the `burn` and `swap` functions of `ConcentratedLiquidityPool`, the lower tick is not explicitly checked to be less than the upper tick. Besides, the ticks are not checked to be at least the minimum tick and at most the maximum tick.  ## Proof of Concept  Referenced code: [Ticks.sol#L68-L70](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L68-L70)  ## Recommended Mitigation Steps  Add sanity checks on the lower and upper ticks in critical functions (see the referenced line of code, for example).  "}, {"title": "Incorrect usage of typecasting in `_getAmountsForLiquidity` lets an attacker steal funds from the pool", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/83", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_getAmountsForLiquidity` function of `ConcentratedLiquidityPool` explicitly converts the result of `DyDxMath.getDy` and `DyDxMath.getDx` from type `uint256` to type `uint128`. The explicit casting without checking whether the integer exceeds the maximum number (i.e., `type(uint128).max`) could cause incorrect results being used. Specifically, an attacker could exploit this bug to mint a large amount of liquidity but only pay a little of `token0` or `token1` to the pool and effectively steal other's funds when burning his liquidity.  ## Proof of Concept  1. Suppose that the current price is at the tick `500000`, an attacker calls the `mint` function with the following parameters:  ``` mintParams.lower = 100000 mintParams.upper = 500000 mintParams.amount1Desired = (1 << 128) + 71914955423 # a carefully chosen number mintParams.amount0Desired = 0 ```  2. Since the current price is equal to the upper price, we have  ``` _liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper - priceLower)            = 4731732988155153573010127840 ```  3. The amounts of `token0` and `token1` that the attacker has to pay is  ``` amount0Actual = 0 amount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))               = uint128(_liquidity * (priceUpper - priceLower) // (1 << 96)) # round up               = uint128(340282366920938463463374607456141861046)             # exceed the max               = 24373649590                                                  # truncated ```  4. The attacker only pays `24373649590` of `token1` to get `4731732988155153573010127840` of the liquidity, which he could burn to get more `token1`. As a result, the attacker is stealing the funds from the pool and could potentially drain it.  Referenced code: [ConcentratedLiquidityPool.sol#L480](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L480) [concentratedPool/DyDxMath.sol#L15](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L15) [concentratedPool/DyDxMath.sol#L30](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L30)  ## Recommended Mitigation Steps  Check whether the result of `DyDxMath.getDy` or `DyDxMath.getDx` exceeds `type(uint128).max` or not. If so, then revert the transaction. Or consider using the [`SafeCast` library](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from OpenZeppelin instead.  "}, {"title": "`incentiveId <= incentiveCount[pool]` is bad and can be removed", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/79", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact When an user subscribes to an incentive using ConcentratedLiquidityPoolManager's `subscribe`, the function checks that `incentiveId` is appropriate: ```js require(incentiveId <= incentiveCount[pool], \"NOT_INCENTIVE\"); ``` This check is actually incorrect, and it should use a `<` instead of `<=`.  If this was the only requirement, it would be possible to subscribe to the next incentive, causing some problems. Fortunately the next line saves the day: `require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, \"TIMED_OUT\");` this fails for uninitiated incentives.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L72  ## Tools Used editor  ## Recommended Mitigation Steps Consider removing this requirement to save gas. The check for existing pool is already considered when looking at `block.timestamp < incentive.endTime`.  "}, {"title": "`addIncentive` and `reclaimIncentive` can be external", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact Function `addIncentive` and `reclaimIncentive` in ConcentratedLiquidityPoolManager can be `external` instead of `public` to save gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L36 https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49  ## Tools Used editor  "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/74", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * I think the error message here should be \"NOT_EXPIRED\":     require(incentive.expiry < block.timestamp, \"EXPIRED\");  * There are hardcoded magic numbers, e.g.: 5 weeks or 128. It would make code more readable and maintanable if you extract such numbers as constants, e.g.:   uint public constant EXPIRY_BUFFER = 5 weeks;   require(incentive.endTime + EXPIRY_BUFFER < incentive.expiry, \"END_PAST_BUFFER\");   "}, {"title": "Useless state variable wETH", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract ConcentratedLiquidityPosition has a state variable 'wETH' but it is not being used in any meaningful way. So you can remove it to save some gas.  ## Recommended Mitigation Steps Remove useless state variables.  "}, {"title": "Unused import", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is an unused import: import \"../../interfaces/ITridentRouter.sol\"; in ConcentratedLiquidityPosition. It will increase the size of deployment with no real benefit.  ## Recommended Mitigation Steps Consider removing this unused import to save some gas.   "}, {"title": "Struct could be optimized for saving gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  Members of structs should be grouped into bunches of 32 bytes for saving gas.  For example:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L15-L23  `ConcentratedLiquidityPoolManager.sol#Incentive` `rewardsUnclaimed` and `secondsClaimed` can be moved to the bottom to optimize for Variable Packing.  "}, {"title": "`ConcentratedLiquidityPoolManager.sol#reclaimIncentive` Misleading error message", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L58  ```solidity function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, \"NOT_OWNER\");     require(incentive.expiry < block.timestamp, \"EXPIRED\");     require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  When the current time is before the `incentive.expiry` time, the error message should be `NOT_EXPIRED` instead of `EXPIRED`.  "}, {"title": "`ConcentratedLiquidityPosition.sol#collect()` Users may get double the amount of yield when they call `collect()` before `burn()`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/53", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#collect()` to collect their yield, it calcuates the yield based on `position.pool.rangeFeeGrowth()` and `position.feeGrowthInside0, position.feeGrowthInside1`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L75-L101  When there are enough tokens in `bento.balanceOf`, it will not call `position.pool.collect()` to collect fees from the pool.  This makes the user who `collect()` their yield when there is enough balance to get double yield when they call `burn()` to remove liquidity. Because `burn()` will automatically collect fees on the pool contract.  ## Impact  The yield belongs to other users will be diluted.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` call `position.pool.collect()` before `position.pool.burn()`. User will need to call `ConcentratedLiquidityPosition.sol#collect()` to collect unclaimed fees after `burn()`.  Or `ConcentratedLiquidityPosition.sol#collect()` can be changed into a `public` method and `ConcentratedLiquidityPosition.sol#burn()` can call it after `position.pool.burn()`.  "}, {"title": "`ConcentratedLiquidityPosition.sol#burn()` Wrong implementation allows attackers to steal yield", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/52", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#burn()` to burn their liquidity, it calls `ConcentratedLiquidityPool.sol#burn()` -> `_updatePosition()`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L525-L553  The `_updatePosition()` function will return `amount0fees` and `amount1fees` of the whole position with the `lower` and `upper` tick and send them to the `recipient` alongside the burned liquidity amounts.  ## Proof of Concept  1. Alice minted $10000 worth of liquidity with `lower` and `upper` tick set to 99 and 199; 2. Alice accumulated $1000 worth of fee in token0 and token1; 3. The attacker can mint a small amount ($1 worth) of liquidity using the same `lower` and `upper` tick; 4. The attacker calls `ConcentratedLiquidityPosition.sol#burn()` to steal all the unclaimed yield with the ticks of (99, 199) include the $1000 worth of yield from Alice.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` always use `address(this)` as `recipient` in:  ```solidity position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento)); ```  and transfer proper amounts to the user.  "}, {"title": "Burning does not update reserves", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/51", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function sends out `amount0`/`amount1` tokens but only updates the reserves by decreasing it by the **fees of these amounts**.  ```solidity unchecked {     // @audit decreases by fees only, not by amount0/amount1     reserve0 -= uint128(amount0fees);     reserve1 -= uint128(amount1fees); } ```  This leads to the pool having wrong reserves after any `burn` action. The pool's balance will be much lower than the reserve variables.  ## Impact As the pool's actual balance will be much lower than the reserve variables, `mint`ing and `swap`ing will not work correctly either. This is because of the `amount0Actual + reserve0 <= _balance(token0)` check in `mint` using a much higher `reserve0` amount than the actual balance (already including the transferred assets from the user). An LP provider will have to make up for the missing reserve decrease from `burn` and pay more tokens.  The same holds true for `swap` which performs the same check in `_updateReserves`.  The pool essentially becomes unusable after a `burn` as LPs / traders need to pay more tokens.  ## Recommended Mitigation Steps The reserve should be decreased by what is transferred out. In `burn`'s case this is `amount0` / `amount1`.   "}, {"title": "Unsafe cast in ConcentratedLiquidityPool burn leads to attack", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/50", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function performs an unsafe cast of a `uint128` type to a _signed_ integer.  ```solidity (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount)); ```  Note that `amount` is chosen by the caller and when choosing `amount = 2**128 - 1`, this is interpreted as `0xFFFFFFFFF... = -1` as a signed integer. Thus `-(-1)=1` adds 1 liquidity unit to the position  This allows an attacker to not only mint LP tokens for free but as this is the `burn` function it also redeems token0/1 amounts according to the unmodified `uint128` `amount` which is an extremely large value.  ## POC I created this POC that implements a hardhat test and shows how to steal the pool tokens.  Choosing the correct `amount` of liquidity to burn and `lower, upper` ticks is not straight-forward because of two competing constraints: 1. the `-int128(amount)` must be less than `MAX_TICK_LIQUIDITY` (see `_updatePosition`). This drives the the `amount` up to its max value (as the max `uint128` value is -1 => -(-1)=1 is very low) 2. The redeemed `amount0, amount1` values must be less than the current pool balance as the transfers would otherwise fail. This drives the `amount` down. However, by choosing a smart `lower` and `upper` tick range we can redeem fewer tokens for the same liquidity.  This example shows how to steal 99% of the `token0` pool reserves: https://gist.github.com/MrToph/1731dd6947073343cf6f942985d556a6  ## Impact An attacker can steal the pool tokens.  ## Recommended Mitigation Steps Even though Solidity 0.8.x is used, type casts do not throw an error. A [`SafeCast` library](https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeCast) must be used everywhere a typecast is done.   "}, {"title": "Gas: `ConcentratedLiquidityPoolManager.addIncentive` ", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` performs an unnecessary check:  ```solidity require(current <= incentive.endTime, \"ALREADY_ENDED\"); ```  As it already checks that `current <= incentive.startTime` and `incentive.startTime < incentive.endTime`, this check is unnecessary and will always be true by transitivity.  ## Recommended Mitigation Steps Remove the check to save on gas.  "}, {"title": "`TridentNFT.permitAll` prviliges discrepancy for operator", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TridentNFT.permitAll` function allows the operator (`isApprovedForAll[owner][recoveredAddress]`) to change the operator (and lock themself out). The same functionality without permits does not work as `setApprovalForAll` requires the `owner` authority.  ## Impact `permitAll` should have the same auth checks as `setApprovalForAll` and not allow the `operator` to change the operator.  ## Recommended Mitigation Steps Remove the `|| isApprovedForAll[owner][recoveredAddress]` from the `require` statement.   "}, {"title": "`TridentNFT.permit` should always check `recoveredAddress != 0`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TridentNFT.permit` function ignores the `recoveredAddress != 0` check if `isApprovedForAll[owner][recoveredAddress]` is true.  ## Impact If a user accidentally set the zero address as the operator, tokens can be stolen by anyone as a wrong signature yield `recoveredAddress == 0`.  ## Recommended Mitigation Steps Change the `require` logic to `recoveredAddress != address(0) && (recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress])`.   "}, {"title": "Incentive should check that it hasn't started yet", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` function can add an incentive that already has a non-zero `incentive.secondsClaimed`.  ## Impact Rewards will be wrong.  ## Recommended Mitigation Steps Add a check: `require(incentive.secondsClaimed == 0, \"!secondsClaimed\")`.   "}, {"title": "Cannot claim reward", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/41", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.claimReward` requires `stake.initialized` but it is never set. It also performs a strange computation as `128 - incentive.secondsClaimed` which will almost always underflow and revert the transaction.  ## Impact One cannot claim rewards.  ## Recommended Mitigation Steps Rethink how claiming rewards should work.   "}, {"title": "`ConcentratedLiquidityPoolManager`'s incentives can be stolen", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/37", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager` keeps all tokens for all incentives in the same contract. The `reclaimIncentive` function does not reduce the `incentive.rewardsUnclaimed` field and thus one can reclaim tokens several times. This allows anyone to steal all tokens from all incentives by creating an incentive themself, and once it's expired, repeatedly claim the unclaimed rewards until the token balance is empty.  ## POC - Attacker creates an incentive for a non-existent pool using a random address for `pool` (This is done such that no other user can claim rewards as we need a non-zero `rewardsUnclaimed` balance for expiry). They choose the `incentive.token` to be the token they want to steal from other incentives. (for example, `WETH`, `USDC`, or `SUSHI`) They choose the `startTime, endTime, expiry` such that the checks pass, i.e., starting and ending in a few seconds from now, expiring in 5 weeks. Then they choose a non-zero `rewardsUnclaimed` and transfer the `incentive.token` to the PoolManager. - Attacker waits for 5 weeks until the incentive is expired - Attacker can now call `reclaimIncentive(pool, incentiveId, amount=incentive.rewardsUnclaimed, attacker, false)` to withdraw `incentive.rewardsUnclaimed` of `incentive.token` from the pool manager. - As the `incentive.rewardsUnclaimed` variable has not been decreased, they can keep calling `reclaimIncentive` until the pool is drained.  ## Impact An attacker can steal all tokens in the PoolManager.  ## Recommended Mitigation Steps In `reclaimIncentive`, reduce `incentive.rewardsUnclaimed` by the withdrawn `amount`.   "}, {"title": "Wrong inequality when adding/removing liquidity in current price range", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/34", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.mint/burn` functions add/remove `liquidity` when `(priceLower < currentPrice && currentPrice < priceUpper)`. Shouldn't it also be changed if `priceLower == currentPrice`?  ## Impact Pools that mint/burn liquidity at a time where the `currentPrice` is right at the lower price range do not work correctly and will lead to wrong swap amounts.  ## Recommended Mitigation Steps Change the inequalities to `if (priceLower <= currentPrice && currentPrice < priceUpper)`.   "}, {"title": "`ConcentratedLiquidityPool`s can be created with the same tokens", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.constructor` does not check that `_token0 != _token1`. The pool factory does not ensure this either.  ## Impact Pools can be created using the same token. This should be prevented as it does not make sense.  ## Recommended Mitigation Steps Add a `_token0 != _token1` check to the constructor.   "}, {"title": "`DyDxMath.getLiquidityForAmounts` underflows", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `DyDxMath.getLiquidityForAmounts/getDx/getDy` functions perform unchecked computations on `priceUpper - priceLower` but they do not check that `priceUpper >= priceLower`.  ## Impact The values can underflow and return much lower liquidity or much higher token amounts than expected.  The calling functions (`mint` and `burn`) also do not check this. For `mint`, it fails further down the callstack at `Ticks.insert`, but `burn` does not fail.  ## Recommended Mitigation Steps Check that the `lower` and `upper` from the provided parameters for `mint` and `burn` are indeed sorted, i.e., `lower < upper`. It should be checked explicitly at the start of the function.   "}, {"title": "range fee growth underflow", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/25", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  broccoli   # Vulnerability details  # range fee growth underflow ## Impact The function `RangeFeeGrowth` [ConcentratedLiquidityPool.sol#L601-L633](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L601-L633) would revert the transaction in some cases.  When a pool cross a tick, it only updates either `feeGrowthOutside0` or `feeGrowthOutside1`. [Ticks.sol#L23-L53](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L23-L53)  `RangeFeeGrowth` calculates the fee as follow: ```solidity             feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;             feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1; ```  `feeGrowthBelow + feeGrowthAbove` is not necessary smaller than `_feeGrowthGlobal`. Please see `POC`.   Users can not provide liquidity or burn liquidity. Fund will get stocked in the contract. I consider this is a high-risk issue.  ## Proof of Concept ```python     # This is the wrapper.     # def add_liquidity(pool, amount, lower, upper)     # def swap(pool, buy, amount)      add_liquidity(pool, deposit_amount, -800, 500)     add_liquidity(pool, deposit_amount, 400, 700)     # We cross the tick here to trigger the bug.      swap(pool, False, deposit_amount)     # Only tick 700's feeGrowthOutside1 is updated      swap(pool, True, deposit_amount)     # Only tick 500's feeGrowthOutside0 is updated          # current tick at -800      # this would revert     # feeGrowthBelow1 = feeGrowthGlobal1     # feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1 would revert     # user would not be able to mint/withdraw/cross this tick. The pool is broken     add_liquidity(pool, deposit_amount, 400, 700) ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps  It's either modify the tick's algo or `RangeFeeGrowth`. The quick-fix I come up with is to deal with the fee in `RangeFeeGrowth`. However, I recommend the team to go through tick's logic again.  "}, {"title": "`ConcentratedLiquidityPool.burn()` Wrong implementation", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/24", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool.  However, the current implementation only updated reserves with the fees subtracted.  Makes the `reserve0` and `reserve1` smaller than the current `balance0` and `balance1`.  ## Impact  As a result, many essential features of the contract will malfunction, includes `swap()` and `mint()`.  ## Recommended Mitigation Steps  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L263-L267  Change:  ```         unchecked {             reserve0 -= uint128(amount0fees);             reserve1 -= uint128(amount1fees);         }  ``` to:  ```         unchecked {             reserve0 -= uint128(amount0);             reserve1 -= uint128(amount1);         } ```  "}, {"title": "ConcentratedLiquidityPoolManager.sol#claimReward() and reclaimIncentive() will fail when incentive.token is token0 or token1", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `ConcentratedLiquidityPosition.collect()`, balances of token0 and token1 in bento will be used to pay the fees.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L103-L116  ```     uint256 balance0 = bento.balanceOf(token0, address(this));     uint256 balance1 = bento.balanceOf(token1, address(this));     if (balance0 < token0amount || balance1 < token1amount) {         (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);          uint256 newBalance0 = amount0fees + balance0;         uint256 newBalance1 = amount1fees + balance1;          /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw         if (token0amount > newBalance0) token0amount = newBalance0;         if (token1amount > newBalance1) token1amount = newBalance1;     }     _transfer(token0, address(this), recipient, token0amount, unwrapBento);     _transfer(token1, address(this), recipient, token1amount, unwrapBento);  ```  In the case of someone add an incentive with `token0` or `token1`, the incentive in the balance of bento will be used to pay fees until the balance is completely consumed.  As a result, when a user calls `claimReward()`, the contract may not have enough balance to pay (it supposed to have it), cause the transaction to fail.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L78-L100 ``` function claimReward(         uint256 positionId,         uint256 incentiveId,         address recipient,         bool unwrapBento     ) public {         require(ownerOf[positionId] == msg.sender, \"OWNER\");         Position memory position = positions[positionId];         IConcentratedLiquidityPool pool = position.pool;         Incentive storage incentive = incentives[position.pool][positionId];         Stake storage stake = stakes[positionId][incentiveId];         require(stake.initialized, \"UNINITIALIZED\");         uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;         uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;         uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;         uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);         uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;         incentive.rewardsUnclaimed -= rewards;         incentive.secondsClaimed += uint160(secondsInside);         stake.secondsInsideLast += uint160(secondsPerLiquidityInside);         _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);         emit ClaimReward(positionId, incentiveId, recipient);     } ```  The same issue applies to `reclaimIncentive()` as well.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49-L62 ``` function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, \"NOT_OWNER\");     require(incentive.expiry < block.timestamp, \"EXPIRED\");     require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  ## Recommendation  Consider making adding `token0` or `token1` as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when `collect()`.  "}, {"title": "Spelling Errors", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  `derrived` \u2192 `derived`  `owerflow` \u2192 `overflow`  "}, {"title": "ConcentratedLiquidityPool: incorrect feeGrowthGlobal accounting when crossing ticks", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/16", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Swap fees are taken from the output. Hence, if swapping token0 for token1 (`zeroForOne` is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache   `feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0;`  and in `_updateFees()`.  However, looking at `Ticks.cross()`, the logic is the reverse, which causes wrong fee accounting.  ```jsx if (zeroForOne) {  ...  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } else {  ...  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } ```  ### Recommended Mitigation Steps  Switch the `0` and `1` in `Ticks.cross()`.  ```jsx if (zeroForOne) {  ...  // feeGrowthGlobal = feeGrowthGlobal1  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } else {  ...  // feeGrowthGlobal = feeGrowthGlobal0  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } ```  "}, {"title": "ConcentratedLiquidityPool: rangeFeeGrowth and secondsPerLiquidity math needs to be unchecked", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/13", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The fee growth mechanism, and by extension, secondsPerLiquidity mechanism of Uniswap V3 has the ability to underflow. It is therefore a necessity for the math to (ironically) be unsafe / unchecked.   ### Proof of Concept  Assume the following scenario and initial conditions:  - Price at parity (nearestTick is 0) - tickSpacing of 10 - Swaps only increase the price (nearestTick moves up only) - feeGrowthGlobal initializes with 0, increases by 1 for every tick moved for simplicity - Existing positions that provide enough liquidity and enable nearestTick to be set to values in the example - Every tick initialized in the example is \u2264 nearestTick, so that its feeGrowthOutside = feeGrowthGlobal  1. When nearestTick is at 40, Alice creates a position for uninitialised ticks [-20, 30]. The ticks are initialized, resulting in their feeGrowthOutside values to be set to 40. 2. nearestTick moves to 50. Bob creates a position with ticks [20, 30] (tick 20 is uninitialised, 30 was initialized from Alice's mint). tick 20 will therefore have a feeGrowthOutside of 50. 3. Let us calculate `rangeFeeGrowth(20,30)`.     - lowerTick = 20, upperTick = 30     - feeGrowthBelow = 50 (lowerTick's feeGrowthOutside) since lowerTick < currentTick     - feeGrowthAbove = 50 - 40 = 10 (feeGrowthGlobal - upperTick's feeGrowthOutside) since upperTick < currentTick     - feeGrowthInside                  = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove                  = 50 - 50 - 10                  = -10           We therefore have negative feeGrowthInside.  This behaviour is actually acceptable, because the important thing about this mechanism is the relative values to each other, not the absolute values themselves.  ### Recommended Mitigation Steps  `rangeFeeGrowth()` and `rangeSecondsInside()` has to be unchecked. In addition, the subtraction of feeGrowthInside values should also be unchecked in `_updatePosition()` and `ConcentratedLiquidityPosition#collect()`.  The same also applies for the subtraction of `pool.rangeSecondsInside` and `stake.secondsInsideLast` in `claimReward()` and `getReward()` of the `ConcentratedLiquidityPoolManager` contract.  "}, {"title": "ConcentratedLiquidityPool: initialPrice should be checked to be within allowable range", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/11", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  No check is performed for the initial price. This means that it can be set to be below the `MIN_SQRT_RATIO` or above `MAX_SQRT_RATIO` (Eg. zero value), which will prevent the usability of all other functions (minting, swapping, burning).  For example, `Ticks.insert()` would fail when attempting to calculate `actualNearestTick = TickMath.getTickAtSqrtRatio(currentPrice);`, which means no one will be able to mint positions.  ### Recommended Mitigation Steps  Check the `initialPrice` is within the acceptable range, ie. `MIN_SQRT_RATIO <= initialPrice <= MAX_SQRT_RATIO`  "}, {"title": "depositYieldBearing didn't check address != 0", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/48", "labels": ["bug", "sponsor confirmed", "disagree with severity", "0 (Non-critical)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pants   # Vulnerability details    "}, {"title": "`public` functions can be `external`", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/45", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pants   # Vulnerability details  These `public` functions are never called by their contract: - `TempusAMM.getSwapAmountToEndWithEqualShares()` - `TempusAMM.getRate()` - `AaveTempusPool.currentInterestRate()` - `AaveTempusPool.numAssetsPerYieldToken()` - `AaveTempusPool.numYieldTokensPerAsset()` - `CompoundTempusPool.currentInterestRate()` - `CompoundTempusPool.numAssetsPerYieldToken()` - `CompoundTempusPool.numYieldTokensPerAsset()` - `LidoTempusPool.currentInterestRate()` - `LidoTempusPool.numAssetsPerYieldToken()` - `LidoTempusPool.numYieldTokensPerAsset()` - `ERC20FixedSupply.decimals()` - `ERC20OwnerMintableToken.burn()` - `ERC20OwnerMintableToken.burnFrom()` - `PoolShare.decimals()` - `PermanentlyOwnable.renounceOwnership()` - `TempusController.depositYieldBearing()` - `TempusController.depositBacking()` - `TempusController.redeemToYieldBearing()` - `TempusController.redeemToBacking()` - `TempusPool.estimatedMintedShares()` - `TempusPool.estimatedRedeem()`  Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `external`.  "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/39", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pants   # Vulnerability details  These files has open TODOs: - `TempusPool.sol` - `unusedAMMImportOnly.sol` - `Fixed256xVar.sol` - `LidoTempusPool.sol`  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve these TODOs and bubble up the errors.  "}, {"title": "Use of uint8 for counter in for loop increases gas costs", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/38", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact Increased gas costs  ## Proof of Concept  On L189, we use a uint8 as the for loop variable: https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L189  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  ## Recommended Mitigation Steps  Change i to be a uint256 and replace any similar uints which only exist in memory and aren't required to use a smaller type.  "}]