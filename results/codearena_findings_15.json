[{"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/188", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/184", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/183", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/179", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/178", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/177", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/174", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/169", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "[WP-H22] Bad debts should not continue to accrue interest", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/167", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "[WP-H22] Bad debts should not continue to accrue interest"}, {"title": "[WP-H9] `_swapUniswapV2` may use an improper `path` which can cause a loss of the majority of the rewardTokens", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/157", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "[WP-H9] `_swapUniswapV2` may use an improper `path` which can cause a loss of the majority of the rewardTokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/154", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/148", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/144", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/142", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/140", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "`StrategyPUSDConvex.balanceOfJPEG` uses incorrect function signature while calling `extraReward.earned`, causing the function to unexpectedly revert everytime", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/139", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234   # Vulnerability details  ## Impact  As specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.  This bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.  ## Proof of Concept  Both `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument  ```     function earned(address account) public view returns (uint256) {         return             balanceOf(account)                 .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))                 .div(1e18)                 .add(rewards[account]);     }      function earned(address account) public view returns (uint256) {         return             balanceOf(account)                 .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))                 .div(1e18)                 .add(rewards[account]);     } ```  But `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called ```     function balanceOfJPEG() external view returns (uint256) {         uint256 availableBalance = jpeg.balanceOf(address(this));          IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;         uint256 length = baseRewardPool.extraRewardsLength();         for (uint256 i = 0; i < length; i++) {             IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));             if (address(jpeg) == extraReward.rewardToken()) {                 availableBalance += extraReward.earned();                 //we found jpeg, no need to continue the loop                 break;             }         }          return availableBalance;     } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Pass `address(this)` as argument of `earned`.  Notice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.  ```     function balanceOfJPEG() external view returns (uint256) {         uint256 availableBalance = jpeg.balanceOf(address(this));          IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;         availableBalance += baseRewardPool.earned(address(this));         uint256 length = baseRewardPool.extraRewardsLength();         for (uint256 i = 0; i < length; i++) {             IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));             if (address(jpeg) == extraReward.rewardToken()) {                 availableBalance += extraReward.earned(address(this));             }         }          return availableBalance;     } ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Wrong calculation for yVault price per share if decimals != 18", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "Wrong calculation for yVault price per share if decimals != 18"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/112", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Division before Multiplication May Result In No Interest Being Accrued", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/97", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-jpegd-findings", "body": "Division before Multiplication May Result In No Interest Being Accrued"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Reentrancy issue in `yVault.deposit`", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/81", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145   # Vulnerability details  ## Impact In `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.  #### POC Initial state: `balance() = 1000`, shares `supply = 1000`. Depositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.  - Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ... - Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ... - Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted. - Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens. - They repeat the attack until the vault is drained.  ## Recommended Mitigation Steps The `safeTransferFrom` should be the last call in `deposit`.   "}, {"title": "Setting new controller can break YVaultLPFarming", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/80", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Setting new controller can break YVaultLPFarming"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/79", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "`setDebtInterestApr` should accrue debt first", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L212   # Vulnerability details  ## Impact The `setDebtInterestApr` changes the debt interest rate without first accruing the debt. This means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.  It should never be applied retroactively to a previous time window as this is unfair & wrong. Borrowers can incur more debt than they should.  ## Recommended Mitigation Steps Call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/71", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/69", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Controller: Strategy migration will fail", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/57", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/Controller.sol#L95 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L266   # Vulnerability details  ## Details  The controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done.  The migration would therefore revert.  ## Proof of Concept  Insert this test into [`StrategyPUSDConvex.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/StrategyPUSDConvex.ts).  ```jsx it.only(\"will revert when attempting to migrate strategy\", async () => {   await controller.setVault(want.address, yVault.address);   await expect(controller.setStrategy(want.address, strategy.address)).to.be.revertedWith(\"jpeg\"); }); ```  ## Recommended Mitigation Steps  Replace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`.  "}, {"title": "yVaultLPFarming: No guarantee JPEG currentBalance > previousBalance", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/56", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170   # Vulnerability details  ## Details & Impact  yVault users participating in the farm have to trust that:  - `vault.balanceOfJPEG()`  returns the correct claimable JPEG amount by its strategy / strategies - the strategy / strategies will send all claimable JPEG to the farm  Should either of these assumptions break, then it could be possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow.  ## Proof of Concept  For instance,   - Farm migration occurs. A new farm is set in `yVault`, then `withdrawJPEG()` is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.  ```jsx it.only(\"will revert old farms' deposits and withdrawals if yVault migrates farm\", async () => {   // 0. setup   await token.mint(owner.address, units(1000));   await token.approve(yVault.address, units(1000));   await yVault.depositAll();   await yVault.approve(lpFarming.address, units(1000));   // send some JPEG to strategy prior to deposit   await jpeg.mint(strategy.address, units(100));   // deposit twice, so that the second deposit will invoke _update()   await lpFarming.deposit(units(250));   await lpFarming.deposit(units(250));     // 1. change farm and call withdrawJPEG()   await yVault.setFarmingPool(user1.address);   await yVault.withdrawJPEG();     // deposit and withdrawal will fail   await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');   await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'); }); ```  - Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing `vault.balanceOfJPEG()` to report a smaller amount than previously recorded - `jpeg` could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets - A future implementation takes a fee on the `jpeg` to be claimed  ## Recommended Mitigation Steps  A simple fix would be to `return` if `currentBalance \u2264 previousBalance`. A full fix would properly handle potential shortfall.  ```jsx if (currentBalance <= previousBalance) return; ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/55", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Oracle data feed is insufficiently validated.", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "Oracle data feed is insufficiently validated."}, {"title": "FungibleAssetVaultForDAO: The withdraw function calls native payable.transfer, which can be unusable for smart contract calls", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-jpegd-findings", "body": "FungibleAssetVaultForDAO: The withdraw function calls native payable.transfer, which can be unusable for smart contract calls"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "NFTHelper Contract Allows Owner to Burn NFTs", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "NFTHelper Contract Allows Owner to Burn NFTs"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/46", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "rewards will be locked if user transfer directly to pool without using deposit function ", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/19", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L190   # Vulnerability details  ## Impact ###### LpFarming.sol reward will be locked in the farming, when user execute a direct transfer with lpToken to farm without using deposit    ## Proof of Concept \"pls add this test to LpFarming.ts to check\"   ``` it(\"a part of rewards can't be distributed if user execute a direct transfer to farm\", async() => {       // manual mine new block         await network.provider.send(\"evm_setAutomine\", [false]);        // prepare        const attacker = bob;       await lpTokens[0].transfer(alice.address, units(1000));       await lpTokens[0].transfer(attacker.address, units(1000));       await lpTokens[0].connect(alice).approve(farming.address, units(1000));       await mineBlocks(1);        // attacker direct deposit lp token to the pool        await lpTokens[0].connect(attacker).transfer(farming.address, units(100));        // create new pool       await farming.add(10, lpTokens[0].address);       await mineBlocks(1);       expect(await farming.poolLength()).to.equal(1);        let pool = await farming.poolInfo(0);       expect(pool.lpToken).to.equal(lpTokens[0].address);       expect(pool.allocPoint).to.equal(10);        // create new epoch ==> balance of pool will be 1000        let blockNumber = await ethers.provider.getBlockNumber();       await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);        // alice deposit        await farming.connect(alice).deposit(0, units(100));       await mineBlocks(1);        expect(await jpeg.balanceOf(farming.address)).to.equal(1000);        // when pool end, alice can just take 500 jpeg, and 500 jpeg will be locked in the contract forever !!!       await mineBlocks(13);       console.log(\"reward of alice: \", (await   farming.pendingReward(0, alice.address)).toString());       expect(await farming.pendingReward(0, alice.address)).to.equal(BigNumber.from('500'));     }); ``` In the test above, the attacker transfers 100 lpToken to the farm without using deposit function, and alice deposit 100 lpToken. Because the contract uses ```pool.lpToken.balanceOf(address(this))``` to get the total supply of lpToken in the pool, it will sum up 100 lpToken of attacker and 100 lpToken of alice. This will lead to the situation where Alice will only be able to claim 500 token (at epoch.endBlock), the rest will be locked in the pool forever. Not only with this pool, it also affects the following, a part of the reward will be locked in the pool when the farm end.  ## Tools Used typescript   ## Recommended Mitigation Steps Declare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```   "}, {"title": "reward will be locked in the farm if no LP join the pool at epoch.startBlock ", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/14", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "reward will be locked in the farm if no LP join the pool at epoch.startBlock "}, {"title": "yVault: First depositor can break minting of shares", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/12", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L148-L153   # Vulnerability details  ## Details  The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.  ## Proof of Concept  - Attacker deposits 1 wei to mint 1 share - Attacker transfers exorbitant amount to the `StrategyPUSDConvex` contract to greatly inflate the share\u2019s price. Note that the strategy deposits its entire balance into Convex when its `deposit()` function is called. - Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.  Insert this test into [`yVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/yVault.ts).  ```jsx it.only(\"will cause 0 share issuance\", async () => {   // mint 10k + 1 wei tokens to user1   // mint 10k tokens to owner   let depositAmount = units(10_000);   await token.mint(user1.address, depositAmount.add(1));   await token.mint(owner.address, depositAmount);   // token approval to yVault   await token.connect(user1).approve(yVault.address, 1);   await token.connect(owner).approve(yVault.address, depositAmount);      // 1. user1 mints 1 wei = 1 share   await yVault.connect(user1).deposit(1);      // 2. do huge transfer of 10k to strategy   // to greatly inflate share price (1 share = 10k + 1 wei)   await token.connect(user1).transfer(strategy.address, depositAmount);      // 3. owner deposits 10k   await yVault.connect(owner).deposit(depositAmount);   // receives 0 shares in return   expect(await yVault.balanceOf(owner.address)).to.equal(0);    // user1 withdraws both his and owner's deposits   // total amt: 20k + 1 wei   await expect(() => yVault.connect(user1).withdrawAll())     .to.changeTokenBalance(token, user1, depositAmount.mul(2).add(1)); }); ```  ## Recommended Mitigation Steps  - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - Ensure the number of shares to be minted is non-zero: `require(_shares != 0, \"zero shares minted\");`  "}, {"title": "The noContract modifier does not work as expected.", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61 https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/farming/yVaultLPFarming.sol#L54 https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The expectation of the noContract modifier is to allow access only to accounts inside EOA or Whitelist, if access is controlled using ! access control with _account.isContract(), then because isContract() gets the size of the code length of the account in question by relying on extcodesize/address.code.length, this means that the restriction can be bypassed when deploying a smart contract through the smart contract's constructor call.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps  Modify the code to `require(msg.sender == tx.origin);`  "}, {"title": "Existing user\u2019s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/10", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L375 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/lock/JPEGLock.sol#L54-L62   # Vulnerability details  ## Details & Impact  A user\u2019s JPEG lock schedule can be overwritten by another user\u2019s if he (the other user) submits and finalizes a proposal to change the same NFT index\u2019s value.  The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.  ## Proof of Concept  1. `user` successfully proposes and finalizes a proposal to change his NFT\u2019s collateral value 2. Another user (`owner`) does the same for the same NFT index 3. `user` will be unable to withdraw his locked JPEG because schedule has been overwritten  Insert this test case into [`NFTVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/NFTVault.ts).  ```jsx it.only(\"will overwrite existing user's JPEG lock schedule\", async () => {   // 0. setup   const index = 7000;   await erc721.mint(user.address, index);   await nftVault     .connect(dao)     .setPendingNFTValueETH(index, units(50));   await jpeg.transfer(user.address, units(150000));   await jpeg.connect(user).approve(locker.address, units(500000));   await jpeg.connect(owner).approve(locker.address, units(500000));    // 1. user has JPEG locked for finalization   await nftVault.connect(user).finalizePendingNFTValueETH(index);    // 2. owner submit proposal to further increase NFT value   await nftVault     .connect(dao)     .setPendingNFTValueETH(index, units(100));      // 3. owner finalizes, has JPEG locked   await nftVault.connect(owner).finalizePendingNFTValueETH(index);    // user schedule has been overwritten   let schedule = await locker.positions(index);   expect(schedule.owner).to.equal(owner.address);    // user tries to unstake   // wont be able to because schedule was overwritten   await timeTravel(days(366));   await expect(locker.connect(user).unlock(index)).to.be.revertedWith(\"unauthorized\"); }); ```  ## Recommended Mitigation Steps  1. Release the tokens of the existing schedule. Simple and elegant.  ```jsx // in JPEGLock#lockFor() LockPosition memory existingPosition = positions[_nftIndex]; if (existingPosition.owner != address(0)) {   // release jpegs to existing owner   jpeg.safeTransfer(existingPosition.owner, existingPosition.lockAmount); } ```  2. Revert in `finalizePendingNFTValueETH()` there is an existing lock schedule. This is less desirable IMO, as there is a use-case for increasing / decreasing the NFT value.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/6", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Chainlink pricer is using a deprecated API", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/PriceOracleImplementation.sol#L29-L30   # Vulnerability details  ## Impact According to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.  ## Proof of Concept https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/PriceOracleImplementation.sol#L29-L30 ## Tools Used None ## Recommended Mitigation Steps Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete https://docs.chain.link/docs/price-feeds-api-reference/  "}, {"title": "When _lpToken is jpeg, reward calculation is incorrect", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/1", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154   # Vulnerability details  ## Impact In the LPFarming contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the _lpToken is the same as the reward token (jpeg) or not. ```     function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {         _massUpdatePools();          uint256 lastRewardBlock = _blockNumber();         totalAllocPoint = totalAllocPoint + _allocPoint;         poolInfo.push(             PoolInfo({                 lpToken: _lpToken,                 allocPoint: _allocPoint,                 lastRewardBlock: lastRewardBlock,                 accRewardPerShare: 0             })         );     } ```  When the _lpToken is the same token as jpeg, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the _lpToken in the contract is used in the calculation of the reward. Since the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. ```     function _updatePool(uint256 _pid) internal {         PoolInfo storage pool = poolInfo[_pid];         if (pool.allocPoint == 0) {             return;         }          uint256 blockNumber = _blockNumber();         //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch         uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);         if (blockNumber <= lastRewardBlock) {             return;         }         uint256 lpSupply = pool.lpToken.balanceOf(address(this));         if (lpSupply == 0) {             pool.lastRewardBlock = blockNumber;             return;         }         uint256 reward = ((blockNumber - lastRewardBlock) *             epoch.rewardPerBlock *             1e36 *             pool.allocPoint) / totalAllocPoint;         pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;         pool.lastRewardBlock = blockNumber;     } ```  ## Proof of Concept https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L288-L311 ## Tools Used None  ## Recommended Mitigation Steps  Add a check that _lpToken is not jpeg in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/121", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/118", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/110", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/109", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/108", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/107", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/104", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/103", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/93", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/91", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208 https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218   # Vulnerability details  ## Impact  If an attacker (lender) lends to a loan, the attacker can always revert transactions when any lenders try to buyout, making anyone can not buyout the loan of the attacker.  ## Proof of Concept  1. A victim calls `lend()`, trying to buyout the loan of the attacker. 2. In `lend()`, it always call `ERC20(loanAssetContractAddress).safeTransfer` to send `accumulatedInterest + previousLoanAmount` to `currentLoanOwner` (attacker). 3. If the `transfer` of `loanAssetContractAddress` is ERC777, it will call `_callTokensReceived` that the attacker can manipulate and always revert it. 4. Because `NFTLoanFacilitator` uses `safeTransfer` and `safeTransferFrom` to check return value, the transaction of the victim will also be reverted. It makes anyone can not buyout the loan of the attacker.  In `_callTokensReceived`, the attacker just wants to revert the buyout transaction, but keep `repayAndCloseLoan` successful. The attacker can call `loanInfoStruct(uint256 loanId)` in `_callTokensReceived` to check if the value of `loanInfo` is changed or not to decide to revert it.  ## Tools Used  vim  ## Recommended Mitigation Steps  Don't transfer `ERC20(loanAssetContractAddress)` to `currentLoanOwner` in `lend()`, use a global mapping to record redemption of lenders and add an external function `redeem` for lenders to transfer `ERC20(loanAssetContractAddress)`.   "}, {"title": "currentLoanOwner can manipulate loanInfo when any lenders try to buyout", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/88", "labels": ["bug", "help wanted", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208 https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218   # Vulnerability details  ## Impact  If an attacker already calls `lend()` to lend to a loan, the attacker can manipulate `loanInfo` by reentrancy attack when any lenders try to buyout. The attacker can set bad values of `lendInfo` (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.  ## Proof of Concept  An attacker lends a loan, and `loanAssetContractAddress` in `loanInfo` is ERC777 which is suffering from reentrancy attack. When a lender (victim) try to buyout the loan of the attacker:  1. The victim called `lend()`. 2. In `lend()`, it always call `ERC20(loanAssetContractAddress).safeTransfer` to send `accumulatedInterest + previousLoanAmount` to `currentLoanOwner` (attacker). 3. The `transfer` of `loanAssetContractAddress` ERC777 will call `_callTokensReceived` so that the attacker can call `lend()` again in reentrancy with parameters:     * loanId: same loan Id     * interestRate: set to bad value (e.g. 0)     * amount: same amount     * durationSeconds: set to bad value (e.g. a long durationSeconds)     * sendLendTicketTo: same address of the attacker (`currentLoanOwner`) 4. Now the variables in `loanInfo` are changed to bad value, and the victim will get the lend ticket but the loan term is manipulated, and can not set it back (because it requires a better term).  ## Tools Used  vim  ## Recommended Mitigation Steps  Use `nonReentrant` modifier on `lend()` to prevent reentrancy attack:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/87", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Borrower can be their own lender and steal funds from buyout due to reentrancy", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/85", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L214-L221 https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L230-L250   # Vulnerability details  ## Impact If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.  ## Proof of Concept This exploit requires that the `loanAssetContractAddress` token transfers control to the receiver.  ### Steps of exploit:  - Borrower creates loan with `createLoan()`. - The same Borrower calls `lend()`, funding their own loan. The Borrower receives the lend ticket, and funds are transferred to themself. - A new lender attempts to buy out the loan. The original loan amount + accruedInterest are sent to the original lender (same person as borrower). - Due to lack of checks-effects-interactions pattern, the borrower is able to immediately call `repayAndCloseLoan()` before the lend ticket is transferred to the new lender.  The following code illustrates that the new lender sends funds to the original lender prior to receiving the lend ticket in return.  ```             } else {                 ERC20(loan.loanAssetContractAddress).safeTransferFrom(                     msg.sender,                     currentLoanOwner,                     accumulatedInterest + previousLoanAmount                 );             }             ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId); ```  The original lender/borrower calls the following `repayAndCloseLoan()` function so that they receive their collateral NFT from the protocol.  ```     function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];           uint256 interest = _interestOwed(             loan.loanAmount,             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );           emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);         emit Close(loanId);     } ```  Finally, the new lender receives the lend ticket that has no utility at this point. The borrower now possesses the NFT, original loan amount, and accrued interest.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely.  If desired, also require that the lender cannot be the same account as the borrower of a loan.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "`sendCollateralTo` is unchecked in `closeLoan()`, which can cause user's collateral NFT to be frozen", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/83", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "`sendCollateralTo` is unchecked in `closeLoan()`, which can cause user's collateral NFT to be frozen"}, {"title": "`mintBorrowTicketTo` can be a contract with no `onERC721Received` method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/81", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "`mintBorrowTicketTo` can be a contract with no `onERC721Received` method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk"}, {"title": "`requiredImprovementRate` can not work as expected when `previousInterestRate` less than 10 due to precision loss", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/80", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179   # Vulnerability details   https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179  ```solidity {     uint256 previousInterestRate = loan.perAnumInterestRate;     uint256 previousDurationSeconds = loan.durationSeconds;      require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');     require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');      require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease     || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds      || (previousInterestRate != 0 // do not allow rate improvement if rate already 0         && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate),      \"NFTLoanFacilitator: proposed terms must be better than existing terms\"); } ```  The `requiredImprovementRate` represents the percentage of improvement required of at least one of the terms when buying out from a previous lender.  However, when `previousInterestRate` is less than `10` and `requiredImprovementRate` is `100`, due to precision loss, the new `interestRate` is allowed to be the same as the previous one.  Making such an expected constraint absent.  ### PoC  1. Alice `createLoan()` with `maxPerAnumInterest` = 10, received `loanId` = 1 2. Bob `lend()` with `interestRate` = 9  for `loanId` = 1 3. Charlie `lend()` with `interestRate` = 9 (and all the same other terms with Bob) and buys out `loanId` = 1  Charlie is expected to provide at least 10% better terms, but actually bought out Bob with the same terms.  ### Recommendation  Consider using: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/math/Math.sol#L39-L42  And change the check to:  ```solidity (previousInterestRate != 0 // do not allow rate improvement if rate already 0         && previousInterestRate - Math.ceilDiv(previousInterestRate * requiredImprovementRate, SCALAR) >= interestRate) ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/77", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/76", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "Protocol doesn't handle fee on transfer tokens", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L155-L160   # Vulnerability details  ## Impact Since the borrower is able to specify any asset token, it is possible that loans will be created with tokens that support fee on transfer. If a fee on transfer asset token is chosen, the protocol will contain a point of failure on the original `lend()` call.  It is my belief that this is a medium severity vulnerability due to its ability to impact core protocol functionality.  ## Proof of Concept  For the first lender to call `lend()`, if the transfer fee % of the asset token is larger than the origination fee %, the second transfer will fail in the following code:  ```             ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);             uint256 facilitatorTake = amount * originationFeeRate / SCALAR;             ERC20(loanAssetContractAddress).safeTransfer(                 IERC721(borrowTicketContract).ownerOf(loanId),                 amount - facilitatorTake             ); ```  Example: - `originationFee = 2%` Max fee is 5% per comments - `feeOnTransfer = 3%` - `amount = 100 tokens`  - Lender transfers `amount` - `NFTLoanFacilitator` receives `97`. - `facilitatorTake = 2` - `NFTLoanFacilitator` attempts to send `100 - 2` to borrower, but only has `97`. - Execution reverts.  ### Other considerations: If the originationFee is less than or equal to the transferFee, the transfers will succeed but will be received at a loss for the borrower and lender. Specifically for the lender, it might be unwanted functionality for a lender to lend 100 and receive 97 following a successful repayment (excluding interest for this example).  ## Tools Used Manual review.  ## Recommended Mitigation Steps Since the `originationFee` is calculated based on the `amount` sent by the lender, this calculation will always underflow given the example above. Instead, a potential solution would be to calculate the `originationFee` based on the requested loan amount, allowing the lender to send a greater value so that `feeOnTransfer <= originationFee`.  Oppositely, the protocol can instead calculate the amount received from the initial transfer and use this amount to calculate the `originationFee`. The issue with this option is that the borrower will receive less than the desired loan amount.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/67", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/57", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/55", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/46", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/44", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/31", "labels": ["bug", "help wanted", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Might not get desired min loan amount if `_originationFeeRate` changes", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L309   # Vulnerability details  ## Impact Admins can update the origination fee by calling `updateOriginationFeeRate`. Note that a borrower does not receive their `minLoanAmount` set in `createLoan`, they only receive `(1 - originationFee) * minLoanAmount`, see [`lend`](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L159). Therefore, they need to precalculate the `minLoanAmount` using the **current** origination fee to arrive at the post-fee amount that they actually receive. If admins then increase the fee, the borrower receives fewer funds than required to cover their rent and might become homeless.  ## Recommended Mitigation Steps Reconsider how the min loan amount works. Imo, this `minLoanAmount` should be the post-fee amount, not the pre-fee amount. It's also more intuitive for the borrower when creating the loan.   "}, {"title": "Borrowers lose funds if they call `repayAndCloseLoan` instead of `closeLoan`", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L241   # Vulnerability details  ## Impact The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan (matched with `lend`). Users should use `closeLoan` in this case but the contract should disallow calling `repayAndCloseLoan` because users can lose funds.  It performs a `ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount)` call where `interest` will be a high value accumulated from timestamp 0 and the `loan.loanAmount` is the initially desired min loan amount `minLoanAmount` set in `createLoan`. The user will lose these funds if they ever approved the contract (for example, for another loan).  ## Recommended Mitigation Steps Add a check that there actually is something to repay.  ```solidity require(loan.lastAccumulatedTimestamp > 0, \"loan was never matched by a lender. use closeLoan instead\"); ```   "}, {"title": "Can force borrower to pay huge interest", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/24", "labels": ["bug", "enhancement", "3 (High Risk)", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "Can force borrower to pay huge interest"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-backed-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/2", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-backed-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/42", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "Not calling `approve(0)` before setting a new approval causes the call to revert when used with Tether (USDT)", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/39", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48 https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58 https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418   # Vulnerability details  Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  ## Impact The code as currently implemented does not handle these sorts of tokens properly when they're a Uniswap pool asset, which would prevent USDT, the sixth largest pool, from being used by this project. This project relies heavily on Uniswap, so this would hamper future growth and availability of the protocol.  ## Proof of Concept  1. File: contracts/vault_and_oracles/FlashLoan.sol (line [48](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48)) ```solidity         IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]); ```  2. File: contracts/vault_and_oracles/FlashLoan.sol (line [58](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58)) ```solidity         IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing); ```  3. File: contracts/vault_and_oracles/UniV3LpVault.sol (line [418](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418)) ```solidity             IERC20Detailed(params.asset).approve(msg.sender, owedBack); ```  There are other calls to `approve()`, but they correctly set the approval to zero after the transfer is done, so that the next approval can go through.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Use OpenZeppelin\u2019s `SafeERC20`'s `safeTransfer()` instead   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/32", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "Arbitrary contract call within `UniV3LpVault._swap` with controllable `swapPath`", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L621 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L379 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L520 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L521   # Vulnerability details  ## Impact  `UniV3LpVault._swap` utilizes `swapRouter.exactInput` to perform swaps between two tokens. During swaps, `transfer` function of each token along the path will be called to propagate the assets.  Since anyone can create a uniswap pair of arbitrary assets, it is possible to include intermediate hop with malicious tokens within the path. Thus `UniV3LpVault._swap` effectively grants users the ability to perform arbitrary contract calls during the swap process if `swapPath` is not validated properly.  Usage of invalidated `swapPath` can be found in `UniV3LpVault.flashFocusCall` and `UniV3LpVault.repayDebt`.  ## Proof of Concept  The security of `Comptroller` and `UniV3LpVault` relies on validating all used tokens thoroughly. This is done by a whitelist mechanism where admin decides a predefined set of usable tokens, and users can only perform actions within the allowed range. This whitelist approach eliminates most of the attack surface regarding directly passing in malicious tokens as arguments.  Apart from passing malicious tokens directly, there are a few other potential weaknesses, the most obvious one is leveraging flash loans for collaterals. However, due to the adoption of AAVE LendingPool, the external validation within flash loan pool blocks this approach.  Unfortunately, a more obscure path exists. Looking at the swapping mechanism, it is not hard to realize it is backed by uniswapV3. An interesting characteristic of uniswap pools is that anyone can create pools for any token pairs, thus if we don't fully validate each and every pool we are using, chances are there will be malicious entries hidden within them.  This is partially the case which we see here, the user gets to supply a path, where the source and target are validated against benign tokens, the intermediate ones are not. An example of utilizing path for arbitrary function call is illustrated below 1. Create malicious token tokenM 2. Create pools tokenS<->tokenM and tokenM<->tokenT where tokenS and tokenT are benign tokens 3. Supply path (tokenS, tokenM, tokenT) for swapping  In the above case, when transferring tokenM while doing swap, we have full control over code executed and can insert arbitrary contract calls within.  Noticeably, while gaining arbitrary contract calls sounds dangerous, it does not necessarily mean the contract is exploitable. It still depends on the scenario in which an arbitrary call happens.  In the case of duality, the two locations where arbitrary `swapPath` can be provided is in `flashFocusCall` and `repayDebt`, both in which holds a local lock over `UniV3LpVault`. No global are applied to `Comptroller` or `Ctokens` while performing swaps.  ```     function flashFocusCall(FlashFocusParams calldata params) external override {         ...         {             ...             if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);             ...         }         ...     }      function flashFocus(FlashFocusParams calldata params)         external         override         nonReentrant(true)         isAuthorizedForToken(params.tokenId)         avoidsShortfall     {         ...         flashLoan.LENDING_POOL().flashLoan(             receiverAddress,             assets,             amounts,             modes,             onBehalfOf,             newParams,             referralCode         );     }      function repayDebt(RepayDebtParams calldata params)         external         override         nonReentrant(true)         isAuthorizedForToken(params.tokenId)         avoidsShortfall         returns (uint256 amountReturned)     {         ...         {             ...             if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);             if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);             ...         }         ...     } ```   The lack of global locks here had us doubting whether an attack is possible. While we spent a considerable amount of time and failed to come up with any possible attack vectors, the complexity of the system held us back from concluding that an attack is impossible.  Thus we report this finding here in hope of inspiring developers either to prove the attack impossible or mitigate the attack surface.  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  The easiest way to mitigate this is to validate the entire path against a predefined whitelist while in `_checkSwapPath`. This approach is far from optimal and also limits the flexibility of swapping between tokens. However, before security is proved, this is the best approach we can come up with.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "Dysfunctional `CToken._acceptAdmin` due to lack of function to assign `pendingAdmin`", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/CToken.sol#L1379   # Vulnerability details  ## Impact  The implementation of `CToken` in Duality introduced an `_acceptAdmin` function, which presumably should allow changing the `admin`. However, there does not exist a pairing `proposePendingAdmin` function that can propose a new `pendingAdmin`, thus `pendingAdmin` will never be set. This renders the `_acceptAdmin` function useless.  ## Proof of Concept  `_acceptAdmin` requires `msg.sender` to equal `pendingAdmin`, however, since `pendingAdmin` can never be set, it will always be `address(0)`, making this function unusable.  ```     function _acceptAdmin() external returns (uint256) {         // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)         if (msg.sender != pendingAdmin || msg.sender == address(0)) {             return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);         }         // Save current values for inclusion in log         address oldAdmin = admin;         address oldPendingAdmin = pendingAdmin;         // Store admin with value pendingAdmin         admin = pendingAdmin;         // Clear the pending value         pendingAdmin = address(0);         emit NewAdmin(oldAdmin, admin);         emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);         return uint256(Error.NO_ERROR);     } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Add a `proposePendingAdmin` function where the current admin can propose successors.  ```     function _proposePendingAdmin(address newPendingAdmin) external {         if (msg.sender != admin) {             return fail(Error.UNAUTHORIZED, FailureInfo.PROPOSE_PENDING_ADMIN_CHECK);         }         address oldPendingAdmin = pendingAdmin;         pendingAdmin = newPendingAdmin;         emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);         return uint256(Error.NO_ERROR)     } ```   "}, {"title": "`Comptroller._setUniV3LpVault` will always cause in-use uniswapV3 positions to become stuck in `UniV3LpVault`", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/Comptroller.sol#L1105   # Vulnerability details  ## Impact  `Comptroller._setUniV3LpVault` allows the admin of `Comptroller` to change the accompanying `UniV3LpVault`. However since actions including collateral calculation, uniswapV3 position withdrawal, uniswapV3 collateral liquidation all require `Comptroller` and `UniV3LpVault` to cooperate seamlessly, a change in `Comptroller.uniV3LpVault` would mean all the above actions are no longer performable on existing NFTs.  ## Proof of Concept  `_setUniV3LpVault` allows changing of `uniV3LpVault`.  ```     function _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {         ...         uniV3LpVault = newVault;         ...     } ```  However, functions such as `UniV3LpVault.withdrawToken` require `Comptroller` to estimate NFT collateral value. This estimation can only be done when the address of `UniV3LpVault` matches `Comptroller.uniV3LpVault` as shown in `addNFTCollateral` below.  ``` contract UniV3LpVault is IUniV3LpVault {     ...     function withdrawToken(...) external override nonReentrant(false) avoidsShortfall {         ...     }      modifier avoidsShortfall() {         _;         (, , uint256 shortfall) = comptroller.getAccountLiquidity(msg.sender);         require(shortfall == 0, \"insufficient liquidity\");     }     ... }  contract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {     ...     function getAccountLiquidity(address account) public view returns (...) {         (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(...);         ...     }      function getHypotheticalAccountLiquidityInternal(...) internal view returns (...) {         ...         addNFTCollateral(account, vars);         ...     }      function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {         uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);         for (uint256 i = 0; i < userTokensLength; i++) {             ...             {                 ...                 address poolAddress = uniV3LpVault.getPoolAddress(tokenId);                 ...             }             ...         }         ...     } } ``` The mutual reliance causes NFT tokens to become stuck. In some cases users can solve this issue by depositing more collateral to cover the shortcoming caused by \"disappearing NFTs\". In other cases such as liquidation, the functionality becomes downright broken and unuseable..  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Remove the option to change `Comptroller.uniV3LpVault` altogether, as this functionality is not really helpful for the overall protocol. Another way to handle this is to forcefully evict all NFTs before changing the vault. However, this is extremely complex as it would potentially cause users to become severely under-collateralized, and would require more care in tracking and maintaining states.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "Improper Access Control", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/25", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "Improper Access Control"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/23", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "Undercollateralized loans possible", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/Comptroller.sol#L1491   # Vulnerability details  ## Impact The `_setPoolCollateralFactors` function does not check that the collateral factor is < 100%. It's possible that it's set to 200% and then borrows more than the collateral is worth, stealing from the pool.  ## Recommended Mitigation Steps Disable the possibility of ever having a collateral factor > 100% by checking:  ```diff for (uint256 i = 0; i < pools.length; i++) { +   require(collateralFactorsMantissa[i] <= 1e18, \"CF > 100%\");     poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i]; } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/11", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-dualityfocus-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/35", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2022-04-axelar-findings", "body": "Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/33", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/27", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/21", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/20", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "`_execute` can potentially reorder a batch of commands while executing, breaking any assumptions on command orders.", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-04-axelar-findings", "body": "`_execute` can potentially reorder a batch of commands while executing, breaking any assumptions on command orders."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/15", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "User's funds can get lost when transferring to other chain", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-04-axelar-findings", "body": "User's funds can get lost when transferring to other chain"}, {"title": "Low level call returns true if the address doesn't exist", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGateway.sol#L545-L548 https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGatewayProxy.sol#L16-L24   # Vulnerability details  ## Impact As written in the [solidity documentation](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions), the low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.   ## Proof of Concept The low-level functions `call` and `delegatecall` are used in some places in the code and it can be problematic. For example, in the `_callERC20Token` of the `AxelarGateway` contract there is a low level call in order to call the ERC20 functions, but if the given `tokenAddress` doesn't exist `success` will be equal to true and the function will return true and the code execution will be continued like the call was successful.  ```sol function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {     (bool success, bytes memory returnData) = tokenAddress.call(callData);     return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool))); } ``` Another place that this can happen is in `AxelarGatewayProxy`'s constructor ```sol constructor(address gatewayImplementation, bytes memory params) {     _setAddress(KEY_IMPLEMENTATION, gatewayImplementation);     (bool success, ) = gatewayImplementation.delegatecall(        abi.encodeWithSelector(IAxelarGateway.setup.selector, params)    );      if (!success) revert SetupFailed(); } ``` If the `gatewayImplementation` address doesn't exist, the delegate call will return true and the function won't revert.  ## Tools Used Remix, VS Code  ## Recommended Mitigation Steps Check before any low-level call that the address actually exists, for example before the low level call in the callERC20 function you can check that the address is a contract by checking its code size.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/9", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/6", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "Unsupported fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/5", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGateway.sol#L284-L334   # Vulnerability details  ## Impact When tokenAddress is fee-on-transfer tokens, in the _burnTokenFrom function, the actual amount of tokens received by the contract will be less than the amount. ## Proof of Concept https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGateway.sol#L284-L334 ## Tools Used None ## Recommended Mitigation Steps Consider getting the received amount by calculating the difference of token balance (using balanceOf) before and after the transferFrom.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "QA Report"}, {"title": "Anybody can destroy contract and take all the ether", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/3", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-axelar-findings", "body": "Anybody can destroy contract and take all the ether"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/2", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-axelar-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/238", "labels": [], "target": "2022-04-badger-citadel-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/235", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/234", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/233", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/232", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/231", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/230", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/229", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/227", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/226", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/224", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/223", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/220", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "StakedCitadel depositors can be attacked by the first depositor with depressing of vault token denomination", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/217", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-04-badger-citadel-findings", "body": "StakedCitadel depositors can be attacked by the first depositor with depressing of vault token denomination"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/213", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/212", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/211", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/209", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/207", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/206", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/204", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/200", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/199", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/196", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/193", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/191", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "no sanity checks on minDiscount", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/185", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L356   # Vulnerability details  Unlike maxDiscount, minDiscount is missing some sanity checks: minDiscount should be smaller than MAX_BPS minDoscount should be smaller than maxDiscount  "}, {"title": "StakedCitadel withdraw when available balance is not sufficient --> rekt some of the capital of the user", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/183", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-badger-citadel-findings", "body": "StakedCitadel withdraw when available balance is not sufficient --> rekt some of the capital of the user"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/181", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/180", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/179", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/177", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Stale price used when `citadelPriceFlag` is cleared", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/176", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L430-L437   # Vulnerability details  During the [video](https://drive.google.com/file/d/1hCzQrgZEsbd0t2mtuaXm7Cp3YS-ZIlw3/view?usp=sharing) it was explained that the policy operations team was meant to be a nimble group that could change protocol values considered to be safe. Further, it was explained that since pricing comes from an oracle, and there would have to be unusual coordination between the two to affect outcomes, the group was given the ability to clear the pricing flag to get things moving again once the price was determined to be valid  ## Impact If an oracle price falls out of the valid min/max range, the `citadelPriceFlag` is set to true, but the out-of-bounds value is not stored. If the policy operations team calls `clearCitadelPriceFlag()`, the stale price from before the flag will be used. Not only is it an issue because of stale prices, but this means the policy op team now has a way to affect pricing not under the control of the oracle (i.e. no unusual coordination required to affect an outcome). Incorrect pricing leads to incorrect asset valuations, and loss of funds.  ## Proof of Concept  The flag is set but the price is not stored File: src/Funding.sol (lines [427-437](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L427-L437)) ```solidity         if (             _citadelPriceInAsset < minCitadelPriceInAsset ||             _citadelPriceInAsset > maxCitadelPriceInAsset         ) {             citadelPriceFlag = true;             emit CitadelPriceFlag(                 _citadelPriceInAsset,                 minCitadelPriceInAsset,                 maxCitadelPriceInAsset             );         } else { ```  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always set the `citadelPriceInAsset`   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/170", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/169", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Out of Gas can block the MedianOracle", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/168", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "Out of Gas can block the MedianOracle"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/166", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/164", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/162", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/160", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "New vest reset `unlockBegin` of existing vest without removing vested amount", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/158", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143 https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109   # Vulnerability details  ## Impact When `vest` is called by xCTDL vault, the previous amount will re-lock according to the new vesting timeline. While this is as described in L127, `claimableBalance` might revert due to underflow if `vesting[recipient].claimedAmounts` > 0 because the user will need to vest the `claimedAmounts` again which should not be an expected behavior as it is already vested.  ## Proof of Concept https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143 ```         vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts +             _amount;         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration; ``` https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109 ```         uint256 locked = vesting[recipient].lockedAmounts;         uint256 claimed = vesting[recipient].claimedAmounts;         if (block.timestamp >= vesting[recipient].unlockEnd) {             return locked - claimed;         }         return             ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /                 (vesting[recipient].unlockEnd -                     vesting[recipient].unlockBegin)) - claimed; ```  ## Recommended Mitigation Steps Reset claimedAmounts on new vest ```         vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts -              vesting[recipient].claimedAmounts +             _amount;         vesting[recipient].claimedAmounts = 0         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration; ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/157", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/156", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/155", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/152", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "the earning amount can bypass toEarnBps", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-badger-citadel-findings", "body": "the earning amount can bypass toEarnBps"}, {"title": "Funding.deposit() doesn't work if there is no discount set", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/149", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L177 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L202 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L184 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L769   # Vulnerability details  ## Impact The Funding contract's `deposit()` function uses the `getAmountOut()` function to determine how many citadel tokens the user should receive for their deposit. But, if no discount is set, the function always returns 0. Now the `deposit()` function tries to deposit 0 tokens for the user through the StakedCitadel contract. But, that function requires the number of tokens to be `!= 0`. The transaction reverts.  This means, that no deposits are possible. Unless there is a discount.  ## Proof of Concept `Funding.deposit()` calls `getAmountOut()`: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L177  Here's the [`getAmountOut()` function](https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L202): ```sol     function getAmountOut(uint256 _assetAmountIn)         public         view         returns (uint256 citadelAmount_)     {         uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;          if (funding.discount > 0) {             citadelAmount_ =                 (citadelAmountWithoutDiscount * MAX_BPS) /                 (MAX_BPS - funding.discount);         }          // unless the above if block is executed, `citadelAmount_` is 0 when this line is executed.         // 0 = 0 / x         citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;     } ```  Call to `StakedCitadel.depositFor()`: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L184  require statement that makes the whole transaction revert: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L769  ## Tools Used none  ## Recommended Mitigation Steps Change the `getAmountOut()` function to:  ```sol     function getAmountOut(uint256 _assetAmountIn)         public         view         returns (uint256 citadelAmount_)     {          uint256 citadelAmount_ = _assetAmountIn * citadelPriceInAsset;          if (funding.discount > 0) {             citadelAmount_ =                 (citadelAmount_ * MAX_BPS) /                 (MAX_BPS - funding.discount);         }          citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;     } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/145", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/144", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/136", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/133", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/132", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/128", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/121", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/118", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/117", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/115", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/114", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/111", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/110", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/109", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/104", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/102", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/99", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/93", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/86", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/85", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/82", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/80", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/77", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "StakedCitadel doesn't use correct balance for internal accounting", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/74", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L772-L776 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L893   # Vulnerability details  ## Impact The StakedCitadel contract's `balance()` function is supposed to return the balance of the vault + the balance of the strategy. But, it only returns the balance of the vault. The balance is used to determine the number of shares that should be minted when depositing funds into the vault and the number of shares that should be burned when withdrawing funds from it.  Since most of the funds will be located in the strategy, the vault's balance will be very low. Some of the issues that arise from this:  **You can't deposit to a vault that already minted shares but has no balance of the underlying token**:  1. fresh vault with 0 funds and 0 shares 2. Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888) 3. Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`) 4. Bob tries to deposit but the transaction fails because the contract tries to divide by zero: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890 (`pool == balance()`)  **You get more shares than you should** 1. fresh vault with 0 funds and 0 shares 2. Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888) 3. Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`) 4. Bob now first transfers 1 token to the vault so that the balance is now `1` instead of `0`. 5. Bob deposits 5 tokens. He receives `5 * 10 / 1 == 50` shares: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890  Now, the vault received 15 tokens. 10 from Alice and 5 from Bob. But Alice only has 10 shares while Bob has 50. Thus, Bob can withdraw more tokens than he should be able to.  It simply breaks the whole accounting of the vault.  ## Proof of Concept The comment says that it should be vault's + strategy's balance: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295  Here's another vault from the badger team where the function is implemented correctly: https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262  ## Tools Used none  ## Recommended Mitigation Steps Add the strategy's balance to the return value of the`balance()` function like [here](https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262).  "}, {"title": "KnightingRound tokenOutPrice changes", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/73", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204   # Vulnerability details  ## Impact `Function.buy` buys the tokens for whatever price is set as `tokenOutPrice`. This might lead to accidental collisions or front-running attacks when user is trying to buy the tokens and his transaction is being included after the transaction of changing the price of the token via `setTokenOutPrice`.  Scenario: 1. User wants to `buy` tokens and can see price `tokenOutPrice` 2. User likes the price and issues a transaction to `buy` tokens 3. At the same time `CONTRACT_GOVERNANCE_ROLE` account is increasing `tokenOutPrice` through `setTokenOutPrice` 4. `setTokenOutPrice` transaction is included before user's `buy` transaction 5. User buys tokens with the price he was not aware of  Another variation of this attack can be performed using front-running.  ## Proof of Concept * https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add additional parameter `uint256 believedPrice` to `KnightingRound.buy` function and check if `believedPrice` is equal to `tokenOutPrice`.  "}, {"title": "Dust accumulation in minter", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/72", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "Dust accumulation in minter"}, {"title": "Guaranteed citadel profit", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/CitadelMinter.sol#L217   # Vulnerability details  ## Impact User can sandwich `mintAndDistribute` function if mintable is high enough - Deposit before - Withdraw after - Take after 21 days citadels  ## Proof of Concept `mintAndDistribute` increase a price of staking share, that allows to withdraw more than deposited. user takes part of distributed citadels, so different users have smaller profit from distribution  ## Tools Used  ## Recommended Mitigation Steps Call `mintAndDistribute` through flashbots  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/68", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "`StakedCitadel`: more shares might be burned", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-badger-citadel-findings", "body": "`StakedCitadel`: more shares might be burned"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/59", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/57", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/54", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/52", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/50", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/35", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/23", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/20", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/16", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/15", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/11", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "StakedCitadel: wrong setupVesting function name", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/9", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830   # Vulnerability details  ## Impact In the _withdraw function of the StakedCitadel contract, the setupVesting function of vesting is called, while in the StakedCitadelVester contract, the function name is vest, which will cause the _withdraw function to fail, so that the user cannot withdraw the tokens.  ```         IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);         token.safeTransfer(vesting, _amount);         ...     function vest(         address recipient,         uint256 _amount,         uint256 _unlockBegin     ) external {         require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");         require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");          vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts +             _amount;         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;          emit Vest(             recipient,             vesting[recipient].lockedAmounts,             _unlockBegin,             vesting[recipient].unlockEnd         );     } ``` ## Proof of Concept https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/interfaces/citadel/IVesting.sol#L5  ## Tools Used None ## Recommended Mitigation Steps  Use the correct function name ``` interface IVesting {     function vest(         address recipient,         uint256 _amount,         uint256 _unlockBegin     ) external; } ... IVesting(vesting).vest(msg.sender, _amount, block.timestamp); token.safeTransfer(vesting, _amount); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/1", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/211", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/209", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/204", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/202", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/199", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/198", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Malicious Stakers can grief Keepers", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/194", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L727-L729   # Vulnerability details  ## Impact  A Staker -- that has their top-up position removed after `execute` is called by a Keeper -- can always cause the transaction to revert. They can do this by deploying a smart contract to the `payer` address that has implemented a `receive()` function that calls `revert()`. The revert will be triggered by the following [lines](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L727-L729) in `execute`  ```sol if (vars.removePosition) {     gasBank.withdrawUnused(payer); } ```  This will consume some gas from the keeper while preventing them accruing any rewards for performing the top-up action.  ## Proof of Concept  I have implemented a [PoC](https://github.com/sseefried/codearena-backd-2022-04/blob/4d3c3ba7a0139bea01a0bdee9e84a7921572a9fd/backd/tests/top_up_action/sseefried_test_staker_grief.py) in a fork of the contest repo. The attacker's contract can be found [here](https://github.com/sseefried/codearena-backd-2022-04/blob/4d3c3ba7a0139bea01a0bdee9e84a7921572a9fd/backd/contracts/AliceAttacker.sol).  ## Tools Used Manual inspection  ## Recommend Mitigation Steps  To prevent this denial of service attack some way of blacklisting badly behaved Stakers should be added.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/192", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/191", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/188", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/187", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/185", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/183", "labels": ["bug", "G (Gas Optimization)", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/182", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Lack of `safeApprove(0)` prevents some registrations, and the changing of stakers and LP tokens", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L50 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L721   # Vulnerability details  OpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value ```solidity     function safeApprove(         IERC20 token,         address spender,         uint256 value     ) internal {         // safeApprove should only be called when setting an initial allowance,         // or when resetting it to zero. To increase and decrease it, use         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'         require(             (value == 0) || (token.allowance(address(this), spender) == 0),             \"SafeERC20: approve from non-zero to non-zero allowance\"         );         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));     } ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58  ## Impact Customers can be prevented from `register()`ing the same `token`/`stakerVaultAddress` as another customer; and once changed away from, stakers and lptokens can't be used in the future.  ## Proof of Concept There are multiple places where `safeApprove()` is called a second time without setting the value to zero first.  `register()` calls `lockFunds()` for each user registration, and since users will use the same tokens and staker vaults, the second user's `register()` call will fail: ```solidity File: backd/contracts/actions/topup/TopUpAction.sol   #1  36       function lockFunds( 37           address stakerVaultAddress, 38           address payer, 39           address token, 40           uint256 lockAmount, 41           uint256 depositAmount 42       ) external { 43           uint256 amountLeft = lockAmount; 44           IStakerVault stakerVault = IStakerVault(stakerVaultAddress); 45    46           // stake deposit amount 47           if (depositAmount > 0) { 48               depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount; 49               IERC20(token).safeTransferFrom(payer, address(this), depositAmount); 50               IERC20(token).safeApprove(stakerVaultAddress, depositAmount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L36-L50  The changing of either the staker or an lp token is behind a time-lock, and once the time has passed, the changed variables rely on this function: ```solidity File: backd/contracts/pool/LiquidityPool.sol   #2  717       function _approveStakerVaultSpendingLpTokens() internal { 718           address staker_ = address(staker); 719           address lpToken_ = address(lpToken); 720           if (staker_ == address(0) || lpToken_ == address(0)) return; 721           IERC20(lpToken_).safeApprove(staker_, type(uint256).max); 722       } ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L717-L722  If a bug is found in a new `staker` or `lpToken` and the governor wishes to change back to the old one(s), the governor will have to wait for the time-lock delay only to find out that the old value(s) cause the code to revert.  I've filed the other more-severe instances as a separate high-severity issue, and flagged the remaining low-severity instances in my QA report  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`   "}, {"title": "Customers cannot be `topUp()`ed a second time", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/178", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L71 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L120 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L53 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L847   # Vulnerability details  OpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value ```solidity     function safeApprove(         IERC20 token,         address spender,         uint256 value     ) internal {         // safeApprove should only be called when setting an initial allowance,         // or when resetting it to zero. To increase and decrease it, use         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'         require(             (value == 0) || (token.allowance(address(this), spender) == 0),             \"SafeERC20: approve from non-zero to non-zero allowance\"         );         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));     } ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58  ## Impact Customers cannot be topped up a second time, which will cause them to be liquidated even though they think they're protected  ## Proof of Concept There are multiple places where `safeApprove()` is called a second time without setting the value to zero first. The instances below are all related to topping up.  Compound-specific top-ups will fail the second time around when approving the `ctoken` again: ```solidity File: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #1  50       function topUp( 51           bytes32 account, 52           address underlying, 53           uint256 amount, 54           bytes memory extra 55       ) external override returns (bool) { 56           bool repayDebt = abi.decode(extra, (bool)); 57           CToken ctoken = cTokenRegistry.fetchCToken(underlying); 58           uint256 initialTokens = ctoken.balanceOf(address(this)); 59    60           address addr = account.addr(); 61    62           if (repayDebt) { 63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken); 64               if (amount == 0) return true; 65           } 66    67           uint256 err; 68           if (underlying == address(0)) { 69               err = ctoken.mint{value: amount}(amount); 70           } else { 71               IERC20(underlying).safeApprove(address(ctoken), amount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L50-L71  Compound-specific top-ups will also fail when trying to repay debt: ```solidity File: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #2  62           if (repayDebt) { 63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken); 64               if (amount == 0) return true; 65           } ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L62-L65  Aave-specific top-ups will fail for the `lendingPool`: ```solidity File: backd/contracts/actions/topup/handlers/AaveHandler.sol   #3  36       function topUp( 37           bytes32 account, 38           address underlying, 39           uint256 amount, 40           bytes memory extra 41       ) external override returns (bool) { 42           bool repayDebt = abi.decode(extra, (bool)); 43           if (underlying == address(0)) { 44               weth.deposit{value: amount}(); 45               underlying = address(weth); 46           } 47    48           address addr = account.addr(); 49    50           DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying); 51           require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED); 52    53           IERC20(underlying).safeApprove(address(lendingPool), amount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L36-L53  The `TopUpAction` itself fails for the `feeHandler`: ```solidity File: backd/contracts/actions/topup/TopUpAction.sol   #4  840       function _payFees( 841           address payer, 842           address beneficiary, 843           uint256 feeAmount, 844           address depositToken 845       ) internal { 846           address feeHandler = getFeeHandler(); 847           IERC20(depositToken).safeApprove(feeHandler, feeAmount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L840-L847  I've filed the other less-severe instances as a separate medium-severity issue, and flagged the remaining low-severity instances in my QA report  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/175", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/174", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/172", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/170", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/168", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "_revokeRole doesn't remove account from roleMember set", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/164", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/access/RoleManager.sol#L155   # Vulnerability details  ## Impact The function doesn't remove the address from _roleMembers[role] set, which will mess up with the roleCount  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps ``` _roles[role].members[account] = false; _roleMembers[role].remove(account); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/162", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "CvxCrvRewardsLocker implements a swap without a slippage check that can result in a loss of funds through MEV", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/161", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252   # Vulnerability details  ## Impact The CvxCrvRewardsLocker contract swaps tokens through the CRV cvxCRV pool. But, it doesn't use any slippage checks. The swap is at risk of being frontrun / sandwiched which will result in a loss of funds.  Since MEV is very prominent I think the chance of that happening is pretty high.  ## Proof of Concept Here's the swap: https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252  ## Tools Used none  ## Recommended Mitigation Steps Use a proper value for `minOut` instead of `0`.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/160", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/151", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/148", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/137", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/136", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "[WP-M11] `CEthInterface#mint()` reading non-existing returns makes `topUp()` with native token alway revert", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/125", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L345   # Vulnerability details  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L345  ```solidity  function mint() external payable returns (uint256); ```  `mint()` for native cToken (`CEther`) will return nothing, while the current `CEthInterface` interface defines the returns as `(uint256)`.  In the current implementation, the interface for `CToken` is used for both `CEther` and `CErc20`.  As a result, the transaction will revert with the error: `function returned an unexpected amount of data` when `topUp()` with the native token (ETH).  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L57-L70  ```solidity     CToken ctoken = cTokenRegistry.fetchCToken(underlying);     uint256 initialTokens = ctoken.balanceOf(address(this));      address addr = account.addr();      if (repayDebt) {         amount -= _repayAnyDebt(addr, underlying, amount, ctoken);         if (amount == 0) return true;     }      uint256 err;     if (underlying == address(0)) {         err = ctoken.mint{value: amount}(amount);     } ```  Ref:  | method  | CEther | CErc20 | |----------|------------|-------------| | mint()   | revert      | error code  | | redeem() | error code | error code  | | repayBorrow() | revert | error code  | | repayBorrowBehalf() | revert | error code  |   - Compound's cToken mint doc: https://compound.finance/docs/ctokens#mint - Compound CEther.mint() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L46 - Compound CErc20.mint() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CErc20.sol#L46  "}, {"title": "[WP-M9] `CEthInterface#repayBorrowBehalf()` reading non-existing returns makes  `_repayAnyDebt()` with CEther always revert", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/121", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L355-L358   # Vulnerability details  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L355-L358  ```solidity function repayBorrowBehalf(address borrower, uint256 repayAmount)         external         payable         returns (uint256); ```  `repayBorrowBehalf()` for native cToken (`CEther`) will return nothing, while the current `CEthInterface` interface defines the returns as `(uint256)`.  As a result, `ether.repayBorrowBehalf()` will always revert  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L117-L118  ```solidity     CEther cether = CEther(address(ctoken));     err = cether.repayBorrowBehalf{value: debt}(account); ```  Ref:  | method  | CEther | CErc20 | |----------|------------|-------------| | mint()   | revert      | error code  | | redeem() | error code | error code  | | repayBorrow() | revert | error code  | | repayBorrowBehalf() | revert | error code  |   - Compound cToken Repay Borrow Behalf doc: https://compound.finance/docs/ctokens#repay-borrow-behalf - Compound CEther.repayBorrowBehalf() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L92-L95 - Compound CErc20.repayBorrowBehalf() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CErc20.sol#L94-L97  "}, {"title": "[WP-M8] `CompoundHandler#topUp()` Using the wrong function selector makes native token `topUp()` always revert", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/120", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L44-L47   # Vulnerability details  https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L44-L47  ```solidity function mint() external payable {     (uint err,) = mintInternal(msg.value);     requireNoError(err, \"mint failed\"); } ```  `mint()` for native cToken (`CEther`) does not have any parameters, as the `Function Selector` is based on `the function name with the parenthesised list of parameter types`, when you add a nonexisting `parameter`, the `Function Selector` will be incorrect.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L316  ```solidity     function mint(uint256 mintAmount) external payable virtual returns (uint256); ```  The current implementation uses the same `CToken` interface for both `CEther` and `CErc20` in `topUp()`, and `function mint(uint256 mintAmount)` is a nonexisting function for `CEther`.  As a result, the native token `topUp()` always revert.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L57-L70  ```solidity     CToken ctoken = cTokenRegistry.fetchCToken(underlying);     uint256 initialTokens = ctoken.balanceOf(address(this));      address addr = account.addr();      if (repayDebt) {         amount -= _repayAnyDebt(addr, underlying, amount, ctoken);         if (amount == 0) return true;     }      uint256 err;     if (underlying == address(0)) {         err = ctoken.mint{value: amount}(amount);     } ```  See also:  - Compound's cToken mint doc: https://compound.finance/docs/ctokens#mint  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/113", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/109", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/107", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/105", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/99", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Inconsistency between constructor and setting method for slippageTolerance", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L38-L43 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L109-L114   # Vulnerability details  ## Impact in the setSlippageTolerance(L119) method you have certain requirements to set slippageTolerance, but in the constructor you don't.    ## Recommended Mitigation Steps I would add the corresponding validations to the constructor   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Position owner should set allowed slippage", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L154 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L187   # Vulnerability details  ## Impact The default swap slippage of 5% allows malicious keepers to sandwich attack topup. Additionally, up to 40% (_MIN_SWAPPER_SLIPPAGE) slippage allows malicious owner to sandwich huge amounts from topup  ## Proof of Concept Keeper can bundle swaps before and after topup to sandwich topup action, in fact it's actually in their best interest to do so.  ## Tools Used  ## Recommended Mitigation Steps Allow user to specify max swap slippage when creating topup similar to how it's specified on uniswap or sushiswap to block attacks from both keepers and owners  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/81", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/67", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "function lockFunds in TopUpActionLibrary can cause serious fund lose. fee and Capped bypass. It's not calling stakerVault.increaseActionLockedBalance when transfers stakes.", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/60", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L57-L65   # Vulnerability details  ## Impact In function TopUpActionLibrary.lockFunds when transfers stakes from payer it doesn't call stakerVault.increaseActionLockedBalance for that payer so stakerVault.actionLockedBalances[payer] is not get updated for payer and stakerVault.stakedAndActionLockedBalanceOf(payer) is going to show wrong value and any calculation based on this function is gonna be wrong which will cause fund lose and theft and some restriction bypasses.  ## Proof of Concept When user wants to create a TopUpAction. so he seposit his funds to Pool and get LP token. then stake the LP token in StakerVault and use that stakes to create a TopUp position with function TopUpAction.register. This function transfer user stakes (locks user staks) and create his position. for transferring and locking user stakes it uses TopUpActionLibrary.lockFunds. function lockFunds transfers user stakes but don't call stakerVault.increaseActionLockedBalance for the payer which cause that stakerVault.actionLockedBalances[payer] to get different values(not equal to position.depositTokenBalance). function StakerVault.stakedAndActionLockedBalanceOf(account) uses stakerVault.actionLockedBalances[account] so it will return wrong value and any where in code that uses stakedAndActionLockedBalanceOf() is going to cause problems. three part of the codes uses stakerVault.stakedAndActionLockedBalanceOf(): 1- LiqudityPool.depositFor() for checking user total deposits to be less than depositCap. 2- LiqudityPool._updateUserFeesOnDeposit() for updating user fee on new deposits. 3- userCheckpoint() for calculating user rewards. attacker can use #1 and #2 to bypass high fee payment and max depositCap and #3 will cause users to lose  rewards.  The detail steps: 1- user deposit fund to Pool and get LP token. 2- user stakes LP token in StakerVault. 3- user approve TopUpAction address to transfer his staks in StakerVault. 3- user use all his stakes to create a position with TopUpAction.register() function. 3.1- register() will call lockFunds to transfer and lock user stakes. 3.2- lockFunds() will transfer user stakes with stakerVault.transferFrom() but don't call stakerVault.increaseActionLockedBalance() so StakerVault.actionLockedBalances[user] will be zero. 3.3- StakerVault.balance[useer] will be zero too because his stakes get transfers in 3.2 4- StakerVault.stakedAndActionLockedBalanceOf(user) will return zero (user has some locked stakes in TopUpAction but because of the bug calculation get out of sync)  In this moment user will lose all the rewards that are minted in LpGauge. becasue userCheckpoint() use stakerVault.stakedAndActionLockedBalanceOf(user) for calculating rewards which is zero  and new rewards will be zero too.  Attacker can use this process to bypass \"max deposit Cap\" and deposit any amount of assets he wants. because LiqudityPool.depositFor(address,uint256,uint256) uses stakedAndActionLockedBalanceOf to check user deposits which is zero so Attacker can deposit & stake & register to make his balance zero and repeat this and in the end reset his TopUp positions to get back his large stakes which are multiple time bigger than \"max deposit Cap\"  Attacker can also use this process to bypass fee penalties for early withdraw. because LiqudityPool._updateUserFeesOnDeposit() to get user current balance use stakedAndActionLockedBalanceOf() which is zero. so the value of shareExisting variable become zero and newFeeRatio will be calculated based on feeOnDeposit which can be minFee if asset is already in wallet for some time.   ## Tools Used VIM  ## Recommended Mitigation Steps add this line to TopUpActionLibrary.lockFunds() after stakerVault.transferFrom():  stakerVault.increaseActionLockedBalance(payer, amountLeft);  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Griefer can extend period of higher withdrawal fees", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/56", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L790-L792   # Vulnerability details  ## Impact The `_updateUserFeesOnDeposit()` function in `LiquidityPool.sol` is used to update a user's withdrawal fees after an action such as deposit, transfer in, etc. The withdrawal fee decays toward a minimum withdrawal fee over a period of 1 or 2 weeks (discussed with developer). Since anyone can transfer lp tokens to any user, a griefer can transfer 1 wei of lp tokens to another user to reset their `lastActionTimestamp` used in the withdrawal fee calculation.  The developers nicely weight the updated withdrawal fee by taking the original balance/original fee vs the added balance/added fee. The attacker will only be able to extend the runway of the withdrawal fee cooldown by resetting the `lastActionTimestamp` for future calculations. Example below:  ## Proof of Concept Assumptions: - MinWithdrawalFee = 0% //For easy math - MaxWithdrawalFee = 10% - timeToWait = 2 weeks  ### Steps - User A has `100 wei` of shares - User A waits 1 week (Current withdrawal fee = 5%) - User B deposits, receives `1 wei` of shares, current withdrawal fee = 10% - User B immediately transfers `1 wei` of shares to User A  Based on the formula to calculated User A's new feeRatio:  ```         uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +             shareAdded.scaledMul(feeOnDeposit); ```  In reality, User A's withdrawal fee will only increase by a negligible amount since the shares added were very small in proportion to the original shares. We can assume user A's current withdrawal fee is still 5%.  The issue is that the function then reset's User A's `lastActionTimestamp` to the current time. This means that User A will have to wait the maximum 2 weeks for the withdrawal fee to reduce from 5% to 0%. Effectively the cooldown runway is the same length as the original runway length, so the decay down to 0% will take twice as long.  `meta.lastActionTimestamp = uint64(_getTime());`  ## Tools Used Manual Review  ## Recommended Mitigation Steps Instead of resetting `lastActionTimestamp` to the current time, scale it the same way the `feeRatio` is scaled. I understand that this would technically not be the timestamp of the last action, so the variable would probably need to be renamed.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/54", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "`call()` should be used instead of `transfer()` on an `address payable`", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/actions/topup/TopUpAction.sol#L291 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/pool/EthPool.sol#L30 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L77 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L93 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L117 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/EthVault.sol#L29 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/EthVault.sol#L37 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/VaultReserve.sol#L81   # Vulnerability details  This is a classic Code4rena issue:  - https://github.com/code-423n4/2021-04-meebits-findings/issues/2 - https://github.com/code-423n4/2021-10-tally-findings/issues/20 - https://github.com/code-423n4/2022-01-openleverage-findings/issues/75  ## Impact The use of the deprecated `transfer()` function for an address will inevitably make the transaction fail when:  1. The claimer smart contract does not implement a payable function. 2. The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit. 3. The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.  Additionally, using higher than 2300 gas might be mandatory for some multisig wallets.  ## Impacted lines:  ```solidity backd/contracts/pool/EthPool.sol:   30:         to.transfer(amount);  backd/contracts/strategies/BkdEthCvx.sol:    77:             payable(vault).transfer(amount);    93:         payable(vault).transfer(amount);   117:         payable(vault).transfer(underlyingBalance);  backd/contracts/vault/EthVault.sol:   29:         payable(to).transfer(amount);    37:         payable(addressProvider.getTreasury()).transfer(amount);    backd/contracts/vault/VaultReserve.sol:   81:             payable(msg.sender).transfer(amount); ```  ## Recommended Mitigation  I recommend using `call()` instead of `transfer()`  "}, {"title": "`getNewCurrentFees` reverts when `minFeePercentage` > `feeRatio`", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L694   # Vulnerability details  ## Impact Depositors won't be able to transfer or redeem funds temporarily.   The problem is caused by the implementation of `LiquidityPool.getNewCurrentFees`:  ``` function getNewCurrentFees(     uint256 timeToWait,     uint256 lastActionTimestamp,     uint256 feeRatio ) public view returns (uint256) {     uint256 timeElapsed = _getTime() - lastActionTimestamp;     uint256 minFeePercentage = getMinWithdrawalFee();     if (timeElapsed >= timeToWait) {         return minFeePercentage;     }     uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);     return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare); } ``` The last line requires the current `feeRatio` to be higher than `minFeePercentage` or the function will revert. When this condition is broken, some critical functions such as transferring tokens and redeeming will be unusable. Affected users need to wait until enough time has elapsed and `getNewCurrentFees` returns `minFeePercentage` on [L691](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L691).  This could happen if governance changes the `MinWithdrawalFee` to be higher than a user's feeRatio.  ## Proof of Concept - Initial `MinWithdrawalFee` is set to 0, `MaxWithdrawalFee` is set to 0.03e18. - Alice deposits fund and receives LP token. Alice's `feeRatio` is now set to 0.03e18 (the current `MaxWithdrawalFee`). - Governance changes `MaxWithdrawalFee` to `0.05e18` and `MinWithdrawalFee` to `0.04e18`. - `minFeePercentage` is now higher than Alice's `feeRatio` and she can't transfer nor redeem the LP token until `timeElapsed >= timeToWait`.  ## Recommended Mitigation Steps Add a new condition in `getNewCurrentFees` [L690](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L690) to account for this case: ``` if (timeElapsed >= timeToWait || minFeePercentage > feeRatio) {     return minFeePercentage; } ```   "}, {"title": "`_decimalMultiplier` doesn't account for tokens with decimals higher than 18", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L287-L289 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L318-L320 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L335-L337   # Vulnerability details  ## Impact In `StrategySwapper`, swapping from or to tokens with decimals higher than 18 will always revert. This will cause inabilities for strategies to harvest rewards.  ## Proof of Concept [L288](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L288) will revert when `token_` has higher than 18 decimals. ```  return 10**(18 - IERC20Full(token_).decimals()); ```   ## Recommended Mitigation Steps Consider modifying how `_decimalMultiplier` works so it could handle tokens with higher than 18 decimals.   Update the calculation of `_minTokenAmountOut` and `_minWethAmountOut` to account when decimals are higher/lower than `18`.  "}, {"title": "ERC777 tokens can bypass `depositCap` guard", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L523   # Vulnerability details  ## Impact When ERC777 token is used as the underlying token for a `LiquidityPool`, a depositor can reenter `depositFor` and bypass the `depositCap` requirement check, resulting in higher total deposit than intended by governance.  ## Proof of Concept - An empty ERC777 liquidity pool is capped at 1.000 token. - Alice deposits 1.000 token. Before the token is actually sent to the contract, `tokensToSend` ERC777 hook is called and Alice reenters `depositFor`. - As the previous deposit hasn't been taken into account, the reentrancy passes the `depositCap` check. - Pool has 2.000 token now, despite the 1.000 deposit cap.  ## Recommended Mitigation Steps Add reentrancy guards to `depositFor`.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "User can steal all rewards due to checkpoint after transfer", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/36", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L112-L119   # Vulnerability details  ## Impact I believe this to be a high severity vulnerability that is potentially included in the currently deployed `StakerVault.sol` contract also. The team will be contacted immediately following the submission of this report.  In `StakerVault.sol`, the user checkpoints occur AFTER the balances are updated in the `transfer()` function. The user checkpoints update the amount of rewards claimable by the user. Since their rewards will be updated after transfer, a user can send funds between their own accounts and repeatedly claim maximum rewards since the pool's inception.  In every actionable function except `transfer()` of `StakerVault.sol`, a call to `ILpGauge(lpGauge).userCheckpoint()` is correctly made BEFORE the action effects.  ## Proof of Concept Assume a certain period of time has passed since the pool's inception. For easy accounting, assume `poolStakedIntegral` of `LpGauge.sol` equals `1`. The `poolStakedIntegral` is used to keep track of the current reward rate.  Steps: - Account A stakes 1000 LP tokens. `balances[A] += 1000`  - In the same `stakeFor()` function, `userCheckpoint()` was already called so A will already have `perUserShare[A]` set correctly based on their previously 0 balance and the current `poolStakedIntegral`. - Account A can immediately send all balance to Account B via `transfer()`. - Since the checkpoint occurs after the transfer, B's balance will increase and then `perUserShare[B]` will be updated. The calculation for `perUserShare` looks as follows.  ``` perUserShare[user] += (             (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(                 (poolStakedIntegral_ - perUserStakedIntegral[user])             )         ); ```  Assuming Account B is new to the protocol, their `perUserStakedIntegral[user]` will default to `0`.  `perUserShare[B] += 1000 * (1 - 0) = 1000`  - B is able to call `claimRewards()` and mint all 1000 reward tokens. - B then calls `transfer()` and sends all 1000 staked tokens to Account C. - Same calculation occurs, and C can claim all 1000 reward tokens. - This process can be repeated until the contract is drained of reward tokens.  ## Tools Used Static review.  ## Recommended Mitigation Steps In `StakerVault.transfer()`, move the call to `ILpGauge(lpGauge).userCheckpoint()` to before the balances are updated.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Chainlink's latestRoundData might return stale or incorrect results", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "Chainlink's latestRoundData might return stale or incorrect results"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/6", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/2", "labels": ["bug", "QA (Quality Assurance)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "reviewed"], "target": "2022-04-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/96", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/94", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/92", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Owner or Managers can rug Aave rewards", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/89", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-pooltogether-findings", "body": "Owner or Managers can rug Aave rewards"}, {"title": "Yield source does not correctly calculate share conversions", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-04-pooltogether-findings", "body": "Yield source does not correctly calculate share conversions"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/80", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/79", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/75", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/73", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "`RewardsController` Emission Manager Can Authorize Users to Claim on Behalf of the `AaveV3YieldSource` Contract and Siphon Yield", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-04-pooltogether-findings", "body": "`RewardsController` Emission Manager Can Authorize Users to Claim on Behalf of the `AaveV3YieldSource` Contract and Siphon Yield"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/66", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/60", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/59", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/58", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/52", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/50", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "[WP-H1] A malicious early user/attacker can manipulate the vault's pricePerShare to take an unfair share of future users' deposits", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/44", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L352-L374   # Vulnerability details  This is a well-known attack vector for new contracts that utilize pricePerShare for accounting.  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L352-L374  ```solidity   /**    * @notice Calculates the number of shares that should be minted or burnt when a user deposit or withdraw.    * @param _tokens Amount of asset tokens    * @return Number of shares.    */   function _tokenToShares(uint256 _tokens) internal view returns (uint256) {     uint256 _supply = totalSupply();      // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply     return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));   }    /**    * @notice Calculates the number of asset tokens a user has in the yield source.    * @param _shares Amount of shares    * @return Number of asset tokens.    */   function _sharesToToken(uint256 _shares) internal view returns (uint256) {     uint256 _supply = totalSupply();      // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares     return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);   } ```  A malicious early user can `supplyTokenTo()` with `1 wei` of `_underlyingAssetAddress` token as the first depositor of the `AaveV3YieldSource.sol`, and get `1 wei` of shares token.  Then the attacker can send `10000e18 - 1` of `aToken` and inflate the price per share from 1.0000 to an extreme value of 1.0000e22 ( from `(1 + 10000e18 - 1) / 1`) .  As a result, the future user who deposits `19999e18` will only receive `1 wei` (from `19999e18 * 1 / 10000e18`) of shares token.  They will immediately lose `9999e18` or half of their deposits if they `redeemToken()` right after the `supplyTokenTo()`.  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L251-L256  ```solidity   function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) {     address _underlyingAssetAddress = _tokenAddress();     IERC20 _assetToken = IERC20(_underlyingAssetAddress);      uint256 _shares = _tokenToShares(_redeemAmount);     _burn(msg.sender, _shares);     ... ```  Furthermore, after the PPS has been inflated to an extremely high value (`10000e18`), the attacker can also redeem tokens up to `9999e18` for free, (burn `0` shares) due to the precision loss.  ### Recommendation  Consider requiring a minimal amount of share tokens to be minted for the first minter, and send a port of the initial mints as a reserve to the DAO address so that the pricePerShare can be more resistant to manipulation.  Also, consder adding `require(_shares > 0, \"AaveV3YS/shares-gt-zero\");` before `_burn(msg.sender, _shares);`.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/43", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/40", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "User fund loss in supplyTokenTo() because of rounding", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/37", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L231-L242 https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L357-L362   # Vulnerability details  ## Impact When user use `supplyTokenTo()` to deposit his tokens and get `share` in `FeildSource` because of rounding in division user gets lower amount of `share`. for example if token's `_decimal` was `1` and `totalSupply()` was `1000` and `aToken.balanceOf(FieldSource.address)` was `2100` (becasue of profits in `Aave Pool` `balance` is higher than `supply`), then if user deposit `4` token to the contract with `supplyTokenTo()`, contract is going to `mint` only `1` share for that user and if user calls `YeildToken.balanceOf(user)` the return value is going to be `2` and user already lost half of his deposit. Of course if `_precision ` was high this loss is going to be low enough to ignore but in case of low `_precision` and high price `token` and high `balance / supply` ratio this loss is going to be noticeable.  ## Proof of Concept This is the code of `supplyTokenTo()`: ```   function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant {     uint256 _shares = _tokenToShares(_depositAmount);     require(_shares > 0, \"AaveV3YS/shares-gt-zero\");      address _underlyingAssetAddress = _tokenAddress();     IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount);     _pool().supply(_underlyingAssetAddress, _depositAmount, address(this), REFERRAL_CODE);      _mint(_to, _shares);      emit SuppliedTokenTo(msg.sender, _shares, _depositAmount, _to);   } ``` which in line: `_shares = _tokenToShares(_depositAmount)` trying to calculated `shares` corresponding to the number of tokens supplied. and then transfer `_depositAmount` from user and `mint` shares amount for user. the problem is that if user convert `_shares` to token, he is going to receive lower amount because in most cases: ``` _depositAmount > _sharesToToken(_tokenToShares(_depositAmount)) ``` and that's because of rounding in division. Value of `_shares` is less than _depositAmount. so `YeildSource` should only take part of `_depositAmount` that equals to `_sharesToToken(_tokenToShares(_depositAmount))` and mint `_share` for user.  Of course if `_precision` was high and `aToken.balanceOf(FieldSource.address) / totalSupply()` was low, then this amount will be insignificant, but for some cases it can be harmful for users. for example this conditions: - `_perecision` is low like 1 or 2. - `token` value is very high like BTC. - `aToken.balanceOf(FieldSource.address) / totalSupply()` is high due to manipulation or profit in `Aave pool`.  ## Tools Used VIM  ## Recommended Mitigation Steps To resolve this issue this can be done: ```   function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant {     uint256 _shares = _tokenToShares(_depositAmount);     require(_shares > 0, \"AaveV3YS/shares-gt-zero\");          _depositAmount = _sharesToToken(_shares); // added hero to only take correct amount of user tokens     address _underlyingAssetAddress = _tokenAddress();     IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount);     _pool().supply(_underlyingAssetAddress, _depositAmount, address(this), REFERRAL_CODE);      _mint(_to, _shares);      emit SuppliedTokenTo(msg.sender, _shares, _depositAmount, _to);   } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/34", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/25", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/21", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/20", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/15", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/12", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "_depositAmount requires to be updated to contract balance increase", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-04-pooltogether-findings", "body": "_depositAmount requires to be updated to contract balance increase"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/199", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/197", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/196", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/195", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/193", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/189", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/182", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/180", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/179", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/178", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/173", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/172", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/169", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/168", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/167", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/160", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/159", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/158", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/149", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/148", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/142", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/137", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Avoidance of Liquidation Via Malicious Oracle", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/136", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-abranft-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L312-L318   # Vulnerability details  Issue: Arbitrary oracles are permitted on construction of loans, and there is no check that the lender agrees to the used oracle.  Consequences: A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation.  ## Proof of Concept  - Borrower requests loan with an malicious oracle - Lender accepts loan unknowingly - Borrowers's bad oracle is set to never return a liquidating rate on `oracle.get` call. - Lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed, as it will fail the check on [L288](https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L288) - To liquidate the NFT, the lender would have to whitehat along the lines of H-01, by atomically updating to an honest oracle and calling `removeCollateral`.  ## Mitigations  - Add `require(params.oracle == accepted.oracle)` as a condition in `_lend` - Consider only allowing whitelisted oracles, to avoid injection of malicious oracles at the initial loan request stage   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/135", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/132", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/128", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/126", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/125", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/124", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/121", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/120", "labels": ["G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/119", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/111", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/109", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/107", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-abranft-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/103", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-abranft-findings", "body": "Gas Optimizations"}]