[{"title": "Update: Fixed in line 630 of the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "body": "Update: Fixed in line 630 of the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-line-630-of-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "labels": ["OpenZeppelin"]}, {"title": "[L05][Partially Fixed] Not using SafeMath", "body": "[L05][Partially Fixed] Not using SafeMath", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[l05][partially-fixed]-not-using-safemath", "labels": ["OpenZeppelin"]}, {"title": "Besides the critical vulnerability found in \u201c[C01] Malicious users could steal with and from the OptionsContract contract\u201d, in OptionsContract there are more places where it is not used or badly used, such as:", "body": "Besides the critical vulnerability found in \u201c[C01] Malicious users could steal with and from the OptionsContract contract\u201d, in OptionsContract there are more places where it is not used or badly used, such as:", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#besides-the-critical-vulnerability-found-in-\u201c[c01]-malicious-users-could-steal-with-and-from-the-optionscontract-contract\u201d,-in-optionscontract-there-are-more-places-where-it-is-not-used-or-badly-used,-such-as:", "labels": ["OpenZeppelin"]}, {"title": "Line 509: uint256 amtCollateralToPay = amtCollateral + amtIncentive", "body": "Line 509: uint256 amtCollateralToPay = amtCollateral + amtIncentive", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#line-509:-uint256-amtcollateraltopay-=-amtcollateral-+-amtincentive", "labels": ["OpenZeppelin"]}, {"title": "Line 582: collateralizationRatio.exponent + strikePrice.exponent", "body": "Line 582: collateralizationRatio.exponent + strikePrice.exponent", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#line-582:-collateralizationratio.exponent-+-strikeprice.exponent", "labels": ["OpenZeppelin"]}, {"title": "Although the first one is unlikely to cause an overflow or underflow, consider using the SafeMath library to eliminate any potential risks. In the last situation, because the variable type is int32, SafeMath cannot be used there. Consider instead adding extra checks to ensure the operation is not performing any underflow or overflow.", "body": "Although the first one is unlikely to cause an overflow or underflow, consider using the SafeMath library to eliminate any potential risks. In the last situation, because the variable type is int32, SafeMath cannot be used there. Consider instead adding extra checks to ensure the operation is not performing any underflow or overflow.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#although-the-first-one-is-unlikely-to-cause-an-overflow-or-underflow,-consider-using-the-safemath-library-to-eliminate-any-potential-risks.-in-the-last-situation,-because-the-variable-type-is-int32,-safemath-cannot-be-used-there.-consider-instead-adding-extra-checks-to-ensure-the-operation-is-not-performing-any-underflow-or-overflow.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where first issue is fixed with SafeMath but second issue remains unfixed.", "body": "Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where first issue is fixed with SafeMath but second issue remains unfixed.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-partially-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-first-issue-is-fixed-with-safemath-but-second-issue-remains-unfixed.", "labels": ["OpenZeppelin"]}, {"title": "[L06] Confusing time frame for actions", "body": "In an option there is a period in which certain actions such as creating repos, adding collateral, liquidating a repo, or burning oTokens, have to be executed prior the expiration time (expiry) of the contract.  There is alaso an exercise action that can be done only during a specific time window defined by the windowSize variable (which closes at expiry).  Instead of subtracting the windowSize from expiry to know the start point where exercise can be executed, it is clearer to define 2 variables: startsExercisability and endsExercisability.  Consider changing the logic to have a start time where these actions can be executed and an end time where the contract expires.  Note: this issue is related to [C01] Malicious users could steal with and from the OptionsContract contract and any mitigation should consider both simultaneously.  Update: The Opyn team explained the exercise window allows for the existence of both American and European Options. American Options can be exercised at any time until expiry, European Options can only be exercised on the last day or so.  [L07][Fixed] Repo owner could lose collateral if leftover oTokens are not burnt before the option expires  Currently, Repo owners are allowed to freely mint oTokens by providing collateral. However, there is no way for the Repo owner to redeem the corresponding collateral for any unsold oTokens after the option expires. The Repo owners are supposed to burn all unsold oTokens before expiry to avoid losing the corresponding collateral.  While this design works and makes sense, it is quite risky for the Repo owners and it is unclear that Repo owners are bearing risks of being stuck with their own oTokens.  Consider adding more documentation and warnings in the code to further advice Repo owners, or only allow issuing oTokens when a trade occurs.  Update: The team confirmed this is an expected behavior, comments are added in line 442 of the follow up commit to ensure users are only issuing oTokens when a trade occurs.  [L08][Fixed] Factorize Repo ownership into modifier  In several functions of the OptionsContract, such as issueOTokens, the function is marked as public but further restricts the operation to only the Repo.owner inside the code.  Since this pattern appears in several functions, consider implementing a isRepoOwner() modifier to write less error-prone code instead of copying the code to check repo ownership in each function independently.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where repos was replaced by newly introduced vaults. The function locates targeted vaults through vaults[msg.sender] and runs a check on if current msg.sender has a vault using hasVault(msg.sender).  [L09][Fixed] Unbalanced ETH operations  In OptionsContract contract, there is a payable fallback function that allows ETH to be sent to the contract but there is no way to withdraw.  Consider adding a withdraw function to the contract or do not accept ETH in the fallback function.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where the payable fallback function was removed.  [L10] Unbounded loops  the Repo structs and  the contract addresses into the  Because there is no function that decreases the length of those arrays once those Repos and OptionsContracts are not needed, it is dangerous to loop through these arrays when they are too big.  In the contract OptionsContract the length of the repos array is used twice as a boundary for a for loop.  Because anyone can call the public openRepo function, someone could start creating Repos until the length of repos is too big to be processed in a block. At that moment, the function could not be called anymore.  Because the only function that uses the length of the repos array is getReposByOwner, and no other function calls getReposByOwner, the issue will not freeze the contracts logic. Nevertheless, consider removing unbounded loops from the contract logic in case a child contract uses a function implementing one of the loops.  Notes  [N01] No way to check liquidation allowance  Currently in OptionsContract contract, there is no way to check the maximum liquidation allowance. During a liquidation situation, liquidators have to blindly request an oToken amount they want to liquidate when calling liquidate.  Although it is within liquidators interest to liquidate as many oTokens as possible, there is no easy way to find out the maximum limit. The liquidate function will revert if liquidators try to liquidate too many oTokens. This design is not very user-friendly for liquidators, and it might cause liquidation events to fail multiple times due to the wrong balance being requested.  Consider adding a function to allow liquidators to get the maximum liquidation allowance for a certain Repo, or just allow liquidators to liquidate the maximum amount if their requests are over the maximum limit.  [N02][Fixed] Usage of SafeMath in non-uint256 variables  L518 and  520 where the value is casted from  L592 and  595)  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where all variables mentioned in the issue are casted to uint256.  [N03][Fixed] oTokens can still be burnt after the contract expires  In OptionsContract, the function burnOTokens should be limited to before the contract expires. There is no need to call this function after it expires, similar to the counterpart actions like issueoTokens, or add and remove collateral.  Consider adding a time check in the burnOTokens function.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where a notExpired modifier is added to the function.  [N04][Fixed] Change uint to uint256  Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256. For example,, the following lines in OptionsContract:  Line 200 returns (uint) should be returns (uint256)  Line 315 returns (uint[] memory) should be returns (uint256[] memory)  Line 316 uint[] should be uint256[]  Line 318 uint index = 0 should be uint256 index = 0  Line 327 uint[](count) should be uint256[](count)  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e, all issues above are either fixed or removed due to code update.  [N05] External contracts addresses should be constants  The OptionsUtils contract  provides basic functionalities regarding the available exchanges, the oracle, and how to tell if an asset is ETH.  Both the Compound Oracle and the Uniswap Factory addresses are stored in 2 public variables called COMPOUND_ORACLE and UNISWAP_FACTORY and those are assigned to the current addresses from the beginning.  During the constructor function those variables are overridden using the parameters provided during the deployment, making the original assignments unnecessary.  a new OptionsContract will copy the values set in the current OptionsExchange to its  the optionsExchange variable from OptionsFactory cannot be updated, the entire project would need to be re-deployed in order to change those variables. Instead of assigning these values twice, it is good enough to set the  Consider declaring the variables as constant.  [N06][Fixed] Default visibility  Some state variables in OptionsContract are using the default public visibility. Consider declaring explicitly the visibility of all the variables for better readability.  liquidationIncentive,  transactionFee,  liquidationFactor,  liquidationFee,  windowSize,  totalExercised,  totalFee,  totalUnderlying,  totalCollateral, and  collateralExp.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where state variable visibilities are clearly stated.  [N07][Fixed]Empty lines  There are some empty lines inside OptionsContract such as L39, L98, and L421.  To favor readability, consider using a linter such as Solhint.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where empty lines are removed  [N08][Fixed] Lack of checks  Certain functions in this project will execute even if the given parameters are not actually updating any state variable values.  For instance,  passing zero as the amtToRemove parameter for removeCollateral will cause the function to execute and trigger the RemoveCollateral event.  Calling transferRepoOwnership from the OptionsContract with the same address as previous owner will trigger the TransferRepoOwnership event but the owner of the Repo has not changed.  Calling transferRepoOwnership with zero address.  Creating a new repo by calling createOptionsContract with an expiry in the past or windowSize value larger that the expiry time.  Calling the updateParameters function with the same existing or wrong value for liquidationIncentive, liquidationFee, transactionFee, collateralizationRatio, and liquidationFactor.  These scenarios could emit useless events or compromise the functionality of the project. Consider adding parameter checks to these functions.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where proper validations and checks are added.  [N9][Partially Fixed] Misleading variable names  In OptionsContract, the variable amtCollateralToPayNum is actually the amount of collateral to pay in ETH, not in collateral.Consider renaming it to amtCollateralToPayInEthNum to avoid confusion.  In OptionsContract, the isSafe function creates a variable called with the same name as the function. Consider changing the name to stillSafe.  In OptionsContract, the getPrice function gets the price of the asset in ETH, but the name where those values are saved suggest the opposite. Consider changing them to collateralToEthPrice and StrikeToEthPrice.  Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where some of the variable names have been updated.  [N10][Fixed] Unknown use of multiple Repos per account  The OptionsContract allows any user to create a new Repo by calling the openRepo function.  However at the moment a single address can create as many Repos as they want but without getting a explicit benefit.  Consider adding to the documentation what are the benefits of doing this, or removing the possibility of having multiple Repos per account and allowing only one.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where repos are replaced by vaults and only one vault is allowed per user.  [N11][Fixed] Inverse order of operations  getExchange function creates a pointer to the  it checks if the address retrieved from Uniswaps getExchange is zero.  Consider first checking if the address returned by UNISWAP_FACTORY.getExchange(_token) in L26 is zero before linking the queried exchange instance into the local variable exchange.  Update: Fixed in line 29 of the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.  [N12][Fixed] Mismatch case for payable address  TransferRepoOwnership event takes the  the transferRepoOwnership function is called, a function that allows the old owner to change the ownership of the  There is a similar issue in the liquidate function: The Liquidate event is defined using an address parameter, however when it is used in the liquidate function, msg.sender can be payable if the collateral is ETH. Consider updating the variable type in the event.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.  [N13][Fixed] Repo owners might not know their collateral balance  The project team mentioned that they are implementing new code into the getRepoByIndex function to return the collateral balance of a Repo owner. However, it might be confusing for a Repo owner to see their collateral value drops due to other users calling the exercise function.This issue was pointed out to us by the project team and asked for our recommendation.  The fact is when the collateral drops, the underlying contained in the contract increases with each exercise call. It might be beneficial to return both the collateral and underlying balances when a Repo owner checks their balance. It is self-explanatory that when other users call exercise, the collateral balance drops while the underlying balance increases. Consider retrieving both balances to the Repo owner to prevent confusions about their balances.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where the newly added getVault() function returns both the collateral and underlying balances.  [N14][Partially Fixed] Misleading comments, variable names, and documentation typos  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  In the audited contracts, several functions have incomplete, or non-existent, docstrings which need to be completed.  In OptionsContract:  strikePrice should be strikePrice.  There are ToDo comments along the code which shows that part of the functionalities are not ready yet.  In L36, L40, and L43 a method is used to convert an integer to percentage (using the net percentage without adding the 100%), but in L47 and L162 it used a different method, which is not congruent to the previous one. For example, for the L40 definition 1054 == 105.4% but for the L47 definition, 1054 == 5.4%. Consider using only one method to calculate the percentage.  collatera should be collateral.  indecies should be indices.  In the exercise function a docstring implies that L270 transfers oTokens to the contract, but actually it burns them.  Functions that move oTokens from the user account, such as addERC20Collateral and exercise, do not say that the user has to allow the contract to handle their oTokens on his behalf before these functions are called.  The docstrings of the addETHCollateral function do not say what the return value is.  The revert message in the exercise function mentions the use of pTokens instead of the current oTokens.  There are places, such as L14, L15, L20, L26, L32, L34, L36, and L40, where it should be explained with more detail what the variable/contract does.  For the Number variables, such as the ones in L36, L40, L43, L47, and L51, it would be ideal add those examples to the actual Number structure in L20 and explicitly explain the formula that links the value with the exponent.  In OptionsExchange:  The functions sellPTokens and buyPTokens, along with their _pTokens parameters, implies the use of pTokens instead of oTokens. If these are a different type of tokens, then it should be explained in the documentation.  In the whitepaper:  cryptoassets in the section 1.1 line 2 should be crypto assets.  marketplaces marketplace in the section 3.3.1 paragraph 2 line 4-5 should be marketplaces.  Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e. Some of these issues are fixed in the new commit.  [N15] Funds cannot be withdrawn under certain conditions  After the OptionsContract has expired, the forgotten funds in collateral or underlying will remain in the contract forever.  Consider adding an extra time checkpoint, such as terminated, when it would be possible to withdraw the forgotten funds in the contract after this period is reached.  [N16] Unnecessary code  There are some uncessary code through out the project, for example  There is an unnecessary return operation in the issueOTokens function of the OptionsContract contract, the function definition does not specify any returned value.  The OptionsContract defines the same isEth function that was inherited from the OptionsUtils contract.  In the OptionsFactory it is imported the OptionsUtils contract to it but it is never used.  Consider removing all unnecessary code.  [N17][Fixed] Unneeded assignment  In the OptionsContract contract, the variable oTokenExchangeRate is defined and assigned but then, during the constructor, it is again assigned with the parameter value _oTokenExchangeExp.  Because the first assignment will not matter when the contract is deployed, consider removing it during the declaration of the variable.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89ewhere the oTokenExchangeRate value is only assigned once in the Constructor.  Conclusion  One critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Update: The Opyn team has fixed the critical issue and implemented partial fixes and monitoring solutions for all high issues in their follow up commit.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[l06]-confusing-time-frame-for-actions", "labels": ["OpenZeppelin"]}, {"title": "In an option there is a period in which certain actions such as creating repos, adding collateral, liquidating a repo, or burning oTokens, have to be executed prior the expiration time (expiry) of the contract.", "body": "In an option there is a period in which certain actions such as creating repos, adding collateral, liquidating a repo, or burning oTokens, have to be executed prior the expiration time (expiry) of the contract.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-an-option-there-is-a-period-in-which-certain-actions-such-as-creating-repos,-adding-collateral,-liquidating-a-repo,-or-burning-otokens,-have-to-be-executed-prior-the-expiration-time-(expiry)-of-the-contract.", "labels": ["OpenZeppelin"]}, {"title": "There is alaso an exercise action that can be done only during a specific time window defined by the windowSize variable (which closes at expiry).", "body": "There is alaso an exercise action that can be done only during a specific time window defined by the windowSize variable (which closes at expiry).", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#there-is-alaso-an-exercise-action-that-can-be-done-only-during-a-specific-time-window-defined-by-the-windowsize-variable-(which-closes-at-expiry).", "labels": ["OpenZeppelin"]}, {"title": "Instead of subtracting the windowSize from expiry to know the start point where exercise can be executed, it is clearer to define 2 variables: startsExercisability and endsExercisability.", "body": "Instead of subtracting the windowSize from expiry to know the start point where exercise can be executed, it is clearer to define 2 variables: startsExercisability and endsExercisability.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#instead-of-subtracting-the-windowsize-from-expiry-to-know-the-start-point-where-exercise-can-be-executed,-it-is-clearer-to-define-2-variables:-startsexercisability-and-endsexercisability.", "labels": ["OpenZeppelin"]}, {"title": "Consider changing the logic to have a start time where these actions can be executed and an end time where the contract expires.", "body": "Consider changing the logic to have a start time where these actions can be executed and an end time where the contract expires.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-changing-the-logic-to-have-a-start-time-where-these-actions-can-be-executed-and-an-end-time-where-the-contract-expires.", "labels": ["OpenZeppelin"]}, {"title": "Note: this issue is related to \u201c[C01] Malicious users could steal with and from the OptionsContract contract\u201d and any mitigation should consider both simultaneously.", "body": "Note: this issue is related to \u201c[C01] Malicious users could steal with and from the OptionsContract contract\u201d and any mitigation should consider both simultaneously.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#note:-this-issue-is-related-to-\u201c[c01]-malicious-users-could-steal-with-and-from-the-optionscontract-contract\u201d-and-any-mitigation-should-consider-both-simultaneously.", "labels": ["OpenZeppelin"]}, {"title": "Update: The Opyn team explained the exercise window allows for the existence of both American and European Options. American Options can be exercised at any time until expiry, European Options can only be exercised on the last day or so.", "body": "Update: The Opyn team explained the exercise window allows for the existence of both American and European Options. American Options can be exercised at any time until expiry, European Options can only be exercised on the last day or so.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-the-opyn-team-explained-the-exercise-window-allows-for-the-existence-of-both-american-and-european-options.-american-options-can-be-exercised-at-any-time-until-expiry,-european-options-can-only-be-exercised-on-the-last-day-or-so.", "labels": ["OpenZeppelin"]}, {"title": "[L07][Fixed] Repo owner could lose collateral if leftover oTokens are not burnt before the option expires", "body": "[L07][Fixed] Repo owner could lose collateral if leftover oTokens are not burnt before the option expires", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[l07][fixed]-repo-owner-could-lose-collateral-if-leftover-otokens-are-not-burnt-before-the-option-expires", "labels": ["OpenZeppelin"]}, {"title": "Currently, Repo owners are allowed to freely mint oTokens by providing collateral. However, there is no way for the Repo owner to redeem the corresponding collateral for any unsold oTokens after the option expires. The Repo owners are supposed to burn all unsold oTokens before expiry to avoid losing the corresponding collateral.", "body": "Currently, Repo owners are allowed to freely mint oTokens by providing collateral. However, there is no way for the Repo owner to redeem the corresponding collateral for any unsold oTokens after the option expires. The Repo owners are supposed to burn all unsold oTokens before expiry to avoid losing the corresponding collateral.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#currently,-repo-owners-are-allowed-to-freely-mint-otokens-by-providing-collateral.-however,-there-is-no-way-for-the-repo-owner-to-redeem-the-corresponding-collateral-for-any-unsold-otokens-after-the-option-expires.-the-repo-owners-are-supposed-to-burn-all-unsold-otokens-before-expiry-to-avoid-losing-the-corresponding-collateral.", "labels": ["OpenZeppelin"]}, {"title": "While this design works and makes sense, it is quite risky for the Repo owners and it is unclear that Repo owners are bearing risks of being stuck with their own oTokens.", "body": "While this design works and makes sense, it is quite risky for the Repo owners and it is unclear that Repo owners are bearing risks of being stuck with their own oTokens.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#while-this-design-works-and-makes-sense,-it-is-quite-risky-for-the-repo-owners-and-it-is-unclear-that-repo-owners-are-bearing-risks-of-being-stuck-with-their-own-otokens.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding more documentation and warnings in the code to further advice Repo owners, or only allow issuing oTokens when a trade occurs.", "body": "Consider adding more documentation and warnings in the code to further advice Repo owners, or only allow issuing oTokens when a trade occurs.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-adding-more-documentation-and-warnings-in-the-code-to-further-advice-repo-owners,-or-only-allow-issuing-otokens-when-a-trade-occurs.", "labels": ["OpenZeppelin"]}, {"title": "Update: The team confirmed this is an expected behavior, comments are added in line 442 of the follow up commit to ensure users are only issuing oTokens when a trade occurs.", "body": "Update: The team confirmed this is an expected behavior, comments are added in line 442 of the follow up commit to ensure users are only issuing oTokens when a trade occurs.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-the-team-confirmed-this-is-an-expected-behavior,-comments-are-added-in-line-442-of-the-follow-up-commit-to-ensure-users-are-only-issuing-otokens-when-a-trade-occurs.", "labels": ["OpenZeppelin"]}, {"title": "[L08][Fixed] Factorize Repo ownership into modifier", "body": "[L08][Fixed] Factorize Repo ownership into modifier", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[l08][fixed]-factorize-repo-ownership-into-modifier", "labels": ["OpenZeppelin"]}, {"title": "In several functions of the OptionsContract, such as issueOTokens, the function is marked as public but further restricts the operation to only the Repo.owner inside the code.", "body": "In several functions of the OptionsContract, such as issueOTokens, the function is marked as public but further restricts the operation to only the Repo.owner inside the code.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-several-functions-of-the-optionscontract,-such-as-issueotokens,-the-function-is-marked-as-public-but-further-restricts-the-operation-to-only-the-repo.owner-inside-the-code.", "labels": ["OpenZeppelin"]}, {"title": "Since this pattern appears in several functions, consider implementing a isRepoOwner() modifier to write less error-prone code instead of copying the code to check repo ownership in each function independently.", "body": "Since this pattern appears in several functions, consider implementing a isRepoOwner() modifier to write less error-prone code instead of copying the code to check repo ownership in each function independently.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#since-this-pattern-appears-in-several-functions,-consider-implementing-a-isrepoowner()-modifier-to-write-less-error-prone-code-instead-of-copying-the-code-to-check-repo-ownership-in-each-function-independently.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where repos was replaced by newly introduced vaults. The function locates targeted vaults through vaults[msg.sender] and runs a check on if current msg.sender has a vault using hasVault(msg.sender).", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where repos was replaced by newly introduced vaults. The function locates targeted vaults through vaults[msg.sender] and runs a check on if current msg.sender has a vault using hasVault(msg.sender).", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-repos-was-replaced-by-newly-introduced-vaults.-the-function-locates-targeted-vaults-through-vaults[msg.sender]-and-runs-a-check-on-if-current-msg.sender-has-a-vault-using-hasvault(msg.sender).", "labels": ["OpenZeppelin"]}, {"title": "[L09][Fixed] Unbalanced ETH operations", "body": "[L09][Fixed] Unbalanced ETH operations", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[l09][fixed]-unbalanced-eth-operations", "labels": ["OpenZeppelin"]}, {"title": "In OptionsContract contract, there is a payable fallback function that allows ETH to be sent to the contract but there is no way to withdraw.", "body": "In OptionsContract contract, there is a payable fallback function that allows ETH to be sent to the contract but there is no way to withdraw.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-optionscontract-contract,-there-is-a-payable-fallback-function-that-allows-eth-to-be-sent-to-the-contract-but-there-is-no-way-to-withdraw.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a withdraw function to the contract or do not accept ETH in the fallback function.", "body": "Consider adding a withdraw function to the contract or do not accept ETH in the fallback function.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-adding-a-withdraw-function-to-the-contract-or-do-not-accept-eth-in-the-fallback-function.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where the payable fallback function was removed.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where the payable fallback function was removed.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-the-payable-fallback-function-was-removed.", "labels": ["OpenZeppelin"]}, {"title": "[L10] Unbounded loops", "body": "[L10] Unbounded loops", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[l10]-unbounded-loops", "labels": ["OpenZeppelin"]}, {"title": "the Repo structs and", "body": "the Repo structs and", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-repo-structs-and", "labels": ["OpenZeppelin"]}, {"title": "the contract addresses into the", "body": "the contract addresses into the", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-contract-addresses-into-the", "labels": ["OpenZeppelin"]}, {"title": "Because there is no function that decreases the length of those arrays once those Repos and OptionsContracts are not needed, it is dangerous to loop through these arrays when they are too big.", "body": "Because there is no function that decreases the length of those arrays once those Repos and OptionsContracts are not needed, it is dangerous to loop through these arrays when they are too big.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#because-there-is-no-function-that-decreases-the-length-of-those-arrays-once-those-repos-and-optionscontracts-are-not-needed,-it-is-dangerous-to-loop-through-these-arrays-when-they-are-too-big.", "labels": ["OpenZeppelin"]}, {"title": "In the contract OptionsContract the length of the repos array is used twice as a boundary for a for loop.", "body": "In the contract OptionsContract the length of the repos array is used twice as a boundary for a for loop.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-the-contract-optionscontract-the-length-of-the-repos-array-is-used-twice-as-a-boundary-for-a-for-loop.", "labels": ["OpenZeppelin"]}, {"title": "Because anyone can call the public openRepo function, someone could start creating Repos until the length of repos is too big to be processed in a block. At that moment, the function could not be called anymore.", "body": "Because anyone can call the public openRepo function, someone could start creating Repos until the length of repos is too big to be processed in a block. At that moment, the function could not be called anymore.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#because-anyone-can-call-the-public-openrepo-function,-someone-could-start-creating-repos-until-the-length-of-repos-is-too-big-to-be-processed-in-a-block.-at-that-moment,-the-function-could-not-be-called-anymore.", "labels": ["OpenZeppelin"]}, {"title": "Because the only function that uses the length of the repos array is getReposByOwner, and no other function calls getReposByOwner, the issue will not freeze the contract\u2019s logic. Nevertheless, consider removing unbounded loops from the contract logic in case a child contract uses a function implementing one of the loops.", "body": "Because the only function that uses the length of the repos array is getReposByOwner, and no other function calls getReposByOwner, the issue will not freeze the contract\u2019s logic. Nevertheless, consider removing unbounded loops from the contract logic in case a child contract uses a function implementing one of the loops.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#because-the-only-function-that-uses-the-length-of-the-repos-array-is-getreposbyowner,-and-no-other-function-calls-getreposbyowner,-the-issue-will-not-freeze-the-contract\u2019s-logic.-nevertheless,-consider-removing-unbounded-loops-from-the-contract-logic-in-case-a-child-contract-uses-a-function-implementing-one-of-the-loops.", "labels": ["OpenZeppelin"]}, {"title": "Notes", "body": "Notes", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#notes", "labels": ["OpenZeppelin"]}, {"title": "[N01] No way to check liquidation allowance", "body": "[N01] No way to check liquidation allowance", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n01]-no-way-to-check-liquidation-allowance", "labels": ["OpenZeppelin"]}, {"title": "Currently in OptionsContract contract, there is no way to check the maximum liquidation allowance. During a liquidation situation, liquidators have to blindly request an oToken amount they want to liquidate when calling liquidate.", "body": "Currently in OptionsContract contract, there is no way to check the maximum liquidation allowance. During a liquidation situation, liquidators have to blindly request an oToken amount they want to liquidate when calling liquidate.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#currently-in-optionscontract-contract,-there-is-no-way-to-check-the-maximum-liquidation-allowance.-during-a-liquidation-situation,-liquidators-have-to-blindly-request-an-otoken-amount-they-want-to-liquidate-when-calling-liquidate.", "labels": ["OpenZeppelin"]}, {"title": "Although it is within liquidator\u2019s interest to liquidate as many oTokens as possible, there is no easy way to find out the maximum limit. The liquidate function will revert if liquidators try to liquidate too many oTokens. This design is not very user-friendly for liquidators, and it might cause liquidation events to fail multiple times due to the wrong balance being requested.", "body": "Although it is within liquidator\u2019s interest to liquidate as many oTokens as possible, there is no easy way to find out the maximum limit. The liquidate function will revert if liquidators try to liquidate too many oTokens. This design is not very user-friendly for liquidators, and it might cause liquidation events to fail multiple times due to the wrong balance being requested.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#although-it-is-within-liquidator\u2019s-interest-to-liquidate-as-many-otokens-as-possible,-there-is-no-easy-way-to-find-out-the-maximum-limit.-the-liquidate-function-will-revert-if-liquidators-try-to-liquidate-too-many-otokens.-this-design-is-not-very-user-friendly-for-liquidators,-and-it-might-cause-liquidation-events-to-fail-multiple-times-due-to-the-wrong-balance-being-requested.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a function to allow liquidators to get the maximum liquidation allowance for a certain Repo, or just allow liquidators to liquidate the maximum amount if their requests are over the maximum limit.", "body": "Consider adding a function to allow liquidators to get the maximum liquidation allowance for a certain Repo, or just allow liquidators to liquidate the maximum amount if their requests are over the maximum limit.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-adding-a-function-to-allow-liquidators-to-get-the-maximum-liquidation-allowance-for-a-certain-repo,-or-just-allow-liquidators-to-liquidate-the-maximum-amount-if-their-requests-are-over-the-maximum-limit.", "labels": ["OpenZeppelin"]}, {"title": "[N02][Fixed] Usage of SafeMath in non-uint256 variables", "body": "[N02][Fixed] Usage of SafeMath in non-uint256 variables", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n02][fixed]-usage-of-safemath-in-non-uint256-variables", "labels": ["OpenZeppelin"]}, {"title": "L518 and", "body": "L518 and", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#l518-and", "labels": ["OpenZeppelin"]}, {"title": "520 where the value is casted from", "body": "520 where the value is casted from", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#520-where-the-value-is-casted-from", "labels": ["OpenZeppelin"]}, {"title": "L592 and", "body": "L592 and", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#l592-and", "labels": ["OpenZeppelin"]}, {"title": "595)", "body": "595)", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#595)", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where all variables mentioned in the issue are casted to uint256.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where all variables mentioned in the issue are casted to uint256.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-all-variables-mentioned-in-the-issue-are-casted-to-uint256.", "labels": ["OpenZeppelin"]}, {"title": "[N03][Fixed] oTokens can still be burnt after the contract expires", "body": "[N03][Fixed] oTokens can still be burnt after the contract expires", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n03][fixed]-otokens-can-still-be-burnt-after-the-contract-expires", "labels": ["OpenZeppelin"]}, {"title": "In OptionsContract, the function burnOTokens should be limited to before the contract expires. There is no need to call this function after it expires, similar to the counterpart actions like issueoTokens, or add and remove collateral.", "body": "In OptionsContract, the function burnOTokens should be limited to before the contract expires. There is no need to call this function after it expires, similar to the counterpart actions like issueoTokens, or add and remove collateral.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-optionscontract,-the-function-burnotokens-should-be-limited-to-before-the-contract-expires.-there-is-no-need-to-call-this-function-after-it-expires,-similar-to-the-counterpart-actions-like-issueotokens,-or-add-and-remove-collateral.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a time check in the burnOTokens function.", "body": "Consider adding a time check in the burnOTokens function.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-adding-a-time-check-in-the-burnotokens-function.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where a notExpired modifier is added to the function.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where a notExpired modifier is added to the function.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-a-notexpired-modifier-is-added-to-the-function.", "labels": ["OpenZeppelin"]}, {"title": "[N04][Fixed] Change uint to uint256", "body": "[N04][Fixed] Change uint to uint256", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n04][fixed]-change-uint-to-uint256", "labels": ["OpenZeppelin"]}, {"title": "Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256. For example,, the following lines in OptionsContract:", "body": "Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256. For example,, the following lines in OptionsContract:", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#throughout-the-code-base,-some-variables-are-declared-as-uint.-to-favor-explicitness,-consider-changing-all-instances-of-uint-to-uint256.-for-example,,-the-following-lines-in-optionscontract:", "labels": ["OpenZeppelin"]}, {"title": "Line 200 returns (uint) should be returns (uint256)", "body": "Line 200 returns (uint) should be returns (uint256)", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#line-200-returns-(uint)-should-be-returns-(uint256)", "labels": ["OpenZeppelin"]}, {"title": "Line 315 returns (uint[] memory) should be returns (uint256[] memory)", "body": "Line 315 returns (uint[] memory) should be returns (uint256[] memory)", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#line-315-returns-(uint[]-memory)-should-be-returns-(uint256[]-memory)", "labels": ["OpenZeppelin"]}, {"title": "Line 316 uint[] should be uint256[]", "body": "Line 316 uint[] should be uint256[]", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#line-316-uint[]-should-be-uint256[]", "labels": ["OpenZeppelin"]}, {"title": "Line 318 uint index = 0 should be uint256 index = 0", "body": "Line 318 uint index = 0 should be uint256 index = 0", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#line-318-uint-index-=-0-should-be-uint256-index-=-0", "labels": ["OpenZeppelin"]}, {"title": "Line 327 uint[](count) should be uint256[](count)", "body": "Line 327 uint[](count) should be uint256[](count)", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#line-327-uint[](count)-should-be-uint256[](count)", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e, all issues above are either fixed or removed due to code update.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e, all issues above are either fixed or removed due to code update.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e,-all-issues-above-are-either-fixed-or-removed-due-to-code-update.", "labels": ["OpenZeppelin"]}, {"title": "[N05] External contracts addresses should be constants", "body": "[N05] External contracts addresses should be constants", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n05]-external-contracts-addresses-should-be-constants", "labels": ["OpenZeppelin"]}, {"title": "The OptionsUtils contract  provides basic functionalities regarding the available exchanges, the oracle, and how to tell if an asset is ETH.", "body": "The OptionsUtils contract  provides basic functionalities regarding the available exchanges, the oracle, and how to tell if an asset is ETH.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-optionsutils-contract--provides-basic-functionalities-regarding-the-available-exchanges,-the-oracle,-and-how-to-tell-if-an-asset-is-eth.", "labels": ["OpenZeppelin"]}, {"title": "Both the Compound Oracle and the Uniswap Factory addresses are stored in 2 public variables called COMPOUND_ORACLE and UNISWAP_FACTORY and those are assigned to the current addresses from the beginning.", "body": "Both the Compound Oracle and the Uniswap Factory addresses are stored in 2 public variables called COMPOUND_ORACLE and UNISWAP_FACTORY and those are assigned to the current addresses from the beginning.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#both-the-compound-oracle-and-the-uniswap-factory-addresses-are-stored-in-2-public-variables-called-compound_oracle-and-uniswap_factory-and-those-are-assigned-to-the-current-addresses-from-the-beginning.", "labels": ["OpenZeppelin"]}, {"title": "During the constructor function those variables are overridden using the parameters provided during the deployment, making the original assignments unnecessary.", "body": "During the constructor function those variables are overridden using the parameters provided during the deployment, making the original assignments unnecessary.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#during-the-constructor-function-those-variables-are-overridden-using-the-parameters-provided-during-the-deployment,-making-the-original-assignments-unnecessary.", "labels": ["OpenZeppelin"]}, {"title": "a new OptionsContract will copy the values set in the current OptionsExchange to its", "body": "a new OptionsContract will copy the values set in the current OptionsExchange to its", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#a-new-optionscontract-will-copy-the-values-set-in-the-current-optionsexchange-to-its", "labels": ["OpenZeppelin"]}, {"title": "the optionsExchange variable from OptionsFactory cannot be updated, the entire project would need to be re-deployed in order to change those variables. Instead of assigning these values twice, it is good enough to set the", "body": "the optionsExchange variable from OptionsFactory cannot be updated, the entire project would need to be re-deployed in order to change those variables. Instead of assigning these values twice, it is good enough to set the", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-optionsexchange-variable-from-optionsfactory-cannot-be-updated,-the-entire-project-would-need-to-be-re-deployed-in-order-to-change-those-variables.-instead-of-assigning-these-values-twice,-it-is-good-enough-to-set-the", "labels": ["OpenZeppelin"]}, {"title": "Consider declaring the variables as constant.", "body": "Consider declaring the variables as constant.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-declaring-the-variables-as-constant.", "labels": ["OpenZeppelin"]}, {"title": "[N06][Fixed] Default visibility", "body": "[N06][Fixed] Default visibility", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n06][fixed]-default-visibility", "labels": ["OpenZeppelin"]}, {"title": "Some state variables in OptionsContract are using the default public visibility. Consider declaring explicitly the visibility of all the variables for better readability.", "body": "Some state variables in OptionsContract are using the default public visibility. Consider declaring explicitly the visibility of all the variables for better readability.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#some-state-variables-in-optionscontract-are-using-the-default-public-visibility.-consider-declaring-explicitly-the-visibility-of-all-the-variables-for-better-readability.", "labels": ["OpenZeppelin"]}, {"title": "liquidationIncentive,", "body": "transactionFee,  liquidationFactor,  liquidationFee,  windowSize,  totalExercised,  totalFee,  totalUnderlying,  totalCollateral, and  collateralExp.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where state variable visibilities are clearly stated.  [N07][Fixed]Empty lines  There are some empty lines inside OptionsContract such as L39, L98, and L421.  To favor readability, consider using a linter such as Solhint.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where empty lines are removed  [N08][Fixed] Lack of checks  Certain functions in this project will execute even if the given parameters are not actually updating any state variable values.  For instance,  passing zero as the amtToRemove parameter for removeCollateral will cause the function to execute and trigger the RemoveCollateral event.  Calling transferRepoOwnership from the OptionsContract with the same address as previous owner will trigger the TransferRepoOwnership event but the owner of the Repo has not changed.  Calling transferRepoOwnership with zero address.  Creating a new repo by calling createOptionsContract with an expiry in the past or windowSize value larger that the expiry time.  Calling the updateParameters function with the same existing or wrong value for  liquidationFee,", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#liquidationincentive,", "labels": ["OpenZeppelin"]}, {"title": "transactionFee,", "body": "collateralizationRatio, and liquidationFactor.  These scenarios could emit useless events or compromise the functionality of the project. Consider adding parameter checks to these functions.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where proper validations and checks are added.  [N9][Partially Fixed] Misleading variable names  In OptionsContract, the variable amtCollateralToPayNum is actually the amount of collateral to pay in ETH, not in collateral.Consider renaming it to amtCollateralToPayInEthNum to avoid confusion.  In OptionsContract, the isSafe function creates a variable called with the same name as the function. Consider changing the name to stillSafe.  In OptionsContract, the getPrice function gets the price of the asset in ETH, but the name where those values are saved suggest the opposite. Consider changing them to collateralToEthPrice and StrikeToEthPrice.  Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where some of the variable names have been updated.  [N10][Fixed] Unknown use of multiple Repos per account  The OptionsContract allows any user to create a new Repo by calling the openRepo function.  However at the moment a single address can create as many Repos as they want but without getting a explicit benefit.  Consider adding to the documentation what are the benefits of doing this, or removing the possibility of having multiple Repos per account and allowing only one.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where repos are replaced by vaults and only one vault is allowed per user.  [N11][Fixed] Inverse order of operations  getExchange function creates a pointer to the  it checks if the address retrieved from Uniswaps getExchange is zero.  Consider first checking if the address returned by UNISWAP_FACTORY.getExchange(_token) in L26 is zero before linking the queried exchange instance into the local variable exchange.  Update: Fixed in line 29 of the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.  [N12][Fixed] Mismatch case for payable address  TransferRepoOwnership event takes the  the transferRepoOwnership function is called, a function that allows the old owner to change the ownership of the  There is a similar issue in the liquidate function: The Liquidate event is defined using an address parameter, however when it is used in the liquidate function, msg.sender can be payable if the collateral is ETH. Consider updating the variable type in the event.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.  [N13][Fixed] Repo owners might not know their collateral balance  The project team mentioned that they are implementing new code into the getRepoByIndex function to return the collateral balance of a Repo owner. However, it might be confusing for a Repo owner to see their collateral value drops due to other users calling the exercise function.This issue was pointed out to us by the project team and asked for our recommendation.  The fact is when the collateral drops, the underlying contained in the contract increases with each exercise call. It might be beneficial to return both the collateral and underlying balances when a Repo owner checks their balance. It is self-explanatory that when other users call exercise, the collateral balance drops while the underlying balance increases. Consider retrieving both balances to the Repo owner to prevent confusions about their balances.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where the newly added getVault() function returns both the collateral and underlying balances.  [N14][Partially Fixed] Misleading comments, variable names, and documentation typos  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  In the audited contracts, several functions have incomplete, or non-existent, docstrings which need to be completed.  In OptionsContract:  strikePrice should be strikePrice.  There are ToDo comments along the code which shows that part of the functionalities are not ready yet.  In L36, L40, and L43 a method is used to convert an integer to percentage (using the net percentage without adding the 100%), but in L47 and L162 it used a different method, which is not congruent to the previous one. For example, for the L40 definition 1054 == 105.4% but for the L47 definition, 1054 == 5.4%. Consider using only one method to calculate the percentage.  collatera should be collateral.  indecies should be indices.  In the exercise function a docstring implies that L270 transfers oTokens to the contract, but actually it burns them.  Functions that move oTokens from the user account, such as addERC20Collateral and exercise, do not say that the user has to allow the contract to handle their oTokens on his behalf before these functions are called.  The docstrings of the addETHCollateral function do not say what the return value is.  The revert message in the exercise function mentions the use of pTokens instead of the current oTokens.  There are places, such as L14, L15, L20, L26, L32, L34, L36, and L40, where it should be explained with more detail what the variable/contract does.  For the Number variables, such as the ones in L36, L40, L43, L47, and L51, it would be ideal add those examples to the actual Number structure in L20 and explicitly explain the formula that links the value with the exponent.  In OptionsExchange:  The functions sellPTokens and buyPTokens, along with their _pTokens parameters, implies the use of pTokens instead of oTokens. If these are a different type of tokens, then it should be explained in the documentation.  In the whitepaper:  cryptoassets in the section 1.1 line 2 should be crypto assets.  marketplaces marketplace in the section 3.3.1 paragraph 2 line 4-5 should be marketplaces.  Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e. Some of these issues are fixed in the new commit.  [N15] Funds cannot be withdrawn under certain conditions  After the OptionsContract has expired, the forgotten funds in collateral or underlying will remain in the contract forever.  Consider adding an extra time checkpoint, such as terminated, when it would be possible to withdraw the forgotten funds in the contract after this period is reached.  [N16] Unnecessary code  There are some uncessary code through out the project, for example  There is an unnecessary return operation in the issueOTokens function of the OptionsContract contract, the function definition does not specify any returned value.  The OptionsContract defines the same isEth function that was inherited from the OptionsUtils contract.  In the OptionsFactory it is imported the OptionsUtils contract to it but it is never used.  Consider removing all unnecessary code.  [N17][Fixed] Unneeded assignment  In the OptionsContract contract, the variable oTokenExchangeRate is defined and assigned but then, during the constructor, it is again assigned with the parameter value _oTokenExchangeExp.  Because the first assignment will not matter when the contract is deployed, consider removing it during the declaration of the variable.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89ewhere the oTokenExchangeRate value is only assigned once in the Constructor.  Conclusion  One critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Update: The Opyn team has fixed the critical issue and implemented partial fixes and monitoring solutions for all high issues in their follow up commit.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#transactionfee,", "labels": ["OpenZeppelin"]}, {"title": "liquidationFactor,", "body": "liquidationFactor,", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#liquidationfactor,", "labels": ["OpenZeppelin"]}, {"title": "liquidationFee,", "body": "transactionFee, collateralizationRatio, and liquidationFactor.  These scenarios could emit useless events or compromise the functionality of the project. Consider adding parameter checks to these functions.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where proper validations and checks are added.  [N9][Partially Fixed] Misleading variable names  In OptionsContract, the variable amtCollateralToPayNum is actually the amount of collateral to pay in ETH, not in collateral.Consider renaming it to amtCollateralToPayInEthNum to avoid confusion.  In OptionsContract, the isSafe function creates a variable called with the same name as the function. Consider changing the name to stillSafe.  In OptionsContract, the getPrice function gets the price of the asset in ETH, but the name where those values are saved suggest the opposite. Consider changing them to collateralToEthPrice and StrikeToEthPrice.  Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where some of the variable names have been updated.  [N10][Fixed] Unknown use of multiple Repos per account  The OptionsContract allows any user to create a new Repo by calling the openRepo function.  However at the moment a single address can create as many Repos as they want but without getting a explicit benefit.  Consider adding to the documentation what are the benefits of doing this, or removing the possibility of having multiple Repos per account and allowing only one.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where repos are replaced by vaults and only one vault is allowed per user.  [N11][Fixed] Inverse order of operations  getExchange function creates a pointer to the  it checks if the address retrieved from Uniswaps getExchange is zero.  Consider first checking if the address returned by UNISWAP_FACTORY.getExchange(_token) in L26 is zero before linking the queried exchange instance into the local variable exchange.  Update: Fixed in line 29 of the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.  [N12][Fixed] Mismatch case for payable address  TransferRepoOwnership event takes the  the transferRepoOwnership function is called, a function that allows the old owner to change the ownership of the  There is a similar issue in the liquidate function: The Liquidate event is defined using an address parameter, however when it is used in the liquidate function, msg.sender can be payable if the collateral is ETH. Consider updating the variable type in the event.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.  [N13][Fixed] Repo owners might not know their collateral balance  The project team mentioned that they are implementing new code into the getRepoByIndex function to return the collateral balance of a Repo owner. However, it might be confusing for a Repo owner to see their collateral value drops due to other users calling the exercise function.This issue was pointed out to us by the project team and asked for our recommendation.  The fact is when the collateral drops, the underlying contained in the contract increases with each exercise call. It might be beneficial to return both the collateral and underlying balances when a Repo owner checks their balance. It is self-explanatory that when other users call exercise, the collateral balance drops while the underlying balance increases. Consider retrieving both balances to the Repo owner to prevent confusions about their balances.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where the newly added getVault() function returns both the collateral and underlying balances.  [N14][Partially Fixed] Misleading comments, variable names, and documentation typos  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  In the audited contracts, several functions have incomplete, or non-existent, docstrings which need to be completed.  In OptionsContract:  strikePrice should be strikePrice.  There are ToDo comments along the code which shows that part of the functionalities are not ready yet.  In L36, L40, and L43 a method is used to convert an integer to percentage (using the net percentage without adding the 100%), but in L47 and L162 it used a different method, which is not congruent to the previous one. For example, for the L40 definition 1054 == 105.4% but for the L47 definition, 1054 == 5.4%. Consider using only one method to calculate the percentage.  collatera should be collateral.  indecies should be indices.  In the exercise function a docstring implies that L270 transfers oTokens to the contract, but actually it burns them.  Functions that move oTokens from the user account, such as addERC20Collateral and exercise, do not say that the user has to allow the contract to handle their oTokens on his behalf before these functions are called.  The docstrings of the addETHCollateral function do not say what the return value is.  The revert message in the exercise function mentions the use of pTokens instead of the current oTokens.  There are places, such as L14, L15, L20, L26, L32, L34, L36, and L40, where it should be explained with more detail what the variable/contract does.  For the Number variables, such as the ones in L36, L40, L43, L47, and L51, it would be ideal add those examples to the actual Number structure in L20 and explicitly explain the formula that links the value with the exponent.  In OptionsExchange:  The functions sellPTokens and buyPTokens, along with their _pTokens parameters, implies the use of pTokens instead of oTokens. If these are a different type of tokens, then it should be explained in the documentation.  In the whitepaper:  cryptoassets in the section 1.1 line 2 should be crypto assets.  marketplaces marketplace in the section 3.3.1 paragraph 2 line 4-5 should be marketplaces.  Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e. Some of these issues are fixed in the new commit.  [N15] Funds cannot be withdrawn under certain conditions  After the OptionsContract has expired, the forgotten funds in collateral or underlying will remain in the contract forever.  Consider adding an extra time checkpoint, such as terminated, when it would be possible to withdraw the forgotten funds in the contract after this period is reached.  [N16] Unnecessary code  There are some uncessary code through out the project, for example  There is an unnecessary return operation in the issueOTokens function of the OptionsContract contract, the function definition does not specify any returned value.  The OptionsContract defines the same isEth function that was inherited from the OptionsUtils contract.  In the OptionsFactory it is imported the OptionsUtils contract to it but it is never used.  Consider removing all unnecessary code.  [N17][Fixed] Unneeded assignment  In the OptionsContract contract, the variable oTokenExchangeRate is defined and assigned but then, during the constructor, it is again assigned with the parameter value _oTokenExchangeExp.  Because the first assignment will not matter when the contract is deployed, consider removing it during the declaration of the variable.  Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89ewhere the oTokenExchangeRate value is only assigned once in the Constructor.  Conclusion  One critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Update: The Opyn team has fixed the critical issue and implemented partial fixes and monitoring solutions for all high issues in their follow up commit.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#liquidationfee,", "labels": ["OpenZeppelin"]}, {"title": "windowSize,", "body": "windowSize,", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#windowsize,", "labels": ["OpenZeppelin"]}, {"title": "totalExercised,", "body": "totalExercised,", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#totalexercised,", "labels": ["OpenZeppelin"]}, {"title": "totalFee,", "body": "totalFee,", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#totalfee,", "labels": ["OpenZeppelin"]}, {"title": "totalUnderlying,", "body": "totalUnderlying,", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#totalunderlying,", "labels": ["OpenZeppelin"]}, {"title": "totalCollateral, and", "body": "totalCollateral, and", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#totalcollateral,-and", "labels": ["OpenZeppelin"]}, {"title": "collateralExp.", "body": "collateralExp.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#collateralexp.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where state variable visibilities are clearly stated.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where state variable visibilities are clearly stated.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-state-variable-visibilities-are-clearly-stated.", "labels": ["OpenZeppelin"]}, {"title": "[N07][Fixed]Empty lines", "body": "[N07][Fixed]Empty lines", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n07][fixed]empty-lines", "labels": ["OpenZeppelin"]}, {"title": "There are some empty lines inside OptionsContract such as L39, L98, and L421.", "body": "There are some empty lines inside OptionsContract such as L39, L98, and L421.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#there-are-some-empty-lines-inside-optionscontract-such-as-l39,-l98,-and-l421.", "labels": ["OpenZeppelin"]}, {"title": "To favor readability, consider using a linter such as Solhint.", "body": "To favor readability, consider using a linter such as Solhint.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#to-favor-readability,-consider-using-a-linter-such-as-solhint.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where empty lines are removed", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where empty lines are removed", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-empty-lines-are-removed", "labels": ["OpenZeppelin"]}, {"title": "[N08][Fixed] Lack of checks", "body": "[N08][Fixed] Lack of checks", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n08][fixed]-lack-of-checks", "labels": ["OpenZeppelin"]}, {"title": "Certain functions in this project will execute even if the given parameters are not actually updating any state variable values.", "body": "Certain functions in this project will execute even if the given parameters are not actually updating any state variable values.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#certain-functions-in-this-project-will-execute-even-if-the-given-parameters-are-not-actually-updating-any-state-variable-values.", "labels": ["OpenZeppelin"]}, {"title": "For instance,", "body": "For instance,", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#for-instance,", "labels": ["OpenZeppelin"]}, {"title": "passing zero as the amtToRemove parameter for removeCollateral will cause the function to execute and trigger the RemoveCollateral event.", "body": "passing zero as the amtToRemove parameter for removeCollateral will cause the function to execute and trigger the RemoveCollateral event.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#passing-zero-as-the-amttoremove-parameter-for-removecollateral-will-cause-the-function-to-execute-and-trigger-the-removecollateral-event.", "labels": ["OpenZeppelin"]}, {"title": "Calling transferRepoOwnership from the OptionsContract with the same address as previous owner will trigger the TransferRepoOwnership event but the owner of the Repo has not changed.", "body": "Calling transferRepoOwnership from the OptionsContract with the same address as previous owner will trigger the TransferRepoOwnership event but the owner of the Repo has not changed.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#calling-transferrepoownership-from-the-optionscontract-with-the-same-address-as-previous-owner-will-trigger-the-transferrepoownership-event-but-the-owner-of-the-repo-has-not-changed.", "labels": ["OpenZeppelin"]}, {"title": "Calling transferRepoOwnership with zero address.", "body": "Calling transferRepoOwnership with zero address.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#calling-transferrepoownership-with-zero-address.", "labels": ["OpenZeppelin"]}, {"title": "Creating a new repo by calling createOptionsContract with an expiry in the past or windowSize value larger that the expiry time.", "body": "Creating a new repo by calling createOptionsContract with an expiry in the past or windowSize value larger that the expiry time.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#creating-a-new-repo-by-calling-createoptionscontract-with-an-expiry-in-the-past-or-windowsize-value-larger-that-the-expiry-time.", "labels": ["OpenZeppelin"]}, {"title": "Calling the updateParameters function with the same existing or wrong value for liquidationIncentive, liquidationFee, transactionFee, collateralizationRatio, and liquidationFactor.", "body": "Calling the updateParameters function with the same existing or wrong value for liquidationIncentive, liquidationFee, transactionFee, collateralizationRatio, and liquidationFactor.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#calling-the-updateparameters-function-with-the-same-existing-or-wrong-value-for-liquidationincentive,-liquidationfee,-transactionfee,-collateralizationratio,-and-liquidationfactor.", "labels": ["OpenZeppelin"]}, {"title": "These scenarios could emit useless events or compromise the functionality of the project. Consider adding parameter checks to these functions.", "body": "These scenarios could emit useless events or compromise the functionality of the project. Consider adding parameter checks to these functions.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#these-scenarios-could-emit-useless-events-or-compromise-the-functionality-of-the-project.-consider-adding-parameter-checks-to-these-functions.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where proper validations and checks are added.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where proper validations and checks are added.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-proper-validations-and-checks-are-added.", "labels": ["OpenZeppelin"]}, {"title": "[N9][Partially Fixed] Misleading variable names", "body": "[N9][Partially Fixed] Misleading variable names", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n9][partially-fixed]-misleading-variable-names", "labels": ["OpenZeppelin"]}, {"title": "In OptionsContract, the variable amtCollateralToPayNum is actually the amount of collateral to pay in ETH, not in collateral.Consider renaming it to amtCollateralToPayInEthNum to avoid confusion.", "body": "In OptionsContract, the variable amtCollateralToPayNum is actually the amount of collateral to pay in ETH, not in collateral.Consider renaming it to amtCollateralToPayInEthNum to avoid confusion.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-optionscontract,-the-variable-amtcollateraltopaynum-is-actually-the-amount-of-collateral-to-pay-in-eth,-not-in-collateral.consider-renaming-it-to-amtcollateraltopayinethnum-to-avoid-confusion.", "labels": ["OpenZeppelin"]}, {"title": "In OptionsContract, the isSafe function creates a variable called with the same name as the function. Consider changing the name to stillSafe.", "body": "In OptionsContract, the isSafe function creates a variable called with the same name as the function. Consider changing the name to stillSafe.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-optionscontract,-the-issafe-function-creates-a-variable-called-with-the-same-name-as-the-function.-consider-changing-the-name-to-stillsafe.", "labels": ["OpenZeppelin"]}, {"title": "In OptionsContract, the getPrice function gets the price of the asset in ETH, but the name where those values are saved suggest the opposite. Consider changing them to collateralToEthPrice and StrikeToEthPrice.", "body": "In OptionsContract, the getPrice function gets the price of the asset in ETH, but the name where those values are saved suggest the opposite. Consider changing them to collateralToEthPrice and StrikeToEthPrice.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-optionscontract,-the-getprice-function-gets-the-price-of-the-asset-in-eth,-but-the-name-where-those-values-are-saved-suggest-the-opposite.-consider-changing-them-to-collateraltoethprice-and-striketoethprice.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where some of the variable names have been updated.", "body": "Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where some of the variable names have been updated.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-partially-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-some-of-the-variable-names-have-been-updated.", "labels": ["OpenZeppelin"]}, {"title": "[N10][Fixed] Unknown use of multiple Repos per account", "body": "[N10][Fixed] Unknown use of multiple Repos per account", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n10][fixed]-unknown-use-of-multiple-repos-per-account", "labels": ["OpenZeppelin"]}, {"title": "The OptionsContract allows any user to create a new Repo by calling the openRepo function.", "body": "The OptionsContract allows any user to create a new Repo by calling the openRepo function.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-optionscontract-allows-any-user-to-create-a-new-repo-by-calling-the-openrepo-function.", "labels": ["OpenZeppelin"]}, {"title": "However at the moment a single address can create as many Repos as they want but without getting a explicit benefit.", "body": "However at the moment a single address can create as many Repos as they want but without getting a explicit benefit.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#however-at-the-moment-a-single-address-can-create-as-many-repos-as-they-want-but-without-getting-a-explicit-benefit.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding to the documentation what are the benefits of doing this, or removing the possibility of having multiple Repos per account and allowing only one.", "body": "Consider adding to the documentation what are the benefits of doing this, or removing the possibility of having multiple Repos per account and allowing only one.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-adding-to-the-documentation-what-are-the-benefits-of-doing-this,-or-removing-the-possibility-of-having-multiple-repos-per-account-and-allowing-only-one.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where repos are replaced by vaults and only one vault is allowed per user.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where repos are replaced by vaults and only one vault is allowed per user.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-repos-are-replaced-by-vaults-and-only-one-vault-is-allowed-per-user.", "labels": ["OpenZeppelin"]}, {"title": "[N11][Fixed] Inverse order of operations", "body": "[N11][Fixed] Inverse order of operations", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n11][fixed]-inverse-order-of-operations", "labels": ["OpenZeppelin"]}, {"title": "getExchange function creates a pointer to the", "body": "getExchange function creates a pointer to the", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#getexchange-function-creates-a-pointer-to-the", "labels": ["OpenZeppelin"]}, {"title": "it checks if the address retrieved from Uniswap\u2019s getExchange is zero.", "body": "it checks if the address retrieved from Uniswap\u2019s getExchange is zero.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#it-checks-if-the-address-retrieved-from-uniswap\u2019s-getexchange-is-zero.", "labels": ["OpenZeppelin"]}, {"title": "Consider first checking if the address returned by UNISWAP_FACTORY.getExchange(_token) in L26 is zero before linking the queried exchange instance into the local variable exchange.", "body": "Consider first checking if the address returned by UNISWAP_FACTORY.getExchange(_token) in L26 is zero before linking the queried exchange instance into the local variable exchange.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-first-checking-if-the-address-returned-by-uniswap_factory.getexchange(_token)-in-l26-is-zero-before-linking-the-queried-exchange-instance-into-the-local-variable-exchange.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in line 29 of the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "body": "Update: Fixed in line 29 of the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-line-29-of-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "labels": ["OpenZeppelin"]}, {"title": "[N12][Fixed] Mismatch case for payable address", "body": "[N12][Fixed] Mismatch case for payable address", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n12][fixed]-mismatch-case-for-payable-address", "labels": ["OpenZeppelin"]}, {"title": "TransferRepoOwnership event takes the", "body": "TransferRepoOwnership event takes the", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#transferrepoownership-event-takes-the", "labels": ["OpenZeppelin"]}, {"title": "the transferRepoOwnership function is called, a function that allows the old owner to change the ownership of the", "body": "the transferRepoOwnership function is called, a function that allows the old owner to change the ownership of the", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-transferrepoownership-function-is-called,-a-function-that-allows-the-old-owner-to-change-the-ownership-of-the", "labels": ["OpenZeppelin"]}, {"title": "There is a similar issue in the liquidate function: The Liquidate event is defined using an address parameter, however when it is used in the liquidate function, msg.sender can be payable if the collateral is ETH. Consider updating the variable type in the event.", "body": "There is a similar issue in the liquidate function: The Liquidate event is defined using an address parameter, however when it is used in the liquidate function, msg.sender can be payable if the collateral is ETH. Consider updating the variable type in the event.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#there-is-a-similar-issue-in-the-liquidate-function:-the-liquidate-event-is-defined-using-an-address-parameter,-however-when-it-is-used-in-the-liquidate-function,-msg.sender-can-be-payable-if-the-collateral-is-eth.-consider-updating-the-variable-type-in-the-event.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.", "labels": ["OpenZeppelin"]}, {"title": "[N13][Fixed] Repo owners might not know their collateral balance", "body": "[N13][Fixed] Repo owners might not know their collateral balance", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n13][fixed]-repo-owners-might-not-know-their-collateral-balance", "labels": ["OpenZeppelin"]}, {"title": "The project team mentioned that they are implementing new code into the getRepoByIndex function to return the collateral balance of a Repo owner. However, it might be confusing for a Repo owner to see their collateral value drops due to other users calling the exercise function.This issue was pointed out to us by the project team and asked for our recommendation.", "body": "The project team mentioned that they are implementing new code into the getRepoByIndex function to return the collateral balance of a Repo owner. However, it might be confusing for a Repo owner to see their collateral value drops due to other users calling the exercise function.This issue was pointed out to us by the project team and asked for our recommendation.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-project-team-mentioned-that-they-are-implementing-new-code-into-the-getrepobyindex-function-to-return-the-collateral-balance-of-a-repo-owner.-however,-it-might-be-confusing-for-a-repo-owner-to-see-their-collateral-value-drops-due-to-other-users-calling-the-exercise-function.this-issue-was-pointed-out-to-us-by-the-project-team-and-asked-for-our-recommendation.", "labels": ["OpenZeppelin"]}, {"title": "The fact is when the collateral drops, the underlying contained in the contract increases with each exercise call. It might be beneficial to return both the collateral and underlying balances when a Repo owner checks their balance. It is self-explanatory that when other users call exercise, the collateral balance drops while the underlying balance increases. Consider retrieving both balances to the Repo owner to prevent confusions about their balances.", "body": "The fact is when the collateral drops, the underlying contained in the contract increases with each exercise call. It might be beneficial to return both the collateral and underlying balances when a Repo owner checks their balance. It is self-explanatory that when other users call exercise, the collateral balance drops while the underlying balance increases. Consider retrieving both balances to the Repo owner to prevent confusions about their balances.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-fact-is-when-the-collateral-drops,-the-underlying-contained-in-the-contract-increases-with-each-exercise-call.-it-might-be-beneficial-to-return-both-the-collateral-and-underlying-balances-when-a-repo-owner-checks-their-balance.-it-is-self-explanatory-that-when-other-users-call-exercise,-the-collateral-balance-drops-while-the-underlying-balance-increases.-consider-retrieving-both-balances-to-the-repo-owner-to-prevent-confusions-about-their-balances.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where the newly added getVault() function returns both the collateral and underlying balances.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e where the newly added getVault() function returns both the collateral and underlying balances.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e-where-the-newly-added-getvault()-function-returns-both-the-collateral-and-underlying-balances.", "labels": ["OpenZeppelin"]}, {"title": "[N14][Partially Fixed] Misleading comments, variable names, and documentation typos", "body": "[N14][Partially Fixed] Misleading comments, variable names, and documentation typos", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n14][partially-fixed]-misleading-comments,-variable-names,-and-documentation-typos", "labels": ["OpenZeppelin"]}, {"title": "Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.", "body": "Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#since-the-purpose-of-the-ethereum-natural-specification-(natspec)-is-to-describe-the-code-to-end-users,-misleading-statements-should-be-considered-a-violation-of-the-public-api.", "labels": ["OpenZeppelin"]}, {"title": "In the audited contracts, several functions have incomplete, or non-existent, docstrings which need to be completed.", "body": "In the audited contracts, several functions have incomplete, or non-existent, docstrings which need to be completed.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-the-audited-contracts,-several-functions-have-incomplete,-or-non-existent,-docstrings-which-need-to-be-completed.", "labels": ["OpenZeppelin"]}, {"title": "In OptionsContract:", "body": "In OptionsContract:", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-optionscontract:", "labels": ["OpenZeppelin"]}, {"title": "strikePrice should be strikePrice.", "body": "strikePrice should be strikePrice.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#strikeprice-should-be-strikeprice.", "labels": ["OpenZeppelin"]}, {"title": "There are ToDo comments along the code which shows that part of the functionalities are not ready yet.", "body": "There are ToDo comments along the code which shows that part of the functionalities are not ready yet.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#there-are-todo-comments-along-the-code-which-shows-that-part-of-the-functionalities-are-not-ready-yet.", "labels": ["OpenZeppelin"]}, {"title": "In L36, L40, and L43 a method is used to convert an integer to percentage (using the net percentage without adding the 100%), but in L47 and L162 it used a different method, which is not congruent to the previous one. For example, for the L40 definition 1054 == 105.4% but for the L47 definition, 1054 == 5.4%. Consider using only one method to calculate the percentage.", "body": "In L36, L40, and L43 a method is used to convert an integer to percentage (using the net percentage without adding the 100%), but in L47 and L162 it used a different method, which is not congruent to the previous one. For example, for the L40 definition 1054 == 105.4% but for the L47 definition, 1054 == 5.4%. Consider using only one method to calculate the percentage.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-l36,-l40,-and-l43-a-method-is-used-to-convert-an-integer-to-percentage-(using-the-net-percentage-without-adding-the-100%),-but-in-l47-and-l162-it-used-a-different-method,-which-is-not-congruent-to-the-previous-one.-for-example,-for-the-l40-definition-1054-==-105.4%-but-for-the-l47-definition,-1054-==-5.4%.-consider-using-only-one-method-to-calculate-the-percentage.", "labels": ["OpenZeppelin"]}, {"title": "collatera should be collateral.", "body": "collatera should be collateral.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#collatera-should-be-collateral.", "labels": ["OpenZeppelin"]}, {"title": "indecies should be indices.", "body": "indecies should be indices.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#indecies-should-be-indices.", "labels": ["OpenZeppelin"]}, {"title": "In the exercise function a docstring implies that L270 transfers oTokens to the contract, but actually it burns them.", "body": "In the exercise function a docstring implies that L270 transfers oTokens to the contract, but actually it burns them.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-the-exercise-function-a-docstring-implies-that-l270-transfers-otokens-to-the-contract,-but-actually-it-burns-them.", "labels": ["OpenZeppelin"]}, {"title": "Functions that move oTokens from the user account, such as addERC20Collateral and exercise, do not say that the user has to allow the contract to handle their oTokens on his behalf before these functions are called.", "body": "Functions that move oTokens from the user account, such as addERC20Collateral and exercise, do not say that the user has to allow the contract to handle their oTokens on his behalf before these functions are called.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#functions-that-move-otokens-from-the-user-account,-such-as-adderc20collateral-and-exercise,-do-not-say-that-the-user-has-to-allow-the-contract-to-handle-their-otokens-on-his-behalf-before-these-functions-are-called.", "labels": ["OpenZeppelin"]}, {"title": "The docstrings of the addETHCollateral function do not say what the return value is.", "body": "The docstrings of the addETHCollateral function do not say what the return value is.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-docstrings-of-the-addethcollateral-function-do-not-say-what-the-return-value-is.", "labels": ["OpenZeppelin"]}, {"title": "The revert message in the exercise function mentions the use of pTokens instead of the current oTokens.", "body": "The revert message in the exercise function mentions the use of pTokens instead of the current oTokens.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-revert-message-in-the-exercise-function-mentions-the-use-of-ptokens-instead-of-the-current-otokens.", "labels": ["OpenZeppelin"]}, {"title": "There are places, such as L14, L15, L20, L26, L32, L34, L36, and L40, where it should be explained with more detail what the variable/contract does.", "body": "There are places, such as L14, L15, L20, L26, L32, L34, L36, and L40, where it should be explained with more detail what the variable/contract does.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#there-are-places,-such-as-l14,-l15,-l20,-l26,-l32,-l34,-l36,-and-l40,-where-it-should-be-explained-with-more-detail-what-the-variable/contract-does.", "labels": ["OpenZeppelin"]}, {"title": "For the Number variables, such as the ones in L36, L40, L43, L47, and L51, it would be ideal add those examples to the actual Number structure in L20 and explicitly explain the formula that links the value with the exponent.", "body": "For the Number variables, such as the ones in L36, L40, L43, L47, and L51, it would be ideal add those examples to the actual Number structure in L20 and explicitly explain the formula that links the value with the exponent.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#for-the-number-variables,-such-as-the-ones-in-l36,-l40,-l43,-l47,-and-l51,-it-would-be-ideal-add-those-examples-to-the-actual-number-structure-in-l20-and-explicitly-explain-the-formula-that-links-the-value-with-the-exponent.", "labels": ["OpenZeppelin"]}, {"title": "In OptionsExchange:", "body": "In OptionsExchange:", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-optionsexchange:", "labels": ["OpenZeppelin"]}, {"title": "The functions sellPTokens and buyPTokens, along with their _pTokens parameters, implies the use of pTokens instead of oTokens. If these are a different type of tokens, then it should be explained in the documentation.", "body": "The functions sellPTokens and buyPTokens, along with their _pTokens parameters, implies the use of pTokens instead of oTokens. If these are a different type of tokens, then it should be explained in the documentation.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-functions-sellptokens-and-buyptokens,-along-with-their-_ptokens-parameters,-implies-the-use-of-ptokens-instead-of-otokens.-if-these-are-a-different-type-of-tokens,-then-it-should-be-explained-in-the-documentation.", "labels": ["OpenZeppelin"]}, {"title": "In the whitepaper:", "body": "In the whitepaper:", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-the-whitepaper:", "labels": ["OpenZeppelin"]}, {"title": "\u201ccryptoassets\u201d in the section 1.1 line 2 should be \u201ccrypto assets\u201d.", "body": "\u201ccryptoassets\u201d in the section 1.1 line 2 should be \u201ccrypto assets\u201d.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#\u201ccryptoassets\u201d-in-the-section-1.1-line-2-should-be-\u201ccrypto-assets\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cmarketplaces marketplace\u201d in the section 3.3.1 paragraph 2 line 4-5 should be \u201cmarketplaces\u201d.", "body": "\u201cmarketplaces marketplace\u201d in the section 3.3.1 paragraph 2 line 4-5 should be \u201cmarketplaces\u201d.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#\u201cmarketplaces-marketplace\u201d-in-the-section-3.3.1-paragraph-2-line-4-5-should-be-\u201cmarketplaces\u201d.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e. Some of these issues are fixed in the new commit.", "body": "Update: Partially Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89e. Some of these issues are fixed in the new commit.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-partially-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89e.-some-of-these-issues-are-fixed-in-the-new-commit.", "labels": ["OpenZeppelin"]}, {"title": "[N15] Funds cannot be withdrawn under certain conditions", "body": "[N15] Funds cannot be withdrawn under certain conditions", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n15]-funds-cannot-be-withdrawn-under-certain-conditions", "labels": ["OpenZeppelin"]}, {"title": "After the OptionsContract has expired, the forgotten funds in collateral or underlying will remain in the contract forever.", "body": "After the OptionsContract has expired, the forgotten funds in collateral or underlying will remain in the contract forever.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#after-the-optionscontract-has-expired,-the-forgotten-funds-in-collateral-or-underlying-will-remain-in-the-contract-forever.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding an extra time checkpoint, such as terminated, when it would be possible to withdraw the forgotten funds in the contract after this period is reached.", "body": "Consider adding an extra time checkpoint, such as terminated, when it would be possible to withdraw the forgotten funds in the contract after this period is reached.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-adding-an-extra-time-checkpoint,-such-as-terminated,-when-it-would-be-possible-to-withdraw-the-forgotten-funds-in-the-contract-after-this-period-is-reached.", "labels": ["OpenZeppelin"]}, {"title": "[N16] Unnecessary code", "body": "[N16] Unnecessary code", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n16]-unnecessary-code", "labels": ["OpenZeppelin"]}, {"title": "There are some uncessary code through out the project, for example", "body": "There are some uncessary code through out the project, for example", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#there-are-some-uncessary-code-through-out-the-project,-for-example", "labels": ["OpenZeppelin"]}, {"title": "There is an unnecessary return operation in the issueOTokens function of the OptionsContract contract, the function definition does not specify any returned value.", "body": "There is an unnecessary return operation in the issueOTokens function of the OptionsContract contract, the function definition does not specify any returned value.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#there-is-an-unnecessary-return-operation-in-the-issueotokens-function-of-the-optionscontract-contract,-the-function-definition-does-not-specify-any-returned-value.", "labels": ["OpenZeppelin"]}, {"title": "The OptionsContract defines the same isEth function that was inherited from the OptionsUtils contract.", "body": "The OptionsContract defines the same isEth function that was inherited from the OptionsUtils contract.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#the-optionscontract-defines-the-same-iseth-function-that-was-inherited-from-the-optionsutils-contract.", "labels": ["OpenZeppelin"]}, {"title": "In the OptionsFactory it is imported the OptionsUtils contract to it but it is never used.", "body": "In the OptionsFactory it is imported the OptionsUtils contract to it but it is never used.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-the-optionsfactory-it-is-imported-the-optionsutils-contract-to-it-but-it-is-never-used.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing all unnecessary code.", "body": "Consider removing all unnecessary code.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#consider-removing-all-unnecessary-code.", "labels": ["OpenZeppelin"]}, {"title": "[N17][Fixed] Unneeded assignment", "body": "[N17][Fixed] Unneeded assignment", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#[n17][fixed]-unneeded-assignment", "labels": ["OpenZeppelin"]}, {"title": "In the OptionsContract contract, the variable oTokenExchangeRate is defined and assigned but then, during the constructor, it is again assigned with the parameter value _oTokenExchangeExp.", "body": "In the OptionsContract contract, the variable oTokenExchangeRate is defined and assigned but then, during the constructor, it is again assigned with the parameter value _oTokenExchangeExp.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#in-the-optionscontract-contract,-the-variable-otokenexchangerate-is-defined-and-assigned-but-then,-during-the-constructor,-it-is-again-assigned-with-the-parameter-value-_otokenexchangeexp.", "labels": ["OpenZeppelin"]}, {"title": "Because the first assignment will not matter when the contract is deployed, consider removing it during the declaration of the variable.", "body": "Because the first assignment will not matter when the contract is deployed, consider removing it during the declaration of the variable.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#because-the-first-assignment-will-not-matter-when-the-contract-is-deployed,-consider-removing-it-during-the-declaration-of-the-variable.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89ewhere the oTokenExchangeRate value is only assigned once in the Constructor.", "body": "Update: Fixed in the follow-up commit 3adfd9afa6d463869d9e0a78cc7f316ae34eb89ewhere the oTokenExchangeRate value is only assigned once in the Constructor.", "html_url": "https://blog.openzeppelin.com/opyn-contracts-audit#update:-fixed-in-the-follow-up-commit-3adfd9afa6d463869d9e0a78cc7f316ae34eb89ewhere-the-otokenexchangerate-value-is-only-assigned-once-in-the-constructor.", "labels": ["OpenZeppelin"]}, {"title": "None. \ud83d\ude42", "body": "None. \ud83d\ude42", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#none.-\ud83d\ude42", "labels": ["OpenZeppelin"]}, {"title": "[H01] Users can influence the lottery winner", "body": "[H01] Users can influence the lottery winner", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[h01]-users-can-influence-the-lottery-winner", "labels": ["OpenZeppelin"]}, {"title": "When the administrator calls reward or rewardAndOpenNextDraw, the secret and salt that will determine the lottery winner is revealed.", "body": "When the administrator calls reward or rewardAndOpenNextDraw, the secret and salt that will determine the lottery winner is revealed.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#when-the-administrator-calls-reward-or-rewardandopennextdraw,-the-secret-and-salt-that-will-determine-the-lottery-winner-is-revealed.", "labels": ["OpenZeppelin"]}, {"title": "However, the selected address will depend on the distribution of committed draws, which can be influenced by sending pool tokens to another address, burning pool tokens, or withdrawing an address\u2019 entire balance. It can also be influenced by sending SAI pool tokens to the DAI pool contract.", "body": "However, the selected address will depend on the distribution of committed draws, which can be influenced by sending pool tokens to another address, burning pool tokens, or withdrawing an address\u2019 entire balance. It can also be influenced by sending SAI pool tokens to the DAI pool contract.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#however,-the-selected-address-will-depend-on-the-distribution-of-committed-draws,-which-can-be-influenced-by-sending-pool-tokens-to-another-address,-burning-pool-tokens,-or-withdrawing-an-address\u2019-entire-balance.-it-can-also-be-influenced-by-sending-sai-pool-tokens-to-the-dai-pool-contract.", "labels": ["OpenZeppelin"]}, {"title": "This gives users an opportunity to front-run the administrator transaction (by setting higher gas prices or mining the block themselves) in order to control the pool distribution and ensure an address they control will win the lottery. Consider freezing the committed distribution before revealing the lottery secret.", "body": "This gives users an opportunity to front-run the administrator transaction (by setting higher gas prices or mining the block themselves) in order to control the pool distribution and ensure an address they control will win the lottery. Consider freezing the committed distribution before revealing the lottery secret.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#this-gives-users-an-opportunity-to-front-run-the-administrator-transaction-(by-setting-higher-gas-prices-or-mining-the-block-themselves)-in-order-to-control-the-pool-distribution-and-ensure-an-address-they-control-will-win-the-lottery.-consider-freezing-the-committed-distribution-before-revealing-the-lottery-secret.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#3. There is a new administrator function that can temporarily freeze all Pool Token balances, which should be called before the lottery secret is revealed. Additionally, it includes a cool down period, set during the Pool initialization, to prevent the administrator from repeatedly calling this function and keeping the balances frozen indefinitely. Naturally, this restriction can be changed or bypassed if the contract is upgraded.", "body": "Update: Fixed in PR#3. There is a new administrator function that can temporarily freeze all Pool Token balances, which should be called before the lottery secret is revealed. Additionally, it includes a cool down period, set during the Pool initialization, to prevent the administrator from repeatedly calling this function and keeping the balances frozen indefinitely. Naturally, this restriction can be changed or bypassed if the contract is upgraded.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#3.-there-is-a-new-administrator-function-that-can-temporarily-freeze-all-pool-token-balances,-which-should-be-called-before-the-lottery-secret-is-revealed.-additionally,-it-includes-a-cool-down-period,-set-during-the-pool-initialization,-to-prevent-the-administrator-from-repeatedly-calling-this-function-and-keeping-the-balances-frozen-indefinitely.-naturally,-this-restriction-can-be-changed-or-bypassed-if-the-contract-is-upgraded.", "labels": ["OpenZeppelin"]}, {"title": "[H02] Winners can stall the system", "body": " and any mitigation should consider both simultaneously.  Update: Fixed in PR#3. The awardWinnings function has been removed. This pull request actually removes the Minted and Transfer events entirely as part of a broader code refactoring, but they are reintroduced in PR#4  [M02] Bypassing token events  Pool Tokens can be redeemed by calling the burn function on the ERC777Pool contract. This will emit the Burned and Transfer events.  However, users can also call the withdraw function, which does not emit the events, to redeem their full balance of underlying tokens.  This will prevent users from reacting to these state changes from the ERC777 events (although if they are aware of the code structure they could respond to the Withdrawn event). It also means that the Minted and Burned events will not track the total token supply. Note that the Withdrawn event does not compensate for this because it does not distinguish between committed balances, open draw balances, sponsorship balances, and fees. Consider either preventing the withdraw function from applying to committed deposits (that have corresponding Pool tokens), or otherwise modifying it to emit the appropriate events.  Note: this issue is related to [L05] Conflated balances and any mitigation should consider them both simultaneously.  Update: Fixed in PR#4. The Minted and Burned events are emitted when committed balances are withdrawn from the pool.  Low severity  [L01] Deviation from ERC777 specification  Pool Tokens are created in a non-conventional way. Whenever users deposit assets into the system, they are internally accounted for but the new balances are not accessible to the ERC777 token functions. At the end of the draw, when the balances become available, it is no longer practical to create the corresponding Minted and Transfer events for each user. Instead, these events are emitted once for all users, with the recipient set to the Pool contract.  This is a deviation from the ERC777 specification and makes it impossible to track balances using the event logs. This is already acknowledged and documented by the PoolTogether team, but we believe it should be stated in this report anyway for the sake of transparency and community awareness.  [L02] Only direct deposits are pausable  The BasePool contract implements a mechanism to allow an administrator to pause the pool contract. However, only the direct deposit functions (depositPool and depositSponsorship) are affected. In particular, it is arguable that indirect deposits of DAI through the SAI migration mechanism should also be paused for consistency.  Depending on the intended uses of the pause functionality, it may be desirable to permit the use of the other functions anyway. Nevertheless, it is surprising that the balances and contract state can change while the contract is paused. Consider documenting this decision and the corresponding rationale.  Update: Fixed in PR#7. The names and documentation have been updated to clarify that the intention is to pause deposits into deprecated pools. Paused contracts are now also prevented from accepting indirect deposits and converting any unexpected token balance into a sponsorship.  [L03] Double spending ERC20 allowance  Like all compliant ERC20 tokens, the ERC777Pool contract is vulnerable to the allowance double spending attack. Briefly, an authorized spender could spend both allowances by front running an allowance-changing transaction. Consider implementing OpenZeppelins decreaseAllowance and increaseAllowance functions to help mitigate this.  Update: Fixed in PR#16. The functions were implemented.  [L04] Unexpected Side Effects  Each Pool Token is a claim on an equivalent amount of the underlying token. The burn and operatorBurn functions of the ERC777Pool contract destroy the Pool Tokens, redeem the equivalent value of cTokens in exchange for the underlying asset from Compound, and then return the underlying asset to the token holder. This is the standard mechanism for exiting the PoolTogether system.  However, the conventionally understood definition of burning ERC20 or ERC777 tokens means sacrificing the token values by sending them to the zero address. As it turns out, this is one step in the redeem functionality, but there are other side effects as well.  Consider adding redeem and operatorRedeem functions to handle the standard withdrawal mechanism. The burn and operatorBurn functions should simply destroy tokens (and they may also prevent some or all users from burning tokens).  Update: Fixed in PR#8. The functionality to exchange pool tokens for underlying tokens is now known as redeeming. The burn and operatorBurn functions revert.  [L05] Conflated balances  The comments on the totalBalanceOf function suggest that the users total balance is comprised of the underlying token balance in open and committed draws. In fact, their underlying balance could also increase when receiving fees or when choosing to sponsor the lottery.  Depending on the intention of the totalBalanceOf function, either the code or the comments should be updated for consistency.  Additionally, since these increases never emit Minted events, update the committed supply, or effect the balanceOf function, they arent and wont be tokenized into Pool Tokens. This means there is no mechanism to withdraw them individually. Instead users must call the withdraw function to redeem their full balances across all draws.  Consider allowing partial withdraws in the withdraw function or providing another mechanism to retrieve balances that are outside all draws.  Note: this issue is related to [M02] Bypassing token events and any mitigation should consider them both simultaneously.  Update: Fixed in PR#4. The totalBalanceOf function comments have been updated. Additional events and functions have been created to support withdrawing from the different user balances. Note that the Withdrawn event no longer applies to token transfers between users.  [L06] Misleading comments and variable names  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  The @return comment describing BasePool.getDraw only describes 4 of the 8 return values.  The @notice function of BasePool.balanceOf states that it returns the users total balance but it only returns the committed balance.  The rewardAndOpenNextDraw function and the reward function of BasePool do not have a @param comment for the salt.  The BasePool contract returns the error message could not transfer winnings even though it applies to all balances.  The @notice function of DrawManager.draw does not describe the case where are no participants.  In addition, the following internal documentation could be clarified:  The MAX_LEAVES constant does not constrain the number of leaves in the sortition tree. It should be a synonym of MAX_BRANCHES_PER_NODE or DEGREE_OF_TREE. It is also missing its comment.  Many of the BasePool functions are not documented.  The emitCommitted functions in the BasePool contract and the ERC777Pool contract claim to commit the current draw. In fact, they simply emit events. The relevant state changes occur when the new draw is opened.  The comments describing ERC777Pool._callTokensReceived do not include the last parameter.  The requireOpenDraw and onlyNonZero modifiers are missing their comments.  The RecipientWhitelistERC777Pool contract and most of its functions are not commented.  Update: Fixed in PR#21. These suggestions were implemented and the documentation has been significantly expanded.  [L07] Excessive code coupling  During a transfer of Pool Tokens, the balance gets added to the recipients committed draw tree. If the recipient does not have any committed balance, it is added to a newly created balance associated with the previous draw.  However, if the pool is currently in the first draw, which starts at index 1, this will associate the new balance with the invalid zero draw, and will also leave the users first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.  Fortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.  Nevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).  Consider confirming that the first draw is committed before assigning deposits to the previous draw.  Update: Fixed in PR#9. The depositCommitted and withdrawCommitted functions now require at least one draw to be committed.  [L08] Unchecked casting from uint256 to int256  The BasePool contract uses the FixidityLib to perform fixed point arithmetic with protection against overflow.  accepts an int256 as the parameter so the  need to be cast into int256 values.  If one of those parameters is higher than the maximum int256, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.  Consider ensuring that neither parameter exceeds the maximum int256.  Update: Fixed in PR#12. The _grossWinnings variable is now capped at the maximum safe value. The _feeFraction was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.  Notes  [N01] Unrestricted token ownership  Whenever a pool token is transferred, the RecipientWhitelistERC777Pool contract restricts the possible recipients to an administrator-defined white list. It should be noted that this does not prevent addresses from receiving tokens in exchange for deposits or winning them in a lottery.  Update: This is the expected behavior  [N02] Inconsistent imports  The code base imports contracts from the OpenZeppelin contracts package as well as contracts-ethereum-package. This is unnecessary and may cause issues if there is a name collision with imported contracts across both packages (or the contracts they depend on). In this case there is no collision, but it does introduce unnecessary fragility.  Consider using contracts-ethereum-package exclusively, which is a copy of contracts that is consistent with the OpenZeppelin upgrades package.  Update: Fixed in PR#10.  [N03] Default Visibility  Throughout the code base, some of the contract variables use default visibility. For readability, consider explicitly declaring the visibility of all state variables.  Update: Fixed in PR#13.  [N04] Reimplementing Pausable  The BasePool contract allows an administrator to pause and resume some functions. The functionality is already part of OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.  Consider inheriting from the OpenZeppelin Pausable contract to benefit from bug fixes to be applied in future releases and to reduce the codes attack surface.  Update: Accepted. PoolTogether would prefer not to adopt this suggestion since it would change the storage layout of an existing contract.  [N05] Repeated code  The RecipientWhitelistERC777Pool contract overrides the _callTokensToSend function to restrict the possible recipients. However, the rest of the function is identical. For simplicity, consider invoking the overridden function to execute the tokensToSend hook.  Update: Fixed in PR#4.  [N06] Random upper bound of zero  The uniform function of the UniformRandomNumber library returns zero whenever the specified upper bound is zero. This contradicts the Ethereum Natural Specification comment and is inconsistent with the usual behavior of returning a value strictly less than the upper bound.  Consider requiring the upper bound to be non-zero, or updating the comment accordingly.  Update: Fixed in PR#14. The bound is now required to be greater than zero. The edge case is handled in the calling function.  [N07] Semantic Overloading  The pool contract identifies if a particular draw has been rewarded by checking if the entropy is non zero. This works because the winner is rewarded in the same function that the entropy is revealed, and it is highly unlikely to be zero.  However, this is an example of semantic overloading. It also necessitates an arbitrary fake entropy value to be used whenever the administrator cannot reveal the entropy. We did not identify any vulnerabilities arising from this pattern, but it does make the code more fragile.  Consider including an explicit contract variable that tracks if the committed draw has been rewarded.  Update: Acccepted. Since the rollover mechanism and entropy source will both be updated, PoolTogether would prefer not to introduce new state that will need to be deprecated.  [N08] Unnecessary casting of drawIndex  obtained with the draw method of the SortionSumTreeFactory, which  returns a bytes32 value. It is then cast to a  used twice to reference the selected tree, where it has to be cast back to a  Consider removing the redundant cast into a uint256 type.  Update: Fixed in PR#17.  [N09] Unnecessary SafeMath sum operation  In the committedBalanceOf function from the DrawManager contract, a balance variable is created to add the funds deposited under the firstDrawIndex and secondDrawIndex.  When the funds under the firstDrawIndex are added to the balance, balance always equals zero, making the addition unnecessary.  For simplicity and clarity, consider changing the SafeMath addition into a simple assignment.  Update: Fixed in PR#18.  [N10] Instances of uint  Throughout the code base, some variables are declared with type uint. To favor explicitness, consider changing all instances of uint to uint256.  Update: Fixed in PR#19.  [N11] Naming  To favor explicitness and readability, several parts of the contracts may benefit from better naming.Our suggestions are:  In DrawManager.sol:  usersFirstDrawIndex to consolidatedDrawIndex  usersSecondDrawIndex to latestDrawIndex  In BasePool.sol:  Opened to DrawOpened  Committed to DrawCommitted  Rewarded to DrawConcluded  Paused to PoolPaused  Unpaused to PoolUnpaused  open to openDraw  Update: Partially fixed in PR#20. The event names remain unchanged to maintain consistency with the deployed contract.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[h02]-winners-can-stall-the-system", "labels": ["OpenZeppelin"]}, {"title": "Before each new draw is created, the previous one must be rewarded. In the reward process, the awardWinnings function of the ERC777Pool contract, mints the new Pool tokens for the winner. Since the Pool Tokens are an ERC777, they first call the tokensReceived hook for the winner\u2019s address, if it exists.", "body": "Before each new draw is created, the previous one must be rewarded. In the reward process, the awardWinnings function of the ERC777Pool contract, mints the new Pool tokens for the winner. Since the Pool Tokens are an ERC777, they first call the tokensReceived hook for the winner\u2019s address, if it exists.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#before-each-new-draw-is-created,-the-previous-one-must-be-rewarded.-in-the-reward-process,-the-awardwinnings-function-of-the-erc777pool-contract,-mints-the-new-pool-tokens-for-the-winner.-since-the-pool-tokens-are-an-erc777,-they-first-call-the-tokensreceived-hook-for-the-winner\u2019s-address,-if-it-exists.", "labels": ["OpenZeppelin"]}, {"title": "If the winner\u2019s tokensReceived hook reverts, it will prevent the reward from being applied, stalling the whole system. They could also use this capability as leverage to extract resources (for instance, by writing a hook that will only succeed after receiving a payment).", "body": "If the winner\u2019s tokensReceived hook reverts, it will prevent the reward from being applied, stalling the whole system. They could also use this capability as leverage to extract resources (for instance, by writing a hook that will only succeed after receiving a payment).", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#if-the-winner\u2019s-tokensreceived-hook-reverts,-it-will-prevent-the-reward-from-being-applied,-stalling-the-whole-system.-they-could-also-use-this-capability-as-leverage-to-extract-resources-(for-instance,-by-writing-a-hook-that-will-only-succeed-after-receiving-a-payment).", "labels": ["OpenZeppelin"]}, {"title": "In the current version, the administrator can still bypass the reward step using the rollover feature. Naturally, this should not be relied upon as a mitigation since it introduces a new discretionary role for the administrator, and the feature will eventually be removed.", "body": "In the current version, the administrator can still bypass the reward step using the rollover feature. Naturally, this should not be relied upon as a mitigation since it introduces a new discretionary role for the administrator, and the feature will eventually be removed.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#in-the-current-version,-the-administrator-can-still-bypass-the-reward-step-using-the-rollover-feature.-naturally,-this-should-not-be-relied-upon-as-a-mitigation-since-it-introduces-a-new-discretionary-role-for-the-administrator,-and-the-feature-will-eventually-be-removed.", "labels": ["OpenZeppelin"]}, {"title": "As detailed in \u201c[M01] Double counting rewards\u201d, assigning the reward should not be treated as a Pool Token minting event. Consider removing the awardWinnings function in the ERC777Pool contract, and instead relying on the overridden function in the BasePool contract.", "body": "As detailed in \u201c[M01] Double counting rewards\u201d, assigning the reward should not be treated as a Pool Token minting event. Consider removing the awardWinnings function in the ERC777Pool contract, and instead relying on the overridden function in the BasePool contract.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#as-detailed-in-\u201c[m01]-double-counting-rewards\u201d,-assigning-the-reward-should-not-be-treated-as-a-pool-token-minting-event.-consider-removing-the-awardwinnings-function-in-the-erc777pool-contract,-and-instead-relying-on-the-overridden-function-in-the-basepool-contract.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#3. The awardWinnings function has been removed.", "body": "Update: Fixed in PR#3. The awardWinnings function has been removed.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#3.-the-awardwinnings-function-has-been-removed.", "labels": ["OpenZeppelin"]}, {"title": "[M01] Double counting rewards", "body": "After each draw with a winner, the awardWinnings function is called. This updates the balances mapping, adds the reward to the current open draw on the winners behalf and emits the Minted and Transfer events. However, at this point in the process, the new Pool Tokens have not been created (since the deposit is in the open draw).  When the draw is subsequently committed, the balance of the draw becomes active and the corresponding events are emitted. This means that the Minted and Transfer events associated with the reward are emitted twice: first sending the prize to the winner address and then implicitly when the open supply is sent to the contract. This will cause a mismatch between the total supply created and the Minted events.  Consider removing the awardWinnings function in the ERC777Pool contract, and instead relying on the overridden function in the BasePool contract.  Note: this issue is related to [H02] Winners can stall the system and any mitigation should consider both simultaneously.  Update: Fixed in PR#3. The awardWinnings function has been removed. This pull request actually removes the Minted and Transfer events entirely as part of a broader code refactoring, but they are reintroduced in PR#4  [M02] Bypassing token events  Pool Tokens can be redeemed by calling the burn function on the ERC777Pool contract. This will emit the Burned and Transfer events.  However, users can also call the withdraw function, which does not emit the events, to redeem their full balance of underlying tokens.  This will prevent users from reacting to these state changes from the ERC777 events (although if they are aware of the code structure they could respond to the Withdrawn event). It also means that the Minted and Burned events will not track the total token supply. Note that the Withdrawn event does not compensate for this because it does not distinguish between committed balances, open draw balances, sponsorship balances, and fees. Consider either preventing the withdraw function from applying to committed deposits (that have corresponding Pool tokens), or otherwise modifying it to emit the appropriate events.  Note: this issue is related to [L05] Conflated balances and any mitigation should consider them both simultaneously.  Update: Fixed in PR#4. The Minted and Burned events are emitted when committed balances are withdrawn from the pool.  Low severity  [L01] Deviation from ERC777 specification  Pool Tokens are created in a non-conventional way. Whenever users deposit assets into the system, they are internally accounted for but the new balances are not accessible to the ERC777 token functions. At the end of the draw, when the balances become available, it is no longer practical to create the corresponding Minted and Transfer events for each user. Instead, these events are emitted once for all users, with the recipient set to the Pool contract.  This is a deviation from the ERC777 specification and makes it impossible to track balances using the event logs. This is already acknowledged and documented by the PoolTogether team, but we believe it should be stated in this report anyway for the sake of transparency and community awareness.  [L02] Only direct deposits are pausable  The BasePool contract implements a mechanism to allow an administrator to pause the pool contract. However, only the direct deposit functions (depositPool and depositSponsorship) are affected. In particular, it is arguable that indirect deposits of DAI through the SAI migration mechanism should also be paused for consistency.  Depending on the intended uses of the pause functionality, it may be desirable to permit the use of the other functions anyway. Nevertheless, it is surprising that the balances and contract state can change while the contract is paused. Consider documenting this decision and the corresponding rationale.  Update: Fixed in PR#7. The names and documentation have been updated to clarify that the intention is to pause deposits into deprecated pools. Paused contracts are now also prevented from accepting indirect deposits and converting any unexpected token balance into a sponsorship.  [L03] Double spending ERC20 allowance  Like all compliant ERC20 tokens, the ERC777Pool contract is vulnerable to the allowance double spending attack. Briefly, an authorized spender could spend both allowances by front running an allowance-changing transaction. Consider implementing OpenZeppelins decreaseAllowance and increaseAllowance functions to help mitigate this.  Update: Fixed in PR#16. The functions were implemented.  [L04] Unexpected Side Effects  Each Pool Token is a claim on an equivalent amount of the underlying token. The burn and operatorBurn functions of the ERC777Pool contract destroy the Pool Tokens, redeem the equivalent value of cTokens in exchange for the underlying asset from Compound, and then return the underlying asset to the token holder. This is the standard mechanism for exiting the PoolTogether system.  However, the conventionally understood definition of burning ERC20 or ERC777 tokens means sacrificing the token values by sending them to the zero address. As it turns out, this is one step in the redeem functionality, but there are other side effects as well.  Consider adding redeem and operatorRedeem functions to handle the standard withdrawal mechanism. The burn and operatorBurn functions should simply destroy tokens (and they may also prevent some or all users from burning tokens).  Update: Fixed in PR#8. The functionality to exchange pool tokens for underlying tokens is now known as redeeming. The burn and operatorBurn functions revert.  [L05] Conflated balances  The comments on the totalBalanceOf function suggest that the users total balance is comprised of the underlying token balance in open and committed draws. In fact, their underlying balance could also increase when receiving fees or when choosing to sponsor the lottery.  Depending on the intention of the totalBalanceOf function, either the code or the comments should be updated for consistency.  Additionally, since these increases never emit Minted events, update the committed supply, or effect the balanceOf function, they arent and wont be tokenized into Pool Tokens. This means there is no mechanism to withdraw them individually. Instead users must call the withdraw function to redeem their full balances across all draws.  Consider allowing partial withdraws in the withdraw function or providing another mechanism to retrieve balances that are outside all draws.  Note: this issue is related to [M02] Bypassing token events and any mitigation should consider them both simultaneously.  Update: Fixed in PR#4. The totalBalanceOf function comments have been updated. Additional events and functions have been created to support withdrawing from the different user balances. Note that the Withdrawn event no longer applies to token transfers between users.  [L06] Misleading comments and variable names  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  The @return comment describing BasePool.getDraw only describes 4 of the 8 return values.  The @notice function of BasePool.balanceOf states that it returns the users total balance but it only returns the committed balance.  The rewardAndOpenNextDraw function and the reward function of BasePool do not have a @param comment for the salt.  The BasePool contract returns the error message could not transfer winnings even though it applies to all balances.  The @notice function of DrawManager.draw does not describe the case where are no participants.  In addition, the following internal documentation could be clarified:  The MAX_LEAVES constant does not constrain the number of leaves in the sortition tree. It should be a synonym of MAX_BRANCHES_PER_NODE or DEGREE_OF_TREE. It is also missing its comment.  Many of the BasePool functions are not documented.  The emitCommitted functions in the BasePool contract and the ERC777Pool contract claim to commit the current draw. In fact, they simply emit events. The relevant state changes occur when the new draw is opened.  The comments describing ERC777Pool._callTokensReceived do not include the last parameter.  The requireOpenDraw and onlyNonZero modifiers are missing their comments.  The RecipientWhitelistERC777Pool contract and most of its functions are not commented.  Update: Fixed in PR#21. These suggestions were implemented and the documentation has been significantly expanded.  [L07] Excessive code coupling  During a transfer of Pool Tokens, the balance gets added to the recipients committed draw tree. If the recipient does not have any committed balance, it is added to a newly created balance associated with the previous draw.  However, if the pool is currently in the first draw, which starts at index 1, this will associate the new balance with the invalid zero draw, and will also leave the users first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.  Fortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.  Nevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).  Consider confirming that the first draw is committed before assigning deposits to the previous draw.  Update: Fixed in PR#9. The depositCommitted and withdrawCommitted functions now require at least one draw to be committed.  [L08] Unchecked casting from uint256 to int256  The BasePool contract uses the FixidityLib to perform fixed point arithmetic with protection against overflow.  accepts an int256 as the parameter so the  need to be cast into int256 values.  If one of those parameters is higher than the maximum int256, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.  Consider ensuring that neither parameter exceeds the maximum int256.  Update: Fixed in PR#12. The _grossWinnings variable is now capped at the maximum safe value. The _feeFraction was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.  Notes  [N01] Unrestricted token ownership  Whenever a pool token is transferred, the RecipientWhitelistERC777Pool contract restricts the possible recipients to an administrator-defined white list. It should be noted that this does not prevent addresses from receiving tokens in exchange for deposits or winning them in a lottery.  Update: This is the expected behavior  [N02] Inconsistent imports  The code base imports contracts from the OpenZeppelin contracts package as well as contracts-ethereum-package. This is unnecessary and may cause issues if there is a name collision with imported contracts across both packages (or the contracts they depend on). In this case there is no collision, but it does introduce unnecessary fragility.  Consider using contracts-ethereum-package exclusively, which is a copy of contracts that is consistent with the OpenZeppelin upgrades package.  Update: Fixed in PR#10.  [N03] Default Visibility  Throughout the code base, some of the contract variables use default visibility. For readability, consider explicitly declaring the visibility of all state variables.  Update: Fixed in PR#13.  [N04] Reimplementing Pausable  The BasePool contract allows an administrator to pause and resume some functions. The functionality is already part of OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.  Consider inheriting from the OpenZeppelin Pausable contract to benefit from bug fixes to be applied in future releases and to reduce the codes attack surface.  Update: Accepted. PoolTogether would prefer not to adopt this suggestion since it would change the storage layout of an existing contract.  [N05] Repeated code  The RecipientWhitelistERC777Pool contract overrides the _callTokensToSend function to restrict the possible recipients. However, the rest of the function is identical. For simplicity, consider invoking the overridden function to execute the tokensToSend hook.  Update: Fixed in PR#4.  [N06] Random upper bound of zero  The uniform function of the UniformRandomNumber library returns zero whenever the specified upper bound is zero. This contradicts the Ethereum Natural Specification comment and is inconsistent with the usual behavior of returning a value strictly less than the upper bound.  Consider requiring the upper bound to be non-zero, or updating the comment accordingly.  Update: Fixed in PR#14. The bound is now required to be greater than zero. The edge case is handled in the calling function.  [N07] Semantic Overloading  The pool contract identifies if a particular draw has been rewarded by checking if the entropy is non zero. This works because the winner is rewarded in the same function that the entropy is revealed, and it is highly unlikely to be zero.  However, this is an example of semantic overloading. It also necessitates an arbitrary fake entropy value to be used whenever the administrator cannot reveal the entropy. We did not identify any vulnerabilities arising from this pattern, but it does make the code more fragile.  Consider including an explicit contract variable that tracks if the committed draw has been rewarded.  Update: Acccepted. Since the rollover mechanism and entropy source will both be updated, PoolTogether would prefer not to introduce new state that will need to be deprecated.  [N08] Unnecessary casting of drawIndex  obtained with the draw method of the SortionSumTreeFactory, which  returns a bytes32 value. It is then cast to a  used twice to reference the selected tree, where it has to be cast back to a  Consider removing the redundant cast into a uint256 type.  Update: Fixed in PR#17.  [N09] Unnecessary SafeMath sum operation  In the committedBalanceOf function from the DrawManager contract, a balance variable is created to add the funds deposited under the firstDrawIndex and secondDrawIndex.  When the funds under the firstDrawIndex are added to the balance, balance always equals zero, making the addition unnecessary.  For simplicity and clarity, consider changing the SafeMath addition into a simple assignment.  Update: Fixed in PR#18.  [N10] Instances of uint  Throughout the code base, some variables are declared with type uint. To favor explicitness, consider changing all instances of uint to uint256.  Update: Fixed in PR#19.  [N11] Naming  To favor explicitness and readability, several parts of the contracts may benefit from better naming.Our suggestions are:  In DrawManager.sol:  usersFirstDrawIndex to consolidatedDrawIndex  usersSecondDrawIndex to latestDrawIndex  In BasePool.sol:  Opened to DrawOpened  Committed to DrawCommitted  Rewarded to DrawConcluded  Paused to PoolPaused  Unpaused to PoolUnpaused  open to openDraw  Update: Partially fixed in PR#20. The event names remain unchanged to maintain consistency with the deployed contract.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[m01]-double-counting-rewards", "labels": ["OpenZeppelin"]}, {"title": "After each draw with a winner, the awardWinnings function is called. This updates the balances mapping, adds the reward to the current open draw on the winner\u2019s behalf and emits the Minted and Transfer events. However, at this point in the process, the new Pool Tokens have not been created (since the deposit is in the open draw).", "body": "After each draw with a winner, the awardWinnings function is called. This updates the balances mapping, adds the reward to the current open draw on the winner\u2019s behalf and emits the Minted and Transfer events. However, at this point in the process, the new Pool Tokens have not been created (since the deposit is in the open draw).", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#after-each-draw-with-a-winner,-the-awardwinnings-function-is-called.-this-updates-the-balances-mapping,-adds-the-reward-to-the-current-open-draw-on-the-winner\u2019s-behalf-and-emits-the-minted-and-transfer-events.-however,-at-this-point-in-the-process,-the-new-pool-tokens-have-not-been-created-(since-the-deposit-is-in-the-open-draw).", "labels": ["OpenZeppelin"]}, {"title": "When the draw is subsequently committed, the balance of the draw becomes active and the corresponding events are emitted. This means that the Minted and Transfer events associated with the reward are emitted twice: first sending the prize to the winner address and then implicitly when the open supply is sent to the contract. This will cause a mismatch between the total supply created and the Minted events.", "body": "When the draw is subsequently committed, the balance of the draw becomes active and the corresponding events are emitted. This means that the Minted and Transfer events associated with the reward are emitted twice: first sending the prize to the winner address and then implicitly when the open supply is sent to the contract. This will cause a mismatch between the total supply created and the Minted events.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#when-the-draw-is-subsequently-committed,-the-balance-of-the-draw-becomes-active-and-the-corresponding-events-are-emitted.-this-means-that-the-minted-and-transfer-events-associated-with-the-reward-are-emitted-twice:-first-sending-the-prize-to-the-winner-address-and-then-implicitly-when-the-open-supply-is-sent-to-the-contract.-this-will-cause-a-mismatch-between-the-total-supply-created-and-the-minted-events.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing the awardWinnings function in the ERC777Pool contract, and instead relying on the overridden function in the BasePool contract.", "body": "Note: this issue is related to [H02] Winners can stall the system and any mitigation should consider both simultaneously.  Update: Fixed in PR#3. The awardWinnings function has been removed. This pull request actually removes the Minted and Transfer events entirely as part of a broader code refactoring, but they are reintroduced in PR#4  [M02] Bypassing token events  Pool Tokens can be redeemed by calling the burn function on the ERC777Pool contract. This will emit the Burned and Transfer events.  However, users can also call the withdraw function, which does not emit the events, to redeem their full balance of underlying tokens.  This will prevent users from reacting to these state changes from the ERC777 events (although if they are aware of the code structure they could respond to the Withdrawn event). It also means that the Minted and Burned events will not track the total token supply. Note that the Withdrawn event does not compensate for this because it does not distinguish between committed balances, open draw balances, sponsorship balances, and fees. Consider either preventing the withdraw function from applying to committed deposits (that have corresponding Pool tokens), or otherwise modifying it to emit the appropriate events.  Note: this issue is related to [L05] Conflated balances and any mitigation should consider them both simultaneously.  Update: Fixed in PR#4. The Minted and Burned events are emitted when committed balances are withdrawn from the pool.  Low severity  [L01] Deviation from ERC777 specification  Pool Tokens are created in a non-conventional way. Whenever users deposit assets into the system, they are internally accounted for but the new balances are not accessible to the ERC777 token functions. At the end of the draw, when the balances become available, it is no longer practical to create the corresponding Minted and Transfer events for each user. Instead, these events are emitted once for all users, with the recipient set to the Pool contract.  This is a deviation from the ERC777 specification and makes it impossible to track balances using the event logs. This is already acknowledged and documented by the PoolTogether team, but we believe it should be stated in this report anyway for the sake of transparency and community awareness.  [L02] Only direct deposits are pausable  The BasePool contract implements a mechanism to allow an administrator to pause the pool contract. However, only the direct deposit functions (depositPool and depositSponsorship) are affected. In particular, it is arguable that indirect deposits of DAI through the SAI migration mechanism should also be paused for consistency.  Depending on the intended uses of the pause functionality, it may be desirable to permit the use of the other functions anyway. Nevertheless, it is surprising that the balances and contract state can change while the contract is paused. Consider documenting this decision and the corresponding rationale.  Update: Fixed in PR#7. The names and documentation have been updated to clarify that the intention is to pause deposits into deprecated pools. Paused contracts are now also prevented from accepting indirect deposits and converting any unexpected token balance into a sponsorship.  [L03] Double spending ERC20 allowance  Like all compliant ERC20 tokens, the ERC777Pool contract is vulnerable to the allowance double spending attack. Briefly, an authorized spender could spend both allowances by front running an allowance-changing transaction. Consider implementing OpenZeppelins decreaseAllowance and increaseAllowance functions to help mitigate this.  Update: Fixed in PR#16. The functions were implemented.  [L04] Unexpected Side Effects  Each Pool Token is a claim on an equivalent amount of the underlying token. The burn and operatorBurn functions of the ERC777Pool contract destroy the Pool Tokens, redeem the equivalent value of cTokens in exchange for the underlying asset from Compound, and then return the underlying asset to the token holder. This is the standard mechanism for exiting the PoolTogether system.  However, the conventionally understood definition of burning ERC20 or ERC777 tokens means sacrificing the token values by sending them to the zero address. As it turns out, this is one step in the redeem functionality, but there are other side effects as well.  Consider adding redeem and operatorRedeem functions to handle the standard withdrawal mechanism. The burn and operatorBurn functions should simply destroy tokens (and they may also prevent some or all users from burning tokens).  Update: Fixed in PR#8. The functionality to exchange pool tokens for underlying tokens is now known as redeeming. The burn and operatorBurn functions revert.  [L05] Conflated balances  The comments on the totalBalanceOf function suggest that the users total balance is comprised of the underlying token balance in open and committed draws. In fact, their underlying balance could also increase when receiving fees or when choosing to sponsor the lottery.  Depending on the intention of the totalBalanceOf function, either the code or the comments should be updated for consistency.  Additionally, since these increases never emit Minted events, update the committed supply, or effect the balanceOf function, they arent and wont be tokenized into Pool Tokens. This means there is no mechanism to withdraw them individually. Instead users must call the withdraw function to redeem their full balances across all draws.  Consider allowing partial withdraws in the withdraw function or providing another mechanism to retrieve balances that are outside all draws.  Note: this issue is related to [M02] Bypassing token events and any mitigation should consider them both simultaneously.  Update: Fixed in PR#4. The totalBalanceOf function comments have been updated. Additional events and functions have been created to support withdrawing from the different user balances. Note that the Withdrawn event no longer applies to token transfers between users.  [L06] Misleading comments and variable names  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  The @return comment describing BasePool.getDraw only describes 4 of the 8 return values.  The @notice function of BasePool.balanceOf states that it returns the users total balance but it only returns the committed balance.  The rewardAndOpenNextDraw function and the reward function of BasePool do not have a @param comment for the salt.  The BasePool contract returns the error message could not transfer winnings even though it applies to all balances.  The @notice function of DrawManager.draw does not describe the case where are no participants.  In addition, the following internal documentation could be clarified:  The MAX_LEAVES constant does not constrain the number of leaves in the sortition tree. It should be a synonym of MAX_BRANCHES_PER_NODE or DEGREE_OF_TREE. It is also missing its comment.  Many of the BasePool functions are not documented.  The emitCommitted functions in the BasePool contract and the ERC777Pool contract claim to commit the current draw. In fact, they simply emit events. The relevant state changes occur when the new draw is opened.  The comments describing ERC777Pool._callTokensReceived do not include the last parameter.  The requireOpenDraw and onlyNonZero modifiers are missing their comments.  The RecipientWhitelistERC777Pool contract and most of its functions are not commented.  Update: Fixed in PR#21. These suggestions were implemented and the documentation has been significantly expanded.  [L07] Excessive code coupling  During a transfer of Pool Tokens, the balance gets added to the recipients committed draw tree. If the recipient does not have any committed balance, it is added to a newly created balance associated with the previous draw.  However, if the pool is currently in the first draw, which starts at index 1, this will associate the new balance with the invalid zero draw, and will also leave the users first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.  Fortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.  Nevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).  Consider confirming that the first draw is committed before assigning deposits to the previous draw.  Update: Fixed in PR#9. The depositCommitted and withdrawCommitted functions now require at least one draw to be committed.  [L08] Unchecked casting from uint256 to int256  The BasePool contract uses the FixidityLib to perform fixed point arithmetic with protection against overflow.  accepts an int256 as the parameter so the  need to be cast into int256 values.  If one of those parameters is higher than the maximum int256, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.  Consider ensuring that neither parameter exceeds the maximum int256.  Update: Fixed in PR#12. The _grossWinnings variable is now capped at the maximum safe value. The _feeFraction was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.  Notes  [N01] Unrestricted token ownership  Whenever a pool token is transferred, the RecipientWhitelistERC777Pool contract restricts the possible recipients to an administrator-defined white list. It should be noted that this does not prevent addresses from receiving tokens in exchange for deposits or winning them in a lottery.  Update: This is the expected behavior  [N02] Inconsistent imports  The code base imports contracts from the OpenZeppelin contracts package as well as contracts-ethereum-package. This is unnecessary and may cause issues if there is a name collision with imported contracts across both packages (or the contracts they depend on). In this case there is no collision, but it does introduce unnecessary fragility.  Consider using contracts-ethereum-package exclusively, which is a copy of contracts that is consistent with the OpenZeppelin upgrades package.  Update: Fixed in PR#10.  [N03] Default Visibility  Throughout the code base, some of the contract variables use default visibility. For readability, consider explicitly declaring the visibility of all state variables.  Update: Fixed in PR#13.  [N04] Reimplementing Pausable  The BasePool contract allows an administrator to pause and resume some functions. The functionality is already part of OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.  Consider inheriting from the OpenZeppelin Pausable contract to benefit from bug fixes to be applied in future releases and to reduce the codes attack surface.  Update: Accepted. PoolTogether would prefer not to adopt this suggestion since it would change the storage layout of an existing contract.  [N05] Repeated code  The RecipientWhitelistERC777Pool contract overrides the _callTokensToSend function to restrict the possible recipients. However, the rest of the function is identical. For simplicity, consider invoking the overridden function to execute the tokensToSend hook.  Update: Fixed in PR#4.  [N06] Random upper bound of zero  The uniform function of the UniformRandomNumber library returns zero whenever the specified upper bound is zero. This contradicts the Ethereum Natural Specification comment and is inconsistent with the usual behavior of returning a value strictly less than the upper bound.  Consider requiring the upper bound to be non-zero, or updating the comment accordingly.  Update: Fixed in PR#14. The bound is now required to be greater than zero. The edge case is handled in the calling function.  [N07] Semantic Overloading  The pool contract identifies if a particular draw has been rewarded by checking if the entropy is non zero. This works because the winner is rewarded in the same function that the entropy is revealed, and it is highly unlikely to be zero.  However, this is an example of semantic overloading. It also necessitates an arbitrary fake entropy value to be used whenever the administrator cannot reveal the entropy. We did not identify any vulnerabilities arising from this pattern, but it does make the code more fragile.  Consider including an explicit contract variable that tracks if the committed draw has been rewarded.  Update: Acccepted. Since the rollover mechanism and entropy source will both be updated, PoolTogether would prefer not to introduce new state that will need to be deprecated.  [N08] Unnecessary casting of drawIndex  obtained with the draw method of the SortionSumTreeFactory, which  returns a bytes32 value. It is then cast to a  used twice to reference the selected tree, where it has to be cast back to a  Consider removing the redundant cast into a uint256 type.  Update: Fixed in PR#17.  [N09] Unnecessary SafeMath sum operation  In the committedBalanceOf function from the DrawManager contract, a balance variable is created to add the funds deposited under the firstDrawIndex and secondDrawIndex.  When the funds under the firstDrawIndex are added to the balance, balance always equals zero, making the addition unnecessary.  For simplicity and clarity, consider changing the SafeMath addition into a simple assignment.  Update: Fixed in PR#18.  [N10] Instances of uint  Throughout the code base, some variables are declared with type uint. To favor explicitness, consider changing all instances of uint to uint256.  Update: Fixed in PR#19.  [N11] Naming  To favor explicitness and readability, several parts of the contracts may benefit from better naming.Our suggestions are:  In DrawManager.sol:  usersFirstDrawIndex to consolidatedDrawIndex  usersSecondDrawIndex to latestDrawIndex  In BasePool.sol:  Opened to DrawOpened  Committed to DrawCommitted  Rewarded to DrawConcluded  Paused to PoolPaused  Unpaused to PoolUnpaused  open to openDraw  Update: Partially fixed in PR#20. The event names remain unchanged to maintain consistency with the deployed contract.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-removing-the-awardwinnings-function-in-the-erc777pool-contract,-and-instead-relying-on-the-overridden-function-in-the-basepool-contract.", "labels": ["OpenZeppelin"]}, {"title": "Note: this issue is related to \u201c[H02] Winners can stall the system\u201d and any mitigation should consider both simultaneously.", "body": "Note: this issue is related to \u201c[H02] Winners can stall the system\u201d and any mitigation should consider both simultaneously.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#note:-this-issue-is-related-to-\u201c[h02]-winners-can-stall-the-system\u201d-and-any-mitigation-should-consider-both-simultaneously.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#3. The awardWinnings function has been removed. This pull request actually removes the Minted and Transfer events entirely as part of a broader code refactoring, but they are reintroduced in PR#4", "body": "Update: Fixed in PR#3. The awardWinnings function has been removed. This pull request actually removes the Minted and Transfer events entirely as part of a broader code refactoring, but they are reintroduced in PR#4", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#3.-the-awardwinnings-function-has-been-removed.-this-pull-request-actually-removes-the-minted-and-transfer-events-entirely-as-part-of-a-broader-code-refactoring,-but-they-are-reintroduced-in-pr#4", "labels": ["OpenZeppelin"]}, {"title": "[M02] Bypassing token events", "body": " and any mitigation should consider them both simultaneously.  Update: Fixed in PR#4. The totalBalanceOf function comments have been updated. Additional events and functions have been created to support withdrawing from the different user balances. Note that the Withdrawn event no longer applies to token transfers between users.  [L06] Misleading comments and variable names  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  The @return comment describing BasePool.getDraw only describes 4 of the 8 return values.  The @notice function of BasePool.balanceOf states that it returns the users total balance but it only returns the committed balance.  The rewardAndOpenNextDraw function and the reward function of BasePool do not have a @param comment for the salt.  The BasePool contract returns the error message could not transfer winnings even though it applies to all balances.  The @notice function of DrawManager.draw does not describe the case where are no participants.  In addition, the following internal documentation could be clarified:  The MAX_LEAVES constant does not constrain the number of leaves in the sortition tree. It should be a synonym of MAX_BRANCHES_PER_NODE or DEGREE_OF_TREE. It is also missing its comment.  Many of the BasePool functions are not documented.  The emitCommitted functions in the BasePool contract and the ERC777Pool contract claim to commit the current draw. In fact, they simply emit events. The relevant state changes occur when the new draw is opened.  The comments describing ERC777Pool._callTokensReceived do not include the last parameter.  The requireOpenDraw and onlyNonZero modifiers are missing their comments.  The RecipientWhitelistERC777Pool contract and most of its functions are not commented.  Update: Fixed in PR#21. These suggestions were implemented and the documentation has been significantly expanded.  [L07] Excessive code coupling  During a transfer of Pool Tokens, the balance gets added to the recipients committed draw tree. If the recipient does not have any committed balance, it is added to a newly created balance associated with the previous draw.  However, if the pool is currently in the first draw, which starts at index 1, this will associate the new balance with the invalid zero draw, and will also leave the users first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.  Fortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.  Nevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).  Consider confirming that the first draw is committed before assigning deposits to the previous draw.  Update: Fixed in PR#9. The depositCommitted and withdrawCommitted functions now require at least one draw to be committed.  [L08] Unchecked casting from uint256 to int256  The BasePool contract uses the FixidityLib to perform fixed point arithmetic with protection against overflow.  accepts an int256 as the parameter so the  need to be cast into int256 values.  If one of those parameters is higher than the maximum int256, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.  Consider ensuring that neither parameter exceeds the maximum int256.  Update: Fixed in PR#12. The _grossWinnings variable is now capped at the maximum safe value. The _feeFraction was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.  Notes  [N01] Unrestricted token ownership  Whenever a pool token is transferred, the RecipientWhitelistERC777Pool contract restricts the possible recipients to an administrator-defined white list. It should be noted that this does not prevent addresses from receiving tokens in exchange for deposits or winning them in a lottery.  Update: This is the expected behavior  [N02] Inconsistent imports  The code base imports contracts from the OpenZeppelin contracts package as well as contracts-ethereum-package. This is unnecessary and may cause issues if there is a name collision with imported contracts across both packages (or the contracts they depend on). In this case there is no collision, but it does introduce unnecessary fragility.  Consider using contracts-ethereum-package exclusively, which is a copy of contracts that is consistent with the OpenZeppelin upgrades package.  Update: Fixed in PR#10.  [N03] Default Visibility  Throughout the code base, some of the contract variables use default visibility. For readability, consider explicitly declaring the visibility of all state variables.  Update: Fixed in PR#13.  [N04] Reimplementing Pausable  The BasePool contract allows an administrator to pause and resume some functions. The functionality is already part of OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.  Consider inheriting from the OpenZeppelin Pausable contract to benefit from bug fixes to be applied in future releases and to reduce the codes attack surface.  Update: Accepted. PoolTogether would prefer not to adopt this suggestion since it would change the storage layout of an existing contract.  [N05] Repeated code  The RecipientWhitelistERC777Pool contract overrides the _callTokensToSend function to restrict the possible recipients. However, the rest of the function is identical. For simplicity, consider invoking the overridden function to execute the tokensToSend hook.  Update: Fixed in PR#4.  [N06] Random upper bound of zero  The uniform function of the UniformRandomNumber library returns zero whenever the specified upper bound is zero. This contradicts the Ethereum Natural Specification comment and is inconsistent with the usual behavior of returning a value strictly less than the upper bound.  Consider requiring the upper bound to be non-zero, or updating the comment accordingly.  Update: Fixed in PR#14. The bound is now required to be greater than zero. The edge case is handled in the calling function.  [N07] Semantic Overloading  The pool contract identifies if a particular draw has been rewarded by checking if the entropy is non zero. This works because the winner is rewarded in the same function that the entropy is revealed, and it is highly unlikely to be zero.  However, this is an example of semantic overloading. It also necessitates an arbitrary fake entropy value to be used whenever the administrator cannot reveal the entropy. We did not identify any vulnerabilities arising from this pattern, but it does make the code more fragile.  Consider including an explicit contract variable that tracks if the committed draw has been rewarded.  Update: Acccepted. Since the rollover mechanism and entropy source will both be updated, PoolTogether would prefer not to introduce new state that will need to be deprecated.  [N08] Unnecessary casting of drawIndex  obtained with the draw method of the SortionSumTreeFactory, which  returns a bytes32 value. It is then cast to a  used twice to reference the selected tree, where it has to be cast back to a  Consider removing the redundant cast into a uint256 type.  Update: Fixed in PR#17.  [N09] Unnecessary SafeMath sum operation  In the committedBalanceOf function from the DrawManager contract, a balance variable is created to add the funds deposited under the firstDrawIndex and secondDrawIndex.  When the funds under the firstDrawIndex are added to the balance, balance always equals zero, making the addition unnecessary.  For simplicity and clarity, consider changing the SafeMath addition into a simple assignment.  Update: Fixed in PR#18.  [N10] Instances of uint  Throughout the code base, some variables are declared with type uint. To favor explicitness, consider changing all instances of uint to uint256.  Update: Fixed in PR#19.  [N11] Naming  To favor explicitness and readability, several parts of the contracts may benefit from better naming.Our suggestions are:  In DrawManager.sol:  usersFirstDrawIndex to consolidatedDrawIndex  usersSecondDrawIndex to latestDrawIndex  In BasePool.sol:  Opened to DrawOpened  Committed to DrawCommitted  Rewarded to DrawConcluded  Paused to PoolPaused  Unpaused to PoolUnpaused  open to openDraw  Update: Partially fixed in PR#20. The event names remain unchanged to maintain consistency with the deployed contract.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[m02]-bypassing-token-events", "labels": ["OpenZeppelin"]}, {"title": "Pool Tokens can be redeemed by calling the burn function on the ERC777Pool contract. This will emit the Burned and Transfer events.", "body": "Pool Tokens can be redeemed by calling the burn function on the ERC777Pool contract. This will emit the Burned and Transfer events.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#pool-tokens-can-be-redeemed-by-calling-the-burn-function-on-the-erc777pool-contract.-this-will-emit-the-burned-and-transfer-events.", "labels": ["OpenZeppelin"]}, {"title": "However, users can also call the withdraw function, which does not emit the events, to redeem their full balance of underlying tokens.", "body": "However, users can also call the withdraw function, which does not emit the events, to redeem their full balance of underlying tokens.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#however,-users-can-also-call-the-withdraw-function,-which-does-not-emit-the-events,-to-redeem-their-full-balance-of-underlying-tokens.", "labels": ["OpenZeppelin"]}, {"title": "This will prevent users from reacting to these state changes from the ERC777 events (although if they are aware of the code structure they could respond to the Withdrawn event). It also means that the Minted and Burned events will not track the total token supply. Note that the Withdrawn event does not compensate for this because it does not distinguish between committed balances, open draw balances, sponsorship balances, and fees. Consider either preventing the withdraw function from applying to committed deposits (that have corresponding Pool tokens), or otherwise modifying it to emit the appropriate events.", "body": "This will prevent users from reacting to these state changes from the ERC777 events (although if they are aware of the code structure they could respond to the Withdrawn event). It also means that the Minted and Burned events will not track the total token supply. Note that the Withdrawn event does not compensate for this because it does not distinguish between committed balances, open draw balances, sponsorship balances, and fees. Consider either preventing the withdraw function from applying to committed deposits (that have corresponding Pool tokens), or otherwise modifying it to emit the appropriate events.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#this-will-prevent-users-from-reacting-to-these-state-changes-from-the-erc777-events-(although-if-they-are-aware-of-the-code-structure-they-could-respond-to-the-withdrawn-event).-it-also-means-that-the-minted-and-burned-events-will-not-track-the-total-token-supply.-note-that-the-withdrawn-event-does-not-compensate-for-this-because-it-does-not-distinguish-between-committed-balances,-open-draw-balances,-sponsorship-balances,-and-fees.-consider-either-preventing-the-withdraw-function-from-applying-to-committed-deposits-(that-have-corresponding-pool-tokens),-or-otherwise-modifying-it-to-emit-the-appropriate-events.", "labels": ["OpenZeppelin"]}, {"title": "Note: this issue is related to \u201c[L05] Conflated balances\u201d and any mitigation should consider them both simultaneously.", "body": "Note: this issue is related to \u201c[L05] Conflated balances\u201d and any mitigation should consider them both simultaneously.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#note:-this-issue-is-related-to-\u201c[l05]-conflated-balances\u201d-and-any-mitigation-should-consider-them-both-simultaneously.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#4. The Minted and Burned events are emitted when committed balances are withdrawn from the pool.", "body": "Update: Fixed in PR#4. The Minted and Burned events are emitted when committed balances are withdrawn from the pool.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#4.-the-minted-and-burned-events-are-emitted-when-committed-balances-are-withdrawn-from-the-pool.", "labels": ["OpenZeppelin"]}, {"title": "Low severity", "body": "Low severity", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#low-severity", "labels": ["OpenZeppelin"]}, {"title": "[L01] Deviation from ERC777 specification", "body": "[L01] Deviation from ERC777 specification", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[l01]-deviation-from-erc777-specification", "labels": ["OpenZeppelin"]}, {"title": "Pool Tokens are created in a non-conventional way. Whenever users deposit assets into the system, they are internally accounted for but the new balances are not accessible to the ERC777 token functions. At the end of the draw, when the balances become available, it is no longer practical to create the corresponding Minted and Transfer events for each user. Instead, these events are emitted once for all users, with the recipient set to the Pool contract.", "body": "Pool Tokens are created in a non-conventional way. Whenever users deposit assets into the system, they are internally accounted for but the new balances are not accessible to the ERC777 token functions. At the end of the draw, when the balances become available, it is no longer practical to create the corresponding Minted and Transfer events for each user. Instead, these events are emitted once for all users, with the recipient set to the Pool contract.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#pool-tokens-are-created-in-a-non-conventional-way.-whenever-users-deposit-assets-into-the-system,-they-are-internally-accounted-for-but-the-new-balances-are-not-accessible-to-the-erc777-token-functions.-at-the-end-of-the-draw,-when-the-balances-become-available,-it-is-no-longer-practical-to-create-the-corresponding-minted-and-transfer-events-for-each-user.-instead,-these-events-are-emitted-once-for-all-users,-with-the-recipient-set-to-the-pool-contract.", "labels": ["OpenZeppelin"]}, {"title": "This is a deviation from the ERC777 specification and makes it impossible to track balances using the event logs. This is already acknowledged and documented by the PoolTogether team, but we believe it should be stated in this report anyway for the sake of transparency and community awareness.", "body": "This is a deviation from the ERC777 specification and makes it impossible to track balances using the event logs. This is already acknowledged and documented by the PoolTogether team, but we believe it should be stated in this report anyway for the sake of transparency and community awareness.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#this-is-a-deviation-from-the-erc777-specification-and-makes-it-impossible-to-track-balances-using-the-event-logs.-this-is-already-acknowledged-and-documented-by-the-pooltogether-team,-but-we-believe-it-should-be-stated-in-this-report-anyway-for-the-sake-of-transparency-and-community-awareness.", "labels": ["OpenZeppelin"]}, {"title": "[L02] Only direct deposits are pausable", "body": "[L02] Only direct deposits are pausable", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[l02]-only-direct-deposits-are-pausable", "labels": ["OpenZeppelin"]}, {"title": "The BasePool contract implements a mechanism to allow an administrator to pause the pool contract. However, only the direct deposit functions (depositPool and depositSponsorship) are affected. In particular, it is arguable that indirect deposits of DAI through the SAI migration mechanism should also be paused for consistency.", "body": "The BasePool contract implements a mechanism to allow an administrator to pause the pool contract. However, only the direct deposit functions (depositPool and depositSponsorship) are affected. In particular, it is arguable that indirect deposits of DAI through the SAI migration mechanism should also be paused for consistency.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-basepool-contract-implements-a-mechanism-to-allow-an-administrator-to-pause-the-pool-contract.-however,-only-the-direct-deposit-functions-(depositpool-and-depositsponsorship)-are-affected.-in-particular,-it-is-arguable-that-indirect-deposits-of-dai-through-the-sai-migration-mechanism-should-also-be-paused-for-consistency.", "labels": ["OpenZeppelin"]}, {"title": "Depending on the intended uses of the pause functionality, it may be desirable to permit the use of the other functions anyway. Nevertheless, it is surprising that the balances and contract state can change while the contract is paused. Consider documenting this decision and the corresponding rationale.", "body": "Depending on the intended uses of the pause functionality, it may be desirable to permit the use of the other functions anyway. Nevertheless, it is surprising that the balances and contract state can change while the contract is paused. Consider documenting this decision and the corresponding rationale.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#depending-on-the-intended-uses-of-the-pause-functionality,-it-may-be-desirable-to-permit-the-use-of-the-other-functions-anyway.-nevertheless,-it-is-surprising-that-the-balances-and-contract-state-can-change-while-the-contract-is-paused.-consider-documenting-this-decision-and-the-corresponding-rationale.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#7. The names and documentation have been updated to clarify that the intention is to pause deposits into deprecated pools. Paused contracts are now also prevented from accepting indirect deposits and converting any unexpected token balance into a sponsorship.", "body": "Update: Fixed in PR#7. The names and documentation have been updated to clarify that the intention is to pause deposits into deprecated pools. Paused contracts are now also prevented from accepting indirect deposits and converting any unexpected token balance into a sponsorship.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#7.-the-names-and-documentation-have-been-updated-to-clarify-that-the-intention-is-to-pause-deposits-into-deprecated-pools.-paused-contracts-are-now-also-prevented-from-accepting-indirect-deposits-and-converting-any-unexpected-token-balance-into-a-sponsorship.", "labels": ["OpenZeppelin"]}, {"title": "[L03] Double spending ERC20 allowance", "body": "[L03] Double spending ERC20 allowance", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[l03]-double-spending-erc20-allowance", "labels": ["OpenZeppelin"]}, {"title": "Like all compliant ERC20 tokens, the ERC777Pool contract is vulnerable to the allowance double spending attack. Briefly, an authorized spender could spend both allowances by front running an allowance-changing transaction. Consider implementing OpenZeppelin\u2019s decreaseAllowance and increaseAllowance functions to help mitigate this.", "body": "Like all compliant ERC20 tokens, the ERC777Pool contract is vulnerable to the allowance double spending attack. Briefly, an authorized spender could spend both allowances by front running an allowance-changing transaction. Consider implementing OpenZeppelin\u2019s decreaseAllowance and increaseAllowance functions to help mitigate this.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#like-all-compliant-erc20-tokens,-the-erc777pool-contract-is-vulnerable-to-the-allowance-double-spending-attack.-briefly,-an-authorized-spender-could-spend-both-allowances-by-front-running-an-allowance-changing-transaction.-consider-implementing-openzeppelin\u2019s-decreaseallowance-and-increaseallowance-functions-to-help-mitigate-this.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#16. The functions were implemented.", "body": "Update: Fixed in PR#16. The functions were implemented.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#16.-the-functions-were-implemented.", "labels": ["OpenZeppelin"]}, {"title": "[L04] Unexpected Side Effects", "body": "[L04] Unexpected Side Effects", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[l04]-unexpected-side-effects", "labels": ["OpenZeppelin"]}, {"title": "Each Pool Token is a claim on an equivalent amount of the underlying token. The burn and operatorBurn functions of the ERC777Pool contract destroy the Pool Tokens, redeem the equivalent value of cTokens in exchange for the underlying asset from Compound, and then return the underlying asset to the token holder. This is the standard mechanism for exiting the PoolTogether system.", "body": "Each Pool Token is a claim on an equivalent amount of the underlying token. The burn and operatorBurn functions of the ERC777Pool contract destroy the Pool Tokens, redeem the equivalent value of cTokens in exchange for the underlying asset from Compound, and then return the underlying asset to the token holder. This is the standard mechanism for exiting the PoolTogether system.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#each-pool-token-is-a-claim-on-an-equivalent-amount-of-the-underlying-token.-the-burn-and-operatorburn-functions-of-the-erc777pool-contract-destroy-the-pool-tokens,-redeem-the-equivalent-value-of-ctokens-in-exchange-for-the-underlying-asset-from-compound,-and-then-return-the-underlying-asset-to-the-token-holder.-this-is-the-standard-mechanism-for-exiting-the-pooltogether-system.", "labels": ["OpenZeppelin"]}, {"title": "However, the conventionally understood definition of burning ERC20 or ERC777 tokens means sacrificing the token values by sending them to the zero address. As it turns out, this is one step in the redeem functionality, but there are other side effects as well.", "body": "However, the conventionally understood definition of burning ERC20 or ERC777 tokens means sacrificing the token values by sending them to the zero address. As it turns out, this is one step in the redeem functionality, but there are other side effects as well.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#however,-the-conventionally-understood-definition-of-burning-erc20-or-erc777-tokens-means-sacrificing-the-token-values-by-sending-them-to-the-zero-address.-as-it-turns-out,-this-is-one-step-in-the-redeem-functionality,-but-there-are-other-side-effects-as-well.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding redeem and operatorRedeem functions to handle the standard withdrawal mechanism. The burn and operatorBurn functions should simply destroy tokens (and they may also prevent some or all users from burning tokens).", "body": "Consider adding redeem and operatorRedeem functions to handle the standard withdrawal mechanism. The burn and operatorBurn functions should simply destroy tokens (and they may also prevent some or all users from burning tokens).", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-adding-redeem-and-operatorredeem-functions-to-handle-the-standard-withdrawal-mechanism.-the-burn-and-operatorburn-functions-should-simply-destroy-tokens-(and-they-may-also-prevent-some-or-all-users-from-burning-tokens).", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#8. The functionality to exchange pool tokens for underlying tokens is now known as \u201credeeming\u201d. The burn and operatorBurn functions revert.", "body": "Update: Fixed in PR#8. The functionality to exchange pool tokens for underlying tokens is now known as \u201credeeming\u201d. The burn and operatorBurn functions revert.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#8.-the-functionality-to-exchange-pool-tokens-for-underlying-tokens-is-now-known-as-\u201credeeming\u201d.-the-burn-and-operatorburn-functions-revert.", "labels": ["OpenZeppelin"]}, {"title": "[L05] Conflated balances", "body": "The comments on the totalBalanceOf function suggest that the users total balance is comprised of the underlying token balance in open and committed draws. In fact, their underlying balance could also increase when receiving fees or when choosing to sponsor the lottery.  Depending on the intention of the totalBalanceOf function, either the code or the comments should be updated for consistency.  Additionally, since these increases never emit Minted events, update the committed supply, or effect the balanceOf function, they arent and wont be tokenized into Pool Tokens. This means there is no mechanism to withdraw them individually. Instead users must call the withdraw function to redeem their full balances across all draws.  Consider allowing partial withdraws in the withdraw function or providing another mechanism to retrieve balances that are outside all draws.  Note: this issue is related to [M02] Bypassing token events and any mitigation should consider them both simultaneously.  Update: Fixed in PR#4. The totalBalanceOf function comments have been updated. Additional events and functions have been created to support withdrawing from the different user balances. Note that the Withdrawn event no longer applies to token transfers between users.  [L06] Misleading comments and variable names  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  The @return comment describing BasePool.getDraw only describes 4 of the 8 return values.  The @notice function of BasePool.balanceOf states that it returns the users total balance but it only returns the committed balance.  The rewardAndOpenNextDraw function and the reward function of BasePool do not have a @param comment for the salt.  The BasePool contract returns the error message could not transfer winnings even though it applies to all balances.  The @notice function of DrawManager.draw does not describe the case where are no participants.  In addition, the following internal documentation could be clarified:  The MAX_LEAVES constant does not constrain the number of leaves in the sortition tree. It should be a synonym of MAX_BRANCHES_PER_NODE or DEGREE_OF_TREE. It is also missing its comment.  Many of the BasePool functions are not documented.  The emitCommitted functions in the BasePool contract and the ERC777Pool contract claim to commit the current draw. In fact, they simply emit events. The relevant state changes occur when the new draw is opened.  The comments describing ERC777Pool._callTokensReceived do not include the last parameter.  The requireOpenDraw and onlyNonZero modifiers are missing their comments.  The RecipientWhitelistERC777Pool contract and most of its functions are not commented.  Update: Fixed in PR#21. These suggestions were implemented and the documentation has been significantly expanded.  [L07] Excessive code coupling  During a transfer of Pool Tokens, the balance gets added to the recipients committed draw tree. If the recipient does not have any committed balance, it is added to a newly created balance associated with the previous draw.  However, if the pool is currently in the first draw, which starts at index 1, this will associate the new balance with the invalid zero draw, and will also leave the users first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.  Fortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.  Nevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).  Consider confirming that the first draw is committed before assigning deposits to the previous draw.  Update: Fixed in PR#9. The depositCommitted and withdrawCommitted functions now require at least one draw to be committed.  [L08] Unchecked casting from uint256 to int256  The BasePool contract uses the FixidityLib to perform fixed point arithmetic with protection against overflow.  accepts an int256 as the parameter so the  need to be cast into int256 values.  If one of those parameters is higher than the maximum int256, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.  Consider ensuring that neither parameter exceeds the maximum int256.  Update: Fixed in PR#12. The _grossWinnings variable is now capped at the maximum safe value. The _feeFraction was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.  Notes  [N01] Unrestricted token ownership  Whenever a pool token is transferred, the RecipientWhitelistERC777Pool contract restricts the possible recipients to an administrator-defined white list. It should be noted that this does not prevent addresses from receiving tokens in exchange for deposits or winning them in a lottery.  Update: This is the expected behavior  [N02] Inconsistent imports  The code base imports contracts from the OpenZeppelin contracts package as well as contracts-ethereum-package. This is unnecessary and may cause issues if there is a name collision with imported contracts across both packages (or the contracts they depend on). In this case there is no collision, but it does introduce unnecessary fragility.  Consider using contracts-ethereum-package exclusively, which is a copy of contracts that is consistent with the OpenZeppelin upgrades package.  Update: Fixed in PR#10.  [N03] Default Visibility  Throughout the code base, some of the contract variables use default visibility. For readability, consider explicitly declaring the visibility of all state variables.  Update: Fixed in PR#13.  [N04] Reimplementing Pausable  The BasePool contract allows an administrator to pause and resume some functions. The functionality is already part of OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.  Consider inheriting from the OpenZeppelin Pausable contract to benefit from bug fixes to be applied in future releases and to reduce the codes attack surface.  Update: Accepted. PoolTogether would prefer not to adopt this suggestion since it would change the storage layout of an existing contract.  [N05] Repeated code  The RecipientWhitelistERC777Pool contract overrides the _callTokensToSend function to restrict the possible recipients. However, the rest of the function is identical. For simplicity, consider invoking the overridden function to execute the tokensToSend hook.  Update: Fixed in PR#4.  [N06] Random upper bound of zero  The uniform function of the UniformRandomNumber library returns zero whenever the specified upper bound is zero. This contradicts the Ethereum Natural Specification comment and is inconsistent with the usual behavior of returning a value strictly less than the upper bound.  Consider requiring the upper bound to be non-zero, or updating the comment accordingly.  Update: Fixed in PR#14. The bound is now required to be greater than zero. The edge case is handled in the calling function.  [N07] Semantic Overloading  The pool contract identifies if a particular draw has been rewarded by checking if the entropy is non zero. This works because the winner is rewarded in the same function that the entropy is revealed, and it is highly unlikely to be zero.  However, this is an example of semantic overloading. It also necessitates an arbitrary fake entropy value to be used whenever the administrator cannot reveal the entropy. We did not identify any vulnerabilities arising from this pattern, but it does make the code more fragile.  Consider including an explicit contract variable that tracks if the committed draw has been rewarded.  Update: Acccepted. Since the rollover mechanism and entropy source will both be updated, PoolTogether would prefer not to introduce new state that will need to be deprecated.  [N08] Unnecessary casting of drawIndex  obtained with the draw method of the SortionSumTreeFactory, which  returns a bytes32 value. It is then cast to a  used twice to reference the selected tree, where it has to be cast back to a  Consider removing the redundant cast into a uint256 type.  Update: Fixed in PR#17.  [N09] Unnecessary SafeMath sum operation  In the committedBalanceOf function from the DrawManager contract, a balance variable is created to add the funds deposited under the firstDrawIndex and secondDrawIndex.  When the funds under the firstDrawIndex are added to the balance, balance always equals zero, making the addition unnecessary.  For simplicity and clarity, consider changing the SafeMath addition into a simple assignment.  Update: Fixed in PR#18.  [N10] Instances of uint  Throughout the code base, some variables are declared with type uint. To favor explicitness, consider changing all instances of uint to uint256.  Update: Fixed in PR#19.  [N11] Naming  To favor explicitness and readability, several parts of the contracts may benefit from better naming.Our suggestions are:  In DrawManager.sol:  usersFirstDrawIndex to consolidatedDrawIndex  usersSecondDrawIndex to latestDrawIndex  In BasePool.sol:  Opened to DrawOpened  Committed to DrawCommitted  Rewarded to DrawConcluded  Paused to PoolPaused  Unpaused to PoolUnpaused  open to openDraw  Update: Partially fixed in PR#20. The event names remain unchanged to maintain consistency with the deployed contract.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[l05]-conflated-balances", "labels": ["OpenZeppelin"]}, {"title": "The comments on the totalBalanceOf function suggest that the user\u2019s total balance is comprised of the underlying token balance in open and committed draws. In fact, their underlying balance could also increase when receiving fees or when choosing to sponsor the lottery.", "body": "The comments on the totalBalanceOf function suggest that the user\u2019s total balance is comprised of the underlying token balance in open and committed draws. In fact, their underlying balance could also increase when receiving fees or when choosing to sponsor the lottery.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-comments-on-the-totalbalanceof-function-suggest-that-the-user\u2019s-total-balance-is-comprised-of-the-underlying-token-balance-in-open-and-committed-draws.-in-fact,-their-underlying-balance-could-also-increase-when-receiving-fees-or-when-choosing-to-sponsor-the-lottery.", "labels": ["OpenZeppelin"]}, {"title": "Depending on the intention of the totalBalanceOf function, either the code or the comments should be updated for consistency.", "body": "Depending on the intention of the totalBalanceOf function, either the code or the comments should be updated for consistency.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#depending-on-the-intention-of-the-totalbalanceof-function,-either-the-code-or-the-comments-should-be-updated-for-consistency.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, since these increases never emit Minted events, update the committed supply, or effect the balanceOf function, they aren\u2019t and won\u2019t be tokenized into Pool Tokens. This means there is no mechanism to withdraw them individually. Instead users must call the withdraw function to redeem their full balances across all draws.", "body": "Additionally, since these increases never emit Minted events, update the committed supply, or effect the balanceOf function, they aren\u2019t and won\u2019t be tokenized into Pool Tokens. This means there is no mechanism to withdraw them individually. Instead users must call the withdraw function to redeem their full balances across all draws.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#additionally,-since-these-increases-never-emit-minted-events,-update-the-committed-supply,-or-effect-the-balanceof-function,-they-aren\u2019t-and-won\u2019t-be-tokenized-into-pool-tokens.-this-means-there-is-no-mechanism-to-withdraw-them-individually.-instead-users-must-call-the-withdraw-function-to-redeem-their-full-balances-across-all-draws.", "labels": ["OpenZeppelin"]}, {"title": "Consider allowing partial withdraws in the withdraw function or providing another mechanism to retrieve balances that are outside all draws.", "body": "Consider allowing partial withdraws in the withdraw function or providing another mechanism to retrieve balances that are outside all draws.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-allowing-partial-withdraws-in-the-withdraw-function-or-providing-another-mechanism-to-retrieve-balances-that-are-outside-all-draws.", "labels": ["OpenZeppelin"]}, {"title": "Note: this issue is related to \u201c[M02] Bypassing token events\u201d and any mitigation should consider them both simultaneously.", "body": "Note: this issue is related to \u201c[M02] Bypassing token events\u201d and any mitigation should consider them both simultaneously.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#note:-this-issue-is-related-to-\u201c[m02]-bypassing-token-events\u201d-and-any-mitigation-should-consider-them-both-simultaneously.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#4. The totalBalanceOf function comments have been updated. Additional events and functions have been created to support withdrawing from the different user balances. Note that the Withdrawn event no longer applies to token transfers between users.", "body": "Update: Fixed in PR#4. The totalBalanceOf function comments have been updated. Additional events and functions have been created to support withdrawing from the different user balances. Note that the Withdrawn event no longer applies to token transfers between users.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#4.-the-totalbalanceof-function-comments-have-been-updated.-additional-events-and-functions-have-been-created-to-support-withdrawing-from-the-different-user-balances.-note-that-the-withdrawn-event-no-longer-applies-to-token-transfers-between-users.", "labels": ["OpenZeppelin"]}, {"title": "[L06] Misleading comments and variable names", "body": "[L06] Misleading comments and variable names", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[l06]-misleading-comments-and-variable-names", "labels": ["OpenZeppelin"]}, {"title": "Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.", "body": "Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#since-the-purpose-of-the-ethereum-natural-specification-(natspec)-is-to-describe-the-code-to-end-users,-misleading-statements-should-be-considered-a-violation-of-the-public-api.", "labels": ["OpenZeppelin"]}, {"title": "The @return comment describing BasePool.getDraw only describes 4 of the 8 return values.", "body": "The @return comment describing BasePool.getDraw only describes 4 of the 8 return values.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-@return-comment-describing-basepool.getdraw-only-describes-4-of-the-8-return-values.", "labels": ["OpenZeppelin"]}, {"title": "The @notice function of BasePool.balanceOf states that it returns the user\u2019s total balance but it only returns the committed balance.", "body": "The @notice function of BasePool.balanceOf states that it returns the user\u2019s total balance but it only returns the committed balance.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-@notice-function-of-basepool.balanceof-states-that-it-returns-the-user\u2019s-total-balance-but-it-only-returns-the-committed-balance.", "labels": ["OpenZeppelin"]}, {"title": "The rewardAndOpenNextDraw function and the reward function of BasePool do not have a @param comment for the salt.", "body": "The rewardAndOpenNextDraw function and the reward function of BasePool do not have a @param comment for the salt.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-rewardandopennextdraw-function-and-the-reward-function-of-basepool-do-not-have-a-@param-comment-for-the-salt.", "labels": ["OpenZeppelin"]}, {"title": "The BasePool contract returns the error message \u201ccould not transfer winnings\u201d even though it applies to all balances.", "body": "The BasePool contract returns the error message \u201ccould not transfer winnings\u201d even though it applies to all balances.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-basepool-contract-returns-the-error-message-\u201ccould-not-transfer-winnings\u201d-even-though-it-applies-to-all-balances.", "labels": ["OpenZeppelin"]}, {"title": "The @notice function of DrawManager.draw does not describe the case where are no participants.", "body": "The @notice function of DrawManager.draw does not describe the case where are no participants.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-@notice-function-of-drawmanager.draw-does-not-describe-the-case-where-are-no-participants.", "labels": ["OpenZeppelin"]}, {"title": "In addition, the following internal documentation could be clarified:", "body": "In addition, the following internal documentation could be clarified:", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#in-addition,-the-following-internal-documentation-could-be-clarified:", "labels": ["OpenZeppelin"]}, {"title": "The MAX_LEAVES constant does not constrain the number of leaves in the sortition tree. It should be a synonym of MAX_BRANCHES_PER_NODE or DEGREE_OF_TREE. It is also missing its comment.", "body": "The MAX_LEAVES constant does not constrain the number of leaves in the sortition tree. It should be a synonym of MAX_BRANCHES_PER_NODE or DEGREE_OF_TREE. It is also missing its comment.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-max_leaves-constant-does-not-constrain-the-number-of-leaves-in-the-sortition-tree.-it-should-be-a-synonym-of-max_branches_per_node-or-degree_of_tree.-it-is-also-missing-its-comment.", "labels": ["OpenZeppelin"]}, {"title": "Many of the BasePool functions are not documented.", "body": "Many of the BasePool functions are not documented.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#many-of-the-basepool-functions-are-not-documented.", "labels": ["OpenZeppelin"]}, {"title": "The emitCommitted functions in the BasePool contract and the ERC777Pool contract claim to commit the current draw. In fact, they simply emit events. The relevant state changes occur when the new draw is opened.", "body": "The emitCommitted functions in the BasePool contract and the ERC777Pool contract claim to commit the current draw. In fact, they simply emit events. The relevant state changes occur when the new draw is opened.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-emitcommitted-functions-in-the-basepool-contract-and-the-erc777pool-contract-claim-to-commit-the-current-draw.-in-fact,-they-simply-emit-events.-the-relevant-state-changes-occur-when-the-new-draw-is-opened.", "labels": ["OpenZeppelin"]}, {"title": "The comments describing ERC777Pool._callTokensReceived do not include the last parameter.", "body": "The comments describing ERC777Pool._callTokensReceived do not include the last parameter.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-comments-describing-erc777pool._calltokensreceived-do-not-include-the-last-parameter.", "labels": ["OpenZeppelin"]}, {"title": "The requireOpenDraw and onlyNonZero modifiers are missing their comments.", "body": "The requireOpenDraw and onlyNonZero modifiers are missing their comments.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-requireopendraw-and-onlynonzero-modifiers-are-missing-their-comments.", "labels": ["OpenZeppelin"]}, {"title": "The RecipientWhitelistERC777Pool contract and most of its functions are not commented.", "body": "The RecipientWhitelistERC777Pool contract and most of its functions are not commented.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-recipientwhitelisterc777pool-contract-and-most-of-its-functions-are-not-commented.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#21. These suggestions were implemented and the documentation has been significantly expanded.", "body": "Update: Fixed in PR#21. These suggestions were implemented and the documentation has been significantly expanded.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#21.-these-suggestions-were-implemented-and-the-documentation-has-been-significantly-expanded.", "labels": ["OpenZeppelin"]}, {"title": "[L07] Excessive code coupling", "body": "[L07] Excessive code coupling", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[l07]-excessive-code-coupling", "labels": ["OpenZeppelin"]}, {"title": "During a transfer of Pool Tokens, the balance gets added to the recipient\u2019s committed draw tree. If the recipient does not have any committed balance, it is added to a newly created balance associated with the previous draw.", "body": "During a transfer of Pool Tokens, the balance gets added to the recipient\u2019s committed draw tree. If the recipient does not have any committed balance, it is added to a newly created balance associated with the previous draw.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#during-a-transfer-of-pool-tokens,-the-balance-gets-added-to-the-recipient\u2019s-committed-draw-tree.-if-the-recipient-does-not-have-any-committed-balance,-it-is-added-to-a-newly-created-balance-associated-with-the-previous-draw.", "labels": ["OpenZeppelin"]}, {"title": "However, if the pool is currently in the first draw, which starts at index 1, this will associate the new balance with the invalid zero draw, and will also leave the user\u2019s first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.", "body": "However, if the pool is currently in the first draw, which starts at index 1, this will associate the new balance with the invalid zero draw, and will also leave the user\u2019s first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#however,-if-the-pool-is-currently-in-the-first-draw,-which-starts-at-index-1,-this-will-associate-the-new-balance-with-the-invalid-zero-draw,-and-will-also-leave-the-user\u2019s-first-draw-index-at-zero.-this-is-an-inconsistent-state-that-would-prevent-the-recipient-from-withdrawing,-transferring-or-receiving-awards-based-on-their-balance.", "labels": ["OpenZeppelin"]}, {"title": "Fortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.", "body": "Fortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#fortunately,-the-overall-semantics-of-the-system-prevent-this-scenario.-in-particular,-no-user-should-have-any-pool-tokens-during-the-first-draw,-so-the-situation-could-not-arise.", "labels": ["OpenZeppelin"]}, {"title": "Nevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).", "body": "Nevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#nevertheless,-it-is-bad-practice-to-rely-on-global-properties-of-the-system-to-prevent-local-edge-cases-and-it-makes-the-code-fragile-to-unrelated-changes-(for-example,-if-a-version-of-the-code-that-pre-minted-tokens-was-released,-it-would-reintroduce-this-vulnerability).", "labels": ["OpenZeppelin"]}, {"title": "Consider confirming that the first draw is committed before assigning deposits to the previous draw.", "body": "Consider confirming that the first draw is committed before assigning deposits to the previous draw.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-confirming-that-the-first-draw-is-committed-before-assigning-deposits-to-the-previous-draw.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#9. The depositCommitted and withdrawCommitted functions now require at least one draw to be committed.", "body": "Update: Fixed in PR#9. The depositCommitted and withdrawCommitted functions now require at least one draw to be committed.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#9.-the-depositcommitted-and-withdrawcommitted-functions-now-require-at-least-one-draw-to-be-committed.", "labels": ["OpenZeppelin"]}, {"title": "[L08] Unchecked casting from uint256 to int256", "body": "[L08] Unchecked casting from uint256 to int256", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[l08]-unchecked-casting-from-uint256-to-int256", "labels": ["OpenZeppelin"]}, {"title": "The BasePool contract uses the FixidityLib to perform fixed point arithmetic with protection against overflow.", "body": "The BasePool contract uses the FixidityLib to perform fixed point arithmetic with protection against overflow.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-basepool-contract-uses-the-fixiditylib-to-perform-fixed-point-arithmetic-with-protection-against-overflow.", "labels": ["OpenZeppelin"]}, {"title": "accepts an int256 as the parameter so the", "body": "accepts an int256 as the parameter so the", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#accepts-an-int256-as-the-parameter-so-the", "labels": ["OpenZeppelin"]}, {"title": "need to be cast into int256 values.", "body": "need to be cast into int256 values.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#need-to-be-cast-into-int256-values.", "labels": ["OpenZeppelin"]}, {"title": "If one of those parameters is higher than the maximum int256, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.", "body": "If one of those parameters is higher than the maximum int256, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#if-one-of-those-parameters-is-higher-than-the-maximum-int256,-the-cast-will-overflow.-this-realistically-should-not-occur-but-it-is-nevertheless-good-coding-practice-to-explicitly-check-any-assumptions.", "labels": ["OpenZeppelin"]}, {"title": "Consider ensuring that neither parameter exceeds the maximum int256.", "body": "Consider ensuring that neither parameter exceeds the maximum int256.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-ensuring-that-neither-parameter-exceeds-the-maximum-int256.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#12. The _grossWinnings variable is now capped at the maximum safe value. The _feeFraction was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.", "body": "Update: Fixed in PR#12. The _grossWinnings variable is now capped at the maximum safe value. The _feeFraction was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#12.-the-_grosswinnings-variable-is-now-capped-at-the-maximum-safe-value.-the-_feefraction-was-already-restricted-by-the-contract-logic-to-be-less-than-1e18-so-it-could-not-cause-an-overflow.", "labels": ["OpenZeppelin"]}, {"title": "Notes", "body": "Notes", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#notes", "labels": ["OpenZeppelin"]}, {"title": "[N01] Unrestricted token ownership", "body": "[N01] Unrestricted token ownership", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n01]-unrestricted-token-ownership", "labels": ["OpenZeppelin"]}, {"title": "Whenever a pool token is transferred, the RecipientWhitelistERC777Pool contract restricts the possible recipients to an administrator-defined white list. It should be noted that this does not prevent addresses from receiving tokens in exchange for deposits or winning them in a lottery.", "body": "Whenever a pool token is transferred, the RecipientWhitelistERC777Pool contract restricts the possible recipients to an administrator-defined white list. It should be noted that this does not prevent addresses from receiving tokens in exchange for deposits or winning them in a lottery.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#whenever-a-pool-token-is-transferred,-the-recipientwhitelisterc777pool-contract-restricts-the-possible-recipients-to-an-administrator-defined-white-list.-it-should-be-noted-that-this-does-not-prevent-addresses-from-receiving-tokens-in-exchange-for-deposits-or-winning-them-in-a-lottery.", "labels": ["OpenZeppelin"]}, {"title": "Update: This is the expected behavior", "body": "Update: This is the expected behavior", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-this-is-the-expected-behavior", "labels": ["OpenZeppelin"]}, {"title": "[N02] Inconsistent imports", "body": "[N02] Inconsistent imports", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n02]-inconsistent-imports", "labels": ["OpenZeppelin"]}, {"title": "The code base imports contracts from the OpenZeppelin contracts package as well as contracts-ethereum-package. This is unnecessary and may cause issues if there is a name collision with imported contracts across both packages (or the contracts they depend on). In this case there is no collision, but it does introduce unnecessary fragility.", "body": "The code base imports contracts from the OpenZeppelin contracts package as well as contracts-ethereum-package. This is unnecessary and may cause issues if there is a name collision with imported contracts across both packages (or the contracts they depend on). In this case there is no collision, but it does introduce unnecessary fragility.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-code-base-imports-contracts-from-the-openzeppelin-contracts-package-as-well-as-contracts-ethereum-package.-this-is-unnecessary-and-may-cause-issues-if-there-is-a-name-collision-with-imported-contracts-across-both-packages-(or-the-contracts-they-depend-on).-in-this-case-there-is-no-collision,-but-it-does-introduce-unnecessary-fragility.", "labels": ["OpenZeppelin"]}, {"title": "Consider using contracts-ethereum-package exclusively, which is a copy of contracts that is consistent with the OpenZeppelin upgrades package.", "body": "Consider using contracts-ethereum-package exclusively, which is a copy of contracts that is consistent with the OpenZeppelin upgrades package.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-using-contracts-ethereum-package-exclusively,-which-is-a-copy-of-contracts-that-is-consistent-with-the-openzeppelin-upgrades-package.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#10.", "body": "Update: Fixed in PR#10.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#10.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Default Visibility", "body": "[N03] Default Visibility", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n03]-default-visibility", "labels": ["OpenZeppelin"]}, {"title": "Throughout the code base, some of the contract variables use default visibility. For readability, consider explicitly declaring the visibility of all state variables.", "body": "Throughout the code base, some of the contract variables use default visibility. For readability, consider explicitly declaring the visibility of all state variables.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#throughout-the-code-base,-some-of-the-contract-variables-use-default-visibility.-for-readability,-consider-explicitly-declaring-the-visibility-of-all-state-variables.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#13.", "body": "Update: Fixed in PR#13.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#13.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Reimplementing Pausable", "body": "[N04] Reimplementing Pausable", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n04]-reimplementing-pausable", "labels": ["OpenZeppelin"]}, {"title": "The BasePool contract allows an administrator to pause and resume some functions. The functionality is already part of OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.", "body": "The BasePool contract allows an administrator to pause and resume some functions. The functionality is already part of OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-basepool-contract-allows-an-administrator-to-pause-and-resume-some-functions.-the-functionality-is-already-part-of-openzeppelin-contracts,-which-has-been-audited-and-is-constantly-reviewed-by-the-community.", "labels": ["OpenZeppelin"]}, {"title": "Consider inheriting from the OpenZeppelin Pausable contract to benefit from bug fixes to be applied in future releases and to reduce the code\u2019s attack surface.", "body": "Consider inheriting from the OpenZeppelin Pausable contract to benefit from bug fixes to be applied in future releases and to reduce the code\u2019s attack surface.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-inheriting-from-the-openzeppelin-pausable-contract-to-benefit-from-bug-fixes-to-be-applied-in-future-releases-and-to-reduce-the-code\u2019s-attack-surface.", "labels": ["OpenZeppelin"]}, {"title": "Update: Accepted. PoolTogether would prefer not to adopt this suggestion since it would change the storage layout of an existing contract.", "body": "Update: Accepted. PoolTogether would prefer not to adopt this suggestion since it would change the storage layout of an existing contract.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-accepted.-pooltogether-would-prefer-not-to-adopt-this-suggestion-since-it-would-change-the-storage-layout-of-an-existing-contract.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Repeated code", "body": "[N05] Repeated code", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n05]-repeated-code", "labels": ["OpenZeppelin"]}, {"title": "The RecipientWhitelistERC777Pool contract overrides the _callTokensToSend function to restrict the possible recipients. However, the rest of the function is identical. For simplicity, consider invoking the overridden function to execute the tokensToSend hook.", "body": "The RecipientWhitelistERC777Pool contract overrides the _callTokensToSend function to restrict the possible recipients. However, the rest of the function is identical. For simplicity, consider invoking the overridden function to execute the tokensToSend hook.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-recipientwhitelisterc777pool-contract-overrides-the-_calltokenstosend-function-to-restrict-the-possible-recipients.-however,-the-rest-of-the-function-is-identical.-for-simplicity,-consider-invoking-the-overridden-function-to-execute-the-tokenstosend-hook.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#4.", "body": "The totalBalanceOf function comments have been updated. Additional events and functions have been created to support withdrawing from the different user balances. Note that the Withdrawn event no longer applies to token transfers between users.  [L06] Misleading comments and variable names  Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to end users, misleading statements should be considered a violation of the public API.  The @return comment describing BasePool.getDraw only describes 4 of the 8 return values.  The @notice function of BasePool.balanceOf states that it returns the users total balance but it only returns the committed balance.  The rewardAndOpenNextDraw function and the reward function of BasePool do not have a @param comment for the salt.  The BasePool contract returns the error message could not transfer winnings even though it applies to all balances.  The @notice function of DrawManager.draw does not describe the case where are no participants.  In addition, the following internal documentation could be clarified:  The MAX_LEAVES constant does not constrain the number of leaves in the sortition tree. It should be a synonym of MAX_BRANCHES_PER_NODE or DEGREE_OF_TREE. It is also missing its comment.  Many of the BasePool functions are not documented.  The emitCommitted functions in the BasePool contract and the ERC777Pool contract claim to commit the current draw. In fact, they simply emit events. The relevant state changes occur when the new draw is opened.  The comments describing ERC777Pool._callTokensReceived do not include the last parameter.  The requireOpenDraw and onlyNonZero modifiers are missing their comments.  The RecipientWhitelistERC777Pool contract and most of its functions are not commented.  Update: Fixed in PR#21. These suggestions were implemented and the documentation has been significantly expanded.  [L07] Excessive code coupling  During a transfer of Pool Tokens, the balance gets added to the recipients committed draw tree. If the recipient does not have any committed balance, it is added to a newly created balance associated with the previous draw.  However, if the pool is currently in the first draw, which starts at index 1, this will associate the new balance with the invalid zero draw, and will also leave the users first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.  Fortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.  Nevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).  Consider confirming that the first draw is committed before assigning deposits to the previous draw.  Update: Fixed in PR#9. The depositCommitted and withdrawCommitted functions now require at least one draw to be committed.  [L08] Unchecked casting from uint256 to int256  The BasePool contract uses the FixidityLib to perform fixed point arithmetic with protection against overflow.  accepts an int256 as the parameter so the  need to be cast into int256 values.  If one of those parameters is higher than the maximum int256, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.  Consider ensuring that neither parameter exceeds the maximum int256.  Update: Fixed in PR#12. The _grossWinnings variable is now capped at the maximum safe value. The _feeFraction was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.  Notes  [N01] Unrestricted token ownership  Whenever a pool token is transferred, the RecipientWhitelistERC777Pool contract restricts the possible recipients to an administrator-defined white list. It should be noted that this does not prevent addresses from receiving tokens in exchange for deposits or winning them in a lottery.  Update: This is the expected behavior  [N02] Inconsistent imports  The code base imports contracts from the OpenZeppelin contracts package as well as contracts-ethereum-package. This is unnecessary and may cause issues if there is a name collision with imported contracts across both packages (or the contracts they depend on). In this case there is no collision, but it does introduce unnecessary fragility.  Consider using contracts-ethereum-package exclusively, which is a copy of contracts that is consistent with the OpenZeppelin upgrades package.  Update: Fixed in PR#10.  [N03] Default Visibility  Throughout the code base, some of the contract variables use default visibility. For readability, consider explicitly declaring the visibility of all state variables.  Update: Fixed in PR#13.  [N04] Reimplementing Pausable  The BasePool contract allows an administrator to pause and resume some functions. The functionality is already part of OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.  Consider inheriting from the OpenZeppelin Pausable contract to benefit from bug fixes to be applied in future releases and to reduce the codes attack surface.  Update: Accepted. PoolTogether would prefer not to adopt this suggestion since it would change the storage layout of an existing contract.  [N05] Repeated code  The RecipientWhitelistERC777Pool contract overrides the _callTokensToSend function to restrict the possible recipients. However, the rest of the function is identical. For simplicity, consider invoking the overridden function to execute the tokensToSend hook.    [N06] Random upper bound of zero  The uniform function of the UniformRandomNumber library returns zero whenever the specified upper bound is zero. This contradicts the Ethereum Natural Specification comment and is inconsistent with the usual behavior of returning a value strictly less than the upper bound.  Consider requiring the upper bound to be non-zero, or updating the comment accordingly.  Update: Fixed in PR#14. The bound is now required to be greater than zero. The edge case is handled in the calling function.  [N07] Semantic Overloading  The pool contract identifies if a particular draw has been rewarded by checking if the entropy is non zero. This works because the winner is rewarded in the same function that the entropy is revealed, and it is highly unlikely to be zero.  However, this is an example of semantic overloading. It also necessitates an arbitrary fake entropy value to be used whenever the administrator cannot reveal the entropy. We did not identify any vulnerabilities arising from this pattern, but it does make the code more fragile.  Consider including an explicit contract variable that tracks if the committed draw has been rewarded.  Update: Acccepted. Since the rollover mechanism and entropy source will both be updated, PoolTogether would prefer not to introduce new state that will need to be deprecated.  [N08] Unnecessary casting of drawIndex  obtained with the draw method of the SortionSumTreeFactory, which  returns a bytes32 value. It is then cast to a  used twice to reference the selected tree, where it has to be cast back to a  Consider removing the redundant cast into a uint256 type.  Update: Fixed in PR#17.  [N09] Unnecessary SafeMath sum operation  In the committedBalanceOf function from the DrawManager contract, a balance variable is created to add the funds deposited under the firstDrawIndex and secondDrawIndex.  When the funds under the firstDrawIndex are added to the balance, balance always equals zero, making the addition unnecessary.  For simplicity and clarity, consider changing the SafeMath addition into a simple assignment.  Update: Fixed in PR#18.  [N10] Instances of uint  Throughout the code base, some variables are declared with type uint. To favor explicitness, consider changing all instances of uint to uint256.  Update: Fixed in PR#19.  [N11] Naming  To favor explicitness and readability, several parts of the contracts may benefit from better naming.Our suggestions are:  In DrawManager.sol:  usersFirstDrawIndex to consolidatedDrawIndex  usersSecondDrawIndex to latestDrawIndex  In BasePool.sol:  Opened to DrawOpened  Committed to DrawCommitted  Rewarded to DrawConcluded  Paused to PoolPaused  Unpaused to PoolUnpaused  open to openDraw  Update: Partially fixed in PR#20. The event names remain unchanged to maintain consistency with the deployed contract.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#4.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Random upper bound of zero", "body": "[N06] Random upper bound of zero", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n06]-random-upper-bound-of-zero", "labels": ["OpenZeppelin"]}, {"title": "The uniform function of the UniformRandomNumber library returns zero whenever the specified upper bound is zero. This contradicts the Ethereum Natural Specification comment and is inconsistent with the usual behavior of returning a value strictly less than the upper bound.", "body": "The uniform function of the UniformRandomNumber library returns zero whenever the specified upper bound is zero. This contradicts the Ethereum Natural Specification comment and is inconsistent with the usual behavior of returning a value strictly less than the upper bound.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-uniform-function-of-the-uniformrandomnumber-library-returns-zero-whenever-the-specified-upper-bound-is-zero.-this-contradicts-the-ethereum-natural-specification-comment-and-is-inconsistent-with-the-usual-behavior-of-returning-a-value-strictly-less-than-the-upper-bound.", "labels": ["OpenZeppelin"]}, {"title": "Consider requiring the upper bound to be non-zero, or updating the comment accordingly.", "body": "Consider requiring the upper bound to be non-zero, or updating the comment accordingly.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-requiring-the-upper-bound-to-be-non-zero,-or-updating-the-comment-accordingly.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#14. The bound is now required to be greater than zero. The edge case is handled in the calling function.", "body": "Update: Fixed in PR#14. The bound is now required to be greater than zero. The edge case is handled in the calling function.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#14.-the-bound-is-now-required-to-be-greater-than-zero.-the-edge-case-is-handled-in-the-calling-function.", "labels": ["OpenZeppelin"]}, {"title": "[N07] Semantic Overloading", "body": "[N07] Semantic Overloading", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n07]-semantic-overloading", "labels": ["OpenZeppelin"]}, {"title": "The pool contract identifies if a particular draw has been rewarded by checking if the entropy is non zero. This works because the winner is rewarded in the same function that the entropy is revealed, and it is highly unlikely to be zero.", "body": "The pool contract identifies if a particular draw has been rewarded by checking if the entropy is non zero. This works because the winner is rewarded in the same function that the entropy is revealed, and it is highly unlikely to be zero.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#the-pool-contract-identifies-if-a-particular-draw-has-been-rewarded-by-checking-if-the-entropy-is-non-zero.-this-works-because-the-winner-is-rewarded-in-the-same-function-that-the-entropy-is-revealed,-and-it-is-highly-unlikely-to-be-zero.", "labels": ["OpenZeppelin"]}, {"title": "However, this is an example of semantic overloading. It also necessitates an arbitrary fake entropy value to be used whenever the administrator cannot reveal the entropy. We did not identify any vulnerabilities arising from this pattern, but it does make the code more fragile.", "body": "However, this is an example of semantic overloading. It also necessitates an arbitrary fake entropy value to be used whenever the administrator cannot reveal the entropy. We did not identify any vulnerabilities arising from this pattern, but it does make the code more fragile.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#however,-this-is-an-example-of-semantic-overloading.-it-also-necessitates-an-arbitrary-fake-entropy-value-to-be-used-whenever-the-administrator-cannot-reveal-the-entropy.-we-did-not-identify-any-vulnerabilities-arising-from-this-pattern,-but-it-does-make-the-code-more-fragile.", "labels": ["OpenZeppelin"]}, {"title": "Consider including an explicit contract variable that tracks if the committed draw has been rewarded.", "body": "Consider including an explicit contract variable that tracks if the committed draw has been rewarded.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-including-an-explicit-contract-variable-that-tracks-if-the-committed-draw-has-been-rewarded.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acccepted. Since the rollover mechanism and entropy source will both be updated, PoolTogether would prefer not to introduce new state that will need to be deprecated.", "body": "Update: Acccepted. Since the rollover mechanism and entropy source will both be updated, PoolTogether would prefer not to introduce new state that will need to be deprecated.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-acccepted.-since-the-rollover-mechanism-and-entropy-source-will-both-be-updated,-pooltogether-would-prefer-not-to-introduce-new-state-that-will-need-to-be-deprecated.", "labels": ["OpenZeppelin"]}, {"title": "[N08] Unnecessary casting of drawIndex", "body": "[N08] Unnecessary casting of drawIndex", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n08]-unnecessary-casting-of-drawindex", "labels": ["OpenZeppelin"]}, {"title": "obtained with the draw method of the SortionSumTreeFactory, which", "body": "obtained with the draw method of the SortionSumTreeFactory, which", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#obtained-with-the-draw-method-of-the-sortionsumtreefactory,-which", "labels": ["OpenZeppelin"]}, {"title": "returns a bytes32 value. It is then cast to a", "body": "returns a bytes32 value. It is then cast to a", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#returns-a-bytes32-value.-it-is-then-cast-to-a", "labels": ["OpenZeppelin"]}, {"title": "used twice to reference the selected tree, where it has to be cast back to a", "body": "used twice to reference the selected tree, where it has to be cast back to a", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#used-twice-to-reference-the-selected-tree,-where-it-has-to-be-cast-back-to-a", "labels": ["OpenZeppelin"]}, {"title": "Consider removing the redundant cast into a uint256 type.", "body": "Consider removing the redundant cast into a uint256 type.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#consider-removing-the-redundant-cast-into-a-uint256-type.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#17.", "body": "Update: Fixed in PR#17.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#17.", "labels": ["OpenZeppelin"]}, {"title": "[N09] Unnecessary SafeMath sum operation", "body": "[N09] Unnecessary SafeMath sum operation", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n09]-unnecessary-safemath-sum-operation", "labels": ["OpenZeppelin"]}, {"title": "In the committedBalanceOf function from the DrawManager contract, a balance variable is created to add the funds deposited under the firstDrawIndex and secondDrawIndex.", "body": "In the committedBalanceOf function from the DrawManager contract, a balance variable is created to add the funds deposited under the firstDrawIndex and secondDrawIndex.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#in-the-committedbalanceof-function-from-the-drawmanager-contract,-a-balance-variable-is-created-to-add-the-funds-deposited-under-the-firstdrawindex-and-seconddrawindex.", "labels": ["OpenZeppelin"]}, {"title": "When the funds under the firstDrawIndex are added to the balance, balance always equals zero, making the addition unnecessary.", "body": "When the funds under the firstDrawIndex are added to the balance, balance always equals zero, making the addition unnecessary.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#when-the-funds-under-the-firstdrawindex-are-added-to-the-balance,-balance-always-equals-zero,-making-the-addition-unnecessary.", "labels": ["OpenZeppelin"]}, {"title": "For simplicity and clarity, consider changing the SafeMath addition into a simple assignment.", "body": "For simplicity and clarity, consider changing the SafeMath addition into a simple assignment.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#for-simplicity-and-clarity,-consider-changing-the-safemath-addition-into-a-simple-assignment.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#18.", "body": "Update: Fixed in PR#18.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#18.", "labels": ["OpenZeppelin"]}, {"title": "[N10] Instances of uint", "body": "[N10] Instances of uint", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n10]-instances-of-uint", "labels": ["OpenZeppelin"]}, {"title": "Throughout the code base, some variables are declared with type uint. To favor explicitness, consider changing all instances of uint to uint256.", "body": "Throughout the code base, some variables are declared with type uint. To favor explicitness, consider changing all instances of uint to uint256.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#throughout-the-code-base,-some-variables-are-declared-with-type-uint.-to-favor-explicitness,-consider-changing-all-instances-of-uint-to-uint256.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#19.", "body": "Update: Fixed in PR#19.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-fixed-in-pr#19.", "labels": ["OpenZeppelin"]}, {"title": "[N11] Naming", "body": "[N11] Naming", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#[n11]-naming", "labels": ["OpenZeppelin"]}, {"title": "To favor explicitness and readability, several parts of the contracts may benefit from better naming.Our suggestions are:", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming.Our suggestions are:", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#to-favor-explicitness-and-readability,-several-parts-of-the-contracts-may-benefit-from-better-naming.our-suggestions-are:", "labels": ["OpenZeppelin"]}, {"title": "In DrawManager.sol:", "body": "In DrawManager.sol:", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#in-drawmanager.sol:", "labels": ["OpenZeppelin"]}, {"title": "usersFirstDrawIndex to consolidatedDrawIndex", "body": "usersFirstDrawIndex to consolidatedDrawIndex", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#usersfirstdrawindex-to-consolidateddrawindex", "labels": ["OpenZeppelin"]}, {"title": "usersSecondDrawIndex to latestDrawIndex", "body": "usersSecondDrawIndex to latestDrawIndex", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#usersseconddrawindex-to-latestdrawindex", "labels": ["OpenZeppelin"]}, {"title": "In BasePool.sol:", "body": "In BasePool.sol:", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#in-basepool.sol:", "labels": ["OpenZeppelin"]}, {"title": "Opened to DrawOpened", "body": "Opened to DrawOpened", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#opened-to-drawopened", "labels": ["OpenZeppelin"]}, {"title": "Committed to DrawCommitted", "body": "Committed to DrawCommitted", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#committed-to-drawcommitted", "labels": ["OpenZeppelin"]}, {"title": "Rewarded to DrawConcluded", "body": "Rewarded to DrawConcluded", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#rewarded-to-drawconcluded", "labels": ["OpenZeppelin"]}, {"title": "Paused to PoolPaused", "body": "Paused to PoolPaused", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#paused-to-poolpaused", "labels": ["OpenZeppelin"]}, {"title": "Unpaused to PoolUnpaused", "body": "Unpaused to PoolUnpaused", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#unpaused-to-poolunpaused", "labels": ["OpenZeppelin"]}, {"title": "open to openDraw", "body": "open to openDraw", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#open-to-opendraw", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in PR#20. The event names remain unchanged to maintain consistency with the deployed contract.", "body": "Update: Partially fixed in PR#20. The event names remain unchanged to maintain consistency with the deployed contract.", "html_url": "https://blog.openzeppelin.com/pooltogether-audit#update:-partially-fixed-in-pr#20.-the-event-names-remain-unchanged-to-maintain-consistency-with-the-deployed-contract.", "labels": ["OpenZeppelin"]}, {"title": "[P1-C01] The bootstrap process can be hijacked", "body": "[P1-C01] The bootstrap process can be hijacked", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-c01]-the-bootstrap-process-can-be-hijacked", "labels": ["OpenZeppelin"]}, {"title": "Critical", "body": "Components: deploy and proxy  BeamBootstrap contract stores its owner in the  deployAccount  variable, which also gets transferred to  20  ForwardProxy contracts through  BeamInitializable.  The BeamInitializable contract also uses an ownership pattern, which allows only the owner to set the implementation that will be delegated from the proxy and to selfdestruct the contract.  The issue here is that the initialize function is public. It does not have a restriction that only the owner can call, and it can be called more than once.  For an attacker to hijack the entire Bootstrap process, it would only require them to deploy a malicious contract like this:  They can also get ownership of the original BeamInitializable contract, but that does not seem to give them any gain.  Test case: https://gist.github.com/mattaereal/9a7fe9d20b3c3253b1effe049cb9211e  Consider requiring that only the owner can call the initialize function, thus making it possible to call it only once during initialization with the onlyConstruction modifier.  destruct  initialize  [P1-C02] Storage collision on Policed contract    Component: policy  Policy  contracts have the power to enforce actions over  Policed  contracts (i.e., the latter are managed by the former). This means that  This enforcement of actions is done via the policyCommand function of the Policed contract, which can only be executed by the managing policy  this last restriction being enforced by the custom onlyPolicy modifier.  Given a Policy contract such as:  And the following contract with some logic that the Policy is going to enforce over the Policed contract:  Here is a snippet of the Policed contract showing its state variable policy:  A proof of concept of this issue goes as follows:  Low-level calls such as delegatecall are always to be implemented with utter care and be thoroughly tested. Strategies to avoid this vulnerability, along with further cases and explanations, can be found at OpenZeppelin SDK documentation on unstructured storage.  implementation  policy  The unstructured storage approach recommended by OpenZeppelin here does help prevent accidental storage collisions, but at the same time it significantly complicates maintenance and upgrades in the future. Ecos engineering team has adopted OpenZeppelins unstructured storage approach for the core proxy functionality (the implementation slot), but prefers to adopt policies and develop tools to manage the risk for other parts of the system. Specifically, when dealing with the policy slot identified here, we plan to extend our linter rules and thoroughly test upgrades to ensure collisions do not cause problems.  High Severity  [P1-H01] Missing test coverage reports  High  Components: all  There are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.  Consider adding the test coverage reports and making it reach at least 95% of the source code.  Update: Partially fixed. The test coverage report was added to the currency repository, reporting 92% of coverage. Ecos statement for this issue:  Test coverage of our contracts is around 98%. Our overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. Coverage on the JavaScript code is intentionally less thorough, approximately 87%. This allows us to iterate more quickly on the JavaScript code, while still covering the core functionality.  [P1-H02] Low unit test coverage  High  Components: all  In the deployment-nicks-method repository, there are no tests at all.  In beam-bootstrap-chain:  Test case file named compute-gas.js only deploys a BeamBootstrap contract and nothing more. It does not compute gas as supposedly intended.  The ForwardTarget and BeamBootstrap contracts have no unit tests.  In policed-contracts, only the Policed contract has tests.  Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.  Consider adding unit tests for every code path. Consider running the tests on every pull request.  Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Ecos statement for this issue in [P1-H01] Missing test coverage reports.  [P1-H03] Outdated ERC820  High", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#critical", "labels": ["OpenZeppelin"]}, {"title": "Components: deploy and proxy", "body": "Components: deploy and proxy", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#components:-deploy-and-proxy", "labels": ["OpenZeppelin"]}, {"title": "BeamBootstrap contract stores its owner in the", "body": "BeamBootstrap contract stores its owner in the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beambootstrap-contract-stores-its-owner-in-the", "labels": ["OpenZeppelin"]}, {"title": "deployAccount", "body": "deployAccount", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#deployaccount", "labels": ["OpenZeppelin"]}, {"title": "variable, which also gets transferred to", "body": "variable, which also gets transferred to", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#variable,-which-also-gets-transferred-to", "labels": ["OpenZeppelin"]}, {"title": "20", "body": "20", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#20", "labels": ["OpenZeppelin"]}, {"title": "ForwardProxy contracts through", "body": "ForwardProxy contracts through", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#forwardproxy-contracts-through", "labels": ["OpenZeppelin"]}, {"title": "BeamInitializable.", "body": "BeamInitializable.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beaminitializable.", "labels": ["OpenZeppelin"]}, {"title": "The BeamInitializable contract also uses an ownership pattern, which allows only the owner to set the implementation that will be delegated from the proxy and to selfdestruct the contract.", "body": "The BeamInitializable contract also uses an ownership pattern, which allows only the owner to set the implementation that will be delegated from the proxy and to selfdestruct the contract.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-beaminitializable-contract-also-uses-an-ownership-pattern,-which-allows-only-the-owner-to-set-the-implementation-that-will-be-delegated-from-the-proxy-and-to-selfdestruct-the-contract.", "labels": ["OpenZeppelin"]}, {"title": "The issue here is that the initialize function is public. It does not have a restriction that only the owner can call, and it can be called more than once.", "body": "The issue here is that the initialize function is public. It does not have a restriction that only the owner can call, and it can be called more than once.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-issue-here-is-that-the-initialize-function-is-public.-it-does-not-have-a-restriction-that-only-the-owner-can-call,-and-it-can-be-called-more-than-once.", "labels": ["OpenZeppelin"]}, {"title": "For an attacker to hijack the entire Bootstrap process, it would only require them to deploy a malicious contract like this:", "body": "For an attacker to hijack the entire Bootstrap process, it would only require them to deploy a malicious contract like this:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#for-an-attacker-to-hijack-the-entire-bootstrap-process,-it-would-only-require-them-to-deploy-a-malicious-contract-like-this:", "labels": ["OpenZeppelin"]}, {"title": "They can also get ownership of the original BeamInitializable contract, but that does not seem to give them any gain.", "body": "They can also get ownership of the original BeamInitializable contract, but that does not seem to give them any gain.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#they-can-also-get-ownership-of-the-original-beaminitializable-contract,-but-that-does-not-seem-to-give-them-any-gain.", "labels": ["OpenZeppelin"]}, {"title": "Test case: https://gist.github.com/mattaereal/9a7fe9d20b3c3253b1effe049cb9211e", "body": "Test case: https://gist.github.com/mattaereal/9a7fe9d20b3c3253b1effe049cb9211e", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#test-case:-https://gist.github.com/mattaereal/9a7fe9d20b3c3253b1effe049cb9211e", "labels": ["OpenZeppelin"]}, {"title": "Consider requiring that only the owner can call the initialize function, thus making it possible to call it only once during initialization with the onlyConstruction modifier.", "body": "Consider requiring that only the owner can call the initialize function, thus making it possible to call it only once during initialization with the onlyConstruction modifier.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-requiring-that-only-the-owner-can-call-the-initialize-function,-thus-making-it-possible-to-call-it-only-once-during-initialization-with-the-onlyconstruction-modifier.", "labels": ["OpenZeppelin"]}, {"title": "destruct", "body": "destruct", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#destruct", "labels": ["OpenZeppelin"]}, {"title": "initialize", "body": "function, thus making it possible to call it only once during initialization with the onlyConstruction modifier.  destruct    [P1-C02] Storage collision on Policed contract  Critical  Component: policy  Policy  contracts have the power to enforce actions over  Policed  contracts (i.e., the latter are managed by the former). This means that  This enforcement of actions is done via the policyCommand function of the Policed contract, which can only be executed by the managing policy  this last restriction being enforced by the custom onlyPolicy modifier.  Given a Policy contract such as:  And the following contract with some logic that the Policy is going to enforce over the Policed contract:  Here is a snippet of the Policed contract showing its state variable policy:  A proof of concept of this issue goes as follows:  Low-level calls such as delegatecall are always to be implemented with utter care and be thoroughly tested. Strategies to avoid this vulnerability, along with further cases and explanations, can be found at OpenZeppelin SDK documentation on unstructured storage.  implementation  policy  The unstructured storage approach recommended by OpenZeppelin here does help prevent accidental storage collisions, but at the same time it significantly complicates maintenance and upgrades in the future. Ecos engineering team has adopted OpenZeppelins unstructured storage approach for the core proxy functionality (the implementation slot), but prefers to adopt policies and develop tools to manage the risk for other parts of the system. Specifically, when dealing with the policy slot identified here, we plan to extend our linter rules and thoroughly test upgrades to ensure collisions do not cause problems.  High Severity  [P1-H01] Missing test coverage reports  High  Components: all  There are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.  Consider adding the test coverage reports and making it reach at least 95% of the source code.  Update: Partially fixed. The test coverage report was added to the currency repository, reporting 92% of coverage. Ecos statement for this issue:  Test coverage of our contracts is around 98%. Our overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. Coverage on the JavaScript code is intentionally less thorough, approximately 87%. This allows us to iterate more quickly on the JavaScript code, while still covering the core functionality.  [P1-H02] Low unit test coverage  High  Components: all  In the deployment-nicks-method repository, there are no tests at all.  In beam-bootstrap-chain:  Test case file named compute-gas.js only deploys a BeamBootstrap contract and nothing more. It does not compute gas as supposedly intended.  The ForwardTarget and BeamBootstrap contracts have no unit tests.  In policed-contracts, only the Policed contract has tests.  Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.  Consider adding unit tests for every code path. Consider running the tests on every pull request.  Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Ecos statement for this issue in [P1-H01] Missing test coverage reports.  [P1-H03] Outdated ERC820  High  Component: policy  In line 59 of Policy.sol and in line 49 of PolicedUtils.sol, the hard-coded address for the ERC820Registry contract is outdated.  The address used is 0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7.  The correct address is 0x820b586C8C28125366C998641B09DCbE7d4cBF06.  Also, the npm dependency erc820: 0.0.22 is outdated. Moreover, it is set as fixed in the package.json file, so not even minor changes in the versions will be downloaded when users run npm install.  The address and version used correspond to a previous version while the standard was a work in progress. Now, the standard is on the final call, but there is still a chance that a new version will be released and/or that the address will change.  Consider changing the address of the ERC820Registry to point it to the actual one. Consider updating the version of the erc820 package and allowing it to install newer minor versions.  For further reference: https://eips.ethereum.org/EIPS/eip-820  Before deploying to production, confirm that the EIP is final, that the address has not changed, and that the package version used is the latest.  Update: Fixed. The EIP 820 is now final, but the Eco team found and reported an issue to the implementation. A new EIP 1820 was proposed to fix it, and it now supersedes EIP 820. The contracts are now using the upstream implementation of EIP 1820.  Medium Severity  [P1-M01] There are multiple hard-coded constants  Medium  Components: all  Hard-coded booleans, numbers, and strings in the code are hard to understand, and they are prone to error, because after some time, their origin and context can be forgotten or mistaken.  For example:  In deployment-nicks-method:  index.js:L40  In beam-bootstrap-chain:  BeamBootstrap.sol:L17: hard-coded 20  truffle.js:L9: hard-coded address  In policed-contracts:  Policy.sol:L59: hard-coded address  erc820.js:L5: bytecode without comment  erc820.js:L9: hard-coded address  erc820.js:L10: hard-coded address  Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For the complex values, consider adding a comment explaining how they were calculated or why they were chosen.  Update: Fixed. All the hard-coded values mentioned above have been moved to constants, commented, or removed.  [P1-M02] Unit tests are not verifying a single condition  Medium  Components: all  Every unit test should verify a single code path to ensure isolation and to make it easier to blame a single line of code when one of the tests fails. The test structure should follow the four phase pattern, clearly separating the interactions with the system under test from the verification.  Consider splitting the tests to make them fully isolated and as short and focused as possible. Consider following the four phase pattern on each of them. Consider following a data-driven pattern for test cases with multiple scenarios like the abs tests.  Update: Fixed. Many tests have been added with a nice and clean style.  [P1-M03] Solidity optimizations in tests may cause unpredictable behavior  Medium  Components: policy and beam-bootstrap-chain  In beam-bootstrap-chain/truffle.js and policed-contracts/truffle.js, Solidity optimizations are enabled.  Solidity has some optimizations that are default and are always executed, and some others are optional. Enabling the optional ones increases the risk of unexpected behavior, since they are not as battle-tested as the default optimizations. Consider adding full test coverage without optimizations before enabling them to verify that the introduced optimizations preserve expected behavior.  Test coverage  note has been added to the README  Our Solidity test coverage is 98%. While this is slightly less than 100%, were satisfied that it covers the risk introduced by using the Solidity optimizer.  [P1-M04] Overriding  is confusing  Medium  Component: proxy  ForwardTarget  contract defines and implements the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#initialize", "labels": ["OpenZeppelin"]}, {"title": "[P1-C02] Storage collision on Policed contract", "body": "[P1-C02] Storage collision on Policed contract", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-c02]-storage-collision-on-policed-contract", "labels": ["OpenZeppelin"]}, {"title": "Component: policy", "body": "Component: policy", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#component:-policy", "labels": ["OpenZeppelin"]}, {"title": "Policy", "body": "component is a generic management framework that allows some contracts to be managed by others.  The second phase was for the Currency component, which is the implementation of the Eco token.  The third phase was for the Governance component, which is in charge of the voting for policy changes and the voting for inflation and deflation decisions.  In the fourth phase, we audited the implementation of a Verifiable Delay Function, that is used for the commit and reveal schema needed for the votes.  In the fifth phase, we reviewed all the changes that the Eco team has implemented to fix the vulnerabilities we have reported. We also spent some time analyzing the system as a whole and trying to attack the integration points of all the components.  Finally, one last review of unsolved issues was carried out, in which we updated each report of the five phases with Ecos statements where appropriate. The last reviewed commit of the currency repository is 68adc904.  By now, almost every single member of the OpenZeppelin team has participated in some way on this project. Some have tried very hard to break the system, some have joined discussions to come up with ideas to simplify very complicated operations, some have spent long nights obsessing about deciphering that last line of assembly code\u2026  As we got deeper into the code, we got more engaged with the project. As the Eco team started fixing the problems we were finding, we got stricter and more demanding. By the end, we had collected 8 vulnerabilities of critical severity and 9 vulnerabilities of high severity, along with many less critical issues and multiple suggestions to make the code clearer. Most of them have been successfully fixed by the Eco team by now. As one of our teammates said, it was amazing to see the improvements in the code during this year. Now, they have some of the best contracts we have seen in terms of organization, documentation, and readability.  You can see the reports of the individual phases for extensive details of every vulnerability found and how they have been fixed or mitigated.  Recommendations before releasing to production  Make all the audited repositories public. Parts of the code have been integrated into a single repository, so the old repositories should be deprecated.  Increase the unit test coverage to 100%.  Limit future pull requests to one single and independent change for improved traceability.  Move the documentation of the contracts API from the README files to a documentation website, like the OpenZeppelin Contracts website (which uses solidity-docgen).  Perform an audit to verify the cryptographic strength of the Verifiable Delay Function.  Perform a game theoretic evaluation of the incentives of the system. In particular, note that votes that use a past snapshot of the balances could have perverse incentives. Users may sell their tokens before casting their votes, having nothing at stake when the results are executed. Game-theoretical analysis is a service we have recently started offering at OpenZeppelin, led by Austin Williams.  Start building a community of users and contributors. We recommend the books and resources published by Jono Bacon.  Deploy the full system to testnet.  Design a beta phase with enough incentives for a big and diverse community to participate.  Start a bug bounty program to give real economic incentives to attack the system, even during testing. We recommend the HackerOne platform.  Publish guides explaining how to write new policy contracts.  Write automated validators to ensure that new policy contracts implement the correct interfaces and will not break the system. You can follow a similar approach to OpenZeppelins ERC20 verifier.  If the Eco token implements the ERC777 standard, the hooks that accounts can execute introduce the risk of reentrancy attacks and can revert operations. Be extremely careful with the transfer of these tokens: Use the checks-effects-interactions pattern, pull payments, reentrancy guards, or execute the transfer without triggering the hooks.  After the upcoming Istanbul fork, the reprice of EIP1884 will affect the implementation of proxy contracts with a payable fallback function. When adding upgrades or new components to the system, use pull payments or the sendValue helper.  Move the BigNumber library to a separate repository. The OpenZeppelin Contracts maintainers might be interested in adding it to the project and co-maintaining it.  Consider adding a Super User module during the first months of production. This will allow for emergency upgrades to the contracts that cannot wait for the  vote period. Then, it can be removed when the project has proved to be stable and ready for full decentralization.  Consider using Meta Transactions for easier on-boarding of new users and to allow them to interact with Eco tokens, even if they do not have ether.  JTNDZGl2JTIwY2xhc3MlM0QlMjJidG4tY29udGFpbmVyJTIyJTNFJTBBJTBBJTNDYnV0dG9uJTIwb25jbGljayUzRCUyMmN1c3RvbXNjcm9sbCUyOCUyOSUyMiUzRSUzQ2ElMjBocmVmJTNEJTIyJTIzcGhhc2UtMSUyMiUyMGNsYXNzJTNEJTIyY3VzdG9tLWxpbmslMjIlM0VyZWFkJTIwZnVsbCUyMHJlcG9ydCUzQyUyRmElM0UlM0MlMkZidXR0b24lM0UlMEElMEElM0MlMkZkaXYlM0U=  Phase 1: Deploy,  and Proxy  The phase 1 audit was delivered to the Eco team on December 17th, 2018.  The locations and versions used for this report are:  Governance:  Repository 1 [deploy component]: https://github.com/BeamNetwork/deployment-nicks-method\u200a\u200aCommit: 8a8b2d3356db689ae09c6c9bc1affc86f83684f0  Repository 2 [deploy and proxy components]: https://github.com/BeamNetwork/beam-bootstrap-chain\u200a\u200aCommit: 96beab1c5cfd41310bfba733ab7216426caf4a38  Repository 3 [policy component]: https://github.com/BeamNetwork/policed-contracts\u200a\u200aCommit: f9299f43e2bf3629bee2f82bf637918ac9221d62  Our biggest challenge during the audit was to understand how the three repositories for deployment, bootstrap, and proxy forwarding work together. We consider this process to be very complicated. Because the whole system will be built on top of this phase, it becomes one of the most vulnerable parts of the project.  We think the Eco team should consider simplifying the process by using and contributing to other projects that are focused on infrastructure so they can focus instead on building the payments network. For example, the OpenZeppelin SDK provides an upgrade proxy that is already tested and in production, so they can use it instead of having to test and maintain the risky assembly blocks on beam-bootstrap-chain and policed-contracts. By using OpenZeppelin, they will not need to deploy the contracts using Nicks method because the configuration files store the locations for every package on all the networks. Another example is Aragon, which provides voting solutions that can be used to govern when and how to modify the parameters of the system.  This is not to say that nobody should develop their own infrastructure if what is out there does not fit their needs. However, it should be taken into account that these are complex problems on their own and that this code will have to be a lot better documented and tested on isolation and end-to-end in order to ensure its safety.  Here are our audit assessment and recommendations, in order of importance.  af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c  Critical Severity  [P1-C01] The bootstrap process can be hijacked  Critical  Components: deploy and proxy  BeamBootstrap contract stores its owner in the  deployAccount  variable, which also gets transferred to  20  ForwardProxy contracts through  BeamInitializable.  The BeamInitializable contract also uses an ownership pattern, which allows only the owner to set the implementation that will be delegated from the proxy and to selfdestruct the contract.  The issue here is that the initialize function is public. It does not have a restriction that only the owner can call, and it can be called more than once.  For an attacker to hijack the entire Bootstrap process, it would only require them to deploy a malicious contract like this:  They can also get ownership of the original BeamInitializable contract, but that does not seem to give them any gain.  Test case: https://gist.github.com/mattaereal/9a7fe9d20b3c3253b1effe049cb9211e  Consider requiring that only the owner can call the initialize function, thus making it possible to call it only once during initialization with the onlyConstruction modifier.  destruct  initialize  [P1-C02] Storage collision on Policed contract  Critical  Component: policy    contracts have the power to enforce actions over  Policed  contracts (i.e., the latter are managed by the former). This means that  This enforcement of actions is done via the policyCommand function of the Policed contract, which can only be executed by the managing policy  this last restriction being enforced by the custom only modifier.  Given a  contract such as:  And the following contract with some logic that the  is going to enforce over the Policed contract:  Here is a snippet of the Policed contract showing its state variable policy:  A proof of concept of this issue goes as follows:  Low-level calls such as delegatecall are always to be implemented with utter care and be thoroughly tested. Strategies to avoid this vulnerability, along with further cases and explanations, can be found at OpenZeppelin SDK documentation on unstructured storage.  implementation  policy  The unstructured storage approach recommended by OpenZeppelin here does help prevent accidental storage collisions, but at the same time it significantly complicates maintenance and upgrades in the future. Ecos engineering team has adopted OpenZeppelins unstructured storage approach for the core proxy functionality (the implementation slot), but prefers to adopt policies and develop tools to manage the risk for other parts of the system. Specifically, when dealing with the policy slot identified here, we plan to extend our linter rules and thoroughly test upgrades to ensure collisions do not cause problems.  High Severity  [P1-H01] Missing test coverage reports  High  Components: all  There are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.  Consider adding the test coverage reports and making it reach at least 95% of the source code.  Update: Partially fixed. The test coverage report was added to the currency repository, reporting 92% of coverage. Ecos statement for this issue:  Test coverage of our contracts is around 98%. Our overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. Coverage on the JavaScript code is intentionally less thorough, approximately 87%. This allows us to iterate more quickly on the JavaScript code, while still covering the core functionality.  [P1-H02] Low unit test coverage  High  Components: all  In the deployment-nicks-method repository, there are no tests at all.  In beam-bootstrap-chain:  Test case file named compute-gas.js only deploys a BeamBootstrap contract and nothing more. It does not compute gas as supposedly intended.  The ForwardTarget and BeamBootstrap contracts have no unit tests.  In policed-contracts, only the Policed contract has tests.  Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.  Consider adding unit tests for every code path. Consider running the tests on every pull request.  Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Ecos statement for this issue in [P1-H01] Missing test coverage reports.  [P1-H03] Outdated ERC820  High  Component: policy  In line 59 of .sol and in line 49 of PolicedUtils.sol, the hard-coded address for the ERC820Registry contract is outdated.  The address used is 0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7.  The correct address is 0x820b586C8C28125366C998641B09DCbE7d4cBF06.  Also, the npm dependency erc820: 0.0.22 is outdated. Moreover, it is set as fixed in the package.json file, so not even minor changes in the versions will be downloaded when users run npm install.  The address and version used correspond to a previous version while the standard was a work in progress. Now, the standard is on the final call, but there is still a chance that a new version will be released and/or that the address will change.  Consider changing the address of the ERC820Registry to point it to the actual one. Consider updating the version of the erc820 package and allowing it to install newer minor versions.  For further reference: https://eips.ethereum.org/EIPS/eip-820  Before deploying to production, confirm that the EIP is final, that the address has not changed, and that the package version used is the latest.  Update: Fixed. The EIP 820 is now final, but the Eco team found and reported an issue to the implementation. A new EIP 1820 was proposed to fix it, and it now supersedes EIP 820. The contracts are now using the upstream implementation of EIP 1820.  Medium Severity  [P1-M01] There are multiple hard-coded constants  Medium  Components: all  Hard-coded booleans, numbers, and strings in the code are hard to understand, and they are prone to error, because after some time, their origin and context can be forgotten or mistaken.  For example:  In deployment-nicks-method:  index.js:L40  In beam-bootstrap-chain:  BeamBootstrap.sol:L17: hard-coded 20  truffle.js:L9: hard-coded address  In policed-contracts:  .sol:L59: hard-coded address  erc820.js:L5: bytecode without comment  erc820.js:L9: hard-coded address  erc820.js:L10: hard-coded address  Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For the complex values, consider adding a comment explaining how they were calculated or why they were chosen.  Update: Fixed. All the hard-coded values mentioned above have been moved to constants, commented, or removed.  [P1-M02] Unit tests are not verifying a single condition  Medium  Components: all  Every unit test should verify a single code path to ensure isolation and to make it easier to blame a single line of code when one of the tests fails. The test structure should follow the four phase pattern, clearly separating the interactions with the system under test from the verification.  Consider splitting the tests to make them fully isolated and as short and focused as possible. Consider following the four phase pattern on each of them. Consider following a data-driven pattern for test cases with multiple scenarios like the abs tests.  Update: Fixed. Many tests have been added with a nice and clean style.  [P1-M03] Solidity optimizations in tests may cause unpredictable behavior  Medium  Components: policy and beam-bootstrap-chain  In beam-bootstrap-chain/truffle.js and policed-contracts/truffle.js, Solidity optimizations are enabled.  Solidity has some optimizations that are default and are always executed, and some others are optional. Enabling the optional ones increases the risk of unexpected behavior, since they are not as battle-tested as the default optimizations. Consider adding full test coverage without optimizations before enabling them to verify that the introduced optimizations preserve expected behavior.  Test coverage  note has been added to the README  Our Solidity test coverage is 98%. While this is slightly less than 100%, were satisfied that it covers the risk introduced by using the Solidity optimizer.  [P1-M04] Overriding initialize is confusing  Medium  Component: proxy  ForwardTarget  contract defines and implements the  initialize  function. Then, the  BeamInitializable contract inherits from  overrides the  initialize  function.  It is not clear if this function is intended to be overridden, but if so, it is not clear why it has an implementation.  Consider documenting the intended use of ForwardTarget as a base class, explaining when and how to override the initialize function. Also, consider commenting on the overriding functions to make it clear that they are not shadowing members from the base class by mistake.  Update: Fixed. A comment has been added to the initialize function to clarify its use.  [P1-M05] Missing zero address checks  Medium  Components: deploy and proxy  The functions that take an address as an argument are not validating that the address is not 0.  For example:  BeamBootstrap.sol:L14  BeamInitializable.sol:L11  ForwardProxy.sol:L13  ForwardTarget.sol:L21  In most cases, passing a 0 address is a mistake.  Consider adding a require statement to check that the address is different from address(0).  Update: Fixed only in EcoBootstrap.sol. Ecos statement for this issue:  Thorough testing prevents our system from mistakenly passing the 0 address when initializing a contract or configuring a proxy. Inserting code to prevent the 0 address from being passed at all also prevents us from doing so intentionally, so as a practice we avoid disallowing the 0 address in code.  [P1-M06] Unclear public cloning functionality  Medium  Component: policy  The PolicedUtils contract includes a public function clone, which according to the docstrings, Creates a clone of this contract by instantiating a proxy at a new address and initializing it based on the current contract [\u2026].  However, the rationale behind including such a functionality is never explained, nor is it clear if the function is supposed to be public and called by anyone.  The single test that attempts to cover the cloning functionality is too vague and poorly documented to understand what is being tested and, more importantly, why. Furthermore, it strangely uses a mock to wrap the clone function inside another cloneMe function, the latter being the one called during the test.  Consider including further tests (while enhancing the existing one) and more thorough documentation regarding the cloning functionality. Moreover, analyze restricting the visibility of the function through custom modifiers if it is not supposed to be called publicly but only by certain privileged accounts.  More documentation has been added to the clone function  test has been improved  [P1-M07] Lack of input validation  Medium  Component: policy  In multiple functions, the values received as arguments are not validated.  In Init.sol:  In the fusedInit function:         Not checking for empty arrays: _setters, _keys, _values, _tokenResolvers     Not checking for zero address: _policyCode     Not checking that uint256(_policycode) is different from the current implementation. Otherwise, implementation might not be actually changed, and fusedInit could be potentially called again.  In .sol:  In the internalCommand function, not checking for zero address: _delegate  In Policed.sol:  In the constructor, not checking for zero address: _policy  In the initialize function, not checking for zero address: _self  In PolicedUtils.sol:  In the initialize function, not checking for zero address: _self  In the setExpectedInterfaceSet function, not checking for zero address: _addr  Consider implementing require clauses where appropriate to validate all user-controlled input.  Update: Only the check for a different implementation has been fixed. Ecos statement for this issue:  The fusedInit function of", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policy", "labels": ["OpenZeppelin"]}, {"title": "contracts have the power to enforce actions over", "body": "contracts have the power to enforce actions over", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#contracts-have-the-power-to-enforce-actions-over", "labels": ["OpenZeppelin"]}, {"title": "Policed", "body": "Policed", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policed", "labels": ["OpenZeppelin"]}, {"title": "contracts (i.e., the latter are managed by the former). This means that", "body": "contracts (i.e., the latter are managed by the former). This means that", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#contracts-(i.e.,-the-latter-are-managed-by-the-former).-this-means-that", "labels": ["OpenZeppelin"]}, {"title": "This enforcement of actions is done via the policyCommand function of the Policed contract, which can only be executed by the managing policy \u2013 this last restriction being enforced by the custom onlyPolicy modifier.", "body": "This enforcement of actions is done via the policyCommand function of the Policed contract, which can only be executed by the managing policy \u2013 this last restriction being enforced by the custom onlyPolicy modifier.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#this-enforcement-of-actions-is-done-via-the-policycommand-function-of-the-policed-contract,-which-can-only-be-executed-by-the-managing-policy-\u2013-this-last-restriction-being-enforced-by-the-custom-onlypolicy-modifier.", "labels": ["OpenZeppelin"]}, {"title": "Given a Policy contract such as:", "body": "Given a Policy contract such as:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#given-a-policy-contract-such-as:", "labels": ["OpenZeppelin"]}, {"title": "And the following contract with some logic that the Policy is going to enforce over the Policed contract:", "body": "And the following contract with some logic that the Policy is going to enforce over the Policed contract:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#and-the-following-contract-with-some-logic-that-the-policy-is-going-to-enforce-over-the-policed-contract:", "labels": ["OpenZeppelin"]}, {"title": "Here is a snippet of the Policed contract showing its state variable policy:", "body": "Here is a snippet of the Policed contract showing its state variable policy:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#here-is-a-snippet-of-the-policed-contract-showing-its-state-variable-policy:", "labels": ["OpenZeppelin"]}, {"title": "A proof of concept of this issue goes as follows:", "body": "A proof of concept of this issue goes as follows:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#a-proof-of-concept-of-this-issue-goes-as-follows:", "labels": ["OpenZeppelin"]}, {"title": "Low-level calls such as delegatecall are always to be implemented with utter care and be thoroughly tested. Strategies to avoid this vulnerability, along with further cases and explanations, can be found at OpenZeppelin SDK documentation on unstructured storage.", "body": "Low-level calls such as delegatecall are always to be implemented with utter care and be thoroughly tested. Strategies to avoid this vulnerability, along with further cases and explanations, can be found at OpenZeppelin SDK documentation on unstructured storage.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#low-level-calls-such-as-delegatecall-are-always-to-be-implemented-with-utter-care-and-be-thoroughly-tested.-strategies-to-avoid-this-vulnerability,-along-with-further-cases-and-explanations,-can-be-found-at-openzeppelin-sdk-documentation-on-unstructured-storage.", "labels": ["OpenZeppelin"]}, {"title": "implementation", "body": "of a Verifiable Delay Function, that is used for the commit and reveal schema needed for the votes.  In the fifth phase, we reviewed all the changes that the Eco team has implemented to fix the vulnerabilities we have reported. We also spent some time analyzing the system as a whole and trying to attack the integration points of all the components.  Finally, one last review of unsolved issues was carried out, in which we updated each report of the five phases with Ecos statements where appropriate. The last reviewed commit of the currency repository is 68adc904.  By now, almost every single member of the OpenZeppelin team has participated in some way on this project. Some have tried very hard to break the system, some have joined discussions to come up with ideas to simplify very complicated operations, some have spent long nights obsessing about deciphering that last line of assembly code\u2026  As we got deeper into the code, we got more engaged with the project. As the Eco team started fixing the problems we were finding, we got stricter and more demanding. By the end, we had collected 8 vulnerabilities of critical severity and 9 vulnerabilities of high severity, along with many less critical issues and multiple suggestions to make the code clearer. Most of them have been successfully fixed by the Eco team by now. As one of our teammates said, it was amazing to see the improvements in the code during this year. Now, they have some of the best contracts we have seen in terms of organization, documentation, and readability.  You can see the reports of the individual phases for extensive details of every vulnerability found and how they have been fixed or mitigated.  Recommendations before releasing to production  Make all the audited repositories public. Parts of the code have been integrated into a single repository, so the old repositories should be deprecated.  Increase the unit test coverage to 100%.  Limit future pull requests to one single and independent change for improved traceability.  Move the documentation of the contracts API from the README files to a documentation website, like the OpenZeppelin Contracts website (which uses solidity-docgen).  Perform an audit to verify the cryptographic strength of the Verifiable Delay Function.  Perform a game theoretic evaluation of the incentives of the system. In particular, note that votes that use a past snapshot of the balances could have perverse incentives. Users may sell their tokens before casting their votes, having nothing at stake when the results are executed. Game-theoretical analysis is a service we have recently started offering at OpenZeppelin, led by Austin Williams.  Start building a community of users and contributors. We recommend the books and resources published by Jono Bacon.  Deploy the full system to testnet.  Design a beta phase with enough incentives for a big and diverse community to participate.  Start a bug bounty program to give real economic incentives to attack the system, even during testing. We recommend the HackerOne platform.  Publish guides explaining how to write new", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#implementation", "labels": ["OpenZeppelin"]}, {"title": "policy", "body": "contracts.  Write automated validators to ensure that new  contracts implement the correct interfaces and will not break the system. You can follow a similar approach to OpenZeppelins ERC20 verifier.  If the Eco token implements the ERC777 standard, the hooks that accounts can execute introduce the risk of reentrancy attacks and can revert operations. Be extremely careful with the transfer of these tokens: Use the checks-effects-interactions pattern, pull payments, reentrancy guards, or execute the transfer without triggering the hooks.  After the upcoming Istanbul fork, the reprice of EIP1884 will affect the implementation of proxy contracts with a payable fallback function. When adding upgrades or new components to the system, use pull payments or the sendValue helper.  Move the BigNumber library to a separate repository. The OpenZeppelin Contracts maintainers might be interested in adding it to the project and co-maintaining it.  Consider adding a Super User module during the first months of production. This will allow for emergency upgrades to the contracts that cannot wait for the Policy vote period. Then, it can be removed when the project has proved to be stable and ready for full decentralization.  Consider using Meta Transactions for easier on-boarding of new users and to allow them to interact with Eco tokens, even if they do not have ether.  JTNDZGl2JTIwY2xhc3MlM0QlMjJidG4tY29udGFpbmVyJTIyJTNFJTBBJTBBJTNDYnV0dG9uJTIwb25jbGljayUzRCUyMmN1c3RvbXNjcm9sbCUyOCUyOSUyMiUzRSUzQ2ElMjBocmVmJTNEJTIyJTIzcGhhc2UtMSUyMiUyMGNsYXNzJTNEJTIyY3VzdG9tLWxpbmslMjIlM0VyZWFkJTIwZnVsbCUyMHJlcG9ydCUzQyUyRmElM0UlM0MlMkZidXR0b24lM0UlMEElMEElM0MlMkZkaXYlM0U=  Phase 1: Deploy, Policy and Proxy  The phase 1 audit was delivered to the Eco team on December 17th, 2018.  The locations and versions used for this report are:  Governance:  Repository 1 [deploy component]: https://github.com/BeamNetwork/deployment-nicks-method\u200a\u200aCommit: 8a8b2d3356db689ae09c6c9bc1affc86f83684f0  Repository 2 [deploy and proxy components]: https://github.com/BeamNetwork/beam-", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policy", "labels": ["OpenZeppelin"]}, {"title": "The unstructured storage approach recommended by OpenZeppelin here does help prevent accidental storage collisions, but at the same time it significantly complicates maintenance and upgrades in the future. Eco\u2019s engineering team has adopted OpenZeppelin\u2019s unstructured storage approach for the core proxy functionality (the implementation slot), but prefers to adopt policies and develop tools to manage the risk for other parts of the system. Specifically, when dealing with the policy slot identified here, we plan to extend our linter rules and thoroughly test upgrades to ensure collisions do not cause problems.", "body": "The unstructured storage approach recommended by OpenZeppelin here does help prevent accidental storage collisions, but at the same time it significantly complicates maintenance and upgrades in the future. Eco\u2019s engineering team has adopted OpenZeppelin\u2019s unstructured storage approach for the core proxy functionality (the implementation slot), but prefers to adopt policies and develop tools to manage the risk for other parts of the system. Specifically, when dealing with the policy slot identified here, we plan to extend our linter rules and thoroughly test upgrades to ensure collisions do not cause problems.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-unstructured-storage-approach-recommended-by-openzeppelin-here-does-help-prevent-accidental-storage-collisions,-but-at-the-same-time-it-significantly-complicates-maintenance-and-upgrades-in-the-future.-eco\u2019s-engineering-team-has-adopted-openzeppelin\u2019s-unstructured-storage-approach-for-the-core-proxy-functionality-(the-implementation-slot),-but-prefers-to-adopt-policies-and-develop-tools-to-manage-the-risk-for-other-parts-of-the-system.-specifically,-when-dealing-with-the-policy-slot-identified-here,-we-plan-to-extend-our-linter-rules-and-thoroughly-test-upgrades-to-ensure-collisions-do-not-cause-problems.", "labels": ["OpenZeppelin"]}, {"title": "[P1-H01] Missing test coverage reports", "body": "[P1-H01] Missing test coverage reports", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-h01]-missing-test-coverage-reports", "labels": ["OpenZeppelin"]}, {"title": "High", "body": "Components: all  There are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.  Consider adding the test coverage reports and making it reach at least 95% of the source code.  Update: Partially fixed. The test coverage report was added to the currency repository, reporting 92% of coverage. Ecos statement for this issue:  Test coverage of our contracts is around 98%. Our overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. Coverage on the JavaScript code is intentionally less thorough, approximately 87%. This allows us to iterate more quickly on the JavaScript code, while still covering the core functionality.  [P1-H02] Low unit test coverage    Components: all  In the deployment-nicks-method repository, there are no tests at all.  In beam-bootstrap-chain:  Test case file named compute-gas.js only deploys a BeamBootstrap contract and nothing more. It does not compute gas as supposedly intended.  The ForwardTarget and BeamBootstrap contracts have no unit tests.  In policed-contracts, only the Policed contract has tests.  Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.  Consider adding unit tests for every code path. Consider running the tests on every pull request.  Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Ecos statement for this issue in [P1-H01] Missing test coverage reports.  [P1-H03] Outdated ERC820", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#high", "labels": ["OpenZeppelin"]}, {"title": "Components: all", "body": "In the deployment-nicks-method repository, there are no tests at all.  In beam-bootstrap-chain:  Test case file named compute-gas.js only deploys a", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#components:-all", "labels": ["OpenZeppelin"]}, {"title": "There are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.", "body": "There are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#there-are-no-test-coverage-reports-on-any-of-the-repositories.-without-these-reports,-it-is-impossible-to-know-whether-there-are-parts-of-the-code-which-are-never-executed-by-the-automated-tests.-for-every-change,-a-full-manual-test-suite-has-to-be-executed-to-make-sure-that-nothing-is-broken-or-misbehaving.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding the test coverage reports and making it reach at least 95% of the source code.", "body": "Consider adding the test coverage reports and making it reach at least 95% of the source code.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-adding-the-test-coverage-reports-and-making-it-reach-at-least-95%-of-the-source-code.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed. The test coverage report was added to the currency repository, reporting 92% of coverage. Eco\u2019s statement for this issue:", "body": "Update: Partially fixed. The test coverage report was added to the currency repository, reporting 92% of coverage. Eco\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-partially-fixed.-the-test-coverage-report-was-added-to-the-currency-repository,-reporting-92%-of-coverage.-eco\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "Test coverage of our contracts is around 98%. Our overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. Coverage on the JavaScript code is intentionally less thorough, approximately 87%. This allows us to iterate more quickly on the JavaScript code, while still covering the core functionality.", "body": "Test coverage of our contracts is around 98%. Our overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. Coverage on the JavaScript code is intentionally less thorough, approximately 87%. This allows us to iterate more quickly on the JavaScript code, while still covering the core functionality.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#test-coverage-of-our-contracts-is-around-98%.-our-overall-coverage-reporting-includes-the-additional-javascript-tooling-included-in-the-repository,-used-for-deployment-and-testing.-coverage-on-the-javascript-code-is-intentionally-less-thorough,-approximately-87%.-this-allows-us-to-iterate-more-quickly-on-the-javascript-code,-while-still-covering-the-core-functionality.", "labels": ["OpenZeppelin"]}, {"title": "[P1-H02] Low unit test coverage", "body": "[P1-H02] Low unit test coverage", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-h02]-low-unit-test-coverage", "labels": ["OpenZeppelin"]}, {"title": "In the deployment-nicks-method repository, there are no tests at all.", "body": "In the deployment-nicks-method repository, there are no tests at all.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-the-deployment-nicks-method-repository,-there-are-no-tests-at-all.", "labels": ["OpenZeppelin"]}, {"title": "In beam-bootstrap-chain:", "body": "In beam-bootstrap-chain:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-beam-bootstrap-chain:", "labels": ["OpenZeppelin"]}, {"title": "Test case file named compute-gas.js only deploys a BeamBootstrap contract and nothing more. It does not compute gas as supposedly intended.", "body": "Test case file named compute-gas.js only deploys a BeamBootstrap contract and nothing more. It does not compute gas as supposedly intended.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#test-case-file-named-compute-gas.js-only-deploys-a-beambootstrap-contract-and-nothing-more.-it-does-not-compute-gas-as-supposedly-intended.", "labels": ["OpenZeppelin"]}, {"title": "The ForwardTarget and BeamBootstrap contracts have no unit tests.", "body": "The ForwardTarget and BeamBootstrap contracts have no unit tests.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-forwardtarget-and-beambootstrap-contracts-have-no-unit-tests.", "labels": ["OpenZeppelin"]}, {"title": "In policed-contracts, only the Policed contract has tests.", "body": "In policed-contracts, only the Policed contract has tests.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policed-contracts,-only-the-policed-contract-has-tests.", "labels": ["OpenZeppelin"]}, {"title": "Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.", "body": "Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#tests-are-the-best-way-to-specify-the-expected-behavior-of-a-system.-automating-these-tests-and-running-them-continuously-pins-down-the-behavior-to-make-sure-that-it-is-not-broken-by-future-changes.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding unit tests for every code path. Consider running the tests on every pull request.", "body": "Consider adding unit tests for every code path. Consider running the tests on every pull request.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-adding-unit-tests-for-every-code-path.-consider-running-the-tests-on-every-pull-request.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Eco\u2019s statement for this issue in [P1-H01] Missing test coverage reports.", "body": "Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Eco\u2019s statement for this issue in [P1-H01] Missing test coverage reports.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-partially-fixed.-extensive-tests-have-been-added-to-the-currency-repository.-however,-it-has-92%-of-test-coverage.-see-eco\u2019s-statement-for-this-issue-in-[p1-h01]-missing-test-coverage-reports.", "labels": ["OpenZeppelin"]}, {"title": "[P1-H03] Outdated ERC820", "body": "[P1-H03] Outdated ERC820", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-h03]-outdated-erc820", "labels": ["OpenZeppelin"]}, {"title": "In line 59 of Policy.sol and in line 49 of PolicedUtils.sol, the hard-coded address for the ERC820Registry contract is outdated.", "body": "In line 59 of Policy.sol and in line 49 of PolicedUtils.sol, the hard-coded address for the ERC820Registry contract is outdated.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-line-59-of-policy.sol-and-in-line-49-of-policedutils.sol,-the-hard-coded-address-for-the-erc820registry-contract-is-outdated.", "labels": ["OpenZeppelin"]}, {"title": "The address used is 0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7.", "body": "The address used is 0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-address-used-is-0x820c4597fc3e4193282576750ea4fcfe34ddf0a7.", "labels": ["OpenZeppelin"]}, {"title": "The correct address is 0x820b586C8C28125366C998641B09DCbE7d4cBF06.", "body": "The correct address is 0x820b586C8C28125366C998641B09DCbE7d4cBF06.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-correct-address-is-0x820b586c8c28125366c998641b09dcbe7d4cbf06.", "labels": ["OpenZeppelin"]}, {"title": "Also, the npm dependency \u201cerc820\u201d: \u201c0.0.22\u201d is outdated. Moreover, it is set as fixed in the package.json file, so not even minor changes in the versions will be downloaded when users run npm install.", "body": "Also, the npm dependency \u201cerc820\u201d: \u201c0.0.22\u201d is outdated. Moreover, it is set as fixed in the package.json file, so not even minor changes in the versions will be downloaded when users run npm install.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#also,-the-npm-dependency-\u201cerc820\u201d:-\u201c0.0.22\u201d-is-outdated.-moreover,-it-is-set-as-fixed-in-the-package.json-file,-so-not-even-minor-changes-in-the-versions-will-be-downloaded-when-users-run-npm-install.", "labels": ["OpenZeppelin"]}, {"title": "The address and version used correspond to a previous version while the standard was a work in progress. Now, the standard is on the final call, but there is still a chance that a new version will be released and/or that the address will change.", "body": "The address and version used correspond to a previous version while the standard was a work in progress. Now, the standard is on the final call, but there is still a chance that a new version will be released and/or that the address will change.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-address-and-version-used-correspond-to-a-previous-version-while-the-standard-was-a-work-in-progress.-now,-the-standard-is-on-the-final-call,-but-there-is-still-a-chance-that-a-new-version-will-be-released-and/or-that-the-address-will-change.", "labels": ["OpenZeppelin"]}, {"title": "Consider changing the address of the ERC820Registry to point it to the actual one. Consider updating the version of the erc820 package and allowing it to install newer minor versions.", "body": "Consider changing the address of the ERC820Registry to point it to the actual one. Consider updating the version of the erc820 package and allowing it to install newer minor versions.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-changing-the-address-of-the-erc820registry-to-point-it-to-the-actual-one.-consider-updating-the-version-of-the-erc820-package-and-allowing-it-to-install-newer-minor-versions.", "labels": ["OpenZeppelin"]}, {"title": "For further reference: https://eips.ethereum.org/EIPS/eip-820", "body": "For further reference: https://eips.ethereum.org/EIPS/eip-820", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#for-further-reference:-https://eips.ethereum.org/eips/eip-820", "labels": ["OpenZeppelin"]}, {"title": "Before deploying to production, confirm that the EIP is final, that the address has not changed, and that the package version used is the latest.", "body": "Before deploying to production, confirm that the EIP is final, that the address has not changed, and that the package version used is the latest.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#before-deploying-to-production,-confirm-that-the-eip-is-final,-that-the-address-has-not-changed,-and-that-the-package-version-used-is-the-latest.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. The EIP 820 is now final, but the Eco team found and reported an issue to the implementation. A new EIP 1820 was proposed to fix it, and it now supersedes EIP 820. The contracts are now using the upstream implementation of EIP 1820.", "body": "Update: Fixed. The EIP 820 is now final, but the Eco team found and reported an issue to the implementation. A new EIP 1820 was proposed to fix it, and it now supersedes EIP 820. The contracts are now using the upstream implementation of EIP 1820.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-the-eip-820-is-now-final,-but-the-eco-team-found-and-reported-an-issue-to-the-implementation.-a-new-eip-1820-was-proposed-to-fix-it,-and-it-now-supersedes-eip-820.-the-contracts-are-now-using-the-upstream-implementation-of-eip-1820.", "labels": ["OpenZeppelin"]}, {"title": "[P1-M01] There are multiple hard-coded constants", "body": "[P1-M01] There are multiple hard-coded constants", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-m01]-there-are-multiple-hard-coded-constants", "labels": ["OpenZeppelin"]}, {"title": "Medium", "body": "Medium", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#medium", "labels": ["OpenZeppelin"]}, {"title": "Hard-coded booleans, numbers, and strings in the code are hard to understand, and they are prone to error, because after some time, their origin and context can be forgotten or mistaken.", "body": "Hard-coded booleans, numbers, and strings in the code are hard to understand, and they are prone to error, because after some time, their origin and context can be forgotten or mistaken.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#hard-coded-booleans,-numbers,-and-strings-in-the-code-are-hard-to-understand,-and-they-are-prone-to-error,-because-after-some-time,-their-origin-and-context-can-be-forgotten-or-mistaken.", "labels": ["OpenZeppelin"]}, {"title": "For example:", "body": "For example:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#for-example:", "labels": ["OpenZeppelin"]}, {"title": "In deployment-nicks-method:", "body": "In deployment-nicks-method:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-deployment-nicks-method:", "labels": ["OpenZeppelin"]}, {"title": "index.js:L40", "body": "index.js:L40", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#index.js:l40", "labels": ["OpenZeppelin"]}, {"title": "BeamBootstrap.sol:L17: hard-coded 20", "body": "BeamBootstrap.sol:L17: hard-coded 20", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beambootstrap.sol:l17:-hard-coded-20", "labels": ["OpenZeppelin"]}, {"title": "truffle.js:L9: hard-coded address", "body": "truffle.js:L9: hard-coded address", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#truffle.js:l9:-hard-coded-address", "labels": ["OpenZeppelin"]}, {"title": "In policed-contracts:", "body": "In policed-contracts:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policed-contracts:", "labels": ["OpenZeppelin"]}, {"title": "Policy.sol:L59: hard-coded address", "body": "Policy.sol:L59: hard-coded address", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policy.sol:l59:-hard-coded-address", "labels": ["OpenZeppelin"]}, {"title": "erc820.js:L5: bytecode without comment", "body": "erc820.js:L5: bytecode without comment", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#erc820.js:l5:-bytecode-without-comment", "labels": ["OpenZeppelin"]}, {"title": "erc820.js:L9: hard-coded address", "body": "erc820.js:L9: hard-coded address", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#erc820.js:l9:-hard-coded-address", "labels": ["OpenZeppelin"]}, {"title": "erc820.js:L10: hard-coded address", "body": "erc820.js:L10: hard-coded address", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#erc820.js:l10:-hard-coded-address", "labels": ["OpenZeppelin"]}, {"title": "Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For the complex values, consider adding a comment explaining how they were calculated or why they were chosen.", "body": "Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For the complex values, consider adding a comment explaining how they were calculated or why they were chosen.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-defining-a-constant-variable-for-every-hard-coded-value,-giving-it-a-clear-and-explanatory-name.-for-the-complex-values,-consider-adding-a-comment-explaining-how-they-were-calculated-or-why-they-were-chosen.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. All the hard-coded values mentioned above have been moved to constants, commented, or removed.", "body": "Update: Fixed. All the hard-coded values mentioned above have been moved to constants, commented, or removed.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-all-the-hard-coded-values-mentioned-above-have-been-moved-to-constants,-commented,-or-removed.", "labels": ["OpenZeppelin"]}, {"title": "[P1-M02] Unit tests are not verifying a single condition", "body": "[P1-M02] Unit tests are not verifying a single condition", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-m02]-unit-tests-are-not-verifying-a-single-condition", "labels": ["OpenZeppelin"]}, {"title": "Every unit test should verify a single code path to ensure isolation and to make it easier to blame a single line of code when one of the tests fails. The test structure should follow the four phase pattern, clearly separating the interactions with the system under test from the verification.", "body": "Every unit test should verify a single code path to ensure isolation and to make it easier to blame a single line of code when one of the tests fails. The test structure should follow the four phase pattern, clearly separating the interactions with the system under test from the verification.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#every-unit-test-should-verify-a-single-code-path-to-ensure-isolation-and-to-make-it-easier-to-blame-a-single-line-of-code-when-one-of-the-tests-fails.-the-test-structure-should-follow-the-four-phase-pattern,-clearly-separating-the-interactions-with-the-system-under-test-from-the-verification.", "labels": ["OpenZeppelin"]}, {"title": "Consider splitting the tests to make them fully isolated and as short and focused as possible. Consider following the four phase pattern on each of them. Consider following a data-driven pattern for test cases with multiple scenarios like the abs tests.", "body": "Consider splitting the tests to make them fully isolated and as short and focused as possible. Consider following the four phase pattern on each of them. Consider following a data-driven pattern for test cases with multiple scenarios like the abs tests.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-splitting-the-tests-to-make-them-fully-isolated-and-as-short-and-focused-as-possible.-consider-following-the-four-phase-pattern-on-each-of-them.-consider-following-a-data-driven-pattern-for-test-cases-with-multiple-scenarios-like-the-abs-tests.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. Many tests have been added with a nice and clean style.", "body": "Update: Fixed. Many tests have been added with a nice and clean style.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-many-tests-have-been-added-with-a-nice-and-clean-style.", "labels": ["OpenZeppelin"]}, {"title": "[P1-M03] Solidity optimizations in tests may cause unpredictable behavior", "body": "[P1-M03] Solidity optimizations in tests may cause unpredictable behavior", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-m03]-solidity-optimizations-in-tests-may-cause-unpredictable-behavior", "labels": ["OpenZeppelin"]}, {"title": "Components: policy and beam-bootstrap-chain", "body": "Components: policy and beam-bootstrap-chain", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#components:-policy-and-beam-bootstrap-chain", "labels": ["OpenZeppelin"]}, {"title": "In beam-bootstrap-chain/truffle.js and policed-contracts/truffle.js, Solidity optimizations are enabled.", "body": "In beam-bootstrap-chain/truffle.js and policed-contracts/truffle.js, Solidity optimizations are enabled.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-beam-bootstrap-chain/truffle.js-and-policed-contracts/truffle.js,-solidity-optimizations-are-enabled.", "labels": ["OpenZeppelin"]}, {"title": "Solidity has some optimizations that are default and are always executed, and some others are optional. Enabling the optional ones increases the risk of unexpected behavior, since they are not as battle-tested as the default optimizations. Consider adding full test coverage without optimizations before enabling them to verify that the introduced optimizations preserve expected behavior.", "body": "Solidity has some optimizations that are default and are always executed, and some others are optional. Enabling the optional ones increases the risk of unexpected behavior, since they are not as battle-tested as the default optimizations. Consider adding full test coverage without optimizations before enabling them to verify that the introduced optimizations preserve expected behavior.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#solidity-has-some-optimizations-that-are-default-and-are-always-executed,-and-some-others-are-optional.-enabling-the-optional-ones-increases-the-risk-of-unexpected-behavior,-since-they-are-not-as-battle-tested-as-the-default-optimizations.-consider-adding-full-test-coverage-without-optimizations-before-enabling-them-to-verify-that-the-introduced-optimizations-preserve-expected-behavior.", "labels": ["OpenZeppelin"]}, {"title": "Test coverage", "body": "Test coverage", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#test-coverage", "labels": ["OpenZeppelin"]}, {"title": "note has been added to the README", "body": "note has been added to the README", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#note-has-been-added-to-the-readme", "labels": ["OpenZeppelin"]}, {"title": "Our Solidity test coverage is 98%. While this is slightly less than 100%, we\u2019re satisfied that it covers the risk introduced by using the Solidity optimizer.", "body": "Our Solidity test coverage is 98%. While this is slightly less than 100%, we\u2019re satisfied that it covers the risk introduced by using the Solidity optimizer.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#our-solidity-test-coverage-is-98%.-while-this-is-slightly-less-than-100%,-we\u2019re-satisfied-that-it-covers-the-risk-introduced-by-using-the-solidity-optimizer.", "labels": ["OpenZeppelin"]}, {"title": "[P1-M04] Overriding initialize is confusing", "body": "[P1-M04] Overriding initialize is confusing", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-m04]-overriding-initialize-is-confusing", "labels": ["OpenZeppelin"]}, {"title": "Component: proxy", "body": "Component: proxy", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#component:-proxy", "labels": ["OpenZeppelin"]}, {"title": "ForwardTarget", "body": "ForwardTarget", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#forwardtarget", "labels": ["OpenZeppelin"]}, {"title": "contract defines and implements the", "body": "contract defines and implements the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#contract-defines-and-implements-the", "labels": ["OpenZeppelin"]}, {"title": "function. Then, the", "body": "function. Then, the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#function.-then,-the", "labels": ["OpenZeppelin"]}, {"title": "BeamInitializable contract inherits from", "body": "BeamInitializable contract inherits from", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beaminitializable-contract-inherits-from", "labels": ["OpenZeppelin"]}, {"title": "overrides the", "body": "overrides the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#overrides-the", "labels": ["OpenZeppelin"]}, {"title": "function.", "body": "function.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#function.", "labels": ["OpenZeppelin"]}, {"title": "It is not clear if this function is intended to be overridden, but if so, it is not clear why it has an implementation.", "body": "It is not clear if this function is intended to be overridden, but if so, it is not clear why it has an implementation.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#it-is-not-clear-if-this-function-is-intended-to-be-overridden,-but-if-so,-it-is-not-clear-why-it-has-an-implementation.", "labels": ["OpenZeppelin"]}, {"title": "Consider documenting the intended use of ForwardTarget as a base class, explaining when and how to override the initialize function. Also, consider commenting on the overriding functions to make it clear that they are not shadowing members from the base class by mistake.", "body": "Consider documenting the intended use of ForwardTarget as a base class, explaining when and how to override the initialize function. Also, consider commenting on the overriding functions to make it clear that they are not shadowing members from the base class by mistake.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-documenting-the-intended-use-of-forwardtarget-as-a-base-class,-explaining-when-and-how-to-override-the-initialize-function.-also,-consider-commenting-on-the-overriding-functions-to-make-it-clear-that-they-are-not-shadowing-members-from-the-base-class-by-mistake.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. A comment has been added to the initialize function to clarify its use.", "body": "Update: Fixed. A comment has been added to the initialize function to clarify its use.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-a-comment-has-been-added-to-the-initialize-function-to-clarify-its-use.", "labels": ["OpenZeppelin"]}, {"title": "[P1-M05] Missing zero address checks", "body": "[P1-M05] Missing zero address checks", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-m05]-missing-zero-address-checks", "labels": ["OpenZeppelin"]}, {"title": "The functions that take an address as an argument are not validating that the address is not 0.", "body": "The functions that take an address as an argument are not validating that the address is not 0.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-functions-that-take-an-address-as-an-argument-are-not-validating-that-the-address-is-not-0.", "labels": ["OpenZeppelin"]}, {"title": "BeamBootstrap.sol:L14", "body": "BeamBootstrap.sol:L14", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beambootstrap.sol:l14", "labels": ["OpenZeppelin"]}, {"title": "BeamInitializable.sol:L11", "body": "BeamInitializable.sol:L11", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beaminitializable.sol:l11", "labels": ["OpenZeppelin"]}, {"title": "ForwardProxy.sol:L13", "body": "ForwardProxy.sol:L13", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#forwardproxy.sol:l13", "labels": ["OpenZeppelin"]}, {"title": "ForwardTarget.sol:L21", "body": "ForwardTarget.sol:L21", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#forwardtarget.sol:l21", "labels": ["OpenZeppelin"]}, {"title": "In most cases, passing a 0 address is a mistake.", "body": "In most cases, passing a 0 address is a mistake.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-most-cases,-passing-a-0-address-is-a-mistake.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a require statement to check that the address is different from address(0).", "body": "Consider adding a require statement to check that the address is different from address(0).", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-adding-a-require-statement-to-check-that-the-address-is-different-from-address(0).", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed only in EcoBootstrap.sol. Eco\u2019s statement for this issue:", "body": "Update: Fixed only in EcoBootstrap.sol. Eco\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed-only-in-ecobootstrap.sol.-eco\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "Thorough testing prevents our system from mistakenly passing the 0 address when initializing a contract or configuring a proxy. Inserting code to prevent the 0 address from being passed at all also prevents us from doing so intentionally, so as a practice we avoid disallowing the 0 address in code.", "body": "Thorough testing prevents our system from mistakenly passing the 0 address when initializing a contract or configuring a proxy. Inserting code to prevent the 0 address from being passed at all also prevents us from doing so intentionally, so as a practice we avoid disallowing the 0 address in code.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#thorough-testing-prevents-our-system-from-mistakenly-passing-the-0-address-when-initializing-a-contract-or-configuring-a-proxy.-inserting-code-to-prevent-the-0-address-from-being-passed-at-all-also-prevents-us-from-doing-so-intentionally,-so-as-a-practice-we-avoid-disallowing-the-0-address-in-code.", "labels": ["OpenZeppelin"]}, {"title": "[P1-M06] Unclear public cloning functionality", "body": "[P1-M06] Unclear public cloning functionality", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-m06]-unclear-public-cloning-functionality", "labels": ["OpenZeppelin"]}, {"title": "The PolicedUtils contract includes a public function clone, which according to the docstrings, \u201cCreates a clone of this contract by instantiating a proxy at a new address and initializing it based on the current contract [\u2026].\u201d", "body": "The PolicedUtils contract includes a public function clone, which according to the docstrings, \u201cCreates a clone of this contract by instantiating a proxy at a new address and initializing it based on the current contract [\u2026].\u201d", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-policedutils-contract-includes-a-public-function-clone,-which-according-to-the-docstrings,-\u201ccreates-a-clone-of-this-contract-by-instantiating-a-proxy-at-a-new-address-and-initializing-it-based-on-the-current-contract-[\u2026].\u201d", "labels": ["OpenZeppelin"]}, {"title": "However, the rationale behind including such a functionality is never explained, nor is it clear if the function is supposed to be public and called by anyone.", "body": "However, the rationale behind including such a functionality is never explained, nor is it clear if the function is supposed to be public and called by anyone.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#however,-the-rationale-behind-including-such-a-functionality-is-never-explained,-nor-is-it-clear-if-the-function-is-supposed-to-be-public-and-called-by-anyone.", "labels": ["OpenZeppelin"]}, {"title": "The single test that attempts to cover the cloning functionality is too vague and poorly documented to understand what is being tested and, more importantly, why. Furthermore, it strangely uses a mock to wrap the clone function inside another cloneMe function, the latter being the one called during the test.", "body": "The single test that attempts to cover the cloning functionality is too vague and poorly documented to understand what is being tested and, more importantly, why. Furthermore, it strangely uses a mock to wrap the clone function inside another cloneMe function, the latter being the one called during the test.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-single-test-that-attempts-to-cover-the-cloning-functionality-is-too-vague-and-poorly-documented-to-understand-what-is-being-tested-and,-more-importantly,-why.-furthermore,-it-strangely-uses-a-mock-to-wrap-the-clone-function-inside-another-cloneme-function,-the-latter-being-the-one-called-during-the-test.", "labels": ["OpenZeppelin"]}, {"title": "Consider including further tests (while enhancing the existing one) and more thorough documentation regarding the cloning functionality. Moreover, analyze restricting the visibility of the function through custom modifiers if it is not supposed to be called publicly but only by certain privileged accounts.", "body": "Consider including further tests (while enhancing the existing one) and more thorough documentation regarding the cloning functionality. Moreover, analyze restricting the visibility of the function through custom modifiers if it is not supposed to be called publicly but only by certain privileged accounts.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-including-further-tests-(while-enhancing-the-existing-one)-and-more-thorough-documentation-regarding-the-cloning-functionality.-moreover,-analyze-restricting-the-visibility-of-the-function-through-custom-modifiers-if-it-is-not-supposed-to-be-called-publicly-but-only-by-certain-privileged-accounts.", "labels": ["OpenZeppelin"]}, {"title": "More documentation has been added to the clone function", "body": "More documentation has been added to the clone function", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#more-documentation-has-been-added-to-the-clone-function", "labels": ["OpenZeppelin"]}, {"title": "test has been improved", "body": "test has been improved", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#test-has-been-improved", "labels": ["OpenZeppelin"]}, {"title": "[P1-M07] Lack of input validation", "body": "[P1-M07] Lack of input validation", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-m07]-lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "In multiple functions, the values received as arguments are not validated.", "body": "In multiple functions, the values received as arguments are not validated.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-multiple-functions,-the-values-received-as-arguments-are-not-validated.", "labels": ["OpenZeppelin"]}, {"title": "In PolicyInit.sol:", "body": "In PolicyInit.sol:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policyinit.sol:", "labels": ["OpenZeppelin"]}, {"title": "In the fusedInit function: ", "body": "In the fusedInit function: ", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-the-fusedinit-function:-", "labels": ["OpenZeppelin"]}, {"title": "   ", "body": "   ", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#---", "labels": ["OpenZeppelin"]}, {"title": "   Not checking for empty arrays: _setters, _keys, _values, _tokenResolvers ", "body": "   Not checking for empty arrays: _setters, _keys, _values, _tokenResolvers ", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#---not-checking-for-empty-arrays:-_setters,-_keys,-_values,-_tokenresolvers-", "labels": ["OpenZeppelin"]}, {"title": "   Not checking for zero address: _policyCode ", "body": "   Not checking for zero address: _policyCode ", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#---not-checking-for-zero-address:-_policycode-", "labels": ["OpenZeppelin"]}, {"title": "   Not checking that uint256(_policycode) is different from the current implementation. Otherwise, implementation might not be actually changed, and fusedInit could be potentially called again.", "body": "   Not checking that uint256(_policycode) is different from the current implementation. Otherwise, implementation might not be actually changed, and fusedInit could be potentially called again.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#---not-checking-that-uint256(_policycode)-is-different-from-the-current-implementation.-otherwise,-implementation-might-not-be-actually-changed,-and-fusedinit-could-be-potentially-called-again.", "labels": ["OpenZeppelin"]}, {"title": "In Policy.sol:", "body": "In Policy.sol:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policy.sol:", "labels": ["OpenZeppelin"]}, {"title": "In the internalCommand function, not checking for zero address: _delegate", "body": "In the internalCommand function, not checking for zero address: _delegate", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-the-internalcommand-function,-not-checking-for-zero-address:-_delegate", "labels": ["OpenZeppelin"]}, {"title": "In Policed.sol:", "body": "In Policed.sol:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policed.sol:", "labels": ["OpenZeppelin"]}, {"title": "In the constructor, not checking for zero address: _policy", "body": "In the constructor, not checking for zero address: _policy", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-the-constructor,-not-checking-for-zero-address:-_policy", "labels": ["OpenZeppelin"]}, {"title": "In the initialize function, not checking for zero address: _self", "body": "In the initialize function, not checking for zero address: _self", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-the-initialize-function,-not-checking-for-zero-address:-_self", "labels": ["OpenZeppelin"]}, {"title": "In PolicedUtils.sol:", "body": "In PolicedUtils.sol:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policedutils.sol:", "labels": ["OpenZeppelin"]}, {"title": "In the setExpectedInterfaceSet function, not checking for zero address: _addr", "body": "In the setExpectedInterfaceSet function, not checking for zero address: _addr", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-the-setexpectedinterfaceset-function,-not-checking-for-zero-address:-_addr", "labels": ["OpenZeppelin"]}, {"title": "Consider implementing require clauses where appropriate to validate all user-controlled input.", "body": "Consider implementing require clauses where appropriate to validate all user-controlled input.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-implementing-require-clauses-where-appropriate-to-validate-all-user-controlled-input.", "labels": ["OpenZeppelin"]}, {"title": "Update: Only the check for a different implementation has been fixed. Eco\u2019s statement for this issue:", "body": "Update: Only the check for a different implementation has been fixed. Eco\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-only-the-check-for-a-different-implementation-has-been-fixed.-eco\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "The fusedInit function of PolicyInit is only called by our own code during deployment and immediately disabled, so we\u2019re not concerned about invalid inputs. Policy, Policed, and PolicedUtils are library contracts that are built on top of our contracts. User-provided addresses are never passed to the functions described, so we\u2019re not concerned about accidental 0 address values.", "body": "The fusedInit function of PolicyInit is only called by our own code during deployment and immediately disabled, so we\u2019re not concerned about invalid inputs. Policy, Policed, and PolicedUtils are library contracts that are built on top of our contracts. User-provided addresses are never passed to the functions described, so we\u2019re not concerned about accidental 0 address values.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-fusedinit-function-of-policyinit-is-only-called-by-our-own-code-during-deployment-and-immediately-disabled,-so-we\u2019re-not-concerned-about-invalid-inputs.-policy,-policed,-and-policedutils-are-library-contracts-that-are-built-on-top-of-our-contracts.-user-provided-addresses-are-never-passed-to-the-functions-described,-so-we\u2019re-not-concerned-about-accidental-0-address-values.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L01] README empty or missing important information", "body": "[P1-L01] README empty or missing important information", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l01]-readme-empty-or-missing-important-information", "labels": ["OpenZeppelin"]}, {"title": "Low", "body": "unit test coverage  High  Components: all  In the deployment-nicks-method repository, there are no tests at all.  In beam-bootstrap-chain:  Test case file named compute-gas.js only deploys a BeamBootstrap contract and nothing more. It does not compute gas as supposedly intended.  The ForwardTarget and BeamBootstrap contracts have no unit tests.  In policed-contracts, only the Policed contract has tests.  Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.  Consider adding unit tests for every code path. Consider running the tests on every pull request.  Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Ecos statement for this issue in [P1-H01] Missing test coverage reports.  [P1-H03] Outdated ERC820  High", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#low", "labels": ["OpenZeppelin"]}, {"title": "The README.md on the root of the GitHub repositories are the first documents that most developers will read, so they should be complete, clear, concise, and accurate.", "body": "The README.md on the root of the GitHub repositories are the first documents that most developers will read, so they should be complete, clear, concise, and accurate.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-readme.md-on-the-root-of-the-github-repositories-are-the-first-documents-that-most-developers-will-read,-so-they-should-be-complete,-clear,-concise,-and-accurate.", "labels": ["OpenZeppelin"]}, {"title": "The README.md files of deployment-nicks-method, beam-bootstrap-chain and\u00a0 policed-contracts, have little or no information about what the purpose of the project is nor how to use it.", "body": "The README.md files of deployment-nicks-method, beam-bootstrap-chain and\u00a0 policed-contracts, have little or no information about what the purpose of the project is nor how to use it.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-readme.md-files-of-deployment-nicks-method,-beam-bootstrap-chain-and\u00a0-policed-contracts,-have-little-or-no-information-about-what-the-purpose-of-the-project-is-nor-how-to-use-it.", "labels": ["OpenZeppelin"]}, {"title": "In beam-bootstrap-chain, it describes a set of instructions to create a bootstrap transaction without the needed context to understand it, including a command named generate-portable-transaction, which is not available. A a sample of the output file used in the example bootstrap-truffle.json is also not available.", "body": "In beam-bootstrap-chain, it describes a set of instructions to create a bootstrap transaction without the needed context to understand it, including a command named generate-portable-transaction, which is not available. A a sample of the output file used in the example bootstrap-truffle.json is also not available.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-beam-bootstrap-chain,-it-describes-a-set-of-instructions-to-create-a-bootstrap-transaction-without-the-needed-context-to-understand-it,-including-a-command-named-generate-portable-transaction,-which-is-not-available.-a-a-sample-of-the-output-file-used-in-the-example-bootstrap-truffle.json-is-also-not-available.", "labels": ["OpenZeppelin"]}, {"title": "Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of each repository, the usage workflows, the public APIs, instructions to test and deploy them independently, and how they relate to the other repositories in the Beam project.", "body": "Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of each repository, the usage workflows, the public APIs, instructions to test and deploy them independently, and how they relate to the other repositories in the Beam project.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-following-standard-readme-to-define-the-structure-and-contents-for-the-readme.md-file.-consider-including-an-explanation-of-the-core-concepts-of-each-repository,-the-usage-workflows,-the-public-apis,-instructions-to-test-and-deploy-them-independently,-and-how-they-relate-to-the-other-repositories-in-the-beam-project.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. All repositories and some sub-directories now have good README files.", "body": "Update: Fixed. All repositories and some sub-directories now have good README files.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-all-repositories-and-some-sub-directories-now-have-good-readme-files.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L02] Missing comments on the code and comments not following NatSpec", "body": "[P1-L02] Missing comments on the code and comments not following NatSpec", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l02]-missing-comments-on-the-code-and-comments-not-following-natspec", "labels": ["OpenZeppelin"]}, {"title": "In the beam-bootstrap-chain and\u00a0 policed-contracts repositories, there are some contracts, struct fields, state variables, mapping keys, functions and parameters without comments, some with comments that do not follow the NatSpec format, and some that are missing important details on their comments.", "body": "In the beam-bootstrap-chain and\u00a0 policed-contracts repositories, there are some contracts, struct fields, state variables, mapping keys, functions and parameters without comments, some with comments that do not follow the NatSpec format, and some that are missing important details on their comments.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-the-beam-bootstrap-chain-and\u00a0-policed-contracts-repositories,-there-are-some-contracts,-struct-fields,-state-variables,-mapping-keys,-functions-and-parameters-without-comments,-some-with-comments-that-do-not-follow-the-natspec-format,-and-some-that-are-missing-important-details-on-their-comments.", "labels": ["OpenZeppelin"]}, {"title": "In the deployment-nicks-method repository, there are no comments at all.", "body": "In the deployment-nicks-method repository, there are no comments at all.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-the-deployment-nicks-method-repository,-there-are-no-comments-at-all.", "labels": ["OpenZeppelin"]}, {"title": "This makes it hard to understand the code and to review that the implemented functionality matches the intended behavior.", "body": "This makes it hard to understand the code and to review that the implemented functionality matches the intended behavior.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#this-makes-it-hard-to-understand-the-code-and-to-review-that-the-implemented-functionality-matches-the-intended-behavior.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding docstrings for all contracts, struct fields, state variables, mapping keys, and functions, paying particular attention to the ones that represent complicated concepts. Consider following the NatSpec format thoroughly for docstrings to improve documentation and code legibility.", "body": "Consider adding docstrings for all contracts, struct fields, state variables, mapping keys, and functions, paying particular attention to the ones that represent complicated concepts. Consider following the NatSpec format thoroughly for docstrings to improve documentation and code legibility.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-adding-docstrings-for-all-contracts,-struct-fields,-state-variables,-mapping-keys,-and-functions,-paying-particular-attention-to-the-ones-that-represent-complicated-concepts.-consider-following-the-natspec-format-thoroughly-for-docstrings-to-improve-documentation-and-code-legibility.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. Many comments have been added to all the contracts. Most of them exhaustively document the parameters and strictly follow the NatSpec format.", "body": "Update: Fixed. Many comments have been added to all the contracts. Most of them exhaustively document the parameters and strictly follow the NatSpec format.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-many-comments-have-been-added-to-all-the-contracts.-most-of-them-exhaustively-document-the-parameters-and-strictly-follow-the-natspec-format.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L03] Not following consistent code style", "body": "[P1-L03] Not following consistent code style", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l03]-not-following-consistent-code-style", "labels": ["OpenZeppelin"]}, {"title": "A consistent code style is essential to make the code base clear and readable and to make it possible to combine contributions from wildly diverse people, as is the case in open source projects.", "body": "A consistent code style is essential to make the code base clear and readable and to make it possible to combine contributions from wildly diverse people, as is the case in open source projects.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#a-consistent-code-style-is-essential-to-make-the-code-base-clear-and-readable-and-to-make-it-possible-to-combine-contributions-from-wildly-diverse-people,-as-is-the-case-in-open-source-projects.", "labels": ["OpenZeppelin"]}, {"title": "Consider making every file in the project follow the documented code style guide and enforce that every new contribution sticks to this code style by adding a linter check that runs on every pull request.", "body": "Consider making every file in the project follow the documented code style guide and enforce that every new contribution sticks to this code style by adding a linter check that runs on every pull request.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-making-every-file-in-the-project-follow-the-documented-code-style-guide-and-enforce-that-every-new-contribution-sticks-to-this-code-style-by-adding-a-linter-check-that-runs-on-every-pull-request.", "labels": ["OpenZeppelin"]}, {"title": "Note that eslint does not enable any rules by default, so at least, the recommended rules should be added to the configuration file.", "body": "Note that eslint does not enable any rules by default, so at least, the recommended rules should be added to the configuration file.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#note-that-eslint-does-not-enable-any-rules-by-default,-so-at-least,-the-recommended-rules-should-be-added-to-the-configuration-file.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. The two repositories now follow a consistent code style and have rules and tasks for running solhint and eslint.", "body": "Update: Fixed. The two repositories now follow a consistent code style and have rules and tasks for running solhint and eslint.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-the-two-repositories-now-follow-a-consistent-code-style-and-have-rules-and-tasks-for-running-solhint-and-eslint.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L04] Functions can be made external to clarify intended use", "body": "[P1-L04] Functions can be made external to clarify intended use", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l04]-functions-can-be-made-external-to-clarify-intended-use", "labels": ["OpenZeppelin"]}, {"title": "BeamBootstrap", "body": "contract and nothing more. It does not compute gas as supposedly intended.  The ForwardTarget and  contracts have no unit tests.  In policed-contracts, only the Policed contract has tests.  Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.  Consider adding unit tests for every code path. Consider running the tests on every pull request.  Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Ecos statement for this issue in [P1-H01] Missing test coverage reports.  [P1-H03] Outdated ERC820  High  Component: policy  In line 59 of Policy.sol and in line 49 of PolicedUtils.sol, the hard-coded address for the ERC820Registry contract is outdated.  The address used is 0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7.  The correct address is 0x820b586C8C28125366C998641B09DCbE7d4cBF06.  Also, the npm dependency erc820: 0.0.22 is outdated. Moreover, it is set as fixed in the package.json file, so not even minor changes in the versions will be downloaded when users run npm install.  The address and version used correspond to a previous version while the standard was a work in progress. Now, the standard is on the final call, but there is still a chance that a new version will be released and/or that the address will change.  Consider changing the address of the ERC820Registry to point it to the actual one. Consider updating the version of the erc820 package and allowing it to install newer minor versions.  For further reference: https://eips.ethereum.org/EIPS/eip-820  Before deploying to production, confirm that the EIP is final, that the address has not changed, and that the package version used is the latest.  Update: Fixed. The EIP 820 is now final, but the Eco team found and reported an issue to the implementation. A new EIP 1820 was proposed to fix it, and it now supersedes EIP 820. The contracts are now using the upstream implementation of EIP 1820.  Medium Severity  [P1-M01] There are multiple hard-coded constants  Medium  Components: all  Hard-coded booleans, numbers, and strings in the code are hard to understand, and they are prone to error, because after some time, their origin and context can be forgotten or mistaken.  For example:  In deployment-nicks-method:  index.js:L40  In beam-bootstrap-chain:  .sol:L17: hard-coded 20  truffle.js:L9: hard-coded address  In policed-contracts:  Policy.sol:L59: hard-coded address  erc820.js:L5: bytecode without comment  erc820.js:L9: hard-coded address  erc820.js:L10: hard-coded address  Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For the complex values, consider adding a comment explaining how they were calculated or why they were chosen.  Update: Fixed. All the hard-coded values mentioned above have been moved to constants, commented, or removed.  [P1-M02] Unit tests are not verifying a single condition  Medium  Components: all  Every unit test should verify a single code path to ensure isolation and to make it easier to blame a single line of code when one of the tests fails. The test structure should follow the four phase pattern, clearly separating the interactions with the system under test from the verification.  Consider splitting the tests to make them fully isolated and as short and focused as possible. Consider following the four phase pattern on each of them. Consider following a data-driven pattern for test cases with multiple scenarios like the abs tests.  Update: Fixed. Many tests have been added with a nice and clean style.  [P1-M03] Solidity optimizations in tests may cause unpredictable behavior  Medium  Components: policy and beam-bootstrap-chain  In beam-bootstrap-chain/truffle.js and policed-contracts/truffle.js, Solidity optimizations are enabled.  Solidity has some optimizations that are default and are always executed, and some others are optional. Enabling the optional ones increases the risk of unexpected behavior, since they are not as battle-tested as the default optimizations. Consider adding full test coverage without optimizations before enabling them to verify that the introduced optimizations preserve expected behavior.  Test coverage  note has been added to the README  Our Solidity test coverage is 98%. While this is slightly less than 100%, were satisfied that it covers the risk introduced by using the Solidity optimizer.  [P1-M04] Overriding initialize is confusing  Medium  Component: proxy  ForwardTarget  contract defines and implements the  initialize  function. Then, the  BeamInitializable contract inherits from  overrides the  initialize  function.  It is not clear if this function is intended to be overridden, but if so, it is not clear why it has an implementation.  Consider documenting the intended use of ForwardTarget as a base class, explaining when and how to override the initialize function. Also, consider commenting on the overriding functions to make it clear that they are not shadowing members from the base class by mistake.  Update: Fixed. A comment has been added to the initialize function to clarify its use.  [P1-M05] Missing zero address checks  Medium  Components: deploy and proxy  The functions that take an address as an argument are not validating that the address is not 0.  For example:  .sol:L14  BeamInitializable.sol:L11  ForwardProxy.sol:L13  ForwardTarget.sol:L21  In most cases, passing a 0 address is a mistake.  Consider adding a require statement to check that the address is different from address(0).  Update: Fixed only in EcoBootstrap.sol. Ecos statement for this issue:  Thorough testing prevents our system from mistakenly passing the 0 address when initializing a contract or configuring a proxy. Inserting code to prevent the 0 address from being passed at all also prevents us from doing so intentionally, so as a practice we avoid disallowing the 0 address in code.  [P1-M06] Unclear public cloning functionality  Medium  Component: policy  The PolicedUtils contract includes a public function clone, which according to the docstrings, Creates a clone of this contract by instantiating a proxy at a new address and initializing it based on the current contract [\u2026].  However, the rationale behind including such a functionality is never explained, nor is it clear if the function is supposed to be public and called by anyone.  The single test that attempts to cover the cloning functionality is too vague and poorly documented to understand what is being tested and, more importantly, why. Furthermore, it strangely uses a mock to wrap the clone function inside another cloneMe function, the latter being the one called during the test.  Consider including further tests (while enhancing the existing one) and more thorough documentation regarding the cloning functionality. Moreover, analyze restricting the visibility of the function through custom modifiers if it is not supposed to be called publicly but only by certain privileged accounts.  More documentation has been added to the clone function  test has been improved  [P1-M07] Lack of input validation  Medium  Component: policy  In multiple functions, the values received as arguments are not validated.  In PolicyInit.sol:  In the fusedInit function:         Not checking for empty arrays: _setters, _keys, _values, _tokenResolvers     Not checking for zero address: _policyCode     Not checking that uint256(_policycode) is different from the current implementation. Otherwise, implementation might not be actually changed, and fusedInit could be potentially called again.  In Policy.sol:  In the internalCommand function, not checking for zero address: _delegate  In Policed.sol:  In the constructor, not checking for zero address: _policy  In the initialize function, not checking for zero address: _self  In PolicedUtils.sol:  In the initialize function, not checking for zero address: _self  In the setExpectedInterfaceSet function, not checking for zero address: _addr  Consider implementing require clauses where appropriate to validate all user-controlled input.  Update: Only the check for a different implementation has been fixed. Ecos statement for this issue:  The fusedInit function of PolicyInit is only called by our own code during deployment and immediately disabled, so were not concerned about invalid inputs. Policy, Policed, and PolicedUtils are library contracts that are built on top of our contracts. User-provided addresses are never passed to the functions described, so were not concerned about accidental 0 address values.  Low Severity  [P1-L01] README empty or missing important information  Low  Components: all  The README.md on the root of the GitHub repositories are the first documents that most developers will read, so they should be complete, clear, concise, and accurate.  The README.md files of deployment-nicks-method, beam-bootstrap-chain and  policed-contracts, have little or no information about what the purpose of the project is nor how to use it.  In beam-bootstrap-chain, it describes a set of instructions to create a bootstrap transaction without the needed context to understand it, including a command named generate-portable-transaction, which is not available. A a sample of the output file used in the example bootstrap-truffle.json is also not available.  Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of each repository, the usage workflows, the public APIs, instructions to test and deploy them independently, and how they relate to the other repositories in the Beam project.  Update: Fixed. All repositories and some sub-directories now have good README files.  [P1-L02] Missing comments on the code and comments not following NatSpec  Low  Components: all  In the beam-bootstrap-chain and  policed-contracts repositories, there are some contracts, struct fields, state variables, mapping keys, functions and parameters without comments, some with comments that do not follow the NatSpec format, and some that are missing important details on their comments.  In the deployment-nicks-method repository, there are no comments at all.  This makes it hard to understand the code and to review that the implemented functionality matches the intended behavior.  Consider adding docstrings for all contracts, struct fields, state variables, mapping keys, and functions, paying particular attention to the ones that represent complicated concepts. Consider following the NatSpec format thoroughly for docstrings to improve documentation and code legibility.  Update: Fixed. Many comments have been added to all the contracts. Most of them exhaustively document the parameters and strictly follow the NatSpec format.  [P1-L03] Not following consistent code style  Low  Components: all  A consistent code style is essential to make the code base clear and readable and to make it possible to combine contributions from wildly diverse people, as is the case in open source projects.  Consider making every file in the project follow the documented code style guide and enforce that every new contribution sticks to this code style by adding a linter check that runs on every pull request.  Note that eslint does not enable any rules by default, so at least, the recommended rules should be added to the configuration file.  Update: Fixed. The two repositories now follow a consistent code style and have rules and tasks for running solhint and eslint.  [P1-L04] Functions can be made external to clarify intended use  Low  Components: all    s  cleanup,  BeamInitializable", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beambootstrap", "labels": ["OpenZeppelin"]}, {"title": "\u2018s", "body": "\u2018s", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#\u2018s", "labels": ["OpenZeppelin"]}, {"title": "cleanup,", "body": "cleanup,", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#cleanup,", "labels": ["OpenZeppelin"]}, {"title": "BeamInitializable", "body": "contract also uses an ownership pattern, which allows only the owner to set the implementation that will be delegated from the proxy and to selfdestruct the contract.  The issue here is that the initialize function is public. It does not have a restriction that only the owner can call, and it can be called more than once.  For an attacker to hijack the entire Bootstrap process, it would only require them to deploy a malicious contract like this:  They can also get ownership of the original  contract, but that does not seem to give them any gain.  Test case: https://gist.github.com/mattaereal/9a7fe9d20b3c3253b1effe049cb9211e  Consider requiring that only the owner can call the initialize function, thus making it possible to call it only once during initialization with the onlyConstruction modifier.  destruct  initialize  [P1-C02] Storage collision on Policed contract  Critical  Component: policy  Policy  contracts have the power to enforce actions over  Policed  contracts (i.e., the latter are managed by the former). This means that  This enforcement of actions is done via the policyCommand function of the Policed contract, which can only be executed by the managing policy  this last restriction being enforced by the custom onlyPolicy modifier.  Given a Policy contract such as:  And the following contract with some logic that the Policy is going to enforce over the Policed contract:  Here is a snippet of the Policed contract showing its state variable policy:  A proof of concept of this issue goes as follows:  Low-level calls such as delegatecall are always to be implemented with utter care and be thoroughly tested. Strategies to avoid this vulnerability, along with further cases and explanations, can be found at OpenZeppelin SDK documentation on unstructured storage.  implementation  policy  The unstructured storage approach recommended by OpenZeppelin here does help prevent accidental storage collisions, but at the same time it significantly complicates maintenance and upgrades in the future. Ecos engineering team has adopted OpenZeppelins unstructured storage approach for the core proxy functionality (the implementation slot), but prefers to adopt policies and develop tools to manage the risk for other parts of the system. Specifically, when dealing with the policy slot identified here, we plan to extend our linter rules and thoroughly test upgrades to ensure collisions do not cause problems.  High Severity  [P1-H01] Missing test coverage reports  High  Components: all  There are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.  Consider adding the test coverage reports and making it reach at least 95% of the source code.  Update: Partially fixed. The test coverage report was added to the currency repository, reporting 92% of coverage. Ecos statement for this issue:  Test coverage of our contracts is around 98%. Our overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. Coverage on the JavaScript code is intentionally less thorough, approximately 87%. This allows us to iterate more quickly on the JavaScript code, while still covering the core functionality.  [P1-H02] Low unit test coverage  High  Components: all  In the deployment-nicks-method repository, there are no tests at all.  In beam-bootstrap-chain:  Test case file named compute-gas.js only deploys a BeamBootstrap contract and nothing more. It does not compute gas as supposedly intended.  The ForwardTarget and BeamBootstrap contracts have no unit tests.  In policed-contracts, only the Policed contract has tests.  Tests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.  Consider adding unit tests for every code path. Consider running the tests on every pull request.  Update: Partially fixed. Extensive tests have been added to the currency repository. However, it has 92% of test coverage. See Ecos statement for this issue in [P1-H01] Missing test coverage reports.  [P1-H03] Outdated ERC820  High  Component: policy  In line 59 of Policy.sol and in line 49 of PolicedUtils.sol, the hard-coded address for the ERC820Registry contract is outdated.  The address used is 0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7.  The correct address is 0x820b586C8C28125366C998641B09DCbE7d4cBF06.  Also, the npm dependency erc820: 0.0.22 is outdated. Moreover, it is set as fixed in the package.json file, so not even minor changes in the versions will be downloaded when users run npm install.  The address and version used correspond to a previous version while the standard was a work in progress. Now, the standard is on the final call, but there is still a chance that a new version will be released and/or that the address will change.  Consider changing the address of the ERC820Registry to point it to the actual one. Consider updating the version of the erc820 package and allowing it to install newer minor versions.  For further reference: https://eips.ethereum.org/EIPS/eip-820  Before deploying to production, confirm that the EIP is final, that the address has not changed, and that the package version used is the latest.  Update: Fixed. The EIP 820 is now final, but the Eco team found and reported an issue to the implementation. A new EIP 1820 was proposed to fix it, and it now supersedes EIP 820. The contracts are now using the upstream implementation of EIP 1820.  Medium Severity  [P1-M01] There are multiple hard-coded constants  Medium  Components: all  Hard-coded booleans, numbers, and strings in the code are hard to understand, and they are prone to error, because after some time, their origin and context can be forgotten or mistaken.  For example:  In deployment-nicks-method:  index.js:L40  In beam-bootstrap-chain:  BeamBootstrap.sol:L17: hard-coded 20  truffle.js:L9: hard-coded address  In policed-contracts:  Policy.sol:L59: hard-coded address  erc820.js:L5: bytecode without comment  erc820.js:L9: hard-coded address  erc820.js:L10: hard-coded address  Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For the complex values, consider adding a comment explaining how they were calculated or why they were chosen.  Update: Fixed. All the hard-coded values mentioned above have been moved to constants, commented, or removed.  [P1-M02] Unit tests are not verifying a single condition  Medium  Components: all  Every unit test should verify a single code path to ensure isolation and to make it easier to blame a single line of code when one of the tests fails. The test structure should follow the four phase pattern, clearly separating the interactions with the system under test from the verification.  Consider splitting the tests to make them fully isolated and as short and focused as possible. Consider following the four phase pattern on each of them. Consider following a data-driven pattern for test cases with multiple scenarios like the abs tests.  Update: Fixed. Many tests have been added with a nice and clean style.  [P1-M03] Solidity optimizations in tests may cause unpredictable behavior  Medium  Components: policy and beam-bootstrap-chain  In beam-bootstrap-chain/truffle.js and policed-contracts/truffle.js, Solidity optimizations are enabled.  Solidity has some optimizations that are default and are always executed, and some others are optional. Enabling the optional ones increases the risk of unexpected behavior, since they are not as battle-tested as the default optimizations. Consider adding full test coverage without optimizations before enabling them to verify that the introduced optimizations preserve expected behavior.  Test coverage  note has been added to the README  Our Solidity test coverage is 98%. While this is slightly less than 100%, were satisfied that it covers the risk introduced by using the Solidity optimizer.  [P1-M04] Overriding initialize is confusing  Medium  Component: proxy  ForwardTarget  contract defines and implements the  initialize  function. Then, the   contract inherits from  overrides the  initialize  function.  It is not clear if this function is intended to be overridden, but if so, it is not clear why it has an implementation.  Consider documenting the intended use of ForwardTarget as a base class, explaining when and how to override the initialize function. Also, consider commenting on the overriding functions to make it clear that they are not shadowing members from the base class by mistake.  Update: Fixed. A comment has been added to the initialize function to clarify its use.  [P1-M05] Missing zero address checks  Medium  Components: deploy and proxy  The functions that take an address as an argument are not validating that the address is not 0.  For example:  BeamBootstrap.sol:L14  .sol:L11  ForwardProxy.sol:L13  ForwardTarget.sol:L21  In most cases, passing a 0 address is a mistake.  Consider adding a require statement to check that the address is different from address(0).  Update: Fixed only in EcoBootstrap.sol. Ecos statement for this issue:  Thorough testing prevents our system from mistakenly passing the 0 address when initializing a contract or configuring a proxy. Inserting code to prevent the 0 address from being passed at all also prevents us from doing so intentionally, so as a practice we avoid disallowing the 0 address in code.  [P1-M06] Unclear public cloning functionality  Medium  Component: policy  The PolicedUtils contract includes a public function clone, which according to the docstrings, Creates a clone of this contract by instantiating a proxy at a new address and initializing it based on the current contract [\u2026].  However, the rationale behind including such a functionality is never explained, nor is it clear if the function is supposed to be public and called by anyone.  The single test that attempts to cover the cloning functionality is too vague and poorly documented to understand what is being tested and, more importantly, why. Furthermore, it strangely uses a mock to wrap the clone function inside another cloneMe function, the latter being the one called during the test.  Consider including further tests (while enhancing the existing one) and more thorough documentation regarding the cloning functionality. Moreover, analyze restricting the visibility of the function through custom modifiers if it is not supposed to be called publicly but only by certain privileged accounts.  More documentation has been added to the clone function  test has been improved  [P1-M07] Lack of input validation  Medium  Component: policy  In multiple functions, the values received as arguments are not validated.  In PolicyInit.sol:  In the fusedInit function:         Not checking for empty arrays: _setters, _keys, _values, _tokenResolvers     Not checking for zero address: _policyCode     Not checking that uint256(_policycode) is different from the current implementation. Otherwise, implementation might not be actually changed, and fusedInit could be potentially called again.  In Policy.sol:  In the internalCommand function, not checking for zero address: _delegate  In Policed.sol:  In the constructor, not checking for zero address: _policy  In the initialize function, not checking for zero address: _self  In PolicedUtils.sol:  In the initialize function, not checking for zero address: _self  In the setExpectedInterfaceSet function, not checking for zero address: _addr  Consider implementing require clauses where appropriate to validate all user-controlled input.  Update: Only the check for a different implementation has been fixed. Ecos statement for this issue:  The fusedInit function of PolicyInit is only called by our own code during deployment and immediately disabled, so were not concerned about invalid inputs. Policy, Policed, and PolicedUtils are library contracts that are built on top of our contracts. User-provided addresses are never passed to the functions described, so were not concerned about accidental 0 address values.  Low Severity  [P1-L01] README empty or missing important information  Low  Components: all  The README.md on the root of the GitHub repositories are the first documents that most developers will read, so they should be complete, clear, concise, and accurate.  The README.md files of deployment-nicks-method, beam-bootstrap-chain and  policed-contracts, have little or no information about what the purpose of the project is nor how to use it.  In beam-bootstrap-chain, it describes a set of instructions to create a bootstrap transaction without the needed context to understand it, including a command named generate-portable-transaction, which is not available. A a sample of the output file used in the example bootstrap-truffle.json is also not available.  Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of each repository, the usage workflows, the public APIs, instructions to test and deploy them independently, and how they relate to the other repositories in the Beam project.  Update: Fixed. All repositories and some sub-directories now have good README files.  [P1-L02] Missing comments on the code and comments not following NatSpec  Low  Components: all  In the beam-bootstrap-chain and  policed-contracts repositories, there are some contracts, struct fields, state variables, mapping keys, functions and parameters without comments, some with comments that do not follow the NatSpec format, and some that are missing important details on their comments.  In the deployment-nicks-method repository, there are no comments at all.  This makes it hard to understand the code and to review that the implemented functionality matches the intended behavior.  Consider adding docstrings for all contracts, struct fields, state variables, mapping keys, and functions, paying particular attention to the ones that represent complicated concepts. Consider following the NatSpec format thoroughly for docstrings to improve documentation and code legibility.  Update: Fixed. Many comments have been added to all the contracts. Most of them exhaustively document the parameters and strictly follow the NatSpec format.  [P1-L03] Not following consistent code style  Low  Components: all  A consistent code style is essential to make the code base clear and readable and to make it possible to combine contributions from wildly diverse people, as is the case in open source projects.  Consider making every file in the project follow the documented code style guide and enforce that every new contribution sticks to this code style by adding a linter check that runs on every pull request.  Note that eslint does not enable any rules by default, so at least, the recommended rules should be added to the configuration file.  Update: Fixed. The two repositories now follow a consistent code style and have rules and tasks for running solhint and eslint.  [P1-L04] Functions can be made external to clarify intended use  Low  Components: all  BeamBootstrap  s  cleanup,", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beaminitializable", "labels": ["OpenZeppelin"]}, {"title": "cleanup, and", "body": "cleanup, and", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#cleanup,-and", "labels": ["OpenZeppelin"]}, {"title": "setImplementation are never called internally.", "body": "setImplementation are never called internally.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#setimplementation-are-never-called-internally.", "labels": ["OpenZeppelin"]}, {"title": "In policed-contracts, policyFor is never called internally.", "body": "In policed-contracts, policyFor is never called internally.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policed-contracts,-policyfor-is-never-called-internally.", "labels": ["OpenZeppelin"]}, {"title": "Consider making the functions external to clarify intended use. If they should be public, consider documenting the reason and intended use from inside the contracts.", "body": "Consider making the functions external to clarify intended use. If they should be public, consider documenting the reason and intended use from inside the contracts.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-making-the-functions-external-to-clarify-intended-use.-if-they-should-be-public,-consider-documenting-the-reason-and-intended-use-from-inside-the-contracts.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed.", "body": "Update: Fixed.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L05] Undocumented assembly code", "body": "[P1-L05] Undocumented assembly code", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l05]-undocumented-assembly-code", "labels": ["OpenZeppelin"]}, {"title": "Components: policy, deploy, and proxy", "body": "Components: policy, deploy, and proxy", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#components:-policy,-deploy,-and-proxy", "labels": ["OpenZeppelin"]}, {"title": "fallback", "body": "fallback", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#fallback", "labels": ["OpenZeppelin"]}, {"title": "function of", "body": "function of", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#function-of", "labels": ["OpenZeppelin"]}, {"title": "ForwardProxy, and in", "body": "ForwardProxy, and in", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#forwardproxy,-and-in", "labels": ["OpenZeppelin"]}, {"title": "policyCommand", "body": "policyCommand", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policycommand", "labels": ["OpenZeppelin"]}, {"title": "of", "body": "of", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#of", "labels": ["OpenZeppelin"]}, {"title": "Policed use a complex assembly block without comments.", "body": "Policed use a complex assembly block without comments.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policed-use-a-complex-assembly-block-without-comments.", "labels": ["OpenZeppelin"]}, {"title": "This is a low-level language that is difficult to understand.", "body": "This is a low-level language that is difficult to understand.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#this-is-a-low-level-language-that-is-difficult-to-understand.", "labels": ["OpenZeppelin"]}, {"title": "Consider documenting the mentioned function in detail to explain the rationale behind the use of assembly and to clarify what every single assembly instruction is doing. This will make it easier for users to trust the code, for reviewers to verify it, and for developers to build on top of it or update it.", "body": "Consider documenting the mentioned function in detail to explain the rationale behind the use of assembly and to clarify what every single assembly instruction is doing. This will make it easier for users to trust the code, for reviewers to verify it, and for developers to build on top of it or update it.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-documenting-the-mentioned-function-in-detail-to-explain-the-rationale-behind-the-use-of-assembly-and-to-clarify-what-every-single-assembly-instruction-is-doing.-this-will-make-it-easier-for-users-to-trust-the-code,-for-reviewers-to-verify-it,-and-for-developers-to-build-on-top-of-it-or-update-it.", "labels": ["OpenZeppelin"]}, {"title": "Note that the use of assembly discards several important safety features of Solidity, so this is a highly vulnerable part of the project. Consider implementing thorough tests to cover all potential use cases of the ForwardProxy contract to ensure it behaves as expected.", "body": "Note that the use of assembly discards several important safety features of Solidity, so this is a highly vulnerable part of the project. Consider implementing thorough tests to cover all potential use cases of the ForwardProxy contract to ensure it behaves as expected.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#note-that-the-use-of-assembly-discards-several-important-safety-features-of-solidity,-so-this-is-a-highly-vulnerable-part-of-the-project.-consider-implementing-thorough-tests-to-cover-all-potential-use-cases-of-the-forwardproxy-contract-to-ensure-it-behaves-as-expected.", "labels": ["OpenZeppelin"]}, {"title": "bootstrap", "body": "bootstrap", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#bootstrap", "labels": ["OpenZeppelin"]}, {"title": "[P1-L06] Unused imports", "body": "[P1-L06] Unused imports", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l06]-unused-imports", "labels": ["OpenZeppelin"]}, {"title": "In beam-bootstrap-chain, SampleForward.sol imports ForwardProxy and never uses it.", "body": "In beam-bootstrap-chain, SampleForward.sol imports ForwardProxy and never uses it.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-beam-bootstrap-chain,-sampleforward.sol-imports-forwardproxy-and-never-uses-it.", "labels": ["OpenZeppelin"]}, {"title": "In policed-contracts, Policy and PolicedUtils import ERC820ImplementerInterface and never use it.", "body": "In policed-contracts, Policy and PolicedUtils import ERC820ImplementerInterface and never use it.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policed-contracts,-policy-and-policedutils-import-erc820implementerinterface-and-never-use-it.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing unused imports.", "body": "Consider removing unused imports.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-removing-unused-imports.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. The unused imports mentioned above have been removed.", "body": "Update: Fixed. The unused imports mentioned above have been removed.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-the-unused-imports-mentioned-above-have-been-removed.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L07] Not using the latest OpenZeppelin Contracts library", "body": "[P1-L07] Not using the latest OpenZeppelin Contracts library", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l07]-not-using-the-latest-openzeppelin-contracts-library", "labels": ["OpenZeppelin"]}, {"title": "Components: policy and deploy", "body": "Components: policy and deploy", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#components:-policy-and-deploy", "labels": ["OpenZeppelin"]}, {"title": "beam-bootstrap-chain and policed-contracts are using openzeppelin-solidity v1.12.0. This is an outdated release. At the time of writing, the latest stable version was v2.4.0.", "body": "beam-bootstrap-chain and policed-contracts are using openzeppelin-solidity v1.12.0. This is an outdated release. At the time of writing, the latest stable version was v2.4.0.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beam-bootstrap-chain-and-policed-contracts-are-using-openzeppelin-solidity-v1.12.0.-this-is-an-outdated-release.-at-the-time-of-writing,-the-latest-stable-version-was-v2.4.0.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the projects to the latest openzeppelin-solidity version.", "body": "Consider updating the projects to the latest openzeppelin-solidity version.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-updating-the-projects-to-the-latest-openzeppelin-solidity-version.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. The openzeppelin-solidity dependency has been updated.", "body": "Update: Fixed. The openzeppelin-solidity dependency has been updated.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-the-openzeppelin-solidity-dependency-has-been-updated.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L08] There are multiple typos", "body": "[P1-L08] There are multiple typos", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l08]-there-are-multiple-typos", "labels": ["OpenZeppelin"]}, {"title": "Components: policy", "body": "Components: policy", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#components:-policy", "labels": ["OpenZeppelin"]}, {"title": "There are multiple typos in the repository:", "body": "There are multiple typos in the repository:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#there-are-multiple-typos-in-the-repository:", "labels": ["OpenZeppelin"]}, {"title": "In Policed.sol and PolicedUtils.sol: pf instead of \u201cof\u201d", "body": "In Policed.sol and PolicedUtils.sol: pf instead of \u201cof\u201d", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#in-policed.sol-and-policedutils.sol:-pf-instead-of-\u201cof\u201d", "labels": ["OpenZeppelin"]}, {"title": "Consider running codespell on pull requests.", "body": "Consider running codespell on pull requests.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-running-codespell-on-pull-requests.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed. The typos mentioned above have been fixed.", "body": "Update: Fixed. The typos mentioned above have been fixed.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-fixed.-the-typos-mentioned-above-have-been-fixed.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L09] Reimplementing the Ownable pattern", "body": "[P1-L09] Reimplementing the Ownable pattern", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l09]-reimplementing-the-ownable-pattern", "labels": ["OpenZeppelin"]}, {"title": "Component: deploy", "body": "Component: deploy", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#component:-deploy", "labels": ["OpenZeppelin"]}, {"title": "BeamInitializable and BeamBootstrap implement the Owner pattern (with the latter calling it deployAccount).", "body": "BeamInitializable and BeamBootstrap implement the Owner pattern (with the latter calling it deployAccount).", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#beaminitializable-and-beambootstrap-implement-the-owner-pattern-(with-the-latter-calling-it-deployaccount).", "labels": ["OpenZeppelin"]}, {"title": "Consider using the Ownable contract from OpenZeppelin instead of reimplementing it.", "body": "Consider using the Ownable contract from OpenZeppelin instead of reimplementing it.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-using-the-ownable-contract-from-openzeppelin-instead-of-reimplementing-it.", "labels": ["OpenZeppelin"]}, {"title": "Update: A comment has been added explaining the reason for not using Ownable from OpenZeppelin.", "body": "Update: A comment has been added explaining the reason for not using Ownable from OpenZeppelin.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-a-comment-has-been-added-explaining-the-reason-for-not-using-ownable-from-openzeppelin.", "labels": ["OpenZeppelin"]}, {"title": "[P1-L10] Unnecessary empty constructors defined", "body": "[P1-L10] Unnecessary empty constructors defined", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l10]-unnecessary-empty-constructors-defined", "labels": ["OpenZeppelin"]}, {"title": "Policy and", "body": "Policy and", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policy-and", "labels": ["OpenZeppelin"]}, {"title": "PolicyInit define empty constructors, which is not necessary and only hinders code readability. According to the", "body": "PolicyInit define empty constructors, which is not necessary and only hinders code readability. According to the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policyinit-define-empty-constructors,-which-is-not-necessary-and-only-hinders-code-readability.-according-to-the", "labels": ["OpenZeppelin"]}, {"title": "Solidity docs on constructors, \u201c", "body": "Solidity docs on constructors, \u201c", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#solidity-docs-on-constructors,-\u201c", "labels": ["OpenZeppelin"]}, {"title": "Consider removing all empty constructors from the codebase.", "body": "Consider removing all empty constructors from the codebase.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-removing-all-empty-constructors-from-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "PolicyInit", "body": "PolicyInit", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#policyinit", "labels": ["OpenZeppelin"]}, {"title": "[P1-L11] Proxy delegation logic can be simplified", "body": "[P1-L11] Proxy delegation logic can be simplified", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#[p1-l11]-proxy-delegation-logic-can-be-simplified", "labels": ["OpenZeppelin"]}, {"title": "fallback function in charge of the delegation process for the proxy can be simplified. It is not necessary to use the", "body": "fallback function in charge of the delegation process for the proxy can be simplified. It is not necessary to use the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#fallback-function-in-charge-of-the-delegation-process-for-the-proxy-can-be-simplified.-it-is-not-necessary-to-use-the", "labels": ["OpenZeppelin"]}, {"title": "free memory pointer, and", "body": "free memory pointer, and", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#free-memory-pointer,-and", "labels": ["OpenZeppelin"]}, {"title": "returndatasize can be saved to a variable instead of calling it twice. Also, the", "body": "returndatasize can be saved to a variable instead of calling it twice. Also, the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#returndatasize-can-be-saved-to-a-variable-instead-of-calling-it-twice.-also,-the", "labels": ["OpenZeppelin"]}, {"title": "result of", "body": "result of", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#result-of", "labels": ["OpenZeppelin"]}, {"title": "delegatecall can be checked after the", "body": "delegatecall can be checked after the", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#delegatecall-can-be-checked-after-the", "labels": ["OpenZeppelin"]}, {"title": "Because this code is hard to understand and Solidity does not check its safety, it is a good idea to make it as short and clear as possible.", "body": "Because this code is hard to understand and Solidity does not check its safety, it is a good idea to make it as short and clear as possible.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#because-this-code-is-hard-to-understand-and-solidity-does-not-check-its-safety,-it-is-a-good-idea-to-make-it-as-short-and-clear-as-possible.", "labels": ["OpenZeppelin"]}, {"title": "Consider refactoring the assembly block. See the OpenZeppelin SDK delegate implementation as an example of a thoroughly tested alternative.", "body": "Consider refactoring the assembly block. See the OpenZeppelin SDK delegate implementation as an example of a thoroughly tested alternative.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#consider-refactoring-the-assembly-block.-see-the-openzeppelin-sdk-delegate-implementation-as-an-example-of-a-thoroughly-tested-alternative.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed. The proxy implementation no longer uses the free memory pointer. Eco\u2019s statement for this issue:", "body": "Update: Partially fixed. The proxy implementation no longer uses the free memory pointer. Eco\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#update:-partially-fixed.-the-proxy-implementation-no-longer-uses-the-free-memory-pointer.-eco\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "The current implementation minimizes gas overhead, which was an important design consideration for us.", "body": "The current implementation minimizes gas overhead, which was an important design consideration for us.", "html_url": "https://blog.openzeppelin.com/eco-contracts-audit#the-current-implementation-minimizes-gas-overhead,-which-was-an-important-design-consideration-for-us.", "labels": ["OpenZeppelin"]}, {"title": "[introduced with the first round of fixes] Stray tokens can be locked in ArroToken contract.", "body": "[introduced with the first round of fixes] Stray tokens can be locked in ArroToken contract.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#[introduced-with-the-first-round-of-fixes]-stray-tokens-can-be-locked-in-arrotoken-contract.", "labels": ["OpenZeppelin"]}, {"title": "The transferAnyERC20Token function is intended to transfer any ERC20 tokens accidentally received by the ArroToken contract. However, this function calls the _transfer internal function passing the address of the stray ERC20 token as the sender. This means that instead of transferring stray tokens out of the ArroToken contract, this function tries to transfer the ArroTokens owned by the stray contract.", "body": "The transferAnyERC20Token function is intended to transfer any ERC20 tokens accidentally received by the ArroToken contract. However, this function calls the _transfer internal function passing the address of the stray ERC20 token as the sender. This means that instead of transferring stray tokens out of the ArroToken contract, this function tries to transfer the ArroTokens owned by the stray contract.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-transferanyerc20token-function-is-intended-to-transfer-any-erc20-tokens-accidentally-received-by-the-arrotoken-contract.-however,-this-function-calls-the-_transfer-internal-function-passing-the-address-of-the-stray-erc20-token-as-the-sender.-this-means-that-instead-of-transferring-stray-tokens-out-of-the-arrotoken-contract,-this-function-tries-to-transfer-the-arrotokens-owned-by-the-stray-contract.", "labels": ["OpenZeppelin"]}, {"title": "Consider calling the transfer function of the stray token contract, instead of the one from the ArroToken contract.", "body": "Consider calling the transfer function of the stray token contract, instead of the one from the ArroToken contract.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-calling-the-transfer-function-of-the-stray-token-contract,-instead-of-the-one-from-the-arrotoken-contract.", "labels": ["OpenZeppelin"]}, {"title": "Not following good Smart Contract development practices", "body": "Not following good Smart Contract development practices", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#not-following-good-smart-contract-development-practices", "labels": ["OpenZeppelin"]}, {"title": "The ArroToken project lacks of a standard Solidity project structure. There are no unit tests and integration tests implemented, and there is no code coverage set up. All the contracts are defined in the same file, which doesn\u2019t have the proper file extension. Additionally, the README.md file is empty.", "body": "The ArroToken project lacks of a standard Solidity project structure. There are no unit tests and integration tests implemented, and there is no code coverage set up. All the contracts are defined in the same file, which doesn\u2019t have the proper file extension. Additionally, the README.md file is empty.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-arrotoken-project-lacks-of-a-standard-solidity-project-structure.-there-are-no-unit-tests-and-integration-tests-implemented,-and-there-is-no-code-coverage-set-up.-all-the-contracts-are-defined-in-the-same-file,-which-doesn\u2019t-have-the-proper-file-extension.-additionally,-the-readme.md-file-is-empty.", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin SDK or", "body": "OpenZeppelin SDK or", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#openzeppelin-sdk-or", "labels": ["OpenZeppelin"]}, {"title": "Truffle for setting up the project environment, organizing the contracts, and adequately develop the project.", "body": "Truffle for setting up the project environment, organizing the contracts, and adequately develop the project.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#truffle-for-setting-up-the-project-environment,-organizing-the-contracts,-and-adequately-develop-the-project.", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin Test Environment and", "body": "OpenZeppelin Test Environment and", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#openzeppelin-test-environment-and", "labels": ["OpenZeppelin"]}, {"title": "OpenZepplin Test Helpers for", "body": "OpenZepplin Test Helpers for", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#openzepplin-test-helpers-for", "labels": ["OpenZeppelin"]}, {"title": "writing automated Smart Contract tests.", "body": "writing automated Smart Contract tests.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#writing-automated-smart-contract-tests.", "labels": ["OpenZeppelin"]}, {"title": "Standard Readme compliant.", "body": "Standard Readme compliant.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#standard-readme-compliant.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed. Arro\u2019s statement for this issue:", "body": "Update: Partially fixed. Arro\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#update:-partially-fixed.-arro\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "The project has been restructured to follow the standard Solidity project structure provided by the OpenZeppelin CLI. The code functionality relies heavily on the provided libraries and interfaces from the OpenZeppelin SDK, this provides test coverage over a majority of the functionality. There are plans in the future to add unit or integration tests on contract functions. A relevant README has been added that provides general project information and installation and development instructions.", "body": "The project has been restructured to follow the standard Solidity project structure provided by the OpenZeppelin CLI. The code functionality relies heavily on the provided libraries and interfaces from the OpenZeppelin SDK, this provides test coverage over a majority of the functionality. There are plans in the future to add unit or integration tests on contract functions. A relevant README has been added that provides general project information and installation and development instructions.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-project-has-been-restructured-to-follow-the-standard-solidity-project-structure-provided-by-the-openzeppelin-cli.-the-code-functionality-relies-heavily-on-the-provided-libraries-and-interfaces-from-the-openzeppelin-sdk,-this-provides-test-coverage-over-a-majority-of-the-functionality.-there-are-plans-in-the-future-to-add-unit-or-integration-tests-on-contract-functions.-a-relevant-readme-has-been-added-that-provides-general-project-information-and-installation-and-development-instructions.", "labels": ["OpenZeppelin"]}, {"title": "Note that the project is missing the .openzeppelin/project.json file from the OpenZeppelin CLI.", "body": "Note that the project is missing the .openzeppelin/project.json file from the OpenZeppelin CLI.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#note-that-the-project-is-missing-the-.openzeppelin/project.json-file-from-the-openzeppelin-cli.", "labels": ["OpenZeppelin"]}]