[{"title": "Wrong error message in `__castOffchainVotes`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The error message states:  ```solidity require(     proposal.offchain,     \"FairSideDAO::__castOffchainVotes: proposal is meant to be voted offchain\" ); ```  But it should be \"... meant to be voted onchain\".   "}, {"title": "`FairSideDAO.SECS_PER_BLOCK` is inaccurate", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/34", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "`FairSideDAO.SECS_PER_BLOCK` is inaccurate"}, {"title": "Bug inside ABDKMathQuad library", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "Bug inside ABDKMathQuad library"}, {"title": "NFTs can never be redeemed back to their conviction scores leading to lock/loss of funds\u2028", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/31", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Besides the conviction scores of users, there appears to be tracking of the FairSide protocol\u2019s tokenized conviction score as a whole (using fscAddress = address(fairSideConviction)). This is evident in the attempted reduction of the protocol\u2019s score when a user acquires conviction back from a NFT. However, the complementary accrual of user's conviction score to fscAddress when user tokenizes their conviction score to mint a NFT is missing in tokenizeConviction().  Because of this missing updation of conviction score to fscAddress on tokenization, there are no checkpoints written for fscAddress and there also doesn\u2019t appear to be any initialization for bootstrapping this address\u2019s conviction score checkpoints. As a result, the sub224() on Line350 of ERC20ConvictionScore.sol will always fail with an underflow because fscOld = 0 (because fscNum = 0) and convictionScore > 0, effectively reverting all calls to acquireConviction().  The impact is that all tokenized NFTs can never be redeemed back to their conviction scores and therefore leads to lock/loss of FSD funds for users who tokenized/sold/bought FairSide NFTs.   ## Proof of Concept  1. Alice tokenizes her conviction score into a NFT. She sells that NFT to Bob who pays an amount commensurate with the conviction score captured by that NFT (as valued by the market) and any FSDs locked with the NFT.   2. Bob then attempts to redeem the bought NFT back to the conviction score to use it on FairSide network. But the call to acquireConviction() fails. Bob is never able to redeem Alice\u2019s NFT and has lost the funds used to buy it.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L343-L355   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add appropriate logic to bootstrap+initialize fscAddress\u2019s tokenized conviction score checkpoints and update it during tokenization.  "}, {"title": "Locked funds from tokenization are credited twice to user leading to protocol fund loss", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/30", "labels": ["bug", "question", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The tokens optionally locked during tokenization are released twice on acquiring conviction back from a NFT. (The incorrect double debit of locked funds during tokenization has been filed as a separate finding because it is not necessarily related and also occurs in a different part of the code.)  When a user wants to acquire back the conviction score captured by a NFT, the FSD tokens locked, if any, are released to the user as well. However, this is incorrectly done twice. Released amount is transferred once on Line123 in _release() (via acquireConviction -> burn) of FairSideConviction.sol and again immediately after the burn on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  This leads to loss of protocol funds.  ## Proof of Concept  Alice tokenizes her conviction score into a NFT and locks 100 FSDs. Bob buys the NFT from Alice and acquires the conviction score back from the NFT. But instead of 100 FSDs that were supposed to be locked with the NFT, Bob receives 100+100 = 200 FSDs from FairSide protocol.  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/conviction/FairSideConviction.sol#L123  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L314-L316   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the redundant transfer of FSD tokens from protocol to user on Line316 in acquireConviction() of ERC20ConvictionScore.sol.  "}, {"title": "Locked funds are debited twice from user during tokenization leading to fund loss", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/29", "labels": ["bug", "3 (High Risk)"], "target": "2021-05-fairside-findings", "body": "Locked funds are debited twice from user during tokenization leading to fund loss"}, {"title": "Conviction totals not updated during tokenization", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  _updateConvictionScore() function returns convictionDelta and governanceDelta which need to be used immediately in a call to _updateConvictionTotals(convictionDelta, governanceDelta) for updating the conviction totals of conviction and governance-enabled conviction for the entire FairSide network.  This updation of totals after a call to _updateConvictionScore() is done on Line70 in _beforeTokenTransfer() and Line367 in updateConvictionScore() of ERC20ConvictionScore.sol.  However, the return values of _updateConvictionScore() are ignored on Line284 in tokenizeConviction() and not used to update the totals using _updateConvictionTotals(convictionDelta, governanceDelta).  The impact is that when a user tokenizes their conviction score, their conviction deltas are updated and recorded (only if the funds locked are zero which is incorrect and reported separately in a different finding) but the totals are not updated. This leads to incorrect accounting of TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE which are used in the calculation of tributes and therefore will lead to incorrect tribute calculations.  ## Proof of Concept  Alice calls tokenizeConviction() to convert her conviction score into an NFT. Her conviction deltas as returned by _updateConvictionScore() are ignored and TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE values are not updated. As a result, the tributes rewarded are proportionally more than what should have been the case because the conviction score totals are used as the denominator in availableTribute() and availableGovernanceTribute().  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L284  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L108-L110  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L52-L70  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L365-L367  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L73-L106  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L83-L100  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L102-L123   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use the return values of _updateConvictionScore() function (i.e. convictionDelta and governanceDelta) on Line284 of ERC20ConvictionScore.sol and use them in a call to _updateConvictionTotals(convictionDelta, governanceDelta).  "}, {"title": "Conviction scoring fails to initialize and bootstrap", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/26", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Conviction scores for new addresses/users fail to initialize+bootstrap in ERC20ConvictionScore\u2019s _updateConvictionScore() because a new user\u2019s numCheckpoints will be zero and never gets initialized.   This effectively means that FairSide conviction scoring fails to bootstrap at all, leading to failure of the protocol\u2019s pivotal feature.  ## Proof of Concept  When Alice transfers FSD tokens to Bob for the first time, _beforeTokenTransfer(Alice, Bob, 100) is triggered which calls _updateConvictionScore(Bob, 100) on Line55 of ERC20ConvictionScore.sol.   In function _updateConvictionScore(), given that this is the first time Bob is receiving FSD tokens, numCheckpoints[Bob] will be 0 (Line116) which will make ts = 0 (Line120), and Bob\u2019s FSD balance will also be zero (Bob never has got FSD tokens prior to this) which makes convictionDelta = 0 (Line122) and not let control go past Line129.   This means that a new checkpoint never gets written, i.e. conviction score never gets initialized, for Bob or for any user for that matter.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  FairSide\u2019s adjustment of Compound\u2019s conviction scoring is based on time and so needs an initialization to take place vs. Compound\u2019s implementation. A new checkpoint therefore needs to be created+initialized for a new user during token transfer.  "}, {"title": "Dangerous Solidity compiler pragma range that spans breaking versions", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/25", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-05-fairside-findings", "body": "Dangerous Solidity compiler pragma range that spans breaking versions"}, {"title": "Call to swapExactTokensForETH in liquidateDai() will always fail\u2028", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  liquidateDai() calls Uniswap\u2019s swapExactTokensForETH to swap Dai to ETH. This will work if msg.sender, i.e. FSD contract,\u00a0has already given the router an allowance of at least amount on the input token Dai.   Given that there is no prior approval, the call to UniswapV2 router for swapping will fail because msg.sender has not approved UniswapV2 with an allowance for the tokens being attempted to swap.  The impact is that updateCostShareRequest() will fail and revert while working with stablecoin Dai.  ## Proof of Concept  https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L191  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L182-L198  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L323  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L307-L329  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L280  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L297   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add FSD approval to UniswapV2 with an allowance for the tokens being attempted to swap.  "}, {"title": "Incorrect use of _addTribute instead of _addGovernanceTribute", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The addRegistrationTributeGovernance() function is called by the FSD network to update tribute when 7.5% is contributed towards governance as part of purchaseMembership(). However, this function incorrectly calls _addTribute() (as done in addRegistrationTribute) instead of _addGovernanceTribute().  The impact is that governanceTributes never gets updated and the entire tribute accounting logic is rendered incorrect.   ## Proof of Concept  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L140  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/token/FSD.sol#L130  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/network/FSDNetwork.sol#L195  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L30-L48  https://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L50-L70   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _addGovernanceTribute() instead of _addTribute on L140 of FSD.sol  "}, {"title": "Missing use of DSMath functions may lead to underflows/overflows", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/19", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "Missing use of DSMath functions may lead to underflows/overflows"}, {"title": "Use of ecrecover is susceptible to signature malleability", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The\u00a0ecrecover\u00a0function is used to verify and execute EIP-2612 permit transactions. The built-in EVM precompile ecrecover is susceptible to signature malleability (because of non-unique s and v values) which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).   While this is not exploitable for replay attacks in the current implementation because of the use of nonces, this may become a vulnerability if used elsewhere.   ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/tokens/Erc2612.sol#L48  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Consider using OpenZeppelin\u2019s ECDSA library (which prevents this malleability) instead of the built-in function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol  "}, {"title": "Repetitive storage access", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _addTribute can reuse lastTribute to reduce the numbers of storage access: tributes[totalTributes - 1].amount = add224(...) can be replaced with lastTribute.amount = add224(...) as it is already a storage pointer that can be assigned a value with no need to recalculate the index and access the array again. Same situation with function _addGovernanceTribute governanceTributes.  ## Recommended Mitigation Steps lastTribute.amount = add224(...)  "}, {"title": "non existing function returns", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions castVote and  castVoteBySig of FairSideDAO.sol have no \"returns\" parameters, however they do call \"return\" at the end of the function.  This is confusing for the readers of the code.  ## Proof of Concept // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dao/FairSideDAO.sol#L443  function castVote(uint256 proposalId, bool support) public {         return _castVote(msg.sender, proposalId, support);     }   function castVoteBySig( .. ) public {        ...        return _castVote(signatory, proposalId, support);     }  ## Tools Used Editor  ## Recommended Mitigation Steps  Remove the \"return\" statements from castVote and castVoteBySig  "}, {"title": "gracePeriod not increased after membership extension", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function purchaseMembership of FSDNetwork.sol, when the membership is extended then membership[msg.sender].creation is increased, however  membership[msg.sender].gracePeriod is not increased. This might lead to a gracePeriod than is less then expected. It seems logical to also increase the gracePeriod    ## Proof of Concept FSDNetwork.sol // https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L171 function purchaseMembership(uint256 costShareBenefit) external {      ...       if (membership[msg.sender].creation == 0) {             ...             membership[msg.sender].creation       = block.timestamp;             membership[msg.sender].gracePeriod =  membership[msg.sender].creation +  MEMBERSHIP_DURATION +  60 days;         } else {           ....           membership[msg.sender].creation += durationIncrease;    }  ## Tools Used Editor  ## Recommended Mitigation Steps Check if gracePeriod has to be increased also.  When that is the case add the logic to do that.  "}, {"title": "Constant values used inline", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "Constant values used inline"}, {"title": "totalCostShareBenefit  vs totalCostShareBenefits ", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "totalCostShareBenefit  vs totalCostShareBenefits "}, {"title": "Improvements arctan", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "Improvements arctan"}, {"title": "Users can avoid paying borrowing interest after the fyToken matures", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  According to the protocol design, users have to pay borrowing interest when repaying the debt with underlying tokens after maturity. However, a user can give his vault to `Witch` and then buy all his collateral using underlying tokens to avoid paying the interest. Besides, this bug could make users less incentivized to repay the debt before maturity and hold the underlying tokens until liquidation.  ## Proof of Concept  1. A user creates a new vault and opens a borrowing position as usual. 2. The maturity date passed. If the user wants to close the position using underlying tokens, he has to pay a borrowing interest (line 350 in `Ladle`), which is his debt multiplied by the rate accrual (line 373). 3. Now, the user wants to avoid paying the borrowing interest. He gives his vault to `Witch` by calling the function `batch` of `Ladle` with the operation `GIVE`. 4. He then calls the function `buy` of `Witch` with the corresponding `vaultId` to buy all his collateral using underlying tokens.  In the last step, the `elapsed` time (line 61) is equal to the current timestamp since the vault is never grabbed by `Witch` before, and thus the auction time of the vault, `cauldron.auctions(vaultId)`, is 0 (the default mapping value). Therefore, the collateral is sold at a price of `balances_.art/balances_.ink` (line 74). The user can buy `balances_.ink` amount of collateral using `balances_.art` but not paying for borrowing fees.  Referenced code: [Ladle.sol#L350](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L350) [Ladle.sol#L368-L377](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L368-L377) [Ladle.sol#L267-L272](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L267-L272) [Cauldron.sol#L234-L252](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L234-L252) [Witch.sol#L61](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L61) [Witch.sol#L74](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L74)  ## Recommended Mitigation Steps  Do not allow users to `give` vaults to `Witch`. To be more careful, require `vaultOwners[vaultId]` and `cauldron.auctions(vaultId)` to be non-zero at the beginning of function `buy`.  "}, {"title": "Possible DoS attack when creating `Joins` in `Wand`", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  It is possible for an attacker to intendedly create a fake `Join` corresponding to a specific token beforehand to make `Wand` unable to deploy the actual `Join`, causing a DoS attack.  ## Proof of Concept  The address of `Join` corresponding to an underlying `asset` is determined as follows and thus unique:  ```solidity Join join = new Join{salt: keccak256(abi.encodePacked(asset))}(); ```  Besides, the function `createJoin` in the contract `JoinFactory` is permissionless: Anyone can create the `Join` corresponding to the `asset`. An attacker could then deploy a large number of `Joins` with different common underlying assets (e.g., DAI, USDC, ETH) before the `Wand` deploying them. The attempt of deploying these `Joins` by `Wand` would fail since the attacker had occupied the desired addresses with fake `Joins`, resulting in a DoS attack.  Moreover, the attacker can also perform DoS attacks on newly added assets: He monitors the mempool to find transactions calling the function `addAsset` of `Wand` and front-runs them to create the corresponding `Join` to make the benign transaction fail.  Referenced code: [JoinFactory.sol#L64-L75](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol#L64-L75) [Wand.sol#L53](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L53)  ## Recommended Mitigation Steps  Enable access control in `createJoin` (e.g., adding the `auth` modifier) and allow `Wand` to call it.  "}, {"title": "User can redeem more tokens by artificially increasing the chi accrual", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-05-yield-findings", "body": "User can redeem more tokens by artificially increasing the chi accrual"}, {"title": "Using stale cToken exchange rate", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-05-yield-findings", "body": "Using stale cToken exchange rate"}, {"title": "Unnecessary `unchecked` keyword is used in `FYToken`", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  At line 172 in the contract `FYToken`, the `unchecked` keyword is unnecessary since no arithmetic operation is involved.  ## Proof of Concept  Referenced code: [FYToken.sol#L172](https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L172)  ## Recommended Mitigation Steps  Consider removing the `unchecked` keyword.  "}, {"title": "In method _update on Pool.sol - Divide before multiply", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  In the Pool.sol contract there is the following code:  ``` function _update(         uint128 baseBalance,         uint128 fyBalance,         uint112 _baseCached,         uint112 _fyTokenCached     ) private {         ....              cumulativeBalancesRatio +=                 (scaledFYTokenCached / _baseCached) *                 timeElapsed;         ....     } ```  The multiplication should be always placed at the end to avoid miscalculations like the following one:  ```   a = (b/d)*c   0 = (5/10)*2      a = (b * c)/ 2   1 = (5 * 2)/10  ```      "}, {"title": "Gas optimizations - using external over public ", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact The following methods could be external instead of public  ``` level(bytes12) should be declared external:         - Cauldron.level(bytes12) (contracts/Cauldron.sol#513-521) mature(bytes6) should be declared external:         - Cauldron.mature(bytes6) (contracts/Cauldron.sol#524-532) accrual(bytes6) should be declared external:         - Cauldron.accrual(bytes6) (contracts/Cauldron.sol#546-553) setFlashFeeFactor(uint256) should be declared external:         - Join.setFlashFeeFactor(uint256) (contracts/Join.sol#33-36) maxFlashLoan(address) should be declared external:         - Join.maxFlashLoan(address) (contracts/Join.sol#90-97) flashFee(address,uint256) should be declared external:         - Join.flashFee(address,uint256) (contracts/Join.sol#105-113) flashLoan(IERC3156FlashBorrower,address,uint256,bytes) should be declared external:         - Join.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) (contracts/Join.sol#132-151) setFee(uint256) should be declared external:         - Ladle.setFee(uint256) (contracts/Ladle.sol#102-105) addAsset(bytes6,address) should be declared external:         - Wand.addAsset(bytes6,address) (contracts/Wand.sol#49-61) makeBase(bytes6,IMultiOracleGov,address,address) should be declared external:         - Wand.makeBase(bytes6,IMultiOracleGov,address,address) (contracts/Wand.sol#65-78) makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) should be declared external:         - Wand.makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) (contracts/Wand.sol#81-94) addSeries(bytes6,bytes6,uint32,bytes6[],string,string) should be declared external:         - Wand.addSeries(bytes6,bytes6,uint32,bytes6[],string,string) (contracts/Wand.sol#98-154) setAuctionTime(uint128) should be declared external:         - Witch.setAuctionTime(uint128) (contracts/Witch.sol#41-44) setInitialProportion(uint128) should be declared external:         - Witch.setInitialProportion(uint128) (contracts/Witch.sol#47-51) grab(bytes12) should be declared external:         - Witch.grab(bytes12) (contracts/Witch.sol#54-59) buy(bytes12,uint128,uint128) should be declared external:         - Witch.buy(bytes12,uint128,uint128) (contracts/Witch.sol#62-99) mint(address,uint256) should be declared external:         - DAIMock.mint(address,uint256) (contracts/mocks/DAIMock.sol#36-38) mint(address,uint256) should be declared external:         - ERC20Mock.mint(address,uint256) (contracts/mocks/ERC20Mock.sol#11-13) mint(address,uint256) should be declared external:         - RestrictedERC20Mock.mint(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#12-14) burn(address,uint256) should be declared external:         - RestrictedERC20Mock.burn(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#17-19) pull(address,uint256) should be declared external:         - GemJoinMock.pull(address,uint256) (contracts/mocks/TLMMock.sol#14-16) mint(address,uint256) should be declared external:         - USDCMock.mint(address,uint256) (contracts/mocks/USDCMock.sol#13-15) withdraw(uint256) should be declared external:         - WETH9Mock.withdraw(uint256) (contracts/mocks/WETH9Mock.sol#21-26) totalSupply() should be declared external:         - WETH9Mock.totalSupply() (contracts/mocks/WETH9Mock.sol#28-30) latestRoundData() should be declared external:         - ChainlinkAggregatorV3Mock.latestRoundData() (contracts/mocks/oracles/chainlink/ChainlinkAggregatorV3Mock.sol#22-34) exchangeRateCurrent() should be declared external:         - CTokenChiMock.exchangeRateCurrent() (contracts/mocks/oracles/compound/CTokenChiMock.sol#12-14) tickSpacing() should be declared external:         - UniswapV3PoolMock.tickSpacing() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#27-29) maxLiquidityPerTick() should be declared external:         - UniswapV3PoolMock.maxLiquidityPerTick() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#31-33) setSources(bytes6[],bytes6[],address[]) should be declared external:         - ChainlinkMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#56-68) peek(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#105-113)         - CompoundMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#78-86)         - UniswapV3Oracle.peek(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#126-132) get(bytes32,bytes32,uint256) should be declared external:         - ChainlinkMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#119-127)         - CompoundMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#92-100)         - UniswapV3Oracle.get(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#138-144) setSources(bytes6[],bytes6[],address[]) should be declared external:         - CompoundMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/compound/CompoundMultiOracle.sol#37-48) setSecondsAgo(uint32) should be declared external:         - UniswapV3Oracle.setSecondsAgo(uint32) (contracts/oracles/uniswap/UniswapV3Oracle.sol#44-48) setSources(bytes6[],bytes6[],address[]) should be declared external:         - UniswapV3Oracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/uniswap/UniswapV3Oracle.sol#73-85) transferOwnership(address) should be declared external:         - Ownable.transferOwnership(address) (contracts/utils/access/Ownable.sol#25-28) tokenSymbol(address) should be declared external:         - SafeERC20Namer.tokenSymbol(address) (contracts/utils/token/SafeERC20Namer.sol#87-95) tokenName(address) should be declared external:         - SafeERC20Namer.tokenName(address) (contracts/utils/token/SafeERC20Namer.sol#98-106) setParameter(bytes32,int128) should be declared external:         - Pool.setParameter(bytes32,int128) (contracts/yieldspace/Pool.sol#135-141) getK() should be declared external:         - Pool.getK() (contracts/yieldspace/Pool.sol#144-147) getG1() should be declared external:         - Pool.getG1() (contracts/yieldspace/Pool.sol#150-152) getG2() should be declared external:         - Pool.getG2() (contracts/yieldspace/Pool.sol#155-157) getCache() should be declared external:         - Pool.getCache() (contracts/yieldspace/Pool.sol#175-185) fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#657-694) baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#707-744) fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#757-797) baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:         - YieldMath.baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#811-848) ```  Here more information about the gas optimizations of external vs public: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tools Used  Slither   "}, {"title": "function build could explicitly check that seriesId is not 0", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/59", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It would be helpful if function build explicitly check that seriesId != bytes12(0). In practice, it is not possible to have a series with an id of 0, so this check will not pass:     require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\"); however, the error message is not very informative, thus I am suggesting adding an explicit check.  ## Recommended Mitigation Steps require (seriesId != bytes12(0), \"Series id is zero\");  "}, {"title": "function redeem should return 'redeemed' amount", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function redeem in contract FYToken should return 'redeemed' amount. There return value is not used anywhere, but it's a mistake that it assigns 'redeemed' but returns 'amount'.  ## Recommended Mitigation Steps Remove return sentence or explicitly return 'redeemed'.  "}, {"title": "external function transferToPool is pretty useless", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact external function transferToPool is pretty useless and error-prone. It relies on the user not to leave these tokens in a separate tx, otherwise, it will just be feeding the bots. To use it directly users will have to write their own custom smart contract and chain actions.  ## Recommended Mitigation Steps It would be better to remove this function and leave the only way to invoke it via a batch function.  "}, {"title": "unnecessary store", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function batch of Ladle.sol, at the operation GIVE, the value of vault is stored and is deleted directly afterwards. So storing is unnecessary. Maybe the solidity compiler already optimizes this.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Ladle.sol#L228   function batch( } else if (operation == Operation.GIVE) {                ...                  vault = _give(vaultId, to);                 delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore              ## Tools Used  ## Recommended Mitigation Steps Remove the \" vault = \"   "}, {"title": "Anyone can create a fake pool to trick unauthorized front-ends", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-05-yield-findings", "body": "Anyone can create a fake pool to trick unauthorized front-ends"}, {"title": "Multiple compiler versions allowing a wide range from 0.5.0 to >=0.8.0", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Project uses multiple compiler versions with most specifying ^0.8.0, some specifying >=0.8.0 which allows breaking versions >= 0.9.0 in future if reused/redeployed, and some even allowing much older >= 0.5.0/0.6.0.   The dangers of allowing multiple compilers across breaking revisions is that the security bug fixes and features might be different across different contracts introducing vulnerabilities or giving a false sense of security.  For example, most contract use ^0.8.0 which means they have default checked arithmetic to prevent overflows/underflows without using OZ SafeMath. This doesn\u2019t apply to the few (inherited) contracts that may be compiled with <0.8.0 and have unchecked overflows/underflows.   ## Proof of Concept  ^0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L2  >= 0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/YieldMath.sol#L2  >= 0.5.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/SafeERC20Namer.sol#L3  >= 0.6.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/TransferHelper.sol#L4  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Update all contracts to use pragma solidity ^0.8.0 or better a fixed version like 0.8.4 2. Deploy with the same compiler version which was used for testing  "}, {"title": "flashFeeFactor is uninitialized at declaration leading to zero-fee flash loans enabled by default\u2028", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  flashFeeFactor is uninitialized at declaration and so zero initially until set by setFlashFeeFactor(). As indicated in one of the the explainer videos, the idea is to set this by default to uint256.max to disable flash loans by default.  Currently, flash loans are enabled by default with a zero flash fee unless changed by setFlashFeeFactor().  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L26  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L32-L39  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L107-L110  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L117-L119  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L132   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize at declaration with a reasonable value which could be uint256.max to disable flash loans by default.  "}, {"title": "Incompatibility With Rebasing/Deflationary/Inflationary tokens", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/52", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-05-yield-findings", "body": "Incompatibility With Rebasing/Deflationary/Inflationary tokens"}, {"title": "Prevent the use of LOCK in setRoleAdmin to instead force the use of lockRole", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The LOCK role is special in AccessControl because it has itself as the admin role (like ROOT) but no members. This means that calling setRoleAdmin(msg.sig, LOCK) means no one can grant/revoke that msg.sig role anymore and it gets locked irreversibly. This means it disables admin-based permissioning management of that role and therefore is very powerful in its impact.  Given this, there is a special function lockRole() which is specifically meant to enforce LOCK as the admin for the specified role parameter. For all other role admin creations, the generic setRoleAdmin() may be used. However, setRoleAdmin() does not itself prevent specifying the use of LOCK as the admin. If this is accidentally used then it leads to disabling that role\u2019s admin management irreversibly similar to the lockRole() function.  It is safer to force admins to use lockRole() as the only way to set admin to LOCK and prevent the use of LOCK as the adminRole parameter in setRoleAdmin(), because doing so will make the intention of the caller clearer as lockRole() clearly has that functionality specified in its name and that\u2019s the only thing it does.   ## Proof of Concept  Alice who is the admin for foo() wants to give the admin rights to Bob (0xFFFFFFF0) but instead of calling setRoleAdmin(foo.sig, 0xFFFFFFF0), she calls setRoleAdmin(foo.sig, 0xFFFFFFFF) where 0xFFFFFFFF is LOCK. This makes LOCK as the admin for foo() and prevents any further admin-based access control management for foo().  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L48  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L129-L131  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L235-L240  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/access/AccessControl.sol#L165-L176  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Prevent the use of LOCK as the adminRole parameter in setRoleAdmin().  "}, {"title": "Missing reentrancy guard and contract existence check for modules\u2028", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-05-yield-findings", "body": "Missing reentrancy guard and contract existence check for modules\u2028"}, {"title": "Missing sender address check in receive() may lead to locked Ether", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Add an address check in receive() of Ladle.sol to ensure the only address sending ETH being received in receive() is the Weth9 contract (similar to the check in PoolRouter.sol) for Ether withdrawal in _exitEther().  This will prevent stray Ether from being sent accidentally to this contract and getting locked.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L521-L522  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/PoolRouter.sol#L145-L148   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add an address check in receive() of Ladle.sol to ensure only Weth9 contract can send Ether to this contract.  "}, {"title": "Return values of batch operations are ignored", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Many batched operation functions return values but these are ignored by the caller batch(). While this may be acceptable for the front-end which picks up any state changes from such functions via emitted events, integrating protocols that make a call to batch() may require it to package and send back return values of all operations from the batch to react on-chain to the success/failure or other return values from such calls. Otherwise, they will be in the dark on the success/impact of batched operations they\u2019ve triggered.  ## Proof of Concept  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L120-L245  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L250  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L258  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L284-L286  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L296-L298  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L326-L328  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L342-L344  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L382-L384  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L396-L398  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L410-L412  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L446-L448  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L462-L464  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L527-L529  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L539-L541  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L559-L561  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L588-L590  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Package and send back return values of all batched operations\u2019 functions to the caller of batch().  "}, {"title": "Violation of implicit constraints in batched operations may break protocol assumptions", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-05-yield-findings", "body": "Violation of implicit constraints in batched operations may break protocol assumptions"}, {"title": "Uninitialized or Incorrectly set auctionInterval may lead to liquidation engine livelock", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The grab() function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized. To prevent re-grabbing without sufficient time for auctioning collateral/debt, the logic uses an auctionInterval threshold to give a reasonable window to a liquidation engine that has grabbed the vault.  The grab() function has a comment on Line 354: \u201c// Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\u201d indicating a requirement of the auctionInterval being equal to one day. This can happen only if the auctionInterval is set appropriately. However, this state variable is uninitialized (defaults to 0) and depends on setAuctionInterval() being called with the appropriate auctionInterval_ value which is also not validated.  Discussion with the project lead indicated that this comment is incorrect. Nevertheless, it is safer to initialize auctionInterval at declaration to a safe default value instead of the current 0 which will allow liquidation engines to re-grab vaults without making any progress on liquidation auction. It is also good to add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because liquidation engines will keep re-grabbing vaults from each other and potentially result in liquidation bots entering a live-lock situation without making any progress on liquidation auctions. This will result in collateral being stuck and impact entire protocol\u2019s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.   ## Proof of Concept  Configuration recipe forgets to set the auctionInterval state variable by calling setAuctionInterval() and inadvertently leaves it at the default value of 0. Alternatively, it calls it but with a lower than intended/reasonable auction interval value. Both scenarios fail to give sufficient protection to liquidation engines from having their grabbed vaults re-grabbed without sufficient time for liquidation auctions.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L63  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L108-L115  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L354   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. Initialize auctionInterval  at declaration with a reasonable default value. 2. Add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.  "}, {"title": "Potential griefing with DoS by front-running vault creation with same vaultID", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The vaultID for a new vault being built is required to be specified by the user building a vault via the build() function (instead of being assigned by the Cauldron/protocol). An attacker can observe a build() as part of a batch transaction in the mempool, identify the vaultID being requested and front-run that by constructing a malicious batch transaction with only the build operation with that same vaultID. The protocol would create a vault with that vaultID and assign attacker as its owner. More importantly, the valid batch transaction in the mempool which was front-run will later fail to create its vault because that vaultID already exists, as per the check on Line180 of Cauldron.sol. As a result, the valid batch transaction fails entirely because of the attacker front-running with the observed vaultID.  While the attacker gains nothing except the ownership of an empty vault after spending the gas, this could grief the protocol\u2019s real users by preventing them from opening a vault and interacting with the protocol in any manner.  Rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because valid vaults from the Yield front-end will never be successfully created and will lead to a DoS against the entire protocol\u2019s functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.  ## Proof of Concept  Alice uses Yield\u2019s front-end to create a valid batch transaction. Evil Eve observes that in the mempool and identifies the vaultID of the vault being built by Alice. Eve submits her own batch transaction (without using the front-end) with only a build operation using Alice\u2019s vaultID. She uses a higher gas price to front-run Alice\u2019s transaction and get\u2019s the protocol to assign that vaultID to herself. Alice\u2019s batch transaction later fails because the vaultID she requested is already assigned to Eve. Eve can do this for any valid transaction to grief protocol users by wasting her gas to cause DoS.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L180  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L173-L190  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L133-L135  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Ladle.sol#L249-L255   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Mitigate this DoS vector by having the Cauldron assign the vauldID instead of user specifying it in the build() operation. This would likely require the build() to be a separate non-batch transaction followed by other operations that use the vaultID assigned in build(). Consider the pros/cons of this approach because it will significantly affect the batching/caching logic in Ladle.  Alternatively, consider adding validation logic in Ladle\u2019s batching to revert batches that have only build or a subset of the operations that do not make sense to the protocol\u2019s operations per valid recipes, which could be an attacker\u2019s signature pattern.  "}, {"title": "Missing zero-address validations\u2028", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/42", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-05-yield-findings", "body": "Missing zero-address validations\u2028"}, {"title": "Missing checks on debt max/min limits could cause pour to revert", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  setDebtLimits() is used to set the maximum and minimum debt for an underlying and ilk pair. The assumption is that max will be greater than min while setting them because otherwise the debt checks in _pour() for line/dust will fail and revert.  While max and min debt limits can be reset, it is safer to perform input validation on them in setDebtLimits().  ## Proof of Concept  A recipe incorrectly interchanges the values of min and max debt which leads to exceptions in pouring into the vaults.  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L91-L92  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Cauldron.sol#L319-L322  https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Wand.sol#L79   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a check to ensure max > mix.  "}, {"title": "ERC20 approve is vulnerable to the front-running", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-05-yield-findings", "body": "ERC20 approve is vulnerable to the front-running"}, {"title": "UniswapV3Oracle function _peek is public", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In contract UniswapV3Oracle function _peek has visibility of public while the name and similar functions in other oracles are declared as private.  ## Recommended Mitigation Steps give _peek private visibility.  "}, {"title": "no need for transferToPool to be payable", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function transferToPool is marked as 'payable'. It only transfers ERC20 tokens, no Ether, so there is no need in having 'payable' here.  ## Recommended Mitigation Steps Remove 'payable' modifier from function transferToPool.  "}, {"title": "_burnInternal always returns 0 for fy tokens returned", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Function _burnInternal always returns 0 as a third parameter. It should return tokensBurnt, tokenOut, fyTokenOut.  ## Recommended Mitigation Steps return (tokensBurned, tokenOut, fyTokenOut);  "}, {"title": "Unsafe call to `.decimals`", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The `FYToken.constructor` performs an external call to `IERC20Metadata(address(IJoin(join_).asset())).decimals()`. This function was optional in the initial ERC-20 and might fail for old tokens that therefore did not implement it.  ## Impact FyTokens cannot be created for tokens that implemented the old initial ERC20 without the `decimals` function.  ## Recommended Mitigation Steps Consider using the helper function in the utils to retrieve it `SafeERC20Namer.tokenDecimals`, the same way the `Pool.constructor` works.  "}, {"title": "Undercollateralized vaults' owner can be overwritten", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/30", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  The witch can `Witch.grab` vaults and the `vaultOwners[vaultId]` field is set to the original owner. However, when the auction time is over and the debt has not been fully paid back, the original owner is not restored, and the witch can grab the same vault again, overwriting the original owner `vaultOwners[vaultId]` field permanently with the witch.  ```solidity function grab(bytes12 vaultId) public {     DataTypes.Vault memory vault = cauldron.vaults(vaultId);     vaultOwners[vaultId] = vault.owner;     cauldron.grab(vaultId, address(this)); } ```  Even a full repayment will not restore the original vault owner anymore.  ## Impact No funds will be stuck as the vault can still be correctly liquidated (calling `settle`). However, the vault owner will not be restored which is bad if it is a valuable vaultId (low number) that has a special meaning or would be used as an NFT/for retroactive airdrops for initial liquidity providers down the road.  ## Recommended Mitigation Steps When grabbing check if `vaultOwners[vaultId]` is already the witch and in that case just do an early return of the function - not overwriting the `vaultOwners[vaultId]` field.   "}, {"title": "Uniswap Oracle uses wrong prices", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-05-yield-findings", "body": "Uniswap Oracle uses wrong prices"}, {"title": "Inefficient Witch buy", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-05-yield-findings", "body": "Inefficient Witch buy"}, {"title": "Implicit unsafe math", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  cmichel   # Vulnerability details  `Ladle._close` (and many other occurrences) reverts the transaction on certain signed inputs that are negated and cast to unsigned integers.  ```solidity // Ladle._close calling it with art or ink as type(int128).min will crash uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art)); ilkJoin.exit(to, uint128(-ink))  // explanation int128 art = type(int128).min; // -2^127 uint128 amt = uint128(-art); // this fails as -art=--2^127=2^127 cannot be represented in int128 ```  Other places: - `CauldronMath.add` - `Ladle._pour` - everywhere where `-int*` is used  ## Impact One cannot use the actual `type(int128).min` value for function parameters.  ## Recommended Mitigation Steps Revert with a meaningful error message as is done in the `/math/Cast*` functions.   "}, {"title": "enum TokenType is never used", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/21", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact enum TokenType in library PoolDataTypes is not used anywhere.  ## Recommended Mitigation Steps Either remove it or use it where intended.  "}, {"title": "Useless 'auth' modifier in setSources", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/20", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setSources in Oracle contracts does not need 'auth' modifier as it will be checked anyway in function setSource. This does not impact the security, it is just a useless check that can be removed.  ## Recommended Mitigation Steps Remove 'auth' modifer from function setSources.  "}, {"title": "'peek' and 'get' are identical (non-transactional)", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In the contract ChainlinkMultiOracle both functions 'peek' and 'get' are identical. They are declared as views while based on IOracle interface 'get' should be transactional.   "}, {"title": "Duplication of Balance", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/16", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  0xsomeone   # Vulnerability details  ## Impact  It is possible to duplicate currently held `ink` or `art` within a Cauldron, thereby breaking the contract's accounting system minting units out of thin air.  ## Proof of Concept  The `stir` function of the `Cauldron`, which can be invoked via a `Ladle` operation, caches balances in memory before decrementing and incrementing. As a result, if a transfer to self is performed, the assignment `balances[to] = balancesTo` will contain the added-to balance instead of the neutral balance.  This allows one to duplicate any number of `ink` or `art` units at will, thereby severely affecting the protocol's integrity. A similar attack was exploited in the third bZx hack resulting in a roughly 8 million loss.  Code Referenced: https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L268-L295  ## Tools Used  Manual Review.  ## Recommended Mitigation Steps  A `require` check should be imposed that prohibits the `from` and `to` variables to be equivalent.  "}, {"title": "Avoid assembly in getRevertMsg ", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getRevertMsg of RevertMsgExtractor.sol uses assembly to retrieve revert information. The latest solidity version have new functions that allows you to retrieve information without assembly.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/RevertMsgExtractor.sol function getRevertMsg(bytes memory returnData) internal pure returns (string memory) { ..        assembly {             // Slice the sighash.             returnData := add(returnData, 0x04)         }   ## Tools Used  ## Recommended Mitigation Steps Below is a piece of code showing the new functionality:  pragma solidity ^0.8.1;  contract ContractError {     function Underflow() public pure returns (uint) {          uint x = 0;          x--; // this will generate an underflow          return x;     }     function UncheckedUnderflow() public pure returns (uint) {          uint x = 0;          unchecked { x--; } // this will generate an underflow          return x;     }  }  contract C {     ContractError e = new ContractError();          function TestUnderflow() public view returns (string memory) {          try e.Underflow() returns (uint) {             return \"Ok\";         } catch Error(string memory reason) {             return reason;         } catch Panic(uint _code) {             if (_code == 0x01) { return \"Assertion failed\"; }             else if (_code == 0x11) { return \"Underflow/overflow\"; }             // We ignore the other errors.             return \"Other Panic\";         } catch (bytes memory reason) {              uint x=0;             for (uint i=0;i<4;i++) //get first 4 bytes                 x = (x<<8) + uint(uint8(reason[i]));                      if (x == 0x08c379a0) // abi.encodeWithSignature(\"Error(string)\")                 return \"Error\";             return \"Unknown\";         }     } }   "}, {"title": "PoolFactory and JoinFactory very similar", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact PoolFactory and JoinFactory contain very similar but also relatively complicated code. // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/PoolFactory.sol // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol  The risk is that future changes/improvements in one contract might not be updated in the other.  ## Proof of Concept  ## Tools Used Editor  ## Recommended Mitigation Steps Consider refactoring the code where the core code is put in a library and reused from both of the contracts.   "}, {"title": "Constants \"chi\" and \"rate\"", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Several implementations of the value of \"chi\" and \"rate\" are used, sometimes as constant and sometimes the direct value is used, see proof of concept below. The risk is that if it is changed in one place if might not be changed in another place, leading to bugs.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L26 bytes6 public constant CHI = \"chi\"; bytes6 public constant RATE = \"rate\";  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L27 bytes32 constant CHI = \"chi\";  //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/oracles/compound/CompoundMultiOracle.sol#L40     function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {       ...         if (kind == \"rate\") rawPrice = CTokenInterface(source).borrowIndex();         else if (kind == \"chi\") rawPrice = CTokenInterface(source).exchangeRateStored();  ## Tools Used grep  ## Recommended Mitigation Steps Define the constants for \"chi\" and \"rate\" on one location and include this where required.   "}, {"title": "Several todos left in the code", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The code still has some todos, which should be resolved before production  ## Proof of Concept Ladle.sol:        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo` Ladle.sol:        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo` Wand.sol:        cauldron.setRateOracle(assetId, IOracle(address(oracle))); // TODO: Consider adding a registry of chi oracles in cauldron as well Wand.sol:        ); // TODO: Use a FYTokenFactory to make Wand deployable at 20000 runs Wand.sol:            name,     // Derive from base and maturity, perhaps Wand.sol:            symbol    // Derive from base and maturity, perhaps  ## Tools Used Grep  ## Recommended Mitigation Steps Check and fix or remove the todos   "}, {"title": "Witch can't give back vault after 2x grab", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The witch.sol contract gets access to a vault via the grab function, in case of liquidation. If the witch.sol contract can't sell the debt within a certain amount of time, a second grab can occur.  After the second grab, the information of the original owner of the vault is lost and the vault can't be returned to the original owner once the debt has been sold.  The grab function stores the previous owner in vaultOwners[vaultId] and then the contract itself is the new owner (via cauldron.grab and cauldron._give). The vaultOwners[vaultId] is overwritten at the second grab  The function buy of Witch.sol tried to give the vault back to the original owner, which won't succeed after a second grab.  ## Proof of Concept // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L50     function grab(bytes12 vaultId) public {         DataTypes.Vault memory vault = cauldron.vaults(vaultId);         vaultOwners[vaultId] = vault.owner;         cauldron.grab(vaultId, address(this));     }  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349     function grab(bytes12 vaultId, address receiver)  external  auth   {      ...         _give(vaultId, receiver);       // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Cauldron.sol#L349  function _give(bytes12 vaultId, address receiver) internal returns(DataTypes.Vault memory vault)  {     ...         vault.owner = receiver;         vaults[vaultId] = vault;  // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Witch.sol#L57  function buy(bytes12 vaultId, uint128 art, uint128 min) public {      ....             cauldron.give(vaultId, vaultOwners[vaultId]);  ## Tools Used Editor  ## Recommended Mitigation Steps Assuming it's useful to give back to vault to the original owner: Make a stack/array of previous owners if multiple instances of the witch.sol contract would be used. Or check if the witch is already the owner (in the grab function) and keep the vaultOwners[vaultId] if that is the case  "}, {"title": "auth collision possible", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/5", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-05-yield-findings", "body": "auth collision possible"}, {"title": "auth only works well with external functions", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The auth modifier of AccessControl.sol doesn't work as you would expect.  It checks if you are authorized for \"msg.sig\", however msg.sig is the signature of the first function you have called, not of the current function. So if you call function A, which calls function B, the \"auth\" modifier of function B checks if you are authorized for function A!  There is a difference between external an public functions. For external functions this works as expected because a fresh call (with a new msg.sig) is always made. However with a public functions, which are called from within the same contract, this doesn't happen and the problem described above occurs. See in the proof of concept for a piece of code which shows the problem. In the code there are several functions which have public and auth combined, see also in the proof of concept .  In the current codebase I couldn't find a problem situation, however this could be accidentally introduced with future changes. If could also be introduced via the _moduleCall of Ladle.sol, which allows functions to be defined which might call the public functions.  ## Proof of Concept ### auth // https://github.com/code-423n4/2021-05-yield/blob/main/contracts/utils/access/AccessControl.sol#L90 modifier auth() {         require (_hasRole(msg.sig, msg.sender), \"Access denied\");         _;     }  ### example pragma solidity ^0.8.0; contract TestMsgSig {      event log(bytes4);      function setFeePublic(uint256) public  {          emit log(this.setFeePublic.selector);          emit log(msg.sig);     }     function setFeeExternal(uint256) external  {          emit log(this.setFeeExternal.selector);          emit log(msg.sig);     }      function TestPublic() public {         setFeePublic(2);     }      function TestExternal() public {        this.setFeeExternal(2);     } } ### occurrences of public auth Wand.sol:   function addAsset(bytes6 assetId,address asset) public auth { Wand.sol:    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) public auth { Wand.sol:    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) public auth { Wand.sol:     function addSeries(...  ) public auth { Witch.sol:    function setAuctionTime(uint128 auctionTime_) public auth { Witch.sol:    function setInitialProportion(uint128 initialProportion_) public auth {  Ladle.sol:     function setFee(uint256 fee)         public        auth      Join.sol:    function setFlashFeeFactor(uint256 flashFeeFactor_) public   auth     {  oracles\\chainlink\\ChainlinkMultiOracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\\chainlink\\ChainlinkMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { oracles\\compound\\CompoundMultiOracle.sol:    function setSource(bytes6 base, bytes6 kind, address source) public auth { oracles\\compound\\CompoundMultiOracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) public auth { oracles\\uniswap\\UniswapV3Oracle.sol:    function setSecondsAgo(uint32 secondsAgo_) public auth { oracles\\uniswap\\UniswapV3Oracle.sol:    function setSource(bytes6 base, bytes6 quote, address source) public auth { oracles\\uniswap\\UniswapV3Oracle.sol:    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth { fytoken.sol:  function setOracle(IOracle oracle_)  public  auth     {   ## Tools Used grep  ## Recommended Mitigation Steps make sure all auth functions use external  (still error prone) or change the modifier to something like:     modifier auth(bytes4 fs) {         require (msg.sig == fs,\"Wrong selector\");         require (_hasRole(msg.sig, msg.sender), \"Access denied\");         _;     }      function setFee(uint256) public auth(this.setFee.selector) {        .....     }    "}, {"title": "Use constants for numbers", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact At several places constants are hardcoded as numbers. It's more readable and more maintainable to turn them into explicit constants. That also lowers to risk to change it on one place and forget is on another place. See examples in proof of concept  ## Proof of Concept .\\Insurance.sol:            if (publicCollateralAmount > 10**18) { .\\Insurance.sol:                amount = poolHoldings - 10**18; .\\Insurance.sol:                publicCollateralAmount = 10**18; .\\Insurance.sol:            if (publicCollateralAmount < 10**18) { .\\Insurance.sol:            } else if (poolHoldings - amount < 10**18) { .\\Insurance.sol:                amount = poolHoldings - 10**18; .\\Insurance.sol:                publicCollateralAmount = 10**18; .\\Insurance.sol:            uint256 multiplyFactor = 36523 * (10**11); .\\Insurance.sol:        return tracer.leveragedNotionalValue() / 100; .\\oracle\\GasOracle.sol:    uint8 public override decimals = 18; .\\lib\\libprices.sol:       for (uint256 i = 0; i < 8; i++) { .\\lib\\libprices.sol:           uint256 currTimeWeight = 8 - i; .\\lib\\LibPrices.sol:        return (averageTracerPrice.toInt256() - averageOraclePrice.toInt256()) / 90; .\\lib\\LibBalances.sol:        uint256 adjustedLiquidationGasCost = liquidationGasCost * 6; .\\lib\\LibPerpetuals.sol:        percentFull = percentFull * 100; // To bring it up to the same percentage units as everything else .\\Liquidation.sol:    uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Replace numeric values with constants   "}, {"title": "YieldMath.sol / Log2: >= or > ?", "html_url": "https://github.com/code-423n4/2021-05-yield-findings/issues/2", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-05-yield-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The V1 version of YieldMath.sol contains \">=\" (larger or equal), while the V2 version of YieldMath.sol containt \">\" (larger) in the log_2 function. This change doesn't seem logical and might lead to miss calculations. The difference is present in a number of adjacent lines.  ## Proof of Concept // https://github.com/yieldprotocol/yieldspace-v1/blob/master/contracts/YieldMath.sol#L217 function log_2 (uint128 x) ... b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}   //https://github.com/code-423n4/2021-05-yield/blob/main/contracts/yieldspace/YieldMath.sol#L58 function log_2(uint128 x) ... b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}  ## Tools Used diff  ## Recommended Mitigation Steps Check which version is the correct version and fix the incorrect version.    "}, {"title": "Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/171", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.  ## Proof of Concept  The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable `timeLeftOfDeposit` indicates the time left of deposit, starting from now. However, at line 672, the `foreclosureTimeWithoutNewCard` is calculated by `timeLeftOfDeposit` plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.  Referenced code: [RCTreasury.sol#L642-L653](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L642-L653) [RCTreasury.sol#L669](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L669) [RCTreasury.sol#L672](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L672) [RCTreasury.sol#L678](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L678) [RCOrderbook.sol#L553-L557](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L553-L557)  ## Recommended Mitigation Steps  Change `depositAbleToWithdraw(_user)` at line 669 to `user[_user].deposit`. Or, change `user[_user].lastRentCalc` at both line 672 and 678 to `block.timestamp`.  "}, {"title": "The `domainSeperator` is not recalculated after a hard fork happens", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/166", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-realitycards-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The variable `domainSeperator` in `EIP712Base` is cached in the contract storage and will not change after the contract is initialized. However, if a hard fork happens after the contract deployment, the `domainSeperator` would become invalid on one of the forked chains due to the `block.chainid` has changed.  ## Proof of Concept  Referenced code: [EIP712Base.sol#L25-L44](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/lib/EIP712Base.sol#L25-L44)  ## Recommended Mitigation Steps  Consider using the [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol) from OpenZeppelin, which recalculates the domain separator if the current `block.chainid` is not the cached chain ID.  "}, {"title": "maxContractBalance can be bypassed", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/163", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-06-realitycards-findings", "body": "maxContractBalance can be bypassed"}, {"title": "Use Mode instead of uint in RCFactory to make code much more readable", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/162", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  On `RCFactory` is using uint to represent the enum Mode while on RCMarket is using the enum directly.  It would make the code much readable if RCFactory would use Mode directly.   "}, {"title": "Gas optimizations - Remove isMarket from RCMarket", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  `RCMarket` contains the constant variable `isMarket` to indicate it is a Market `bool public constant override isMarket = true;`. This is after used in `RCFactory` ``` function changeMarketApproval(address _market) external onlyGovernors {         require(_market != address(0));         // check it's an RC contract         IRCMarket _marketToApprove = IRCMarket(_market);         assert(_marketToApprove.isMarket());         isMarketApproved[_market] = !isMarketApproved[_market];         emit LogMarketApproved(_market, isMarketApproved[_market]);     } ```  Why not use `mappingOfMarkets` to verify the address is a Market? This would reduce the state space used.  "}, {"title": "`RCNftHubL2.safeTransferFrom` not accoring to spec", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `RCNftHubL2.safeTransferFrom` function does not correctly implement the ERC721 spec:  > When using safeTransferFrom, the token contract checks to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. [ERC721](https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721-safeTransferFrom)  This check is not implemented, it just drops the `_data` argument.  ## Impact  Contracts that don't know how to handle ERC721 tokens (are not an `IERC721Receiver`) can accept them but they should not when using `safeTransferFrom` according to spec.  ## Recommended Mitigation Steps  Implement the `IERC721Receiver` check in `safeTransferFrom`.   "}, {"title": "Dangerous toggle functions", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/157", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  Usually one tries to avoid toggle functions in blockchains, because it could be that you think that the first transaction you sent was not correctly submitted (but it's just pending for a long time), or you might even be unaware that it was already sent if multiple roles can set it (like with `changeMarketApproval` / `onlyGovernors`) or if it's an msig. This results in potentially double-toggling the state, i.e, it is set to the initial value again.  Some example functions: `changeMarketCreationGovernorsOnly`, `changeMarketApproval`, and the ones that follow.  ## Impact  The outcome of toggle functions is hard to predict on blockchains due to the very async nature and lack of information about pending transactions.  ## Recommended Mitigation Steps  Use functions that accept a specific value as a parameter instead.  "}, {"title": "uberOwner cannot do all the things an owner can", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/156", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `uberOwner` cannot do the same things the owner can. They can \"only\" set the reference contract for the market.  The same ideas apply to `Treasury` and `Factory`'s `uberOwner`.  ## Impact  The name is misleading as it sounds like the uber-owner is more powerful than the owner.  ## Recommended Mitigation Steps  Uberowner should at least be able to set the owner if not be allowed to call all functions that an `owner` can. Alternatively, rename the `uberOwner`.  "}, {"title": "Unbounded iteration on _cardAffiliateAddresses", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/154", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `Factory.createMarket` iterates over all `_cardAffiliateAddresses`.  ## Impact  The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.   ## Recommended Mitigation Steps  Perform a `_cardAffiliateAddresses.length == 0 || _cardAffiliateAddresses.length == tokenUris.length` check in `createMarket` instead of silently skipping card affiliate cuts in `Market.initialize`. This would restrict the `_cardAffiliateAddresses` length to the `nftMintingLimit` as well.  "}, {"title": "Deposits can be denied by abusing `maxContractBalance`", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/153", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "Deposits can be denied by abusing `maxContractBalance`"}, {"title": "Deposits don't work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/152", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-06-realitycards-findings", "body": "Deposits don't work with fee-on transfer tokens"}, {"title": "Market-specific pause is not checked for sponsor", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The treasury only checks its `globalPause` field but does not check its market-specific `marketPaused` field for `Treasury.sponsor`. A paused market contract can therefore still deposit as a sponsor using `Market.sponsor`  ## Impact  The market-specific pause does not work correctly.  ## Recommended Mitigation Steps  Add checks for `marketPaused` in the Treasury for `sponsor`.   "}, {"title": "Gas Optimizations - Use storage or memory to reduce reads", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "Gas Optimizations - Use storage or memory to reduce reads"}, {"title": "Gas optimizations - Duplicated state variable ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact On `RCOrderbook`, there are duplicated the state variable `treasuryAddress` and `treasury`  ```     address public treasuryAddress;     IRCTreasury public treasury; ``` ```     constructor(address _factoryAddress, address _treasuryAddress) {         factoryAddress = _factoryAddress;         treasuryAddress = _treasuryAddress;         treasury = IRCTreasury(treasuryAddress);         uberOwner = msgSender();     }  ```  "}, {"title": "totalNftMintCount can be replaced with ERC721 totalSupply()", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/134", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I can't find a reason why totalNftMintCount in Factory can't be replaced with ERC721 totalSupply() to make it less error-prone. As nfthub.mint issues a new token it should automatically increment totalSupply and this assignment won't be needed:       totalNftMintCount = totalNftMintCount + _tokenURIs.length; Also in function setNftHubAddress you need to manually set _newNftMintCount if you want to change nfthub so an invalid value may crash the system. totalSupply() will eliminate totalNftMintCount and make the system more robust.  ## Recommended Mitigation Steps Replace totalNftMintCount with nfthub totalSupply() in Factory contract.  "}, {"title": "Shadowing Local Variables found in RCOrderbook.sol", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  maplesyrup   # Vulnerability details  ## Impact 1 - Low Risk    - Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.  ## Proof of Concept  According to the Slither-analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing), shadowing local variables is naming conventions found in two or more variables that are similar. Although they do not pose any immediate risk to the contract, incorrect usage of the variables is possible and can cause serious issues if the developer does not pay close attention.   It is recommended that the naming of the following variables should be changed slightly to avoid any confusion:   -------------------------------------------------------------------  RCOrderbook._updateBidInOrderbook(address,address,uint256,uint256,uint256,RCOrderbook.Bid)._owner   (contracts/RCOrderbook.sol line(s)#358) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)    -------------------------------------------------------------------  RCOrderbook.closeMarket()._owner   (contracts/RCOrderbook.sol line(s)#639) shadows:  Ownable._owner <------(state variable)  (node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)   -------------------------------------------------------------------  ## Tools Used  Solidity Compiler 0.8.4 Hardhat v2.3.3 Slither v0.8.0  Compiled, Tested, Deployed contracts on a local hardhat network.  Ran Slither-analyzer for further detecting and testing.  ## Recommended Mitigation Steps  (Worked best under python venv) 1. Clone Project Repository 2. Run Project against Hardhat network;    compile and run default test on contracts. 3. Installed slither analyzer:   https://github.com/crytic/slither 4. Ran [$ slither .] against RCOrderbook.sol and all contracts to verify results  "}, {"title": "Redudant calculations in payRent when marketBalance < _amount", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact   _amount -= (_amount - marketBalance); is basically the same as:    _amount = marketBalance;   "}, {"title": "Wrong calculation on _collectRentAction", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/122", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  The method `_collectRentAction` contains the following code: ``` ...            } else if (!_foreclosed && _limitHit && _marketLocked) {                 // CASE 4                 // didn't foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN refund rent between the earliest event and now                 if (_cardTimeLimitTimestamp < marketLockingTime) {                     // time limit hit before market locked                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = block.timestamp - _cardTimeLimitTimestamp;                 } else {                     // market locked before time limit hit                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && !_limitHit && !_marketLocked) {                 // CASE 5                 // did foreclose AND                 // didn't hit time limit AND                 // didn't lock market                 // THEN rent OK, find new owner                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else if (_foreclosed && !_limitHit && _marketLocked) {                 // CASE 6                 // did foreclose AND                 // didn't hit time limit AND                 // did lock market                 // THEN if foreclosed first rent ok, otherwise refund after locking                 if (_timeUserForeclosed < marketLockingTime) {                     // user foreclosed before market locked                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // market locked before user foreclosed                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = block.timestamp - marketLockingTime;                 }             } else if (_foreclosed && _limitHit && !_marketLocked) {                 // CASE 7                 // did foreclose AND                 // did hit time limit AND                 // didn't lock market                 // THEN if foreclosed first rent ok, otherwise refund after limit                 if (_timeUserForeclosed < _cardTimeLimitTimestamp) {                     // user foreclosed before time limit                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else {                     // time limit hit before user foreclosed                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 }             } else {                 // CASE 8                 // did foreclose AND                 // did hit time limit AND                 // did lock market                 // THEN (\u256f\u00b0\u76ca\u00b0)\u256f\u5f61\u253b\u2501\u253b                 if (                     _timeUserForeclosed <= _cardTimeLimitTimestamp &&                     _timeUserForeclosed < marketLockingTime                 ) {                     // user foreclosed first (or at same time as time limit)                     _timeOfThisCollection = _timeUserForeclosed;                     _newOwner = true;                     _refundTime = 0;                 } else if (                     _cardTimeLimitTimestamp < _timeUserForeclosed &&                     _cardTimeLimitTimestamp < marketLockingTime                 ) {                     // time limit hit first                     _timeOfThisCollection = _cardTimeLimitTimestamp;                     _newOwner = true;                     _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;                 } else {                     // market locked first                     _timeOfThisCollection = marketLockingTime;                     _newOwner = false;                     _refundTime = _timeUserForeclosed - marketLockingTime;                 } ... ```  On the case 6, instead of doing `_refundTime = _timeUserForeclosed - marketLockingTime;` like the following cases, is doing `_refundTime = block.timestamp - marketLockingTime;`. This could lead to funds being drained by the miscalculation.   "}, {"title": "Anyone can affect deposits of any user and turn the owner of the token", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/119", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  On `RCTreasury`, we have the method `collectRentUser`. This method is public, so anyone can call it using whatever user and whatever timestamp.  So, calling this method using `user = XXXXX` and `_timeToCollectTo = type(uint256).max)`, would make `isForeclosed[user] = true`.  ```     function collectRentUser(address _user, uint256 _timeToCollectTo)         public         override         returns (             uint256 newTimeLastCollectedOnForeclosure         )     {         require(!globalPause, \"Global pause is enabled\");         assert(_timeToCollectTo != 0);         if (user[_user].lastRentCalc < _timeToCollectTo) {             uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);              if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {                 // The User has run out of deposit already.                 uint256 previousCollectionTime = user[_user].lastRentCalc;                  /*             timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)                                   = (now - previousCollectionTime) * (usersDeposit/rentOwed)             */                 uint256 timeUsersDepositLasts =                     ((_timeToCollectTo - previousCollectionTime) *                         uint256(user[_user].deposit)) / rentOwedByUser;                 /*             Users last collection time = previousCollectionTime + timeTheirDepsitLasted             */                 rentOwedByUser = uint256(user[_user].deposit);                 newTimeLastCollectedOnForeclosure =                     previousCollectionTime +                     timeUsersDepositLasts;                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(                     newTimeLastCollectedOnForeclosure                 );                 assert(user[_user].deposit == 0);                 isForeclosed[_user] = true;                 emit LogUserForeclosed(_user, true);             } else {                 // User has enough deposit to pay rent.                 _increaseMarketBalance(rentOwedByUser, _user);                 user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);             }             emit LogAdjustDeposit(_user, rentOwedByUser, false);         }     } ```  Now, we can do the same for all the users bidding for a specific token.  Finally, I can become the owner of the token by just calling `newRental` and using a small price. `newRental` will iterate over all the previous bid and will remove them because there are foreclosed.   ## Tools Used Editor  ## Recommended Mitigation Steps  `collectRentUser` should be private and create a new public method with `onlyOrderbook` modifier  "}, {"title": "NFT Hub implementation deviates from ERC721 for transfer functions", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  ERC721 standard and implementation allows the use of approved addresses to affect transfers besides the token owners. However, the L2 NFT Hub implementation deviates from ERC721 by ignoring the presence of any approvers in the overriding function implementations of transferFrom() and safeTransferFrom().   Impact: The system interactions with NFT platforms may not work if they expect ERC721 adherence. Users who interact via approved addresses will see their transfers failing for their approved addresses.   Given that the key value proposition of this project is the use of NFTs, the expectation will be that it is fully compatible with ERC721.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/nfthubs/RCNftHubL2.sol#L212-L234  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/00128bd26061986d10172573ceec914a4f3b4d3c/contracts/token/ERC721/ERC721.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add support for approval in NFT transfers.  "}, {"title": "Calculation imprecision when calculating the reaming cut", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/117", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "Calculation imprecision when calculating the reaming cut"}, {"title": "Missing balancedBooks modifier could result in failed system insolvency detection", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-06-realitycards-findings", "body": "Missing balancedBooks modifier could result in failed system insolvency detection"}, {"title": "questionFinalised is redundant", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/111", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact questionFinalised is redundant, it is only set to true or false but never queried or used in any meaningful way.  ## Recommended Mitigation Steps Remove questionFinalised from the codebase.  "}, {"title": "Missing call to removeOldBids may affect foreclosure", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/109", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Orderbook.removeBids() as commented \u201c///remove bids in closed markets for a given user ///this can reduce the users bidRate and chance to foreclose\u201d  removeOldBids() is performed currently in Market.newRental() and Treasury.deposit() to  \u201cdo some cleaning up, it might help cancel their foreclosure\u201d as commented. However, this is missing in the withdrawDeposit() function where the need is the most because user is removing deposit which may lead to foreclosure and is even commented as being useful on L356.  Impact: If we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's bidrate in the conditional on L357 and therefore do not prevent the foreclosure in withdrawDeposit that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L671-L713  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L356  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L357-L367  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L704-L705  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L300-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add call to removeOldBids() on L355 of withdrawDeposit() of Treasury.  "}, {"title": "Deposit double-counting miscalculation could incorrectly prevent user foreclosure", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-06-realitycards-findings", "body": "Deposit double-counting miscalculation could incorrectly prevent user foreclosure"}, {"title": "Deposit whitelist enforced on msg.sender instead of user", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-06-realitycards-findings", "body": "Deposit whitelist enforced on msg.sender instead of user"}, {"title": "Critical uberOwner address changes should be a two-step process", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/105", "labels": ["bug", "2 (Med Risk)"], "target": "2021-06-realitycards-findings", "body": "Critical uberOwner address changes should be a two-step process"}, {"title": "Test function left behind can expose order book", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/101", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-06-realitycards-findings", "body": "Test function left behind can expose order book"}, {"title": "Unused named return values are misleading and could lead to errors", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/96", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The code base uses a mix of named return values and explicit returns. In some places, the named return values are never assigned to and explicit returns are used instead.   Impact: This makes code readability and auditability hard potentially leading to errors and missed vulnerabilities.  ## Proof of Concept  Named return value shouldContinue is never assigned in _collectRentAction(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L856   Named return value didUpdateEverything is never assigned in _collectRent(): https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1040  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unassigned named return variables and be consistent in named vs explicit return usage.  "}, {"title": "Redundant allowance and balance checks", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In Market sponsor() the call to treasury.checkSponsorship() checks allowance and balance  of user. This is redundant because the call to treasury.sponsor downstream checks allowance again and insufficient balance would cause any transfer to fail anyway.  Impact: Given the gas sensitivity of the code base, removing this redundant check could help conserve gas and prevent any DoS from breaking gas limits.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L810  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L386-L396  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L474-L478   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant checks.  "}, {"title": "exitedTimestamp set prematurely", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/91", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The exitedTimestamp flag is used to prevent front-running of user exiting and re-entering in the same block. The setting of this flag in exit() should really be inside the conditionals and triggered only if current owner or if bidExists. It currently assumes that either of the two will always be true which may not necessarily be the case.  Impact: A user accidentally exiting a card he doesn't own or have a bid for currently will be marked as exited and prevented from a newRental in the same block. User can prevent one's own newRental from succeeding, because it was accidentally triggered, by front-running it himself with an exit. There could be other more realistic scenarios.   ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L784-L804  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L56-L57  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L678-L681   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Set exitedTimestamp flag only when the conditionals are true within exit()  "}, {"title": "Assert indicates unnecessary check or missing constraint/logic", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/90", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-06-realitycards-findings", "body": "Assert indicates unnecessary check or missing constraint/logic"}, {"title": "Flows can bypass market and global pause", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-06-realitycards-findings", "body": "Flows can bypass market and global pause"}, {"title": "maxSumOfPrices check is broken", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  rentAllCards() requires the sender to specify a _maxSumOfPrices parameter which specifies \u201climit to the sum of the bids to place\u201d as specified in the Natspec @param comment. This is apparently for front-run protection.  However, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total of bids places greater than the _maxSumOfPrices specified.  Impact: The user may not have sufficient deposit, be foreclosed and/or impacted on other bids/markets.  ## Proof of Concept  Scenario: Assume two cards for a market with current winning rentals of 50 each. _maxSumofPrices = 101 passes check on L643 but then the forced 10% increase on L650 (assuming sender is not the owner of either card) causes newRentals to be called with 55 for each card thus totalling to 110 which is > 101 as requested by the user.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L636-L637  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L639-L657   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Modify the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.  "}, {"title": "Missing market open check", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing _checkState(States.OPEN) on first line of rentAllCards() as specified on L617. These core market functions are supposed to operate only when market is open but the missing check allows control to proceed further in the control flow. In this case, the function proceeds to call newRental() which has a conditional check state == States.OPEN and silently returns success otherwise, without reverting.  Impact: rentAllCards does not fail if executed when market is closed or locked. newRental returns silently without failure when market is closed or locked.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L617  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L637-L658  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L672   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a require() to check market open state in the beginning of all core market functions and revert with an informative error string otherwise.  "}, {"title": "Use of assert() instead of require()", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/83", "labels": ["bug", "1 (Low Risk)"], "target": "2021-06-realitycards-findings", "body": "Use of assert() instead of require()"}, {"title": "Misplaced zero-address check", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Misplaced zero-address check for nfthub on L595 in createMarket() because nfthub cannot be 0 at this point as nfthub.addMarket() on L570 would have already reverted if that were the case.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L570  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L595  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move nfthub zero-address check to before the call to nfthub.addMarket().  "}, {"title": "Susceptible to collusion and sybil attacks", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/79", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-06-realitycards-findings", "body": "Susceptible to collusion and sybil attacks"}, {"title": "Making isMarketApproved False on an operational market will lock NFTs to L2", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Once market is approved and operational, changing approval to false should not be allowed or else it will prevent NFTs from being withdrawn to mainnet. All other Governor controlled variables are used during market creation and not thereafter, except this one. The other onlyGovernors functions only affect state before market creation but this one affects after creation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L382-L391  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L326-L330   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Once market is approved and operational, changing approval to false should not be allowed.  "}, {"title": "isGovernor excludes Factory owner", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "isGovernor excludes Factory owner"}, {"title": "Missing input validation on timeout", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "Missing input validation on timeout"}, {"title": "Basis points usage deviates from general definition", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/72", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The general definition of basis points is 100 bps = 1%. The usage here, 1000 bps = 100%, deviates from generally accepted definition and could cause confusion among users/creators/affiliates or potential miscalculations.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L228  https://www.investopedia.com/terms/b/basispoint.asp  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Document the used definition of basis points or switch to the generally accepted definition.  "}, {"title": "NFT minting limit dependence on block gas limit", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "NFT minting limit dependence on block gas limit"}, {"title": "Use of ecrecover is susceptible to signature malleability", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/66", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "Use of ecrecover is susceptible to signature malleability"}, {"title": "Missing events in multiple functions ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "Missing events in multiple functions "}, {"title": "prevent bids in WINNER_TAKES_ALL when it is no longer possible to win", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "prevent bids in WINNER_TAKES_ALL when it is no longer possible to win"}, {"title": "Redundant require() statement in RCFactory.createMarket()", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  jvaqa   # Vulnerability details  Redundant require() statement in RCFactory.createMarket()  ## Impact  RCFactory.createMarket() contains two require() statements side-by-side both checking the value of the relative values of _timestamps[0] and block.timestamp. // [1]  However, there is no case where the first require() statement would be triggered without the second require() statement also being triggered, since advancedWarning cannot have a negative value. // [2]  Thus, the first require() statement is redundant, and unnecessarily uses gas.  ## Proof of Concept  Alice can call RCFactory.createMarket() with an advancedWarning value greater than zero, and a _timestamps[0] value less than block.timestamp.  ## Recommended Mitigation Steps  Remove this require statement:  require(                 _timestamps[0] >= block.timestamp,                 \"Market opening time not set\"             ); // [3]   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L524  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L520  "}, {"title": "RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  jvaqa   # Vulnerability details  RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so.  ## Impact  IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. // [1]  The comments explicitly state that _incrementState() should be called \"thrice\". // [2]  However, it is possible to create a market where these events do not occur sequentially.  You can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.  This is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0]. // [3]  This is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. // [4]  Thus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.  ## Proof of Concept  When calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0]. // [5]  ## Recommended Mitigation Steps  Add the following check to RCFactory.createMarket():  require(     _timestamps[0] < _timestamps[1],     \"market must begin before market can lock\" );  [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L7  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1093  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L539  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L521  [5] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L468  "}, {"title": "Lack of zero address validation ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact   constructor of RCorderbook.sol lacks zero address validation , since parameter of costructor are used initialize state variable which are used in other function of the contract , error in these state variable can lead to redeployment of contract  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L106  ## Tools Used manual review  ## Recommended Mitigation Steps add require condition to check for zero address  "}, {"title": "Unused return value from orderbook.findNewOwner() and treasury.payRent()", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact checking the return value from function indicates ether function call was success or failure because of that, we should utilise the return value   ## Proof of Concept  In RCmarket.sol  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1025  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1060  ## Tools Used slither  ## Recommended Mitigation Steps  Utilize return value  "}, {"title": "RCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-realitycards-findings", "body": "# Handle  jvaqa   # Vulnerability details  RCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted  ## Impact  The comments state that calling addToWhitelist() should add a user to the whitelist. [1]  However, since the implementation simply flips the user's whitelist bool, if the user is already on the whitelist, then calling addToWhitelist() will actually remove them from the whitelist. [2]  Since batchAddToWhitelist() will repeatedly call addToWhitelist() with an entire array of users, it is very possible that someone could inadvertently call addToWhitelist twice for a particular user, thereby leaving them off of the whitelist. [3]   ## Proof of Concept  If a governor calls addToWhitelist() with the same user twice, the user will not be added to the whitelist, even though the comments state that they should.  ## Recommended Mitigation Steps  Change addToWhitelist to only ever flip a user's bool to true. To clarify the governor's intention, create a corresponding removeFromWhitelist and batchRemoveFromWhitelist which flip a user's bool to false, so that the governor does not accidently remove a user when intending to add them.   Change this:  isAllowed[_user] = !isAllowed[_user]; // [4]  To this:  isAllowed[_user] = true; // [4]  And add this:      /// @notice Remove a user to the whitelist     function removeFromWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), \"Not authorised\");         isAllowed[_user] = false;     }      /// @notice Remove multiple users from the whitelist     function batchRemoveFromWhitelist(address[] calldata _users) public override {         for (uint256 index = 0; index < _users.length; index++) {             removeFromWhitelist(_users[index]);         }     }   [1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L209  [2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213  [3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L217  [4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213   "}, {"title": "Possible locked-ether (funds) Issue in RCOrderbook.sol", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-06-realitycards-findings", "body": "Possible locked-ether (funds) Issue in RCOrderbook.sol"}, {"title": "anyone can call function sponsor", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/40", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:     /// @notice ability to add liqudity to the pot without being able to win.     /// @dev called by Factory during market creation     /// @param _sponsorAddress the msgSender of createMarket in the Factory     function sponsor(address _sponsorAddress, uint256 _amount)         external         override     {         _sponsor(_sponsorAddress, _amount);     }  ## Recommended Mitigation Steps Check that the sender is a factory contract.  "}, {"title": "circuitBreaker overrides the state", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function circuitBreaker calls _incrementState but later sets the state itself again:     function _incrementState() internal {         assert(uint256(state) < 4);         state = States(uint256(state) + (1));         emit LogStateChange(uint256(state));     }      function circuitBreaker() external {         require(             block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),             \"Too early\"         );         _incrementState();         orderbook.closeMarket();         state = States.WITHDRAW;     }  ## Recommended Mitigation Steps state = States.WITHDRAW; shouldn't be there, or another solution would be to put it before orderbook.closeMarket(); and remove _incrementState(); instead but then LogStateChange event will also need to be emitted manually.  "}, {"title": "contract RCTreasury does not use nfthub and setNftHubAddress", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract RCTreasury has an unused storage variable nfthub and setNftHubAddress function. This variable was moved to the Factory contract so it is useless here.  ## Recommended Mitigation Steps Remove nfthub variable and function setNftHubAddress.  "}, {"title": "functions safeTransferFrom and transferFrom are too similar", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/34", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function safeTransferFrom is almost identical to function transferFrom. It would be better to reduce code duplication by re-using the code.  ## Recommended Mitigation Steps    function safeTransferFrom(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) public override {         transferFrom(from, to, tokenId);         _data;     }  "}, {"title": "event WithdrawnBatch is not used", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact event WithdrawnBatch in contract RCNftHubL2 is not used anywhere.  ## Recommended Mitigation Steps Remove or use it where intended.  "}, {"title": "minRentalDayDivisor can be different between markets and treasury", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "minRentalDayDivisor can be different between markets and treasury"}, {"title": "Add comment to not obvious code in withdrawDeposit ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function withdrawDeposit of RCTreasury.sol, the value of isForeclosed[_msgSender]  is set to true. In the next statement it is overwritten with a new value. So the first statement seem redundant. However this is not the case because it is retrieved from the function removeUserFromOrderbook (see proof of concept below)  As this is not obvious it is probably useful to add a comment so future developers can understand this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322 function withdrawDeposit(uint256 _amount, bool _localWithdrawal)  external  override  balancedBooks  {   ...      isForeclosed[_msgSender] = true;   // this seems to be redundant     isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook( _msgSender );  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L575   function removeUserFromOrderbook(address _user)  external override returns (bool _userForeclosed) {         require(treasury.isForeclosed(_user), \"User must be foreclosed\");   // this checks the isForeclosed value from the treasury contract   ## Tools Used  ## Recommended Mitigation Steps Add a comment to  isForeclosed[_msgSender] = true;  explaining this line is important.   "}, {"title": "payout doesn't fix isForeclosed state", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function payout of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.  For example the function refundUser does check and update the isForeclosed status.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L429  function payout(address _user, uint256 _amount)  external override balancedBooks onlyMarkets returns (bool) {         require(!globalPause, \"Payouts are disabled\");         assert(marketPot[msgSender()] >= _amount);         user[_user].deposit += SafeCast.toUint128(_amount);         marketPot[msgSender()] -= _amount;         totalMarketPots -= _amount;         totalDeposits += _amount;         emit LogAdjustDeposit(_user, _amount, true);         return true;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L447  function refundUser(address _user, uint256 _refund)  external override onlyMarkets {      ...         if ( isForeclosed[_user] && user[_user].deposit > user[_user].bidRate / minRentalDayDivisor )  {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }  ## Tools Used  ## Recommended Mitigation Steps Check and update the isForeclosed state in the payout function  "}, {"title": "unnecessary emit of LogUserForeclosed", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function deposit of RCTreasury.sol resets the isForeclosed state and emits LogUserForeclosed, if the use have enough funds. However this also happens if the user is not Foreclosed and so the emit is redundant and confusing.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L279 function deposit(uint256 _amount, address _user) public override balancedBooks returns (bool) {    ....         // this deposit could cancel the users foreclosure         if ( (user[_user].deposit + _amount) > (user[_user].bidRate / minRentalDayDivisor) ) {             isForeclosed[_user] = false;             emit LogUserForeclosed(_user, false);         }         return true;     }  ## Tools Used  ## Recommended Mitigation Steps Only do the emit when isForeclosed was true  "}, {"title": "addToWhitelist doesn't check factoryAddress", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function addToWhitelist of RCTreasury.sol does a call to the factory contract, however the factoryAddress might not be initialized, because it is set via a different function (setFactoryAddress). The function addToWhitelist will revert when it calls a 0 address, but it might be more difficult to troubleshoot.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L233    function setFactoryAddress(address _newFactory) external override {         ...         factoryAddress = _newFactory;     }  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L210     function addToWhitelist(address _user) public override {         IRCFactory factory = IRCFactory(factoryAddress);         require(factory.isGovernor(msgSender()), \"Not authorised\");         isAllowed[_user] = !isAllowed[_user];     }  ## Tools Used  ## Recommended Mitigation Steps Verify that factoryAddress is set in the function addToWhitelist, for example using the following code.  require(factory != address(0), \"Must have an address\");  "}, {"title": "timestamp", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/20", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-06-realitycards-findings", "body": "timestamp"}, {"title": "external-function", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#tokenURI(uint256) is declared external in the IRCMarket interface but is declared public in the RCMarket implementation.   This is inconsistent and affect the gas behavior of the function: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L27  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L344  ## Tools Used  Slither  ## Recommended Mitigation Steps  Mark the implementation method as external.  "}, {"title": "costly-loop", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  RCMarket#initialize(uint256,uint32[],uint256,uint256,address,address,address[],address,string) has a potentially expensive loop that modifies state continually over an indeterminate number of cards.  ## Proof of Concept  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L252  ## Tools Used  Slither  ## Recommended Mitigation Steps  Potentially a gas-expensive loop because of arbitrary length of _cardAffiliateAddresses possibly assigning to state variable cardAffiliateCut multiple times. * It appears that the loop may be exited on the first cardAffiliateCut = 0 to optimize gas * Alternatively a local variable may be assigned temporarily and then assigned to state: https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop   "}, {"title": "Camel case function name", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Minimal code quality issue.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCFactory.sol#L26  The function setminimumPriceIncreasePercent does not follow the code standard of camel casing of function names.    ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Rename the function to have proper camel casing.  "}, {"title": "Multiple calls necessary for getWinnerFromOracle", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-realitycards-findings", "body": "Multiple calls necessary for getWinnerFromOracle"}, {"title": "Can access cards of other markets", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/11", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Within RCMarket.sol the functions ownerOf and onlyTokenOwner do not check if the _cardId/_token is smaller than numberOfCards. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for isMarketApproved can be circumvented by trying to move the card via another market.  You can still only move cards you own.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338     function ownerOf(uint256 _cardId) public view override returns (address) {         uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards         return nfthub.ownerOf(_tokenId);     }  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313   modifier onlyTokenOwner(uint256 _token) {         require(msgSender() == ownerOf(_token), \"Not owner\"); // _token could be higher than numberOfCards,         _;     }    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,         _checkState(States.WITHDRAW);         require(             !factory.trapIfUnapproved() ||                 factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market             \"Upgrade blocked\"         );         uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market         _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place         nfthub.withdrawWithMetadata(_tokenId);         emit LogNftUpgraded(_card, _tokenId);     }    ## Tools Used  ## Recommended Mitigation Steps Add the following to ownerOf: require(_card < numberOfCards, \"Card does not exist\");   "}, {"title": "1000 as a constant", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact A value of 1000 is used to indicate 100%. This value is hardcoded on several places. It's saver to use a constant, to prevent mistakes in future updates.  ## Proof of Concept .\\RCFactory.sol:    /// @dev in basis points (so 1000 = 100%) .\\RCFactory.sol:                1000, .\\RCMarket.sol:                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) - .\\RCMarket.sol:            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) - .\\RCMarket.sol:            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000); .\\RCMarket.sol:                (1000); .\\RCMarket.sol:            _remainingPot = (totalRentCollected * _remainingCut) / (1000); .\\RCMarket.sol:            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut; .\\RCMarket.sol:            (_rentCollected * _remainingCut) / (1000); .\\RCMarket.sol:            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000); .\\RCMarket.sol:            uint256 _payment = (totalRentCollected * _cut) / (1000);  ## Tools Used grep  ## Recommended Mitigation Steps Replace 1000 with a constant.   "}, {"title": "Checks for enum bounds", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact For the enums Mode and State, checks are made that the variables are within bounds. Here specific size are used, e.g. 2 and 4. If the size of the enums would be changed in the future, those numbers don't change automatically. Also solidity provides in-built check to check that variables are within bounds, which could be used instead. This also make the code more readable.  ## Proof of Concept // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L202 enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE} function initialize(      ...         assert(_mode <= 2);        // can be removed       ...          mode = Mode(_mode);  // this makes sure: 0<=mode<=2   // move to top  https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/interfaces/IRCMarket.sol#L7     enum States {CLOSED, OPEN, LOCKED, WITHDRAW}  // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L1094     function _incrementState() internal {         assert(uint256(state) < 4);                 // can be removed         state = States(uint256(state) + (1));  // this makes sure: 0<=state<=3         emit LogStateChange(uint256(state));     }  ## Tools Used  ## Recommended Mitigation Steps For function initialize: Remove the \"assert(_mode <= 2);\" and move the statement \"mode = Mode(_mode);\" to the top of the function and add a comment  For function _incrementState:  Remove \"assert(uint256(state) < 4);\" and add a comment at \"state = States(uint256(state) + (1));\"  "}, {"title": "improve readability of 1000000 ", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The number 1000000  is used in the constructor of RCTreasury.sol. This is difficult to read in a glance. Solidity allows the use of an underscore ( _ ) to make numbers more readable.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L114 setMaxContractBalance(1000000 ether); // 1m  ## Tools Used  ## Recommended Mitigation Steps  Replace 1000000 with 1_000_000   "}, {"title": "_realitioAddress not used", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The variable _realitioAddress of RCMarket.sol isn't used. The variable realitio seems to used instead. Two variables with the same purpose is confusing.  ## Proof of Concept https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L121     IRealitio public realitio;     address public _realitioAddress;  ## Tools Used  ## Recommended Mitigation Steps Remove     address public _realitioAddress;  "}, {"title": "Use immutable keyword", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/6", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Some of the constructors set values that are never changed. See proof of concept. Its best to use the immutable keyword to make sure they aren't changed by accident.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L38 address public tokenA; address public tokenB;  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L37 IPairFactory public factory; IController  public controller; IERC20  public rewardToken;  ## Tools Used  ## Recommended Mitigation Steps Add the immutable keyword where possible   "}, {"title": "Unchecked ERC20 transfers can cause lock up", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/2", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  axic   # Vulnerability details  ## Impact  Some major tokens went live before ERC20 was finalised, resulting in a discrepancy whether the transfer functions a) should return a boolean or b) revert/fail on error. The current best practice is that they should revert, but return \u201ctrue\u201d on success. However, not every token claiming ERC20-compatibility is doing this \u2014 some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.  Today many tools, including OpenZeppelin, offer a wrapper for \u201csafe ERC20 transfer\u201d: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  RealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the `balancedBooks` modifier:  ```     modifier balancedBooks {         _;         // using >= not == in case anyone sends tokens direct to contract         require(             erc20.balanceOf(address(this)) >=                 totalDeposits + marketBalance + totalMarketPots,             \"Books are unbalanced!\"         );     } ```  This modifier is present on most functions, but is missing on `topupMarketBalance`: ```     function topupMarketBalance(uint256 _amount) external override {         erc20.transferFrom(msgSender(), address(this), _amount);         if (_amount > marketBalanceDiscrepancy) {             marketBalanceDiscrepancy = 0;         } else {             marketBalanceDiscrepancy -= _amount;         }         marketBalance += _amount;     } ```  In the case an ERC20 token which is not reverting on failures is used, a malicious actor could call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings. After this, `deposit`, `withdrawDeposit`, `payRent`, `payout`, `sponsor`, etc. could be locked up and always failing with \u201cBooks are unbalanced\u201d.  ## Proof of Concept  Anyone can call `topupMarketBalance` with some unrealistically large number, so that `marketBalance` does not overflow, but is above the actually helping balances. This is only possible if the underlying ERC20 used is not reverting on failures, but return \u201cfalse\u201d instead.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Use something like OpenZeppelin\u2019s SafeERC20 2. Set up an allow list for tokens, which are knowingly safe 3. Consider a different approach to the `balancedBooks` modifier   "}, {"title": "Gas inefficiency with NativeMetaTransaction and calldata", "html_url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-06-realitycards-findings", "body": "# Handle  axic   # Vulnerability details  ## Impact  In `lib/NativeMetaTransactions.sol` there is a frequently used helper `msgSender`: ```     function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             bytes memory array = msg.data;             uint256 index = msg.data.length;             assembly {                 // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.                 sender := and(                     mload(add(array, index)),                     0xffffffffffffffffffffffffffffffffffffffff                 )             }         } else { ... ```  Even though only the last 20-bytes matter, the `bytes memory array = msg.data;` line causes the *entire* calldata to be copied to memory. This is exaggerated by the fact, that if `msgSender()` is called multiple times in a transaction, the calldata will be also copied multiple times as memory is not freed.  ## Proof of Concept  N/A  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  There are multiple ways to avoid this:  1. Make use of calldata slices and conversions  Something along the lines of (untested!): ```             // Copy last 20 bytes             bytes calldata data = msg.data[(msg.data.length - 20):];             sender = payable(address(uint160(bytes20(data)))); ```  2. Implementing purely in assembly  The OpenZeppelin implementation (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol#L21-L30) is an example of an optimised assembly version: ```             assembly {                 sender := shr(96, calldataload(sub(calldatasize(), 20)))             } ```  3. Combining slices and assembly  One must note that the pure assembly version is obviously the most gas efficient, at least today.   "}, {"title": "Gas optimization on `redeemToken` of `ATokenYieldSource`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  At line 213 of `ATokenYieldSource`, `depositToken()` can be replaced by `_tokenAddress()` to save gas since the former is a public function, while the latter is an internal function.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L213](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L213)  ## Recommended Mitigation Steps  Change `depositToken()` to `_tokenAddress()`.  "}, {"title": "Gas optimization on `_depositToAave`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The function `_depositToAave` of `ATokenYieldSource` calls `_lendingPool` and `_tokenAddress` twice, both of which include function calls to external contracts. Thus, storing the first results into local variables and reuse them for the second time could help save gas.  ## Proof of Concept  Referenced code: [ATokenYieldSource.sol#L175-L182](https://github.com/pooltogether/aave-yield-source/blob/main/contracts/yield-source/ATokenYieldSource.sol#L175-L182)  ## Recommended Mitigation Steps  Store the result of `_tokenAddress()` and `_lendingPool()` to local variables and resue them.  "}, {"title": "User could lose underlying tokens when redeeming from the `IdleYieldSource`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/120", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "IdleYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should.  ## Proof of Concept  When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.  Referenced code: [IdleYieldSource.sol#L129-L131](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L129-L131)  ## Recommended Mitigation Steps  Change `redeemedShare` to `redeemAmount` at line 131.  "}, {"title": "Lack of `nonReentrant` modifier in yield source contracts", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ATokenYieldSource", "IdleYieldSource", "SushiYieldSource", "BadgerYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `YearnV2YieldSource` contract prevents the `supplyTokenTo`, `redeemToken`, and `sponsor` functions from being reentered by applying a `nonReentrant` modifier. Since these contracts share a similar logic, adding a `nonReentrant` modifier to these functions in all of the yield source contracts is reasonable. However, the same protection is not seen in other yield source contracts.  ## Proof of Concept  A `nonReentrant` modifier in the following functions is missing: 1. The `sponsor` function of `ATokenYieldSource` 2. The `supplyTokenTo` and `redeemToken` function of `BadgerYieldSource` 3. The `sponsor` function of `IdleYieldSource` 4. The `supplyTokenTo` and `redeemToken` function of `SushiYieldSource`  Referenced code: [ATokenYieldSource.sol#L233](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/ATokenYieldSource.sol#L233) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [IdleYieldSource.sol#L150](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L150) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Add a `nonReentrant` modifier to these functions. For `BadgerYieldSource` and `SushiYieldSource` contracts, make them inherit from Openzeppelin's `ReentrancyGuardUpgradeable` to use the `nonReentrant` modifier.  "}, {"title": "`onERC721Received` not implemented in `PrizePool`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/118", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `PrizePool` contract does not implement the `onERC721Received` function, which is considered a best practice to transfer ERC721 tokens from contracts to contracts. The absence of this function could prevent `PrizePool` from receiving ERC721 tokens from other contracts via `safeTransferFrom`.  ## Proof of Concept  Referenced code: [PrizePool.sol](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol)  ## Recommended Mitigation Steps  Consider adding an implementation of the `onERC721Received` function in `PrizePool`.  "}, {"title": "Using `transferFrom` on ERC721 tokens", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of `safeTransferFrom`. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.  ## Proof of Concept  Referenced code: [PrizePool.sol#L602](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L602)  ## Recommended Mitigation Steps  Consider changing `transferFrom` to `safeTransferFrom` at line 602. However, it could introduce a DoS attack vector if any winner maliciously rejects the received ERC721 tokens to make the others unable to get their awards. Possible mitigations are to use a `try/catch` statement to handle error cases separately or provide a function for the pool owner to remove malicious winners manually if this happens.  "}, {"title": "SafeMath not completely used in yield source contracts", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/114", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  SafeMath is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: 1. line 78 in `SushiYieldSource` 2. line 67 in `BadgerYieldSource` 3. line 91 and 98 in `IdleYieldSource`  ## Proof of Concept  Referenced code: [SushiYieldSource.sol#L78](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L78) [BadgerYieldSource.sol#L67](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L67) [IdleYieldSource.sol#L91](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L91) [IdleYieldSource.sol#L98](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/IdleYieldSource.sol#L98)  ## Recommended Mitigation Steps  Use the SafeMath library functions in the above lines.  "}, {"title": "Return values of ERC20 `transfer` and `transferFrom` are unchecked", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "SushiYieldSource", "BadgerYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In the contracts `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked to be `true`, which could be `false` if the transferred tokens are not ERC20-compliant (e.g., `BADGER`). In that case, the transfer fails without being noticed by the calling contract.  ## Proof of Concept  If warden's understanding of the `BadgerYieldSource` is correct, the `badger` variable should be the `BADGER` token at address `0x3472a5a71965499acd81997a54bba8d852c6e53d`. However, this implementation of `BADGER` is not ERC20-compliant, which returns `false` when the sender does not have enough token to transfer (both for `transfer` and `transferFrom`). See the [source code on Etherscan](https://etherscan.io/address/0x3472a5a71965499acd81997a54bba8d852c6e53d#code) (at line 226) for more details.  Referenced code: [BadgerYieldSource.sol#L44](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L44) [BadgerYieldSource.sol#L79](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L79) [SushiYieldSource.sol#L48](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L48) [SushiYieldSource.sol#L89](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L89)  ## Recommended Mitigation Steps  Use the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from Openzeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.  "}, {"title": "Unlocked pragma used in multiple contracts", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Most of the contracts use an unlocked pragma (e.g., `pragma solidity ^0.8.0`) which is not fixed to a specific Solidity version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most.  ## Proof of Concept  Referenced code: Please use `grep -R pragma .` to find the unlocked pragma statements.  ## Recommended Mitigation Steps  Lock pragmas to a specific Solidity version. Consider the compiler bugs in the following lists and ensure the contracts are not affected by them. It is also recommended to use the latest version of Solidity when deploying contracts (see [Solidity docs](https://docs.soliditylang.org/en/v0.8.6/)).  Solidity compiler bugs: [Solidity repo - known bugs](https://github.com/ethereum/solidity/blob/develop/docs/bugs.json) [Solidity repo - bugs by version](https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json)  "}, {"title": "Declare functions as `external` to save gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "SushiYieldSource", "BadgerYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Functions (e.g., `supplyTokenTo`, `redeemToken`) in the `BadgerYieldSource` and `SushiYieldSource` can be declared `external` instead of `public` to save gas.  ## Proof of Concept  Referenced code: [BadgerYieldSource.sol#L26](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L26) [BadgerYieldSource.sol#L32](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L32) [BadgerYieldSource.sol#L43](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L43) [BadgerYieldSource.sol#L57](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L57) [SushiYieldSource.sol#L29](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L29) [SushiYieldSource.sol#L35](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L35) [SushiYieldSource.sol#L47](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L47) [SushiYieldSource.sol#L66](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L66)  ## Recommended Mitigation Steps  Change the keyword `public` to `external`.  "}, {"title": "Use ERC-165 instead of homebrew staticcall-based check", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-pooltogether-findings", "body": "Use ERC-165 instead of homebrew staticcall-based check"}, {"title": "IdleYieldSource doesn't use mantissa calculations", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/103", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.  For example, say I deposit 1 token, expecting 1 share in return. On L95, if the totalunderlying assets is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.    ## Proof of Concept https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L95  https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L106  ## Recommended Mitigation Steps Implement mantissa calculations like in the contract for the AAVE  yield.  "}, {"title": "Gas savings on uninitialized variables.", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  tensors   # Vulnerability details  ##Impact Uninitialized variables initialize to 0 automatically. No need to explicitly initialize it.   ##Proof of concept https://github.com/pooltogether/aave-yield-source/blob/bc65c875f62235b7af55ede92231a495ba091a47/contracts/yield-source/ATokenYieldSource.sol#L141  ##Recommended mitigation steps Replace with: `uint256 shares;`  "}, {"title": "CreditBurned event emitted even on zero tokens burned", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  In `PrizePool._updateCreditBalance` the `CreditBurned` event is emitted even if nothing was burned. Not emitting this event when nothing happened can save gas and also seems better semantically.  "}, {"title": "Credit accrual is done twice in `award`", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The credit is accrued twice in `award`. The first accrual happens implicitly when calling `_mint` through the `ControlledToken(controlledToken).controllerMint` call which then performs the `PrizePool.beforeTokenTransfer` hook which accrues credit. Then the explicit accrual is done again. It should be enough to only add the `extraCredit` without doing another accrual (calling `_updateCreditBalance(..., newBalance= _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra)))` instead).  "}, {"title": "SushiYieldSource save gas with pre-approval", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "SushiYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  `SushiYieldSource` should approve the SushiBar once during initialization with the max value. This saves gas on every `supplyTokenTo` call as the approval can be removed from there.  "}, {"title": "ATokenYieldSource save gas with pre-approval", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource", "IdleYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  `ATokenYieldSource` should approve the lending contract once during initialization with the max value. This saves gas on every `supplyTokenTo/_depositToAave` call as the approval can be removed from there.  "}, {"title": "`YieldSourcePrizePool_canAwardExternal` does not work", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/92", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-06-pooltogether-findings", "body": "`YieldSourcePrizePool_canAwardExternal` does not work"}, {"title": "withdraw timelock can be circumvented", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/91", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  One can withdraw the entire `PrizePool` deposit by circumventing the timelock. Assume the user has no credits for ease of computation: - user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This \"mints\" an equivalent `amount` of `timelock` and resets `_unlockTimestamps[user] = timestamp = blockTime + lockDuration`. - user calls `withdrawWithTimelockFrom(user, amount=0)` again but this time withdrawing `0` amount. This will return a `lockDuration` of `0` and thus `unlockTimestamp = blockTime`. The inner `_mintTimelock` now resets `_unlockTimestamps[user] = unlockTimestamp` - As `if (timestamp <= _currentTime()) ` is true, the full users amount is now transferred out to the user in the `_sweepTimelockBalances` call.  ## Impact  Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.  ## Recommended Mitigation Steps  The unlock timestamp should be increased by duration each time, instead of being reset to the duration.  "}, {"title": "`YearnV2YieldSource` wrong subtraction in withdraw", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/90", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  `YearnV2YieldSource._withdrawFromVault` uses a wrong subtraction. When withdrawing from the `vault` one redeems `yTokens` for `token`s, thus the `token` balance of the contract should increase after withdrawal. But the contract subtracts the `currentBalance` from the `previousBalance`:  ```solidity uint256 yShares = _tokenToYShares(amount); uint256 previousBalance = token.balanceOf(address(this)); // we accept losses to avoid being locked in the Vault (if losses happened for some reason) if(maxLosses != 0) {     vault.withdraw(yShares, address(this), maxLosses); } else {     vault.withdraw(yShares); } uint256 currentBalance = token.balanceOf(address(this)); // @audit-issue this seems wrong return previousBalance.sub(currentBalance); ```  ## Impact  All vault withdrawals fail due to the integer underflow as the `previousBalance` is less than `currentBalance`. Users won't be able to get back their investment.  ## Recommended Mitigation Steps  It should return `currentBalance > previousBalance ? currentBalance - previousBalance : 0`  "}, {"title": "ATokenYieldSource mixes aTokens and underlying when redeeming", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ATokenYieldSource.redeemToken` function burns `aTokens` and sends out underlying, however, it's used in a reverse way in the code: The `balanceDiff` is used as the `depositToken` that is transferred out but it's computed on the **aTokens** that were burned instead of on the `depositToken` received.  ## Impact  It should not directly lead to issues as aTokens are 1-to-1 with their underlying but we still recommend doing it correctly to make the code more robust against any possible rounding issues.  ## Recommended Mitigation Steps  Compute `balanceDiff` on the underyling balance (depositToken), not on the aToken. Subtract the actual burned aTokens from the user shares.  "}, {"title": "BadgerYieldSource balanceOfToken share calculation seems wrong", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/84", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "BadgerYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details   When suppling to the `BadgerYieldSource`, some `amount` of `badger` is deposited to `badgerSett` and one receives `badgerSett` share tokens in return which are stored in the `balances` mapping of the user. So far this is correct.  The `balanceOfToken` function should then return the redeemable balance in `badger` for the user's `badgerSett` balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of `badgerSett`) on the `badger` in the vault:  ```solidity balances[addr].mul(   badger.balanceOf(address(badgerSett)) ).div(   badgerSett.totalSupply() ) ```  However, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault (\"Sett\") due to most of the capital being deployed to the _strategies_. Therefore, it under-reports the actual balance:  > Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. [Badger Docs](https://badger-finance.gitbook.io/badger-finance/technical/setts/sett-contract)  ## Impact  Any contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.  ## Recommended Mitigation Steps  It should use [`badgerSett.balance()`](https://github.com/Badger-Finance/badger-system/blob/2b0ee9bd77a2cc6f875b9b984ae4dfe713bbc55c/contracts/badger-sett/Sett.sol#L126) instead of `badger.balanceOf(address(badgerSett))` to also account for \"the balance in the Sett, the Controller, and the Strategy\".  "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/81", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ATokenYieldSource", "SushiYieldSource", "BadgerYieldSource", "PrizePool", "ControlledToken", "StakePrizePool"], "target": "2021-06-pooltogether-findings", "body": "Missing parameter validation"}, {"title": "_depositToAave always returns 0", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract ATokenYieldSource function _depositToAave returns 0 if successful. However, this value is not checked nor used anywhere. As this function is internal it would probably be better to remove this unnecessary return to save some gas and eliminate confusion.  ## Recommended Mitigation Steps refactor function _depositToAave to return void.  "}, {"title": "Uneven use of events", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact To track off-chain data it is necessary to use events  ## Proof of Concept  In  ATokenYieldSource.sol, IdleYieldSource.sol, yearnV2yieldsource  : events are emmitted in supplyTokenTo(), redeemToken() sponsor(), but not in  BadgerYieldsource.sol and shushiyieldsource.sol     ## Tools Used  Manual analysis  ## Recommended Mitigation Steps use events   "}, {"title": "Various gas optimizations", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  # General Gas optimization  ## Upgrade to at least 0.8.4 (even better is 0.8.5)  The following should lead to better gas savings:    - The inliner should decrease runtime gas.   - Inbuilt safemath instead of openzeppelin safemath should save some gas.   - Various improvement in the expression simplifier in the compiler throughout (0.7.0 - 0.8.5)     which should decrease both runtime and deploy time costs. (I'm assuming that the project     currently uses 0.6.12, since the compiler version was not explicitly specified.)  Of course, these improvements comes when optimizer is enabled, preferably with a high `--optimize-runs` value.  Note that the `inliner` in particular can be quite useful for the contract, since the contracts sometimes generously chains small functions.  ## Use custom errors instead of large revert strings  Saves both deploy time and runtime gas (runtime gas is only relevant when the revert condition is met.)  Need at least solidity 0.8.4 for this feature.  ### Use shorter revert strings  If you decide to not use custom errors, then try to use revert strings of size at most 32 characters.  For one, shorter strings would save deploy cost (one time saving of 200 gas per byte / character decreased). Also strings more than 32 bytes requires an additional `mstore`, two additional `push`, and an `add`. Roughly, 18 more gas during runtime (when revert condition is met).  Example string (33 bytes), from ControlledToken.sol  ``` solidity uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, \"ControlledToken/exceeds-allowance\"); ```  # Specific Gas optimizations  ## Use `immutable`  For state variables that are only assigned in constructors, change it to `immutable`.  This saves an `sload` each time the variable is accessed. Can save around 2100 gas (or 100 depending on warm / cold.)  Examples:  ### StakePrizePool.sol  ``` diff modified   contracts/StakePrizePool.sol @@ -8,7 +8,7 @@ import \"../PrizePool.sol\";   contract StakePrizePool is PrizePool {  -  IERC20Upgradeable private stakeToken; +  IERC20Upgradeable immutable private stakeToken;     event StakePrizePoolInitialized(address indexed stakeToken); ```  ### ControlledToken.sol  ``` diff contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {     /// @notice Interface to the contract responsible for controlling mint/burn -  TokenControllerInterface public override controller; +  TokenControllerInterface public immutable override controller; ```  ### yield-source/YearnV2YieldSource.sol  ``` diff @@ -24,7 +24,7 @@ contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeabl      /// @notice Yearn Vault which manages `token` to generate yield      IYVaultV2 public vault;      /// @dev Deposit Token contract address -    IERC20Upgradeable internal token; +    IERC20Upgradeable immutable internal token;      /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS      uint256 public maxLosses = 0; // 100% would be 10_000 ```  This change would likely require changing the initialization pattern. See the section below for details.  Similarly, several such variables can be changed. Not listing everything here.  ## Avoiding the `initialize` pattern  If elements can be initialized in the constructor, or via calls to internal functions in constructor, instead of the public `initialize` function, it should be possible to save deployment costs. On top of that, since the `initialize` function won't be part of the function dispatch in the contract, one could save some gas at run time for some calls (saves approximately two `push`, an `eq` and a `jumpi`.)  Another benefit for this is that several state variables can be converted to immutables. Again, saves `sload` costs during runtime.  Also, it might also be possible to change `initialize` from `public` to `internal`.  ## `_msgSender()` (Possible micro optimization)  Use `msg.sender` instead of `_msgSender()`. The latter might not be inlined by the compiler. (This is for cases where `_msgSender()` function simply returns `msg.sender`.) Can save around 30 gas (2 `JUMP`, plus some `PUSH` and some stack operations.)  Also, the contracts seem to mix `_msgSender()` and `msg.sender`, for example in `PrizePool.sol`. This could be avoided.  ## Use `decreaseAllowance` in ControllerToken.sol  ``` diff @@ -58,8 +58,7 @@ contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {    /// @param _amount Amount of tokens to burn    function controllerBurnFrom(address _operator, address _user, uint256 _amount) external virtual override onlyController {      if (_operator != _user) { -      uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, \"ControlledToken/exceeds-allowance\"); -      _approve(_user, _operator, decreasedAllowance); +      decreaseAllowance(_user, _operator, _amount);      }      _burn(_user, _amount);    } ```  Will be slightly more gas efficient than the first once.  # General comments  ## Try to avoid `super` if possible  For example, in Ticket.sol:  ``` solidity   public   virtual   override   initializer {   super.initialize(_name, _symbol, _decimals, _controller); ```  The above usage of `super` is unnecessary. Unless you are dealing with multiple inheritance, where `super` is absolutely required, there is no need to use super, instead of statically specifying the name of the parent contract. There is however no performance penalty in using `super` instead of a static call to the parent.  ## Several `balance` related function can be made `view`?  In PrizePool, the function `function balance() external returns (uint256)` can perhaps be made `view`. This would also mean that a few other internal functions should be made `view`, such as `_balance`.   "}, {"title": "Using memory[] parameter without checking its length", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Using memory array parameters (e.g. uint[] memory) as function parameters can be tricky in Solidity, because an attack is possible with a very large array which will overlap with other parts of the memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L219  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L639   This an example to show the exploit:  // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol  pragma solidity ^0.4.24; // only works with low solidity version  contract test{     struct Overlap {         uint field0;     }     event log(uint);    function mint(uint[] memory amounts) public  returns (uint) {   // this can be in any solidity version        Overlap memory v;        v.field0 = 1234;        emit log(amounts[0]); // would expect to be 0 however is 1234        return 1;      }    function go() public { // this part requires the low solidity version       uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251       bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x);       bool success=address(this).call(payload);   } }     ## Tools Used  manual analysis  ## Recommended Mitigation Steps check the array length before using it  "}, {"title": "safeApprove() for Yearn Vault may revert preventing deposits causing DoS", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The _depositInVault() function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract\u2019s token balance.  However, the\u00a0safeApprove\u00a0function\u00a0prevents changing an allowance between non-zero values\u00a0to mitigate a\u00a0possible front-running attack. It reverts if that is the case. Instead, the\u00a0safeIncreaseAllowance\u00a0and\u00a0safeDecreaseAllowance\u00a0functions should be used. Comment from the OZ library for this function: \u201c// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and \u2018safeDecreaseAllowance'\"  Impact: If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user\u2019s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible.  ## Proof of Concept  Reference: See similar Medium-severity finding M03 here: https://blog.openzeppelin.com/1inch-exchange-audit/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L173  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6842518b1b71fac9a21c7d94ec521992cff266b5/contracts/token/ERC20/utils/SafeERC20.sol#L44-L57   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use safeIncreaseAllowance()\u00a0function instead of safeApprove().  "}, {"title": "Ignored return values may lead to undefined behavior", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-06-pooltogether-findings", "body": "Ignored return values may lead to undefined behavior"}, {"title": "Overly permissive threshold check allows high yield loss", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-pooltogether-findings", "body": "Overly permissive threshold check allows high yield loss"}, {"title": "Lack of event emission after critical initialize() functions", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, Ticket.sol nor its base class ControlledToken.sol emit such an event in their initialize() functions.  Impact: These contracts are initialized but their critical init parameters (name, symbol, decimals and controller address) are not logged for any off-chain monitoring.  ## Proof of Concept  See similar Medium-severity Finding M01 in OpenZeppelin\u2019s audit of UMA protocol: https://blog.openzeppelin.com/uma-audit-phase-4/  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/Ticket.sol#L24-L37  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/ControlledToken.sol#L22-L36  Examples of event emission: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L47   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit an initialised event in Ticket.sol and ControlledToken.sol logging their init parameters.  "}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/65", "labels": ["bug", "duplicate", "1 (Low Risk)", "ATokenYieldSource", "IdleYieldSource", "YearnV2YieldSource", "SushiYieldSource", "BadgerYieldSource", "PrizePool", "ControlledToken", "YieldSourcePrizePool", "StakePrizePool"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Zero-address checks as input validation closest to the function beginning is a best-practice. There are two places where an explicit zero-address check is missing which may lead to a later revert, gas wastage or even token burn.  ## Proof of Concept  1. Explicit zero-address check is missing here for _newYieldSource  and will revert later down the control flow on L256: https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L269  https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L256   2. Missing zero-address check on \u2018to\u2019 address will lead to token burn because imBalances accounts it for the zero-address from which it can never be redeemed using msg.sender: https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L85  https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L94   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add explicit zero-address checks closest to the function entry.  "}, {"title": "Missing calls to init functions of inherited contracts", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "ATokenYieldSource", "IdleYieldSource", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Most contracts use the delegateCall proxy pattern and hence their implementations require the use of initialize() functions instead of constructors. This requires derived contracts to call the corresponding init functions of their inherited base contracts. This is done in most places except a few.  Impact: The inherited base classes do not get initialized which may lead to undefined behavior.   ## Proof of Concept  Missing call to __ReentrancyGuard_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/ATokenYieldSource.sol#L99-L102  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  Missing call to__ERC20_init: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L59-L61  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L83-L86   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing calls to init functions of inherited contracts.  "}, {"title": "Actual yield source check on address will succeed for non-existent contract", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "YieldSourcePrizePool", "MitigationStarted"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall\u00a0return\u00a0true\u00a0even if the account called is non-existent (per EVM design). Solidity documentation warns: \"The low-level functions\u00a0call, delegatecall\u00a0and staticcall return\u00a0true\u00a0as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\u201d  The staticcall here will return True even if the _yieldSource contract doesn't exist at any incorrect-but-not-zero address, e.g. EOA address, used during initialization by accident. Impact: The hack, as commented, to check if it\u2019s an actual yield source contract will fail if the address is indeed a contract account which doesn\u2019t implement the depositToken function. However, if the address is that of an EOA account, the check will pass here but will revert in all future calls to the yield source forcing contract redeployment after the pool is active. Users will not be able to interact with the pool and abandon it.  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.6/control-structures.html#error-handling-assert-require-revert-and-exceptions  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/YieldSourcePrizePool.sol#L41-L45  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  A contract existence check should be performed on _yieldSource prior to the depositToken function existence hack for determining yield source contract.  "}, {"title": "Missing modifier onlyControlledToken may result in undefined/exceptional behavior", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "PrizePool"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The modifier onlyControlledToken is used for functions that allow the controlledToken address as a parameter to ensure that only whitelisted tokens (ticket and sponsorship) are provided. This is used in all functions except calculateEarlyExitFee().  Impact: The use of a non-whitelisted controlledToken will result in calls to potentially malicious token contract and cause undefined behavior for the `from` user address specified in the call.  ## Proof of Concept  Missing modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L729-L747  Modifier: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1105-L1110  All other functions which accept controlledToken parameter have modifier onlyControlledToken: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L327  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L378  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L498  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L888  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L903  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add missing modifier onlyControlledToken to calculateEarlyExitFee().   "}, {"title": "Named return values are never used in favor of explicit returns", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Named return values in multiple functions are never used in favor of explicit returns.   Impact: This affects readability/auditability at the least and could potentially result in unexpected values being returned along paths with no explicit returns.  ## Proof of Concept  Unused in favor of explicit return:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L717-L726  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L741-L744  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L770  Used without explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L923-L930  Used with explicit return:  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L944-L947   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused named returns where unnecessary. Be consistent in using named vs explicit returns.  "}, {"title": "The assumption that operator == to (user) may not hold leading to failed timelock deposits", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-06-pooltogether-findings", "body": "The assumption that operator == to (user) may not hold leading to failed timelock deposits"}, {"title": "Switch modifier order to consistently place the nonreentrant modifier as the first one", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  If a function has multiple modifiers they are executed in the order specified. If checks or logic of modifiers depend on other modifiers this has to be considered in their ordering. PrizePool has functions with multiple modifiers with one of them being nonreentrant which prevents reentrancy on the functions. This should ideally be the first one to prevent even the execution of other modifiers in case of reentrancies.  While there is no obvious vulnerability currently with nonreentrant being the last modifier in the list, it is safer to place it in the first. This is of slight concern with the deposit functions which have the canAddLiquidity() modifier (before nonreentrant) that makes external calls to get totalSupply of controlled tokens.  ## Proof of Concept  For reference, see similar finding in Consensys\u2019s audit of Balancer : https://consensys.net/diligence/audits/2020/05/balancer-finance/#switch-modifier-order-in-bpool  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L275-L277  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L299-L301   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Switch modifier order to consistently place the nonreentrant modifier as the first one to run so that all other modifiers are executed only if the call is nonreentrant.  "}, {"title": "Caching sushiAddr and sushiBar in local variables to save 200 gas in supplyTokenTo()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "SushiYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Caching sushiAddr and sushiBar in local variables right at the beginning of supplyTokenTo() (similar to what's done in redeemToken) can save 100 gas from repeat SLOADs for each of them for a total savings of 200.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/SushiYieldSource.sol#L48-L51  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Caching sushiAddr and sushiBar in local variables at the beginning of supplyTokenTo() and use those instead.  "}, {"title": "maxLosses can be cached in a local variable to save 100 gas in _withdrawFromVault()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  maxLosses state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L187-L188  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxLosses in a local variable at the beginning of the function and use that instead.  "}, {"title": "token can be cached in a local variable to save 100 gas in _withdrawFromVault()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in two places in _withdrawFromVault(). It can be cached in a local variable  at the beginning of the function to save 100 gas from one repeated SLOAD.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L185  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L192   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  "}, {"title": "token can be cached in a local variable to save 200 gas in _depositInVault()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  token state variable is used in three places in _depositInVault(). It can be cached in a local variable  at the beginning of the function to save 200 gas from two repeated SLOADs.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L172  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache token in a local variable  at the beginning of the function and use that instead.  "}, {"title": "Using function parameter in initialize() instead of state variable saves 100 gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Using parameter _vault instead of SLOAD of state variable vault in the call to safeApprove() leads to gas savings of 100.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L87  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L67  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Using parameter _vault instead of state variable vault in the call to safeApprove()  "}, {"title": "Zero-address check unnecessary due to the initializer modifier", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  YearnV2YieldSource initialize does a zero-address check for value address to detect if it has already been initialized. This is an unnecessary check because vault address default value is zero, it is not initialized/set anywhere else and the initializer modifier will prevent the calling of initialize() a second time. So vault is guaranteed to be zero in initialize().  The impact is gas wastage from an additional SLOAD of vault state variable and the require() check.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L25  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L73  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the zero-address check for vault.  "}, {"title": "Caching badger and badgerSett can save 400 gas in supplyTokenTo()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  State variables badger and badgerSett addresses are read two and four times respectively in supplyTokenTo(). Caching them in local variables at the beginning of the function and using those local variables can save 400 gas from avoiding 3 repeated SLOADs for badgerSett and 1 repeated SLOAD for badger.  Impact: Gas savings of 400  ## Proof of Concept  Two badger reads: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L44-L45  Four badgerSett reads:   https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L45  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L47  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L48  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/BadgerYieldSource.sol#L49  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache badger and badgerSett state variables in local variables at the beginning of the function and use those local variables instead.  "}, {"title": "Gas savings of (100*loop-iteration-count) by caching _tokens.end() in _tokenTotalSupply()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The loop iteration in _tokenTotalSupply() ends when currentToken matches _tokens.end() where _tokens is a state variable.  Impact: Checking against the state variable for every iteration costs 100 gas per iteration. Even with only two controlled tokens (tickets & sponsorship), this costs 100 more than caching this in a local memory variable and using that within the while predicate.   ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L177   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _tokens.end() in a local memory variable before the loop and using that within the while predicate.  "}, {"title": "Preventing zero-address controlled tokens from being added can avoid checks later", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "PrizePool"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  When _tokenTotalSupply() adds up the supplies of all controlled tokens, it checks and skips zero-address tokens. Instead of checking for zero-address every time for every call to _tokenTotalSupply() from captureAwardBalance() and every deposit via canAddLiquidity modifier, preventing zero-address controlled-token addresses from being added in _addControlledToken() during initialization will avoid these checks.  Impact: All deposit calls which cost 0.5M gas currently will be impacted by these unnecessary checks if we instead perform it one time during the addition of tokens in initialization.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1059  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L228-L230  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move zero-address check from time of use to time of adding the tokens into the list in initialize().  "}, {"title": "Unnecessary indirection to access block.timestamp value", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-pooltogether-findings", "body": "Unnecessary indirection to access block.timestamp value"}, {"title": "Gas savings of 100 by caching maxTimelockDuration in _calculateTimelockDuration()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  State variable maxTimelockDuration is read twice on consecutive lines 723 and 724 of function _calculateTimelockDuration(). Caching it in a local variable will save 100 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L723-L724   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache maxTimelockDuration in a local variable in the beginning of the function.  "}, {"title": "Gas savings of 100 per user by caching _timelockBalances[user] in _sweepTimelockBalances()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Mapping state variable value _timelockBalances[user] is read on consecutive lines 655 and 656 resulting in 2 SLOADS (2100 + 100 gas).   Impact: Caching this in a local variable would save ~= 100 gas savings per user iteration (by converting the use of the second 100-gas costing SLOAD to 1 MSTORE and 1 MLOAD both of which only cost 3 gas). If there are 1000 users in a call to sweepTimelockBalances(), this could be significant savings of 100,000 gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L655-L656   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _timelockBalances[user] in a local variable before using on lines 655 and 656.  "}, {"title": "Using access lists can save gas due to EIP-2930 post-Berlin hard fork", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  EIP-2929 in Berlin fork increased the gas costs of SLOADs and CALL* family opcodes increasing them for not-accessed slots/addresses and decreasing them for accessed slots. EIP-2930 optionally supports specifying an access list (in the transaction) of all slots and addresses accessed by the transaction which reduces their gas cost upon access and prevents EIP-2929 gas cost increases from breaking contracts.   Impact: Considering these changes may significantly impact gas usage for transactions that call functions touching many state variables or making many external calls. Specifically, removeUserActiveBlocks() removes an active block from the array of blocks for an user, all of which are stored in storage. Transactions for fulfill() and cancel() functions that call removeUserActiveBlocks()  can consider using access lists for all the storage state (of user\u2019s active blocks) they touch (read + write) to reduce gas.   ## Proof of Concept  https://eips.ethereum.org/EIPS/eip-2929  https://eips.ethereum.org/EIPS/eip-2930  https://hackmd.io/@fvictorio/gas-costs-after-berlin  https://github.com/gakonst/ethers-rs/issues/265  SLOADs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L580  SSTOREs: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L583  Calls: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L346  https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L490   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the feasibility of using access lists to save gas due to EIPs 2929 & 2930 post-Berlin hard fork. The tooling support is WIP.  "}, {"title": "Gas savings of 300 by caching _currentAwardBalance in captureAwardBalance()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Cache _currentAwardBalance state variable in a local variable for computation to save gas. 4 SLOADs + 1 SSTORE can be reduced to 1 SLOAD and 1 STORE.   Impact: Saves 300 gas from avoid 3 SLOADs because each SLOAD to already accessed storage slot costs 100.  ## Proof of Concept  2 SLOADs: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L456  1 SSTORE + 1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L465  1 SLOAD: https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L470   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache _currentAwardBalance in a local variable in the beginning, use that for computation/return and one updation to state variable at the end.  "}, {"title": "Simplifying extensible but expensive modifier may save gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The canAddLiquidity modifier, which is used on all deposits (each deposit costs 0.5M gas), appears to be an expensive modifier because it calculates the sum of all the supplies across controlled tokens (by making external CALLs) and adding that up with reserve and timelock supplies. While this is an extensible implementation that supports arbitrary number of controlled tokens via mapped singly linked list, the prize pools typically have only two controlled tokens: tickets and sponsorship.   Impact: deposits currently cost 0.5M gas.  ## Proof of Concept  https://docs.pooltogether.com/protocol/overview#gas-usage  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L276  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L300  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1119-L1122  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1069-L1072  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L1054-L1064  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider gas profiling a fast-path calculation by keeping a separate state variable that tracks the sum of timelock+reserve along with all deposits made towards controlled token supplies and comparing new deposits with that state variable instead of reevaluating totals during each deposit. The extra SLOADs, CALLs and other expensive operations (in linked list and other logic) during reevaluation may add up to more than updating this proposed new state variable across different operations.  "}, {"title": "Avoid use of state variables in event emissions to save gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase.  ## Proof of Concept  The Initialized event in PrizePool uses state variables maxExitFeeMantissa and maxTimelockDuration instead of using the equivalent function parameters _maxExitFeeMantissa and _maxTimelockDuration which were just used to set these state variables. Using them instead will save 2 extra SLOADs, leading to gas savings of 200.  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L239-L243  The StakePrizePoolInitialized event uses state variable stakeToken instead of the function parameter _stakeToken used to set it. Using that instead will save 100 gas.  \u2028\u2028https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/StakePrizePool.sol#L36-L38\u2028  The IdleYieldSourceInitialized similarly uses idleToken instead of _idleToken.\u2028\u2028  https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/IdleYieldSource.sol#L62-L66  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use equivalent function parameters or local variables in event emits instead of state variables.  "}, {"title": "Upgrading the solc compiler to >=0.8 may save gas", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-06-pooltogether-findings", "body": "Upgrading the solc compiler to >=0.8 may save gas"}, {"title": "Gas Optimization: PrizePool._calculateCreditBalance.creditBalance is incorrectly passed by reference rather than passed by value, causing unnecessary SLOADs instead of MLOADs", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool._calculateCreditBalance.creditBalance is incorrectly declared as storage rather than as memory, causing unnecessary SLOADs instead of MLOADs. [1]  PrizePool._calculateCreditBalance() is declared as a view function, so we know definitively that PrizePool._calculateCreditBalance.creditBalance is not modified within the function. [2]  Since PrizePool._calculateCreditBalance.creditBalance is not modified within the function, then when we fetch it, we want to pass it by value and not by reference by declaring it as 'CreditBalance memory creditBalance' rather than 'CreditBalance storage creditBalance'.   This way, each of the subsequent reads of the creditBalance are read from memory (MLOAD) rather than read from storage (SLOAD), where MLOAD is cheaper than SLOAD.  ## Recommended Mitigation Steps  Change this:  CreditBalance storage creditBalance  To this:  CreditBalance memory creditBalance   [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L825  [2] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L823  "}, {"title": "PrizePool.beforeTokenTransfer() incorrectly uses msg.sender in seven places instead of _msgSender()", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-pooltogether-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact PrizePool.beforeTokenTransfer() incorrectly uses msg.sender in seven places instead of _msgSender(). [1]  Nearly all of PrizePool.sol opts to use _msgSender() to provide for more optionality.   It appears that PrizePool.beforeTokenTransfer() may have been copy/pasted into PrizePool.sol without adjusting msg.sender to use _msgSender().  ## Recommended Mitigation Steps  Replace the seven instances of msg.sender in PrizePool.beforeTokenTransfer() with _msgSender()  [1] https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L418  "}, {"title": "function _getRefferalCode() can be refactored to a constant variable", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "ATokenYieldSource"], "target": "2021-06-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _getRefferalCode() in ATokenYieldSource just returns a constant of uint16(188). To save some gas and improve the readability this can be extracted to a constant variable and used where necessary.  ## Recommended Mitigation Steps  uint16 internal constant REFFERAL_CODE = uint16(188);  "}, {"title": "modifier canAddLiquidity and function _canAddLiquidity", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact modifier canAddLiquidity calls internal function _canAddLiquidity. This function is not called anywhere else so I do not see a reason why all the logic can't be moved to the modifier to save some gas by reducing the extra call.  ## Recommended Mitigation Steps Remove function _canAddLiquidity, place its logic directly in the canAddLiquidity modifier.  "}, {"title": "_accrueCredit -> _updateCreditBalance", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-pooltogether-findings", "body": "_accrueCredit -> _updateCreditBalance"}, {"title": "setPrizeStrategy check for Interface Supported in PrizePool.sol doesn't guarantee that the new prize strategy is valid", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-06-pooltogether-findings", "body": "setPrizeStrategy check for Interface Supported in PrizePool.sol doesn't guarantee that the new prize strategy is valid"}, {"title": "staticCall to yieldSource.depositToken doesn't provide any security guarantees", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/14", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-pooltogether-findings", "body": "staticCall to yieldSource.depositToken doesn't provide any security guarantees"}, {"title": "currentTime() outside of loop", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/11", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-06-pooltogether-findings", "body": "currentTime() outside of loop"}, {"title": "What is default duration when creditRateMantissa is not set", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/10", "labels": ["bug", "1 (Low Risk)"], "target": "2021-06-pooltogether-findings", "body": "What is default duration when creditRateMantissa is not set"}, {"title": "Use immutable keyword", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/7", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "Use immutable keyword"}, {"title": "function sponsor not allways present", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/6", "labels": ["bug", "0 (Non-critical)"], "target": "2021-06-pooltogether-findings", "body": "function sponsor not allways present"}, {"title": "no check for _stakeToken!=0", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/4", "labels": ["bug", "1 (Low Risk)"], "target": "2021-06-pooltogether-findings", "body": "no check for _stakeToken!=0"}, {"title": "uint256(-1)", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact uint256(-1) is used in the function initialize of PrizePool.sol to indicate the max uint256 value. Solidity also allows type(uint256).max), which is easier to read.  ## Proof of Concept // https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/PrizePool.sol#L233 function initialize ( ...     _setLiquidityCap(uint256(-1));  ## Tools Used  ## Recommended Mitigation Steps Replace uint256(-1) with: type(uint256).max)  "}, {"title": "cache and reuse _vault.apiVersion() result", "html_url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "YearnV2YieldSource"], "target": "2021-06-pooltogether-findings", "body": "cache and reuse _vault.apiVersion() result"}, {"title": "Add reentracy protections on function `executeTrade`", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/143", "labels": ["bug", "2 (Med Risk)", "sponsor dispute"], "target": "2021-06-tracer-findings", "body": "Add reentracy protections on function `executeTrade`"}, {"title": "The `currentHour` variable in `Pricing` could be out of sync", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/142", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `recordTrade` function in `Pricing` updates the `currentHour` variable by 1 every hour. However, if there is no trade (i.e., the `recordTrade` is not called) during this hour, the `currentHour` is out of sync with the actual hour. As a result, the `averagePriceForPeriod` function uses the prices before 24 hours and causes errors on the average price.  ## Proof of Concept  Referenced code: [Pricing.sol#L90-L94](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L90-L94)  ## Recommended Mitigation Steps  Calculate how much time passed (e.g., `(block.timestamp - startLastHour) / 3600`) to update the `currentHour` variable correctly.  "}, {"title": "Margin value is not checked to be non-negative in `leveragedNotionalValue`", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/141", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-tracer-findings", "body": "Margin value is not checked to be non-negative in `leveragedNotionalValue`"}, {"title": "The `averagePriceForPeriod` function may revert without proper error message returned", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `averagePriceForPeriod` function of `LibPrices` does not handle the case where `j` equals 0 (i.e., no trades happened in the last 24 hours). The transaction reverts due to dividing by 0 without a proper error message returned.  ## Proof of Concept  Referenced code: [LibPrices.sol#L73](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPrices.sol#L73)  ## Recommended Mitigation Steps  Add `require(j > 0, \"...\")` before line 73 to handle this special case.  "}, {"title": "`Prices.averagePrice` does not show a difference between no trades and a zero price", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `getHourlyAvgTracerPrice` and `getHourlyAvgOraclePrice` functions in `Pricing` return 0 if there is no trade during the given `hour` because of the design of `averagePrice`, which could mislead users that the hourly average price is 0. The same problem happens when emitting the old hourly average in the `recordTrade` function.  ## Proof of Concept  Referenced code: [Pricing.sol#L254-L256](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L254-L256) [Pricing.sol#L262-L264](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L262-L264) [Pricing.sol#L74](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L74)  ## Recommended Mitigation Steps  Return a special value (e.g., `type(uint256).max`) from `averagePrice` if there is no trade during the specified hour to distinguish from an actual zero price. Handle this particular value whenever the `averagePrice` function is called by others.  "}, {"title": "Unlocked pragma used in multiple contracts", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/133", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "Unlocked pragma used in multiple contracts"}, {"title": "Gas savings in verifyAndSubmitLiquidation()", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Liquidation.verifyAndSubmitLiquidation(...) we can save the minimumMargin to memory since it's called two times.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L171  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Save the result of Balances.minimumMargin(...) to memory.  "}, {"title": "Missing validation on calculateTWAP", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/130", "labels": ["bug", "invalid", "sponsor dispute"], "target": "2021-06-tracer-findings", "body": "Missing validation on calculateTWAP"}, {"title": "Change claimEscrow() to external", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The claimEscrow(...) function in Liquidation.sol can be set external instead of public since it's not used in the contract. (code clarity and gas savings)  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L109  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change public to external.  "}, {"title": "Logic error in fee subtraction", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/127", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In LibBalances.applyTrade() we need to collect a fee from the trade. The current code however subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see TracerPerpetualSwaps.sol#L272). This issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L187  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change +fee to -fee in the highlighted line.  "}, {"title": "Gas savings in getPoolFundingRate()", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact We can save gas by substituting getPoolTarget() with levNotionalValue/100, since tracer.leveragedNotionalValue() is already saved in memory.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L216  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Substitute getPoolTarget() with levNotionalValue/100.  "}, {"title": "State variable not used", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/122", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact State variable perpsFactory is not used in the Insurance contract.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L18  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Just delete it.  "}, {"title": "Superfluous verifySignature function", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/121", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In the trader contract isValidSignature(...) and verifySignature(...) serve the same purpose. Suggested keep only one for code clarity.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L206 https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L231  ## Tools Used Manual analysys  ## Recommended Mitigation Steps Suggested keep only one function for code clarity.  "}, {"title": "Use EIP-1167 in order to deploy new perpetual swap contracts", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  For every new TracerPerpetualSwaps contract, we need to deploy a new Liquidation, Insurance, and Pricing contract.  All these deployments are really gas-intensive, so it would be recommended to use EIP-1167: Minimal Proxy Contract to reduce the gas cost of the deployments.  ```solidity function _deployTracer(         bytes calldata _data,         address tracerOwner,         address oracle,         address fastGasOracle,         uint256 maxLiquidationSlippage     ) internal returns (address) {         // Create and link tracer to factory         address market = IPerpsDeployer(perpsDeployer).deploy(_data);         ITracerPerpetualSwaps tracer = ITracerPerpetualSwaps(market);          validTracers[market] = true;         tracersByIndex[tracerCounter] = market;         tracerCounter++;          // Instantiate Insurance contract for tracer         address insurance = IInsuranceDeployer(insuranceDeployer).deploy(market);         address pricing = IPricingDeployer(pricingDeployer).deploy(market, insurance, oracle);         address liquidation = ILiquidationDeployer(liquidationDeployer).deploy(             pricing,             market,             insurance,             fastGasOracle,             maxLiquidationSlippage         );          // Perform admin operations on the tracer to finalise linking         tracer.setInsuranceContract(insurance);         tracer.setPricingContract(pricing);         tracer.setLiquidationContract(liquidation);          // Ownership either to the deployer or the DAO         tracer.transferOwnership(tracerOwner);         ILiquidation(liquidation).transferOwnership(tracerOwner);         emit TracerDeployed(tracer.marketId(), address(tracer));         return market;     } ```   More info: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/ https://eips.ethereum.org/EIPS/eip-1167   "}, {"title": "Wrong trading pricing calculations", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/119", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In the Pricing contract, an agent can manipulate the trading prices by spamming an high amount of trades.  Indeed an agent can create an high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls Trader.executeTrade; now every order calls a Pricing.recordTrade using the arbitrary price set by the agent.  Since the trades are all made in the same hour, by the way hourlyTracerPrices[currentHour] is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the fundingRates and the fairPrice, letting a malicious agent get the ability to manipulate the market.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L129  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Pass the fillAmount parameter to recordTrade(...), and calculate hourlyTracerPrices[currentHour].trades summing fillAmount instead of 1 every trade.  "}, {"title": "Unnecessary type conversions", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/118", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact Superfluous type conversions.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L229-L230 The type conversion here is not necessary.  ## Recommended Mitigation Steps Remove the type conversion.  "}, {"title": "Missing checks for lowestMaxLeverage < maxLeverage and insurancePoolSwitchStage < deleveragingCliff", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/117", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The contract TracerPerpetualSwaps introduces these four state variables (lowestMaxLeverage,  maxLeverage, insurancePoolSwitchStage and deleveragingCliff) and four respective set functions. Logically the following relations are needed: lowestMaxLeverage < maxLeverage and insurancePoolSwitchStage < deleveragingCliff, but the code doesn't check for them.  Non-critical because needs an error by the owner.  ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L552 Also lines L560, L564, L568  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add appropriate requires to the set functions and the constructor.  "}, {"title": "Underflow problems occurring when a token has >18 decimals", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/116", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact The contracts assume that all tokens will have <=18 decimals. If the Tracer team are the only people deploying the contracts, and they keep this in mind, this isn't a problem. If the contracts are to be deployed by other people, this assumption should be made explicit and hard-coded.   ## Proof of Concept https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L220-L232 We can see that the scaler computations will underflow and be defined when it should not be.  ## Recommended Mitigation Steps Write a require check that ensures tokenDecimals <= 18 before running the above functions.  "}, {"title": "No check transferFrom() return value", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  s1m0   # Vulnerability details  ## Impact The smart contract doesn't check the return value of token.transfer() and token.transferFrom(), some erc20 token might not revert in case of error but return false. In the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. Other places: [TracerPerpetualSwaps: withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L203) [TracerPerpetualSwaps:withdrawFees](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L514) [SafetyWithdraw:withdrawERC20Token](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/SafetyWithdraw.sol#L13) [Insurance:withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L97)  ## Recommended Mitigation Steps Wrap the call into a require() or use openzeppelin's [SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) library.  "}, {"title": "inclusive check that account is not above minimum margin", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Here the check currentMargin < Balances.minimumMargin should be inclusive <= to indicate the account is not above minimum margin:     require(         currentMargin <= 0 ||             uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),         \"LIQ: Account above margin\"     );  ## Recommended Mitigation Steps uint256(currentMargin) <= Balances.minimumMargin ...  "}, {"title": "amountToReturn > receipt.escrowedAmount could be inclusive", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Could save some gas here when amountToReturn = receipt.escrowedAmount:     if (amountToReturn > receipt.escrowedAmount) {        liquidationReceipts[receiptId].escrowedAmount = 0;     } else {        liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;     }  ## Recommended Mitigation Steps  if (amountToReturn >= receipt.escrowedAmount) { ...  "}, {"title": "Wrong funding index in settle when no base?", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TracerPerpetualSwaps.settle` function updates the user's last index to `currentGlobalFundingIndex`, however a comment states:  > \"// Note: global rates reference the last fully established rate (hence the -1), and not the current global rate. User rates reference the last saved user rate\"  The code for the `else` branch also updates the last index to `currentGlobalFundingIndex - 1` instead of `currentGlobalFundingIndex`.  ```solidity if (accountBalance.position.base == 0) {     // set to the last fully established index     // @audit shouldn't this be global - 1 like below?     accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;     accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer(); } ```   ## Impact It might be possible that first-time depositors skip having to pay the first funding rate period as the `accountLastUpdatedIndex + 1 < currentGlobalFundingIndex` check will still return `false` when the funding rates are updated the next time.  ## Recommended Mitigation Steps Check if setting it to `currentGlobalFundingIndex` or to `currentGlobalFundingIndex - 1` is correct.  "}, {"title": "Insurance slippage reimbursement can be used to steal insurance fund", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/105", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Liquidation` contract allows the liquidator to submit \"bad\" trade orders and the insurance reimburses them from the insurance fund, see `Liquidation.claimReceipt`. The function can be called with an `orders` array which does not check for duplicate orders. An attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.  Example: - Attacker uses two accounts, one as the liquidator and one as the liquidatee. - They run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.) - Liquidator liquidates liquidatee - They now do two trades:   - One \"good\" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade   - One \"bad\" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade - The liquidator now calls `claimReceipt(orders)` where `orders` is an array that contains many duplicates of the \"bad\" trade, for example 100 times. The `calcUnitsSold` function will return `unitsSold = receipt.amountLiquidated` and a bad `avgPrice`. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit  This can be repeated until the insurance fund is drained.  ## Impact  The attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.  ## Recommended Mitigation Steps Disallow duplicate orders in the `orders` argument of `claimReceipt`. This should make the attack at least unprofitable, but it could still be a griefing attack. A quick way to ensure that `orders` does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the `calcUnitsSold` `for` loop that the current order ID is strictly greater than the previous one.  "}, {"title": "Deflationary tokens are not supported", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/104", "labels": ["bug", "1 (Low Risk)", "sponsor dispute", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "Deflationary tokens are not supported"}, {"title": "Can set values to more than 100%", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/102", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  There are several setter functions that do not check if the amount is less than 100%.  - `TracerPerpetualSwaps`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage` - `Insurance`: `setFeeRate`, `setDeleveragingCliff`, `setInsurancePoolSwitchStage`  ## Impact Setting values to more than 100% might lead to unintended functionality.  ## Recommended Mitigation Steps Ensure that the parameters are less than 100%.  "}, {"title": "Trader orders can be frontrun and users can be denied from trading", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/100", "labels": ["bug", "2 (Med Risk)"], "target": "2021-06-tracer-findings", "body": "Trader orders can be frontrun and users can be denied from trading"}, {"title": "Wrong token approval", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The pool holdings of `Insurance` (`publicCollateralAmount` and `bufferCollateralAmount`) is in WAD (18 decimals) but it's used as a raw token value in `drainPool`  ```solidity // amount is a mix of pool holdings, i.e., 18 decimals // this requires amount to be in RAW! if tracerMarginToken has > 18 decimals, it'll break, < 18 decimals will approve too much tracerMarginToken.approve(address(tracer), amount); // this requires amount to be in WAD which is correct tracer.deposit(amount); ```  ## Impact  If `tracerMarginToken` has less than 18 decimals, the approval approves orders of magnitude more tokens than required for the `deposit` call that follows. If `tracerMarginToken` has more than 18 decimals, the `deposit` that follows would fail as fewer tokens were approved, but the protocol seems to disallow tokens in general with more than 18 decimals.  ## Recommended Mitigation Steps Convert the `amount` to a \"raw token value\" and approve this one instead.   "}, {"title": "Wrong price scale for `GasOracle`", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/93", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.  However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it's in 18 decimals.  > \"Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\"  There is a `toWad` function that seems to involve scaling but it is never used.  ## Impact** If the scale is wrong, the gas price can be heavily inflated or under-reported.   ## Recommended Mitigation Steps Check `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.  "}, {"title": "LibMath sumN can iterate over array", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/89", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  When `LibMath.sumN` function does not check if `n <= arr.length` and can therefore fail if called with `n > arr.length`.  ## Impact The caller must always check that it's called with an argument that is less than `n` which is inconvenient.  ## Recommendation Change the condition to iterate up to `min(n, arr.length)`.   "}, {"title": "LibMath fails implicitly", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details   When `LibMath.abs` is called with -2^255 (`type(int256).min`), it tries to multiply it by `-1` but it'll fail as it exceeds the max signed 256-bit integers.  ## Impact The function will fail with an implicit error that might be hard to locate.  ## Recommendation Throw an error similar to `toInt256` like `int256 overflow`.   "}, {"title": "hardcoded chainId", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/85", "labels": ["bug", "1 (Low Risk)"], "target": "2021-06-tracer-findings", "body": "hardcoded chainId"}, {"title": "Potential division by zero\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In function minimumMargin(), maximumLeverage being zero is not handled because it will result in div by zero as PRBMathUD60x18.div expects non-zero divisor.   Impact: Various critical market functions will revert if maximumLeverage is zero.  ## Proof of Concept  https://github.com/hifi-finance/prb-math/blob/c4dea7d0e6ae246fbb631f7fb4be4072d1da9a07/contracts/PRBMathUD60x18.sol#L71-L77   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L118  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L135  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L186  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L242  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L248  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add checks to make sure maximumLeverage is never zero or handle appropriately.  "}, {"title": "Malicious owner can drain the market at any time using SafetyWithdraw\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/81", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawERC20Token() in SafetyWithdraw inherited in TracerPerpetualSwaps is presumably a guarded launch emergency withdrawal mechanism. However, given the trust model where the market creator/owner is potentially untrusted/malicious, this is a dangerous approach to emergency withdrawal in the context of guarded launch.   Alternatively, if this is meant for the owner to withdraw \u201cexternal\u201d ERC20 tokens mistakenly deposited to the Tracer market then the function should exclude tracerQuoteToken from being the tokenAddress that can be used as a parameter to withdrawERC20Token().  Impact: Malicious owner of a market withdraws/rugs all tracerQuoteTokens deposited at any time after market launch. All users lose deposits. Protocol takes a reputational hit and has to refund the users from treasury.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/SafetyWithdraw.sol#L8-L14  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  For a guarded launch circuit breaker, design a pause/unpause feature where deposits are paused  (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to market, exclude the tracerQuoteToken from being given as the tokenAddress.   "}, {"title": "Missing length check on array could lead to undefined behavior", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The sumN() library function expects to calculate the sum of n elements of the supplied array but there is no check to see if the array indeed has n elements. A smaller array could lead to reading out of bounds memory resulting in undefined values.  Impact: The current usage of the library does not indicate an out of bounds access but any new code using this library could be impacted.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L38-L46  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibMath.sol#L68  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibPrices.sol#L73   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(n <= arr.length) at the beginning of sumN() to be safe.  "}, {"title": "setDecimals can be set by anyone and not used", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The setDecimals() in the sample Gas Price Oracle implementation allows anyone to set the decimals value used by the contract but is not used anywhere.  Impact: It is unclear if this should be set by anyone and if that value should be used in determining the precision of the values returned.  ## Proof of Concept   https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L64-L66   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if this access and missing logic is correct.  "}, {"title": "Using tx.gasprice to prevent front-running may lead to failed liquidations", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-tracer-findings", "body": "Using tx.gasprice to prevent front-running may lead to failed liquidations"}, {"title": "Close-ended time ranges may confuse users/interfaces", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Time ranges are typically open-ended which includes the start & end times, and not close-ended. So the releaseTime would be interpreted as the time it would be released i.e. block.timestamp >= releaseTime would be the expected check here instead of \u2018>\u2019. Similarly, on L406, it should be \u2018<=\u2018 instead of \u2018<\u2018.  Impact: Claims of escrow and receipts are expected to succeed in a particular block but they revert and have to wait until the next block.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L112  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L406  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Unless justified, change the strict inequality and make it \u2018>=\u2018 and \u2018<=\u2018 to convert open ranges to closed ranges for block.timestamp comparisons.  "}, {"title": "Use of incorrect index leads to incorrect updation of funding rates", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/74", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The updateFundingRate() function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of [currentFundingIndex] which has been updated since the previous call to this function while it should really be using [currentFundingIndex-1] to reference the previous funding rate.  Impact: The cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and protocol takes a reputation hit.   ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L155-L160  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L168  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L77  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L196-L215  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L221-L230  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L445-L446  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use [currentFundingIndex-1] for non-zero values of currentFundingIndex to get the value updated in the previous call on lines L155 and L159 of Pricing.sol.  "}, {"title": "Use of deprecated Chainlink API\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/73", "labels": ["bug", "2 (Med Risk)"], "target": "2021-06-tracer-findings", "body": "Use of deprecated Chainlink API\u2028"}, {"title": "Lack of a contract existence check may lead to undefined behavior", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/71", "labels": ["bug", "1 (Low Risk)"], "target": "2021-06-tracer-findings", "body": "Lack of a contract existence check may lead to undefined behavior"}, {"title": "Missing replay protection against previously executed orders\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/70", "labels": ["bug", "invalid", "sponsor dispute"], "target": "2021-06-tracer-findings", "body": "Missing replay protection against previously executed orders\u2028"}, {"title": "Potential Out-of-Gas exception due to unbounded loop", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact Trading function executeTrade() batch executes maker/taker orders against a market. The trader/interface provides arrays of makers/takers which is unbounded. As a result, if the number of orders is too many, there is a risk of this transaction exceeding the block gas limit (which is 15 million currently).  Impact: executeTrade() is called with too many orders in the batch. Tx exceeds block gas limit and reverts. None of the orders are executed.  ## Proof of Concept  See similar Medium-severity finding from ConsenSys's Audit of Growth DeFi: https://consensys.net/diligence/audits/2020/12/growth-defi-v1/#potential-resource-exhaustion-by-external-calls-performed-within-an-unbounded-loop  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L67  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Trader.sol#L78  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Limit the number or orders executed based on gasleft() after every iteration or estimate the gas cost and enforce an upper bound on the number of orders allowed in maker/taker arrays.  "}, {"title": "Malicious owner can arbitrarily change fee to any % value\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Tracer protocol like any other allows market creators to charge fees for trades. However, a malicious/greedy owner can arbitrarily change fee to any % value and without an event to observe this change or a timelock to react, there is no easy way for users to monitor this via front-end or off-chain monitoring tools.  Impact: Users trade on a market with 0.1% fees. The owner suddenly changes this to 100%. Users realise this only after their trades are executed. Market loses confidence. Protocol takes a reputational hit.  ## Proof of Concept  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L548-L550  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/lib/LibBalances.sol#L198-L214  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Emit event, provide time lock for users to react and establish an upper threshold for fees that is decided across markets by governance.  "}, {"title": "Missing events for critical parameter changing operations by owner", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/64", "labels": ["bug", "2 (Med Risk)"], "target": "2021-06-tracer-findings", "body": "Missing events for critical parameter changing operations by owner"}, {"title": "Event log poisoning/griefing in withdrawFees()\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  withdrawFees() is an external function which can be called by anyone to transfer the accumulated fees to the feeReceiver account. However, there is no data validation to check if fees are non-zero.  Impact: One can keep calling withdrawFees(), even if the fees is zero, to grief the system with 0 amount transfers and emission of events recording the same. This leads to what is known as event log poisoning where malicious external users spam the Tracer contract to generate arbitrary FeeWithdrawn events.  ## Proof of Concept  See similar Finding from Sigma Prime\u2019s audit of Synthetix Unipool: https://github.com/sigp/public-audits/blob/master/synthetix/unipool/review.pdf  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L508-L516  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Consider adding a require or if statement preventing the withdrawFees() function from emitting the event when the amount variable is zero, i.e. check if fees != 0 before transfer+emit.  "}, {"title": "function which can declared as external ", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact public function which are not called within contract should be declared as external to save gas  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L572  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L470  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/InsurancePoolToken.sol#L14  ## Tools Used  manual review  ## Recommended Mitigation Steps  Declare public function as external which are not called in the contract  "}, {"title": "Dangerous use of storage data location specifier", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Reference type local variables require an explicit data location specified indicating if they need to be in storage or memory. Assigning state variables to storage local variables creates a reference  (instead of a copy) to the state variable and modifications to the local variable will be reflected in the state variable. This is required if the intention is to make updates to state variables. Unnecessarily using storage specifiers may lead to unintentional updates of state variables and has led to vulnerabilities.  In L457 of settle(), a local variable insuranceBalance is created in storage to point to balances[address(insuranceContract)] but is never updated. Instead balances[address(insuranceContract)] itself is updated on L474.  Impact: While there is no immediate impact, any modifications to the code with insuranceBalance will be dangerous because it will update the critical state variable balances[address(insuranceContract)]. It is safer to use a memory specifier for insuranceBalance.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L456-L457  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L467  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L474  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace the use of storage specifier on L457 with memory.  "}, {"title": "tvl calculation in withdraw() should use convertedWadAmount instead of amount", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The tvl calculation in deposit() uses convertedWadAmount but the one in withdraw() uses the parameter amount. While amount is still in WAD format, it may contain dust which is what the conversion to rawTokenAmount and then back to convertedWadAmount removes.  Impact: Use of amount in tvl during withdraw() will consider dust while the one in deposit() will not, which is inconsistent.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L200  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L176-L177  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use convertedWadAmount instead of amount to be consistent with the increment during withdraw() tvl calculation.  "}, {"title": "Deposit event should use the converted WAD amount", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The Deposit event uses the function parameter amount instead of the convertedWadAmount which is what is used to update the user\u2019s position and tvl because it prevents any dust deposited in amount. This will also make it consistent with the emit event in withdraw function.  Impact: Deposit event amount reflects the value with dust while the user position does not. This may lead to confusion.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L163  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L153-L162  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L204  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use uint256(convertedWadAmount) instead of amount in Deposit event.  "}, {"title": "executionPrice, newMakeAverage and newTakeAverage before calling the market", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Trader function executeTrade calculates executionPrice, newMakeAverage, newTakeAverage, then calls the market, and only if it succeeds it uses these variables.  ## Recommended Mitigation Steps Better first call the market and only then calculate and use these variables to avoid useless calculations and gas costs.  "}, {"title": "recalculation of 10**18", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Insurance function drainPool calculates 10**18 many times. To reduce the number of calculations and save gas, this number can be extracted as a constant variable and used everywhere where necessary.  ## Recommended Mitigation Steps Extract 10**18 as a constant.  "}, {"title": "Zero-address checks are missing", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/49", "labels": ["bug", "1 (Low Risk)"], "target": "2021-06-tracer-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Zero-address checks are a best-practise for input validation of critical address parameters. While the codebase applies this to most addresses in setters, there are many places where this is missing in constructors and setters.  Impact: Accidental use of zero-addresses may result in exceptions, burn fees/tokens or force redeployment of contracts.  ## Proof of Concept  The following code sections are missing zero address check.   https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L36 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/Treasury.sol#L104 https://github.com/code-423n4/2021-10-union/blob/main/contracts/treasury/TreasuryVester.sol#L19 https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Whitelistable.sol#L55 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L157 https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L170 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L138 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L142 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L721 https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/MarketRegistry.sol#L59 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L78 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AssetManager.sol#L72 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L89 https://github.com/code-423n4/2021-10-union/blob/main/contracts/asset/AaveAdapter.sol#L93   ## Tools Used  None  ## Recommended Mitigation Steps  Consider to Add zero-address checks.    "}, {"title": "LIQUIDATION_GAS_COST may not be a constant\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The gas cost for liquidation may change if code is updated/optimized, compiler changed or profiling improved. The developers may forget to update this constant in code.  Impact: The margin validity calculation which uses this value may be affected if this changes and hence is not as declared in the constant. This may adversely impact validation.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L26  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L244  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L250  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/TracerPerpetualSwaps.sol#L494  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L159  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L193  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  It is safer to make this a constructor-set immutable value that will force usage of an updated accurate value at deployment time. Evaluate if the sensitivity to this value is great enough to justify a setter to change it if incorrectly initialized at deployment.  "}, {"title": "orders and orderToSig mappings", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Contract Trader has 2 mappings: orders and orderToSig. I see that orderToSig also stores Perpetuals.Order inside it, so I wonder if it really was necessary to separate these mappings as some state (order) is duplicated among them. It may be a bit more efficient to access orders without signatures but it also makes it more error-prone as you need to keep the invariant that orders match in these mappings. Currently I don't see an exact problem as orderToSig are only set in function grabOrder and never used in code anywhere but I am not sure if it is really necessary.   Tracer representetive's answer on Discord: 'Yeah thats a good point on the Trader mapping, one does look redundant now as they both store the order itself. I think originally one was mutated and one wasn't, but then that functionality got moved into the filled mapping anyway. Seems safe to remove orders and simply reference the orderToSig mapping'.  ## Recommended Mitigation Steps Remove orders and simply reference the orderToSig mapping.  "}, {"title": "Single-step process for critical ownership transfer\u2028", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-06-tracer-findings", "body": "Single-step process for critical ownership transfer\u2028"}, {"title": "state variable which can be declared as immutable", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact state variable which have to initialise in constructor can be declared as immutable to save gas  ## Proof of Concept  https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L23  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Insurance.sol#L20  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L30  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L31  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Pricing.sol#L17  ## Tools Used  manual review  "}, {"title": "Unused State variable", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Unused state variable will increase unnecessarily code size and use the memory  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/oracle/GasOracle.sol#L19  ## Tools Used  manual review  ## Recommended Mitigation Steps  remove the variable which are unused  "}, {"title": "[Gas] Use at least 0.8.0 instead of 0.8.4", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## Use at least 0.8.4 instead of 0.8.0  It has an important optimization improvement: a low level inliner. Especially since you have several small functions.  The current hardhat config indicates that version `0.8.0` is being used.    "}, {"title": "[Gas] Change some function parameters from `memory` to `calldata`", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Impact  Gas optimization.  ## For function arguments, change `memory` to `calldata`  There are several places where this is applicable, however, will point out one such occasion:  ``` diff modified   src/contracts/Trader.sol @@ -64,7 +64,7 @@ contract Trader is ITrader {       * @param makers An array of signed make orders       * @param takers An array of signed take orders       */ -    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) +    function executeTrade(Types.SignedLimitOrder[] calldata makers, Types.SignedLimitOrder[] calldata takers)          external          override      { @@ -144,7 +144,7 @@ contract Trader is ITrader {       * @dev Should only be called with a verified signedOrder and with index       *      < signedOrders.length       */ -    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index) +    function grabOrder(Types.SignedLimitOrder[] calldata signedOrders, uint256 index)          internal          returns (Perpetuals.Order memory)      { ```  Reason: when you specify `memory` for a (non value type) function-parameter for an external function, the following happens: the compiler would copy elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Then later on, the internal call (here `grabOrder`) would pass a memory reference. However, this is a great example of where copying to memory is unnecessary. Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  You would only have to use `memory` if the function has to modify the parameter, in which case a copy is really needed as `calldata` cannot be modified.    "}, {"title": "Using array memory parameter without checking its length ", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact These array memory parameter can be  problematic if not used properly , if the array is very large it may overlap over other part of memory.  ## Proof of Concept  https://github.com/code-423n4/2021-06-tracer/blob/74e720ee100fd027c592ea44f272231ad4dfa2ab/src/contracts/Liquidation.sol#L274  This an example to show the exploit: // based on https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/swap/private/Exploit.sol pragma solidity ^0.4.24; // only works with low solidity version  contract test{ struct Overlap { uint field0; } event log(uint);  function mint(uint[] memory amounts) public returns (uint) {  // this can be in any solidity version Overlap memory v; v.field0 = 1234; emit log(amounts[0]); // would expect to be 0 however is 1234 return 1; }  function go() public { // this part requires the low solidity version uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251 bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x); bool success=address(this).call(payload); } } ## Tools Used  manual review  ## Recommended Mitigation Steps  check array length before using it  "}, {"title": "claimEscrow() accepts invalid receiptId", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/33", "labels": ["bug", "0 (Non-critical)"], "target": "2021-06-tracer-findings", "body": "claimEscrow() accepts invalid receiptId"}, {"title": "avoid paying insurance", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/30", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact It's possible to avoid paying insurance in the following way: - once per hour (at the right moment), do the following: ----using a flash loan, or with a large amount of tokens, call deposit of Insurance.sol to make sure that the pool is sufficiently filled (poolHoldings > poolTarget) ----call the function executeTrade of Trader.sol with a minimal trade (possibly of value 0, see finding \"executeTrade with same trades\") ----executeTrade calls matchOrders, which calls recordTrade ----recordTrade calls updateFundingRate();   (once per hour, so you have to be sure you do it in time before other trades trigger this) ----updateFundingRate calls getPoolFundingRate ----getPoolFundingRate determines the insurance rate, but because the insurance pool is sufficiently full (due to the flash loan), the rate is 0 ----updateFundingRate stores the 0 rate via setInsuranceFundingRate  (which is used later on to calculate the amounts for the insurances) ----withdraw from the Insurance and pay back the flash loan  The insurance rates are 0 now and no-one pays insurance. The gas costs relative to the insurance costs + the flash loan fees determine if this is an economically viable attack. Otherwise it is still a grief attack This will probably be detected pretty soon because the insurance pool will stay empty. However its difficult to prevent.  ## Proof of Concept  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L45 function deposit(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L74 function withdraw(uint256 amount) external override {  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L69      function recordTrade(uint256 tradePrice) external override onlyTracer {       ..         if (startLastHour <= block.timestamp - 1 hours) {            ..             updateFundingRate();  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Pricing.sol#L141 function updateFundingRate() internal {       ..         int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();       ..         int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;      ..         setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);  // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L204 function getPoolFundingRate() external view override returns (uint256) {      ..         // If the pool is above the target, we don't pay the insurance funding rate         if (poolTarget <= poolHoldings) {             return 0;         }  ## Tools Used  ## Recommended Mitigation Steps Set a timelock on withdrawing insurance   "}, {"title": "Use immutable keyword", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "Use immutable keyword"}, {"title": "Comment in claimEscrow", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function claimEscrow of Liquidation.sol can be called by everyone. The claimed funds go to the trader so there are no funds at risk. However the comment says the traders is doing this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L106 /**      * @notice Allows a trader to claim escrowed funds after the escrow period has expired      * @param receiptId The ID number of the insurance receipt from which funds are being claimed from      */     function claimEscrow(uint256 receiptId) public override {   ## Tools Used  ## Recommended Mitigation Steps Double check and it the code works as intended adapt the comment. Otherwise add check that only the trader can call the function.  "}, {"title": "use try catch", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-tracer-findings", "body": "use try catch"}, {"title": "Variables that can be converted into immutables", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Variables that can be converted into immutables  ``` txt Warning: Variable declaration can be converted into an immutable.   --> contracts/external/ERC20.sol:17:3:    | 17 |   uint8 public decimals;    |   ^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:17:3:    | 17 |   uint MAX_INT = 2**256 - 1;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:22:3:    | 22 |   address public lendingPairMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:23:3:    | 23 |   address public lpTokenMaster;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/PairFactory.sol:24:3:    | 24 |   IController public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:35:3:    | 35 |   IPairFactory public factory;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:36:3:    | 36 |   IController  public controller;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   Warning: Variable declaration can be converted into an immutable.   --> contracts/RewardDistribution.sol:37:3:    | 37 |   IERC20  public rewardToken;    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ ```  Instead of the expensive `sload`, to read from storage, these would be transformed into a cheap `push value`, when the variables are converted into immutable.  ## Tools Used  A custom compiler.    "}, {"title": "make sure withdrawFees allways can withdraw", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact If you call the function withdrawFees and the \"tvl\" would not be enough for the fee then the code would revert. In this case the fees cannot be withdrawn. Although it is unlikely that the tvl would be wrong it is probably better to be able to withdraw the remaining fees.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L508 function withdrawFees() external override {         uint256 tempFees = fees;         fees = 0;         tvl = tvl - tempFees;          // Withdraw from the account         IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);         emit FeeWithdrawn(feeReceiver, tempFees);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like: tempFees = min (fees, tvl); and change fees=0 to: fees -= tempFees;  "}, {"title": "Comment in partialLiquidationIsValid misleading", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/18", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The comments for partialLiquidationIsValid indicate that the params are in WAD format (except liquidationGasCost) However the parameter minimumLeftoverGasCostMultiplier originates from Liquidation.sol and has the value 10. So it is not in WAD format and the comment is misleading.  ## Proof of Concept //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L149  @dev Assumes params are WAD except liquidationGasCost  function partialLiquidationIsValid(         Balances.Position memory updatedPosition,         uint256 lastUpdatedGasPrice,         uint256 liquidationGasCost,         uint256 price,         uint256 minimumLeftoverGasCostMultiplier     )   //https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L27 uint256 public override minimumLeftoverGasCostMultiplier = 10;  ## Tools Used  ## Recommended Mitigation Steps Update the comment   "}, {"title": "check sign in calculateSlippage", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/17", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In function calculateSlippage of LibLiquidation.sol, the value of amountToReturn is calculated by subtracting to numbers. Later on it is check if this value is negative. However amountToReturn is an unsigned integer so it can never be negative. If a negative number would be attempted to be assigned, the code will revert, because solidity 0.8 checks for this.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L106 function calculateSlippage( ...             uint256 amountToReturn = 0;             uint256 percentSlippage = 0;             if (avgPrice < receipt.price && receipt.liquidationSide == Perpetuals.Side.Long) {                 amountToReturn = amountExpectedFor - amountSoldFor;             } else if (avgPrice > receipt.price && receipt.liquidationSide == Perpetuals.Side.Short) {                 amountToReturn = amountSoldFor - amountExpectedFor;             }             if (amountToReturn <= 0) {    // can never be smaller than 0, because amountToReturn is uint256                 return 0;             }  ## Tools Used  ## Recommended Mitigation Steps Double check if amountToReturn could be negative. If this is the case change the type of amountToReturn to int256 and add the appropriate type casts   "}, {"title": "Comment for formula calcEscrowLiquidationAmount different than code", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The comment for the formula in calcEscrowLiquidationAmount is:  currentMargin - (minMargin - currentMargin) * portion  however it is coded as:  {currentMargin - (minMargin - currentMargin)} * portion  According to Ray/Lions mane the comment is wrong  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibLiquidation.sol#L32 //       Calculated as currentMargin - (minMargin - currentMargin) * portion of whole position being liquidated function calcEscrowLiquidationAmount( ..         int256 amountToEscrow = currentMargin - (minMargin.toInt256() - currentMargin);         int256 amountToEscrowProportional = PRBMathSD59x18.mul(amountToEscrow, PRBMathSD59x18.div(amount, totalBase));   ## Tools Used  ## Recommended Mitigation Steps Fix the comment  "}, {"title": "alternative solidity coding", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Solidity allows some tricks to make the code easier to read:     LibMath.sol:     uint256 public constant POSITIVE_INT256_MAX = 2**255 - 1;     uint256 public constant POSITIVE_INT256_MAX = uint(type(int256).max);   // alternative coding  Insurance.sol:     uint256 public multiplyFactor = 36523 * (10**11);     uint256 public multiplyFactor = 0.0036523e18;   // alternative coding   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps Use the most readable coding   "}, {"title": "Use constants for numbers", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "Use constants for numbers"}, {"title": "todos left in the code", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact There are several todos left in the code.  ## Proof of Concept .\\Pricing.sol:                     // todo by using public variables lots of these can be removed .\\Trader.sol:                      // todo this could be succeptible to re-entrancy as .\\lib\\LibLiquidation.sol:    // todo with the below * -1, note ints can overflow as 2^-127 is valid but 2^127 is not. .\\lib\\LibPrices.sol:             // todo double check safety of this.  ## Tools Used  ## Recommended Mitigation Steps Check, fix and remove the todos before it is deployed in production    "}, {"title": "prb-math not audited", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The library prb-math documents that it is not audited by a security researcher.  This means its more risky to rely on this library.  ## Proof of Concept // https://github.com/hifi-finance/prb-math#security The contracts have not been audited by a security researcher.      ## Tools Used  ## Recommended Mitigation Steps Consider (crowdsourcing) an audit for prb-math   "}, {"title": "Only one constructor with an emit", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The constructor of Insurance.so does an emit. However the constructors of the other contracts (InsurancePoolToken.sol, Liquidation.sol, Pricing.sol, TracerPerpetualSwaps.sol, TracerPerpetualsFactory.sol, Trader.sol) don't do an emit in the constructor.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L31 constructor(address _tracer) {      ...         emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());     }  ## Tools Used  ## Recommended Mitigation Steps Perhaps it's useful for other constructor to also include an emit   "}, {"title": "Deployers can be called by everyone", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/9", "labels": ["bug", "invalid", "sponsor dispute"], "target": "2021-06-tracer-findings", "body": "Deployers can be called by everyone"}, {"title": "No pause function is present", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/8", "labels": ["bug", "invalid", "sponsor dispute"], "target": "2021-06-tracer-findings", "body": "No pause function is present"}, {"title": "matchOrders could/should check market", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function matchOrders of TracerPerpetualSwaps.sol doesn't check that the contract itself is indeed equal to order1.market and order2.market. The function executeTrade Trader.sol, which calls the matchOrders, can deal with multiple markets. Suppose there would be a mistake in executeTrade,  or in a future version, the matchOrders would be done in the wrong market.  ## Proof of Concept // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L216 function matchOrders( Perpetuals.Order memory order1, Perpetuals.Order memory order2, uint256 fillAmount )   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67  function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external  override { ...  (bool success, ) = makeOrder.market.call(                 abi.encodePacked(                     ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,                     abi.encode(makeOrder, takeOrder, fillAmount)                 )             );   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibPerpetuals.sol#L128 function canMatch( Order memory a, uint256 aFilled,Order memory b, uint256 bFilled ) internal view returns (bool) {     ...         bool marketsMatch = a.market == b.market;  ## Tools Used  ## Recommended Mitigation Steps Add something like: require ( order1.market == address(this), \"Wrong market\");  Note: canMatch already verifies that  order1.market== order2.market   "}, {"title": "Claim liquidation escrow", "html_url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/2", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-tracer-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact A liquidator can always claim the liquidation escrow in the following way: - create a second account - setup a complimentary trade in that second account, which will result in a large slippage when executed - call executeTrade (which everyone can call), to execute a trade between his own two accounts with a large slippage - the slippage doesn't hurt because the liquidator owns both accounts - call claimReceipt with the receiptId of the executed order, within the required period (e.g. 15 minutes)  ## Proof of Concept   // https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67 function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {  https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394  function claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {  ## Tools Used  ## Recommended Mitigation Steps perhaps limit who can call executeTrade   "}, {"title": "Use of deprecated Chainlink function `latestAnswer`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/126", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-06-gro-findings", "body": "Use of deprecated Chainlink function `latestAnswer`"}, {"title": "Use of `tx.origin` for authentication", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/122", "labels": ["bug", "1 (Low Risk)"], "target": "2021-06-gro-findings", "body": "Use of `tx.origin` for authentication"}, {"title": "More accurate calculation of return USD of `withdrawSingleByLiquidity`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/121", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `withdrawSingleByLiquidity` function of `LifeGuard3Pool` calls `buoy.singleStableToUsd` to calculate the return USD amount, which internally calls `_stableToUsd` with the `deposit` parameter set to `true`. A more accurate calculation is to set the `deposit` parameter to `false` since this action is a withdrawal. A similar issue exists in the function `calcProtocolWithdraw` of `Allocation`, where the current strategy's USD is calculated by `buoy.singleStableToUsd`.  ## Proof of Concept  Referenced code: [LifeGuard3Pool.sol#L226](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/LifeGuard3Pool.sol#L226) [Buoy3Pool.sol#L122](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L122) [Allocation.sol#L142](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L142)  ## Recommended Mitigation Steps  Consider adding a new boolean parameter, `deposit`, to the `singleStableToUsd` function of `Buoy3Pool` to indicate whether the action is a deposit or not, as that in the `stableToUsd` and `stableToLp` functions.  "}, {"title": "Add a proper revert message in `_withdrawSingle`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/120", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Add a proper revert message in `_withdrawSingle`"}, {"title": "Unlocked pragma used in multiple contracts", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/117", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-06-gro-findings", "body": "Unlocked pragma used in multiple contracts"}, {"title": "function withdrawToAdapter should be inluded in the interface and return withdrawal amount", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-06-gro-findings", "body": "function withdrawToAdapter should be inluded in the interface and return withdrawal amount"}, {"title": "BaseVaultAdaptor assumes `sharePrice` is always in underlying decimals", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/114", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The two `BaseVaultAdaptor.calculateShare` functions computes `share = amount.mul(uint256(10)**decimals).div(sharePrice)`  ```solidity uint256 sharePrice = _getVaultSharePrice(); // amount is in \"token\" decimals, share should be in \"vault\" decimals share = amount.mul(uint256(10)**decimals).div(sharePrice); ```  This assumes that the `sharePrice` is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.  This both happens to be the case for Yearn vaults, but will not necessarily be the case for other protocols. As this functionality is in the `BaseVaultAdaptor` and not in the specific `VaultAdaptorYearnV2_032`, consider generalizing the conversion.  ## Impact Integrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.  ## Recommended Mitigation Steps The conversion seems highly protocol specific, `calculateShare` should be an abstract function like `_getVaultSharePrice`, that is implemented in the specific adaptors.  "}, {"title": "strategiesLength should not be allowed to exceed MAX_STRATS", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/110", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor disputed"], "target": "2021-06-gro-findings", "body": "strategiesLength should not be allowed to exceed MAX_STRATS"}, {"title": "Rational actors will just set themselves as referral", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor disputed"], "target": "2021-06-gro-findings", "body": "Rational actors will just set themselves as referral"}, {"title": "Early user can break minting", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Early user can break minting"}, {"title": "Usage of deprecated ChainLink API in `Buoy3Pool`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The Chainlink API (`latestAnswer`) used in the `Buoy3Pool` oracle wrappers is deprecated:  > This API is deprecated. Please see API Reference for the latest Price Feed API. [Chainlink Docs](https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/#latestanswer)  ## Impact It seems like the old API can return stale data. Checks similar to that of the new API using `latestTimestamp` and `latestRoundare` are needed. This could lead to stale prices according to the Chainlink documentation: * [under current notifications: \"if answeredInRound < roundId could indicate stale data.\"](https://docs.chain.link/docs/developer-communications#current-notifications) * [under historical price data: \"A timestamp with zero value means the round is not complete and should not be used.\"](https://docs.chain.link/docs/historical-price-data#solidity)  ## Recommended Mitigation Steps Add the recommended checks: ```solidity (     uint80 roundID,     int256 price,     ,     uint256 timeStamp,     uint80 answeredInRound ) = chainlink.latestRoundData(); require(     timeStamp != 0,     \u201cChainlinkOracle::getLatestAnswer: round is not complete\u201d ); require(     answeredInRound >= roundID,     \u201cChainlinkOracle::getLatestAnswer: stale data\u201d ); require(price != 0, \"Chainlink Malfunction\u201d); ```  "}, {"title": "`Buoy3Pool._updateRatios` unsafe math", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/105", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-06-gro-findings", "body": "`Buoy3Pool._updateRatios` unsafe math"}, {"title": "`Buoy3Pool.safetyCheck` is not precise and has some assumptions", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/104", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `safetyCheck` function has several issues that impact how precise the checks are:  1. only checks if the `a/b` and `a/c` ratios are within `BASIS_POINTS`. By transitivity `b/c` is only within `2 * BASIS_POINTS` if `a/b` and `a/c` are in range. For a more precise check whether both USDC and USDT are within range, `b/c` must be checked as well.  2. If `a/b` is within range, this does not imply that `b/a` is within range. > \"inverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions\"  Example: `lastRatio = 1.0` `ratio: a = 1.0, b = 0.8` => `a/b = 1.25`, `b/a = 0.8` If `a/b` was used with a 20% range, it'd be out of range, but `b/a` is in range.  3. The natspec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both `_ratio` and `lastRatio` are only from Curve. Only `_updateRatios` checks the oracle.  ## Recommended Mitigation Steps In addition, check if `b/c` is within `BASIS_POINTS`.  "}, {"title": "`Allocaiton.calcProtocolExposureDelta` gas optimization", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details `Allocaiton.calcProtocolExposureDelta` should break out of the loop to save gas after `protocolExposedDeltaUsd` is set.  ```solidity if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {     // ...Calculate the delta between exposure and target     uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);     protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(         PERCENTAGE_DECIMAL_FACTOR     );     protocolExposedIndex = i;     // @audit break here } ```  "}, {"title": "`Exposure.sortVaultsByDelta` does not work for N_COINS != 3", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/101", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor disputed"], "target": "2021-06-gro-findings", "body": "`Exposure.sortVaultsByDelta` does not work for N_COINS != 3"}, {"title": "`Insurance.getVaultDeltaForDeposit` returns wrong `investDelta`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/98", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-06-gro-findings", "body": "`Insurance.getVaultDeltaForDeposit` returns wrong `investDelta`"}, {"title": "Wrong min amount check in `withdrawByStablecoin`", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/97", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `WithdrawHandler.withdrawByStablecoin` incorrectly uses the `lpAmount` instead of the `minAmount` in the check.  ```solidity require(lpAmount > 0, \"!minAmount\"); ```  ## Recommended Mitigation Steps Use `minAmount > 0` if trying to check for `!minAmount` or use a different error message for an invalid LP amount.  "}, {"title": "Hardcoded 99 as deadcoin", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/96", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Hardcoded 99 as deadcoin"}, {"title": "Loss of precision", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/95", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-06-gro-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, there's a loss of precision that can be corrected by shifting the operations.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L274  ## Tools Used editor  ## Recommended Mitigation Steps Consider rewriting L274-275 with `uint numerator = (_fees * reserve) / eraLength / maxTrades;`.  "}, {"title": "RebasingGToken emits same events on transfer", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "RebasingGToken emits same events on transfer"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/90", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Missing parameter validation"}, {"title": "event LogTransfer is only emitted in function transfer", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/88", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "event LogTransfer is only emitted in function transfer"}, {"title": "burnAll should check that factor > 0 and amount > 0", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/87", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-06-gro-findings", "body": "burnAll should check that factor > 0 and amount > 0"}, {"title": "totalAssets > withdrawUsd should be inclusive", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "totalAssets > withdrawUsd should be inclusive"}, {"title": "Two SafeApprove calls when it could be just one", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Two SafeApprove calls when it could be just one"}, {"title": "Inconsistent usage of exponentiation for constants", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact Detailed description of the impact of this finding. See Constants.sol, where you use 10**DECIMALS: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Constants.sol#L7  VS  FixedContracts.sol, where you use 1E6: https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/FixedContracts.sol#L13  While both expressions result in the same values, I recommend picking one to avoid potential confusion     "}, {"title": "Return False early in isValidBigFish", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Return False early in isValidBigFish"}, {"title": "setBigFishThreshold above 100%", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/80", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setBigFishThreshold should require that _percent is not above PERCENTAGE_DECIMAL_FACTOR if it is not intended to have it over 100%.  ## Recommended Mitigation Steps require _percent <= PERCENTAGE_DECIMAL_FACTOR  "}, {"title": "withdrawal fee may be set above 100% or frontrunned", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "withdrawal fee may be set above 100% or frontrunned"}, {"title": "decimals of FixedStablecoins", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/77", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "decimals of FixedStablecoins"}, {"title": "updateStrategiesDebtRatio function and LogNewDebtRatios event", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/74", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "updateStrategiesDebtRatio function and LogNewDebtRatios event"}, {"title": "Unused code", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "Unused code"}, {"title": "Incorrect use of operator leads to arbitrary minting of GVT tokens", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/69", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeStrategyGainLoss() function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on msg.sender by checking that vaultIndexes[msg.sender] is a valid index range 1-4. However the operator used in the require() is || instead of &&, which allows an arbitrary msg.sender, i.e. attacker, to bypass the check.  Scenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in vaultIndexes[msg.sender] which will fail the > 0 check but pass the <= N_COINS + 1 check (N_COINS = 3) because 0 <= 4 which will allow control to go past this check. Furthermore, on L362, index=0 will underflow the -1 decrement (due to lack of SafeMath.sub and use of < 0.8.0 solc) and index will be set to (uint256_MAX - 1). This will allow execution to proceed to the else part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.   ## Proof of Concept  The attack control flow: -> Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0) -> index = 0 passes check for the index <= N_COINS + 1 part of predicate on L357 in Controller.sol -> index = uint256_MAX after L362 -> gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN); on L371 in Controller.sol -> ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward); on L376 in Controller.sol -> (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward); on L254 in PnL.sol -> performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR); on L186 of PnL.sol ->  gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus); on L256 in PnL.sol  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L355  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L356-L357  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L362  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L370-L371  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L376  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L253-L258  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change || to && in require() on L357 of Controller.sol to prevent arbitrary addresses from going past this check. Or consider explicit access control for the authorized vault adaptors.  "}, {"title": "Stricter than needed inequalities may affect borderline scenarios", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/67", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Stricter than needed inequalities may affect borderline scenarios"}, {"title": "Unauthorized rebalanceTrigger calls may allow one to exploit arbitrage opportunity and put system at risk", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/66", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Unauthorized rebalanceTrigger calls may allow one to exploit arbitrage opportunity and put system at risk"}, {"title": "Use of uninitialized value and unclear/unused logic", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  vaultIndexes is uninitialized and it's unclear what 10000 signifies here. investDelta return value is also ignored at call site. If this is an indication of missed/incorrect logic, then it's risky. If not, removing will help readability/maintainability.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L166  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L155  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate any missing logic or else remove unused code.  "}, {"title": "Whitelist addition/removal is done unconditionally", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-06-gro-findings", "body": "Whitelist addition/removal is done unconditionally"}, {"title": "Vault assets can be migrated to an arbitrary address at anytime by owner", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/59", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  BaseVaultAdaptor contains logic that is \u201cbuilt on top of any vault in order for it to function with Gro protocol.\u201d One of such functions is the migrate() function which is onlyOwner and takes an address parameter which allows owner to migrate vault\u2019s entire balance at any time to that address. This is extremely risky because it gives an opportunity for, at least a perception of, rug-pull by a disgruntled/malicious owner/dev to the protocol users/community. This could also be dangerous if triggered accidentally especially by an EOA owner address or maliciously via compromised keys.  Scenario1: Protocol launches and starts accumulating TVL. A savvy user analyzes source and shares the presence of this migrate() function as potential owner rug-pull vector. Users withdraw funds and protocol reputation takes a hit.  Scenario 2: Protocol launches and hits 100MM TVL. A disgruntled dev/owner migrates vault assets to their address and drains the protocol.  Scenario 3: Protocol launches and hits 100MM TVL. Owner EOA keys get compromised and attacker migrates vault assets to their address and drains the protocol.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L294-L302  See similar concern on migrate() functionality in ShibaSwap recently: Yearn dev https://twitter.com/bantg/status/1412370758987354116 https://twitter.com/bantg/status/1412388385663164425 Others https://twitter.com/valentinmihov/status/1412352490918625280 https://twitter.com/shegenerates/status/1412642215537545218   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate the need for this function and avoid/mitigate risk appropriately.  "}, {"title": "Incorrect error strings used may cause confusion", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Error strings used in require checks should accurately reflect the failing condition. Use of informative/accurate error messages helps troubleshoot exceptional conditions during transaction failures or unexpected behavior. Otherwise, it can be misleading and waste crucial time during exploits or emergency conditions.   While the codebase has this correct in most places, there are a few places where there appears to be a copy/paste error:  Example 1: require(msg.sender == withdrawHandler || msg.sender == insurance, \"depositStable: !depositHandler\");  The error string should indicate \u201c!withdrawHandler/insurance\u201d instead of \u201c!depositHandler\u201d  Example 2: require(msg.sender == _controller().insurance(), \"withdraw: !withdrawHandler/insurance\");  The error string should only indicate \u201c!insurance\u201d instead of \u201c!withdrawHandler/insurance\u201d  ## Proof of Concept  For reference, see Note 2 in OpenZeppelin's Audit of Compound Governor Bravo: https://blog.openzeppelin.com/compound-governor-bravo-audit/  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L206-L211  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L228  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L162  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L285  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L405   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check/fix error strings.  "}, {"title": "Emergency disabling can only be done one stablecoin at a time", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Emergency disabling can only be done one stablecoin at a time"}, {"title": "Critical protocol parameter configuration/changes should have sanity/threshold checks", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Critical protocol parameter configuration/changes should have sanity/threshold checks"}, {"title": "Critical protocol parameter changes should have time-delayed enforcement", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Critical protocol parameter changes should have time-delayed enforcement"}, {"title": "Enabling preventSmartContracts may lead to lock/loss of funds", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-06-gro-findings", "body": "Enabling preventSmartContracts may lead to lock/loss of funds"}, {"title": "The use of tx.origin for smart contract safe list is risky and not generic", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "The use of tx.origin for smart contract safe list is risky and not generic"}, {"title": "Flash loan risk mitigation is optional and not robust enough", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Flash loan risk mitigation is optional and not robust enough"}, {"title": "Safe addresses can only be added but not removed", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The addSafeAddress()  takes an address and adds it to a \u201csafe list\". This is used in eoaOnly() to give exemption to safe addresses that are trusted smart contracts, when all other smart contacts are prevented from protocol interaction. The stated purpose is to allow only such partner/trusted smart contract integrations (project rep mentioned Argent wallet as the only one for now but that may change) an exemption from potential flash loan threats. But if there a safe listed integration that needs to be later disabled, it cannot be done. The protocol will have to rely on other measures (outside the scope of this contest) to prevent flash loan manipulations which are specified as an area of critical concern.  Scenario: A trusted integration/partner address is added to safe list. But that wallet/protocol/DApp is later manipulated (by project, its users or an attacker) to somehow launch a flash loan attack on the protocol. However, its address cannot be removed from the safe list and the protocol cannot prevent flash loan manipulations from that source because of its exemption. Contract/project will have to be redeployed.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L171-L174  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L176-L178  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L266-L272   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change addSafeAddress() to isSafeAddress() with an additional bool parameter to allow both enabling/disabling of safe addresses.  "}, {"title": "Uninitialized vaults/addresses will lead to reverts", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Uninitialized vaults/addresses will lead to reverts"}, {"title": "Missing zero-address check and event parameter for _emergencyHandler", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Controller setWithdrawHandler() is missing a zero-address check and event parameter for _emergencyHandler which is the more critical (used rarely but in an emergency incident-response that is always time-critical ) of the two addresses.  Scenario: setWithdrawHandler() is accidentally called with _emergencyHandler = 0 address. Without a check or an event here, this error goes unnoticed (unless caught in the event from WithdrawHandler::setDependencies). There is an emergency triggered after which withdrawals are attempted via the emergencyHandler but they fail because of the zero address. The correct non-zero emergencyHandler has to be set again. Valuable time is lost and funds are lost.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105-L110  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L129  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L158   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check and event parameter for _emergencyHandler  "}, {"title": "Having only owner unpause/restart is risky", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Having only owner unpause/restart is risky"}, {"title": "Missing emits for declared events", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/47", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Missing emits for declared events indicate potentially missing logic, redundant declarations or reduced off-chain monitoring capabilities.  Scenario: For example, the event LogFlashSwitchUpdated is missing an emit in Controller. Based on the name, this is presumably related to flash loans being enabled/disabled which could have significant security implications. Or the (misspelled) LogHealhCheckUpdate which is presumably related to a health check logic that is missing in LifeGuard.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L83  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L48  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L61  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/vaults/BaseVaultAdaptor.sol#L62  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate if logic is missing and add logic+emit or remove event.  "}, {"title": "Single-step process for critical ownership transfer is risky", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The Controller contract is arguably the most critical contract in the project for access control management (it has 17 onlyOwner functions). Given that it is derived from Ownable, the ownership management of this contract (also Whitelist and Controllable) defaults to Ownable\u2019s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  The same applies to the changing of controller\u2019s address in contracts deriving from Controllable using setController().  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b9e2c7896d899de9960f2b3d17ca04d5beb79e8a/contracts/access/Ownable.sol#L46-L64  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L38  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L101  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L105  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L112  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L137  And many other onlyOwner functions such as setController():  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/common/Controllable.sol#L35-L40   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a time-delay for such sensitive actions. And at a minimum, use a multisig owner address and not an EOA.  "}, {"title": "Missing input validation on _feeToken in DepositHandler constructor and setFeeToken()", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation on _feeToken in constructor to check if it's referring to a valid index (only USDT=2 makes sense) in the stablecoins similar to the check in setFeeToken(), which cannot be done here because the controller variable is only set later in setDependencies(). Also, given that it is set to true and that only USDT has this capability, the constructor should really check if this value is 2 and nothing else.  Also, setFeeToken() should only allow an index of 2 for now.  Scenario: Incorrectly using a _feeToken value other than 2 will cause an unnecessary balance check because of the presumed transfer fees for that token which does not exist.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L56  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L68-L75   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for _feeToken == 2 in constructor or set+check it using setFeeToken() later. Given that it is only USDT which may have fees, consider hardcoding this assumption instead of making it flexible and leaving room for error, because this is not something that applies to DAI or USDC. The entire codebase currently assumes the presence of only these three tokens in the protocol anyway.  "}, {"title": "Simpler logic can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The for loop in investSingle() can be removed in favor of simpler logic to calculate k [k = N_COINS - (i + j)], which will save some gas in the deposit flow.   ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L317-L326   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace L317 to L323 with: ``` uint256 inBalance = inAmounts[N_COINS - (i + j)]; if (inBalance > 0) {       _exchange(inBalance, int128(k), int128(i)); } ```  "}, {"title": "Removing unnecessary lpToken.balanceOf can save 4700+ gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In LifeGuard3Pool (LG) deposit(), lp token balance is determined for the crv3pool.add_liquidity() call. Given that LG does not hold any lp tokens between txs, there is no need to determine and subtract lp token balance before and after the curve add liquidity call. Removing the call on L204 will save at least 2600+2100=4700 gas from the external call.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L204-L206  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove the call on L204 and just get the balance on L206 without any subtraction.  "}, {"title": "Removing redundant code can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In LG setDependencies(), the code to approve withdrawHandler to pull from lifeguard is repeated twice, once to set it to 0 allowance if the withdrawHandler is != 0 and then unconditionally to set it MAX. Given that this is the only function that sets withdrawHandler, the first set of 0 approvals seem to be redundant given the unconditional approvals that follow. Removing this can save some gas although we don\u2019t expect this to be called often.  The redundant logic could be for the case where the withdrawHandler is updated and the old handler is given an approval of 0 and the new one MAX.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L78-L89   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate code and remove logic if redundant. If this is present to handle withdrawHandler updates then ignore this recommendation.  "}, {"title": "Removing unused return values can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The investDelta return variable from function getVaultDeltaForDeposit() is ignored at the only call-site in DepositHandler. Removing it can save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L144-L152  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L171-L175  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unused return value or add logic to use it at caller.  "}, {"title": "Removing unnecessary check can save gas in withdraw flow", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The minAmount <= amount check in _prepareForWithdrawalSingle() is an unnecessary check because the same check has already passed in both lg.withdrawSingleByLiquidity and lg.withdrawSingleByExchange. And there is no logic that changes the checked parameters between the earlier checks and this one.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L361  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L224  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pools/LifeGuard3Pool.sol#L268   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary check.  "}, {"title": "Changing function visibility from public to external/internal/private can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  For public functions, the input parameters are copied to memory automatically which costs gas. If a function is only called externally, making its visibility as external will save gas because external function\u2019s parameters are not copied into memory and are instead read from calldata directly. If a function is called only from with that contract or derived contracts, making it internal/private can further reduce gas costs because the expensive calls are converted into cheaper jumps.   ## Proof of Concept  The only callers of eoaOnly() are external contracts DepositHandler and WithdrawHandler. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L268 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 The only caller of calcSystemTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L62-L63 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L213 The only caller of calcVaultTargetDelta() is Insurance. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Allocation.sol#L92-L93 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/insurance/Insurance.sol#L432 validGTokenDecrease() can be made private just like validGTokenIncrease because it is only called from within Controller. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L448 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L248   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change function visibility from public to external/private where possible.  "}, {"title": "Moving logic to where required will save >=6800 gas on deposit/withdraw flows", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  In isValidBigFish(), the calculation of gvt and pard assets by making an external call to PnL.calcPnL() is required only if the amount is >= bigFishAbsoluteThreshold.   Impact: Moving this logic for calculation of `assets` to the else part where it is required will save gas due to the external pnl call (2600 call + 2*2100 SLOADs for state variable reads in calcPnL()) for the sardine flow, where this is not required.  ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L250-L258  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/pnl/PnL.sol#L144-L146   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move logic to else part instead of doing it before the conditional as shown below: ```         if (amount < bigFishAbsoluteThreshold) {             return false;         } else if (amount > assets) {             return true;         } else {             (uint256 gvtAssets, uint256 pwrdAssets) = IPnL(pnl).calcPnL();             uint256 assets = pwrdAssets.add(gvtAssets);             return amount > assets.mul(bigFishThreshold).div(PERCENTAGE_DECIMAL_FACTOR);         } ```  "}, {"title": "Unnecessary zero-address check", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Unnecessary zero-address check for account in addReferral() because it is always msg.sender (can never be 0) in the only call site from DepositHandler::depositGToken(). Removing this check can save a little gas in the critical deposit flow.   ## Proof of Concept  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L202  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove unnecessary zero-address check.  "}, {"title": "Removing unnecessary initializations can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Removing unnecessary initializations can save gas"}, {"title": "Rearranging order of state variable declarations to pack them will save storage slots and gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Moving declarations of state variables that take < 32 Bytes next to each other will allow combining them in the same storage slot and potentially save gas from combined SSTOREs depending on store patterns.  Impact: Moving emergencyState bool right next to preventSmartContracts bool will conserve a storage slot and may save gas.  ## Proof of Concept  See reference: https://mudit.blog/solidity-gas-optimization-tips/ and https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L54  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/Controller.sol#L44   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Moving declarations of state variables that take < 32 Bytes next to each other. E.g.: booleans next to each other or address types.  "}, {"title": "Simplifying logic will save at least 4200-11,500 gas in deposit flow", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The feeToken logic is to account for tokens that may charge transfer fees and therefore require balance checks before/after transfers. For now, the only token that is programmed to potentially do so (in future, not currently) is USDT (neither DAI/USDC have this capability).  Impact: While this flexible future-proof logic is good design, this costs 3 SLOADs = 3*2100 = 6300 gas for reading the state variable feeToken 3 times (different index each time i.e. costs 2100, not 100) while the only token programmed for transfer fees is USDT (which has never charged fees). 2100 gas + two external token balance calls for USDT (2600*2 = 5200 gas + balance gas costs) >= total of 7300 gas for USDT and 4200 gas for other two tokens is perhaps expensive to support this future-proofing logic. However, from a security-perspective, it might be safer to leave this in here for USDT but remove checking for other two.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L145-L149  https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L163-L167  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Evaluate removing it completely or hardcoding logic only for USDT index=2 to save gas.  "}, {"title": "Caching repeatedly read state variables in local variables can save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. Successive SLOADs cost 100 gas. Memory stores/loads (MSTOREs/MLOADs) cost only 3 gas. Therefore, by caching repeatedly read state variables in local variables within a function, one can save >=100 gas.  ## Proof of Concept  * Caching ctrl address in a local variable will save 300 gas because it is SLOADed 4 times now in this critical deposit flow. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L112 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L115 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L119 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L121  * Caching lg address state variable in a local variable outside the loop can save 1100 gas by avoiding 4 unnecessary SLOADs per loop iteration (4*3 = 12 but one SLOAD is hoisted out of the loop = 11 extra SLOADS at 100 gas = 1100 gas). https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L147-L151  * Caching buoy address state variable in the function beginning can save 100 gas from an extra SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L174-L176  * Caching insurance address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L193 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L198  * Caching lg address in function beginning can save 100 gas from an unnecessary SLOAD. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L197 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/DepositHandler.sol#L199  * Hoisting buoy state variable out of the loop and caching it in a local variable will save 300 gas from 3 unnecessary SLOADs. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L181  * Caching buoy in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L212 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L219  * Caching ctrl in a local variable at the function beginning and using that in the rest of this function will save 4 unnecessary SLOADs i.e. 400 gas in this function. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L211 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L221 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L226 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L236 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L260 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L264  * Hoisting buoy out of the loop and caching in a local variable will save 3 unnecessary SLOADs and so 300 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L329  * Caching lg in a local variable will save 100 gas. https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L356 https://github.com/code-423n4/2021-06-gro/blob/091660467fc8d13741f8aafcec80f1e8cf129a33/contracts/WithdrawHandler.sol#L357  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Cache repeatedly read state variables (especially those within a loop) in local variables at an appropriate part of the function (preferably the beginning) and use them instead of state variables. Converting SLOADs to MLOADs reduces gas from 100 to 3.  "}, {"title": "Using access lists can save gas due to EIP-2930 post-Berlin hard fork", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Using access lists can save gas due to EIP-2930 post-Berlin hard fork"}, {"title": "Avoid use of state variables in event emissions to save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Avoid use of state variables in event emissions to save gas"}, {"title": "Upgrading the solc compiler to >=0.8 may save gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Upgrading the solc compiler to >=0.8 may save gas"}, {"title": "Unnecessary duplication of array", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  The methods `_stableToUsd` and `_stableToLp`  in the`Buoy3Pool.sol` contract is duplicating the array unnecessarily and costing gas to the users.  ``` function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, \"deposit: !length\");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     uint256 lpAmount = curvePool.calc_token_amount(_tokenAmounts, deposit);     return _lpToUsd(lpAmount);   }    function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit)     internal     view     returns (uint256)   {     require(tokenAmounts.length == N_COINS, \"deposit: !length\");     uint256[N_COINS] memory _tokenAmounts;     for (uint256 i = 0; i < N_COINS; i++) {       _tokenAmounts[i] = tokenAmounts[i];     }     return curvePool.calc_token_amount(_tokenAmounts, deposit);   } ```  "}, {"title": "optimization uses extra gas", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "optimization uses extra gas"}, {"title": "BASIS_POINTS naming convention", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The variable BASIS_POINTS in Buoy3Pool.sol is written in capitals, which is the naming convention for constants. However BASIS_POINTS isn't a constant, because it is updated in setBasisPointsLmit This is confusing when reading the code.  ## Proof of Concept https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L30 uint256 public BASIS_POINTS = 20;   function setBasisPointsLmit(uint256 newLimit) external onlyOwner {         uint256 oldLimit = BASIS_POINTS;         BASIS_POINTS = newLimit;         emit LogNewBasisPointLimit(oldLimit, newLimit);     }  ## Tools Used  ## Recommended Mitigation Steps Change BASIS_POINTS  to something like: basisPoints   "}, {"title": "use safemath", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "use safemath"}, {"title": "calcProtocolExposureDelta could use a break", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact calcProtocolExposureDelta should probably stop executing once it has found the first occurrence where exposure > threshold. (as is also indicated in the comment).  The current code also works (due to the check protocolExposedDeltaUsd == 0), however inserting a break statement at the end of the \"if\" is more logical and saves a bit of gas.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Allocation.sol#L286 ///     By defenition, only one protocol can exceed exposure in the current setup. ...  function calcProtocolExposureDelta(uint256[] memory protocolExposure, SystemState memory sysState) private pure        returns (uint256 protocolExposedDeltaUsd, uint256 protocolExposedIndex)     {         for (uint256 i = 0; i < protocolExposure.length; i++) {             // If the exposure is greater than the rebalance threshold...             if (protocolExposedDeltaUsd == 0 && protocolExposure[i] > sysState.rebalanceThreshold) {                 // ...Calculate the delta between exposure and target                 uint256 target = sysState.rebalanceThreshold.sub(sysState.targetBuffer);                 protocolExposedDeltaUsd = protocolExposure[i].sub(target).mul(sysState.totalCurrentAssetsUsd).div(                     PERCENTAGE_DECIMAL_FACTOR                 );                 protocolExposedIndex = i;                     // probably put a break here             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add a break statement at the end of the if  "}, {"title": "Unnecessary update of amount ", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In several functions of BaseVaultAdaptor a value is stored in the variable amount at the end of the function. However this variable is never used afterwards so the storage is unnecessary and just uses gas.  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/BaseVaultAdaptor.sol#L165     function withdraw(uint256 amount) external override {      ..         if (!_withdrawFromAdapter(amount, msg.sender)) {             amount = _withdraw(calculateShare(amount), msg.sender);      function withdraw(uint256 amount, address recipient) external override {     ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdraw(calculateShare(amount), recipient);      function withdrawToAdapter(uint256 amount) external onlyOwner {         amount = _withdraw(calculateShare(amount), address(this));     }      function withdrawByStrategyOrder( ..         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyOrder(calculateShare(amount), recipient, reversed);      function withdrawByStrategyIndex(    ...         if (!_withdrawFromAdapter(amount, recipient)) {             amount = _withdrawByStrategyIndex(calculateShare(amount), recipient, strategyIndex);   ## Tools Used  ## Recommended Mitigation Steps Replace   amount = _withdraw***(...); with    _withdraw***(...);  "}, {"title": "Easier way to determine strategiesLength ", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Easier way to determine strategiesLength "}, {"title": "initialize maxPercentForWithdraw and maxPercentForDeposit?", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/16", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "initialize maxPercentForWithdraw and maxPercentForDeposit?"}, {"title": "require comments don't all follow convention", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "require comments don't all follow convention"}, {"title": "Outdated comment at calculateWithdrawalAmountsOnPartVaults ", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "Outdated comment at calculateWithdrawalAmountsOnPartVaults "}, {"title": "redundant check of array length", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _stableToUsd and _stableToLp check that the size of the input array is right. However because that parameter definition also contains the length (e.g. [N_COINS] ), it is already checked by solidity.  So checking it again is not necessary. Note: if this would be necessary than it should also be done at the other functions that have an input parameter with  [N_COINS], see at Proof of concept.  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L174     function _stableToUsd(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, \"deposit: !length\");     ...      function _stableToLp(uint256[N_COINS] memory tokenAmounts, bool deposit) internal view returns (uint256) {         require(tokenAmounts.length == N_COINS, \"deposit: !length\");       ..  Other functions with a [N_COINS] parameter: .\\Controller.sol:    function distributeCurveAssets(uint256 amount, uint256[N_COINS] memory delta) external onlyWhitelist { .\\DepositHandler.sol:    function _invest(uint256[N_COINS] memory _inAmounts, uint256 roughUsd) internal returns (uint256 dollarAmount) { .\\DepositHandler.sol:    function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) { .\\WithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[N_COINS] calldata minAmounts) external override { .\\insurance\\Exposure.sol:    function getUnifiedAssets(address[N_COINS] calldata vaults) .\\insurance\\Exposure.sol:    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure) .\\insurance\\Insurance.sol:    function calculateWithdrawalAmountsOnPartVaults(uint256 amount, address[N_COINS] memory vaults) .\\insurance\\Insurance.sol:    function calculateWithdrawalAmountsOnAllVaults(uint256 amount, address[N_COINS] memory vaults) .\\pools\\LifeGuard3Pool.sol:    function distributeCurveVault(uint256 amount, uint256[N_COINS] memory delta) .\\pools\\LifeGuard3Pool.sol:    function invest(uint256 depositAmount, uint256[N_COINS] calldata delta) .\\pools\\LifeGuard3Pool.sol:    function _withdrawUnbalanced(uint256 inAmount, uint256[N_COINS] memory delta) private { .\\pools\\oracle\\Buoy3Pool.sol:    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) { .\\pools\\oracle\\Buoy3Pool.sol:    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {  ## Tools Used  ## Recommended Mitigation Steps Remove : require(tokenAmounts.length == N_COINS, \"deposit: !length\");  "}, {"title": "setUnderlyingTokenPercent should check percentages", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/11", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-06-gro-findings", "body": "setUnderlyingTokenPercent should check percentages"}, {"title": "setFeeToken doesn't check index", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "setFeeToken doesn't check index"}, {"title": "implicit assumptions about underlying coins", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "implicit assumptions about underlying coins"}, {"title": "hardcoded values", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact There are several hardcodes values that could very well be replaced with constants. For example: - 10**18 - 5E17 - 10000  - 10**4 - 3 (N_COINS) This will make the code more readable and easier to maintain  ## Proof of Concept //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/DepositHandler.sol#L206  function roughUsd(uint256[N_COINS] memory inAmounts) private view returns (uint256 usdAmount) {      ..            usdAmount = usdAmount.add(inAmounts[i].mul(10**18).div(getDecimal(i)));  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/tokens/GToken.sol#L24 abstract contract GToken is GERC20, Constants, Whitelist, IToken {     uint256 public constant BASE = DEFAULT_DECIMALS_FACTOR;   function applyFactor(   ....      if (diff >= 5E17) {  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/vaults/yearnv2/v032/VaultAdaptorYearnV2_032.sol#L107 function updateStrategiesDebtRatio(uint256[] memory ratios) internal override {         ..         require(ratioTotal <= 10**4, \"The total of ratios is more than 10000\");  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L317  function emergency(uint256 coin) external onlyWhitelist { ...        percent = 10000;  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Insurance.sol#L144  function getVaultDeltaForDeposit(uint256 amount) ....   investDelta[vaultIndexes[0]] = 10000;   .\\common\\StructDefinitions.sol:    uint256[3] vaultCurrentAssets; .\\common\\StructDefinitions.sol:    uint256[3] vaultCurrentAssetsUsd; .\\common\\StructDefinitions.sol:    uint256[3] stablePercents; .\\common\\StructDefinitions.sol:    uint256[3] stablecoinExposure; .\\common\\StructDefinitions.sol:    uint256[3] protocolWithdrawalUsd; .\\common\\StructDefinitions.sol:    uint256[3] swapInAmounts; .\\common\\StructDefinitions.sol:    uint256[3] swapInAmountsUsd; .\\common\\StructDefinitions.sol:    uint256[3] swapOutPercents; .\\common\\StructDefinitions.sol:    uint256[3] vaultsTargetUsd; .\\interfaces\\IBuoy.sol:    function stableToUsd(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\\interfaces\\IBuoy.sol:    function stableToLp(uint256[3] calldata inAmount, bool deposit) external view returns (uint256); .\\interfaces\\IController.sol:    function stablecoins() external view returns (address[3] memory); .\\interfaces\\IController.sol:    function vaults() external view returns (address[3] memory); .\\interfaces\\ICurve.sol:    function calc_token_amount(uint256[3] calldata inAmounts, bool deposit) external view returns (uint256); .\\interfaces\\ICurve.sol:    function add_liquidity(uint256[3] calldata uamounts, uint256 min_mint_amount) external; .\\interfaces\\ICurve.sol:    function remove_liquidity(uint256 amount, uint256[3] calldata min_uamounts) external; .\\interfaces\\ICurve.sol:    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external; .\\interfaces\\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\\interfaces\\IDepositHandler.sol:        uint256[3] calldata inAmounts, .\\interfaces\\IExposure.sol:    function getUnifiedAssets(address[3] calldata vaults) .\\interfaces\\IExposure.sol:        returns (uint256 unifiedTotalAssets, uint256[3] memory unifiedAssets); .\\interfaces\\IExposure.sol:        uint256[3] calldata unifiedAssets, .\\interfaces\\IExposure.sol:        uint256[3] calldata targetPercents .\\interfaces\\IExposure.sol:    ) external pure returns (uint256[3] memory vaultIndexes); .\\interfaces\\IExposure.sol:        uint256[3] calldata targets, .\\interfaces\\IExposure.sol:        address[3] calldata vaults, .\\interfaces\\IExposure.sol:    ) external view returns (uint256[3] memory); .\\interfaces\\IInsurance.sol:    function calculateDepositDeltasOnAllVaults() external view returns (uint256[3] memory); .\\interfaces\\IInsurance.sol:    function getDelta(uint256 withdrawUsd) external view returns (uint256[3] memory delta); .\\interfaces\\IInsurance.sol:            uint256[3] memory, .\\interfaces\\IInsurance.sol:            uint256[3] memory, .\\interfaces\\IInsurance.sol:    function sortVaultsByDelta(bool bigFirst) external view returns (uint256[3] memory vaultIndexes); .\\interfaces\\ILifeGuard.sol:    function getAssets() external view returns (uint256[3] memory); .\\interfaces\\ILifeGuard.sol:    function distributeCurveVault(uint256 amount, uint256[3] memory delta) external returns (uint256[3] memory); .\\interfaces\\ILifeGuard.sol:    function invest(uint256 whaleDepositAmount, uint256[3] calldata delta) external returns (uint256 dollarAmount); .\\interfaces\\ILifeGuard.sol:        uint256[3] calldata inAmounts, .\\interfaces\\IWithdrawHandler.sol:        uint256[3] calldata minAmounts .\\interfaces\\IWithdrawHandler.sol:    function withdrawAllBalanced(bool pwrd, uint256[3] calldata minAmounts) external; .\\pools\\oracle\\Buoy3Pool.sol:    function getTokenRatios(uint256 i) private view returns (uint256[3] memory _ratios) { .\\pools\\oracle\\Buoy3Pool.sol:        uint256[3] memory _prices; .\\pools\\oracle\\Buoy3Pool.sol:        for (uint256 j = 0; j < 3; j++) {   ## Tools Used  ## Recommended Mitigation Steps Do the following replacements - 10**18 ==> DEFAULT_DECIMALS_FACTOR - 5E17 ==> DEFAULT_DECIMALS_FACTOR /2 or BASE/2 - 10000 ==> PERCENTAGE_DECIMAL_FACTOR - 10**4 ==> PERCENTAGE_DECIMAL_FACTOR - 3 ==> N_COINS  "}, {"title": "lastRatio of Buoy3Pool not initialized", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-06-gro-findings", "body": "lastRatio of Buoy3Pool not initialized"}, {"title": "implicit underflows", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/6", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert. int256(a-b)  where a and b are uint, For example if a=1 and b=2 then the intermediate result would be uint(-1) == 2**256-1 int256(-x) where x is a uint. For example if x=1 then the intermediate result would be uint(-1) == 2**256-1 Its better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(..) ..         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result  //https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112  function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)... ..  emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result  // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87  function safetyCheck() external view override returns (bool) {       ...             _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result    ## Tools Used  ## Recommended Mitigation Steps replace int256(a-b) with int256(a)-int256(b) replace int256(-x)   with -int256(x)   "}, {"title": "emergencyHandler not checked & not emitted", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/5", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setWithdrawHandler allows the setting of withdrawHandler and emergencyHandler. However emergencyHandler isn't checked for 0 (like the withdrawHandler ) The value of the emergencyHandler is also not emitted (like the withdrawHandler )  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/Controller.sol#L105  function setWithdrawHandler(address _withdrawHandler, address _emergencyHandler) external onlyOwner {         require(_withdrawHandler != address(0), \"setWithdrawHandler: 0x\");         withdrawHandler = _withdrawHandler;         emergencyHandler = _emergencyHandler;         emit LogNewWithdrawHandler(_withdrawHandler);     }  ## Tools Used  ## Recommended Mitigation Steps Add something like:         require(_emergencyHandler!= address(0), \"setEmergencyHandler: 0x\");         event LogNewEmergencyHandler(address tokens);         emit LogNewEmergencyHandler(_emergencyHandler);  "}, {"title": "sortVaultsByDelta doesn't work as expected", "html_url": "https://github.com/code-423n4/2021-06-gro-findings/issues/2", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-06-gro-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function sortVaultsByDelta doesn't always work as expected. Suppose all the delta's are positive, and delta1 >= delta2 >= delta3 > 0 Then maxIndex = 0 And (delta < minDelta (==0) ) is never true, so minIndex = 0  Then (assuming bigFirst==true): vaultIndexes[0] = maxIndex = 0 vaultIndexes[2] = minIndex = 0 vaultIndexes[1] = N_COINS - maxIndex - minIndex = 3-0-0 = 3  This is clearly not what is wanted, all vaultIndexes should be different and should be in the range [0..2] This is due to the fact that maxDelta and minDelta are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because vaultIndexes[1]  is out of range).  ## Proof of Concept // https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178 function sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {         uint256 maxIndex;         uint256 minIndex;         int256 maxDelta;         int256 minDelta;         for (uint256 i = 0; i < N_COINS; i++) {             // Get difference between vault current assets and vault target             int256 delta = int256(                 unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)             );             // Establish order             if (delta > maxDelta) {                 maxDelta = delta;                 maxIndex = i;             } else if (delta < minDelta) {                 minDelta = delta;                 minIndex = i;             }         }         if (bigFirst) {             vaultIndexes[0] = maxIndex;             vaultIndexes[2] = minIndex;         } else {             vaultIndexes[0] = minIndex;             vaultIndexes[2] = maxIndex;         }         vaultIndexes[1] = N_COINS - maxIndex - minIndex;     }  ## Tools Used  ## Recommended Mitigation Steps Initialize maxDelta and minDelta:         int256 maxDelta = -2**255; // or type(int256).min when using a newer solidity version         int256 minDelta  = 2**255; // or type(int256).max when using a newer solidity version Check maxIndex and minIndex are not the same require (maxIndex != minIndex);  "}, {"title": "The interest rate is calculated based on assumptions on the block time", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/142", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "The interest rate is calculated based on assumptions on the block time"}, {"title": "Unimplemented methods in several interfaces", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/140", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Some methods declared in the interfaces are not implemented. Specifically, the `withdrawRepay` method of `ILendingPair` and the `liqFeePool` method of `Controller`.  ## Proof of Concept  Referenced code: [IController.sol#L14](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/IController.sol#L14) [ILendingPair.sol#L22](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/interfaces/ILendingPair.sol#L22)  ## Recommended Mitigation Steps  Remove the unimplemented methods.  "}, {"title": "Add a proper revert message in `transferFrom` of `LPTokenMaster`", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/138", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Add a proper revert message in `transferFrom` of `LPTokenMaster`"}, {"title": "Math.max can be used", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/133", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The line `return (rate < MIN_RATE) ? MIN_RATE : rate;` can be written as `return Math.max(rate, MIN_RATE);` for an easier reading, since the Math library is already imported.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/InterestRateModel.sol#L37  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Rewrite using the Math.max function  "}, {"title": "Boolean to constant comparison", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/132", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Boolean to constant comparison"}, {"title": "typo in revert", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/131", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "typo in revert"}, {"title": "typo: totalAccountBorrrow", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/130", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact Simple typo: totalAccountBorrrow instead of totalAccountBorrow  ## Proof of Concept In LendingPair.sol: ```     uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);      return totalAccountSupply * 1e18 / totalAccountBorrrow; ```  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Correct the typo  "}, {"title": "Unused imported interface in LendingPair", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The './interfaces/IInterestRateModel.sol' imported in LendingPair.sol isn't actually used and can be removed  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L13  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove the import line.  "}, {"title": " Recommended", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/127", "labels": ["bug", "invalid", "disagree with severity", "sponsor disputed", "3 (High Risk)"], "target": "2021-07-wildcredit-findings", "body": " Recommended"}, {"title": "repayAll() and repayAllETH() vulnerable to frontrunning", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/125", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The repayAll() and repayAllETH() functions allow any user to pay off debt of another user. Since all of the debt is going to be paid, no amount is specified, allowing the recipient of the repayment to frontrun the transaction to increase their debt. The risk of this issued was lowered as it depended on the user having enough tokens and allowance in the case of repayAll(), or having a msg.sender higher than the current debt in the case of repayAllEth().  ## Proof of Concept The affected lines are the following:  https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L147 https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156  The scenario for repayAll() is the following:  1. Alice pays off 5 of Bob's Dai debt using repayAll(). 2. Bob monitors the mempool for Alice's transaction, and front-runs it by taking out as much debt as Alice's allowance (and therefore balance) to the contract. 3. `debtOf[_token][_account]` now returns the higher amount and pays off Bob's new debt.   The scenario for repayAllEth() is similar:  1. Alice pays off 0.5 of Bob's Weth debt using repayAllEth(). 2. Bob monitors the mempool for Alice's transaction, and frontruns it by taking out as much debt as Alice's msg.value amount used. 3. `debtOf[address(WETH)][_account]` now returns the higher amount and pays off Bob's new debt.  ## Recommended Mitigation Steps This issue can be mitigated by enforcing a minimum time to hold debt - e.g. not allowed to repay debt for at least 6 blocks. Alternatively, the repay() function could be used to replace the 2 affected functions by passing in the _amount as the total debt (looked up off-chain and used in the dapp, for example) so that only up to a certain amount of debt is paid. This also means the repay() function would need to be made `payable`, and that the `msg.value` is validated to equal the _amount parameter.  "}, {"title": "`LendingPair.pendingSupplyInterest` is not accurate", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LendingPair.pendingSupplyInterest` does not accrue the new interest since the last update.  ## Impact The returned value is not accurate.  ## Recommendation Accrue it first such that `cumulativeInterestRate` updates and `_newInterest` returns the updated value.  "}, {"title": "`LendingPair.liquidateAccount` fails if tokens are lent out", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/123", "labels": ["bug", "disagree with severity", "sponsor confirmed", "3 (High Risk)"], "target": "2021-07-wildcredit-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function tries to pay out underlying supply tokens to the liquidator using `_safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput)` but there's no reason why there should be enough `supplyOutput` amount in the contract, the contract only ensures `minReserve`.  ## Impact No liquidations can be performed if all tokens are lent out. Example: User A supplies 1k$ WETH, User B supplies 1.5k$ DAI and borrows the ~1k$ WETH (only leaves `minReserve`). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.  ## Recommendation Mint LP supply tokens to `msg.sender` instead, these are the LP supply tokens that were burnt from the borrower. This way the liquidator basically seizes the borrower's LP tokens.  "}, {"title": "`LendingPair.liquidateAccount` does not accrue and update cumulativeInterestRate", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/122", "labels": ["bug", "disagree with severity", "sponsor confirmed", "3 (High Risk)"], "target": "2021-07-wildcredit-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LendingPair.liquidateAccount` function does not accrue and update the `cumulativeInterestRate` first, it only calls `_accrueAccountInterest` which does not update and instead uses the old `cumulativeInterestRate`.  ## Impact The liquidatee (borrower)'s state will not be up to date. I could skip some interest payments by liquidating myself instead of repaying if I'm under-water. As the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.  ## Recommendation It should call `accrueAccount` instead of `_accrueAccountInterest`   "}, {"title": "Simple interest formula is used", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Simple interest formula is used"}, {"title": "Uniswap oracle assumes PairToken <> WETH liquidity", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/118", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Uniswap oracle assumes PairToken <> WETH liquidity"}, {"title": "Reward computation is wrong", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/116", "labels": ["bug", "disagree with severity", "sponsor acknowledged", "3 (High Risk)"], "target": "2021-07-wildcredit-findings", "body": "Reward computation is wrong"}, {"title": "Total LP supply & total debt accrual is wrong", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Total LP supply & total debt accrual is wrong"}, {"title": "LPTokenMaster does not implement `IERC20`", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/113", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "LPTokenMaster does not implement `IERC20`"}, {"title": "Interest model is non-continuous", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/112", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  cmichel   # Vulnerability details  The `InterestRateModel.borrowRatePerBlock` function has a literal jump at target ratio and does not form a continuous function. Usually (as in Compound) it's a piece-wise continuous function with a linear function `f` on `[0%; TARGET%]` and a second linear function `g` on [`TARGET%; 100%]` where `f(TARGET) = g(TARGET)` and `g`'s slope is much higher than `f` to discourage further borrows.  Example: Assuming a `TARGET_UTILIZATION` of 80%, the `borrowRatePerBlock` for a utilisation ratio slightly less than `TARGET_UTILIZATION` (`if` branch) would be: `LOW_RATE * TARGET_UTILIZATION`. However, when borrowing **at** `TARGET_UTILIZATION` (`else` branch), the `borrowRatePerBlock` suddenly becomes `TARGET_UTILIZATION`, i.e., a `(1-LOW_RATE) * TARGET_UTILIZATION` increase.  This is because `debt - (supply * TARGET_UTILIZATION / 100e18) = 0` (as `debt * 100e18 / supply = TARGET_UTILIZATION`) and thus the inner `utilization = 0`.   ## Impact Borrowing a single wei more that pushes the utilization ratio to the `TARGET_UTILIZATION` (going from `if` to `else` branch)  leads to suddenly having to pay 20% (1 - target) more interest **on the overall debt position**.  ## Recommended Mitigation Steps I think the expected behavior for the `else` case should be something like `TARGET_UTILIZATION * LOW_RATE + (HIGH_RATE - TARGET_UTILIZATION * LOW_RATE) * utilization / 100e18` such that it's a continuous function at utiisation ratio of `TARGET_UTILIZATION`.  "}, {"title": "Variables that can be converted into immutables", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "Variables that can be converted into immutables"}, {"title": "when setting new value for feeRecepient/totalRewardPerBlock ensure that new value is different from old one", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/109", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "when setting new value for feeRecepient/totalRewardPerBlock ensure that new value is different from old one"}, {"title": "Lack of zero address validation", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/108", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Due to lack of zero address validation funds can be lost in following case  ex - No checking of address(0) in constructor        No checking of address(0) while using low-level call to transfer eth  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L25  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L49  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L57  ## Tools Used manual review  ## Recommended Mitigation Steps  add zero address validation  "}, {"title": "Packing of  variable in controller.sol", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Packing of  variable in controller.sol"}, {"title": "Migrate Rewards Without Distribution", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/102", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Migrate Rewards Without Distribution"}, {"title": "Use of Floating Pragma", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact  https://swcregistry.io/docs/SWC-103  ## Proof of Concept Most of  listed files uses floating pragma, some are  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L6  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L3  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/InterestRateModel.sol#L6  ## Tools Used  manual review  ## Recommended Mitigation Steps use fixed solidity version  "}, {"title": "Erc20 Race condition for allowance", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor disputed"], "target": "2021-07-wildcredit-findings", "body": "Erc20 Race condition for allowance"}, {"title": "Rewards can be migrated to an arbitrary address at anytime by owner", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/93", "labels": ["bug", "invalid", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Rewards can be migrated to an arbitrary address at anytime by owner"}, {"title": "Critical protocol parameter configuration/changes should have sanity/threshold checks", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/85", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Critical protocol parameter configuration/changes should have sanity/threshold checks"}, {"title": "Single-step process for critical ownership transfers is risky", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Multiple contracts: Controller, LPTokenMaster, RewardDistribution and UniswapV3Oracle use onlyOwner authorized functions. Given that this is derived from Ownable, the ownership management of these contracts defaults to Ownable\u2019s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  Scenario: If an incorrect address, e.g. for which the private key is not known, is used accidentally then it prevents the use of all the onlyOwner() functions forever, which includes the changing of various critical addresses and parameters. This use of incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing onlyOwner() function call, it will force the redeployment of these contracts and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in the protocol and incur a significant reputational damage.   ## Proof of Concept  See similar High Risk severity finding from Trail-of-Bits Audit of Hermez: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  See similar Medium Risk severity finding from Trail-of-Bits Audit of Uniswap V3: https://github.com/Uniswap/uniswap-v3-core/blob/main/audits/tob/audit.pdf  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/external/Ownable.sol#L25-L38  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/Controller.sol#L11  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/LPTokenMaster.sol#L12  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/RewardDistribution.sol#L17  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/UniswapV3Oracle.sol#L12  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Override the inherited methods to null functions and use separate functions for a two-step address change: 1) Approve a new address as a pendingOwner 2) A transaction from the pendingOwner address claims the pending ownership change. This mitigates risk because if an incorrect address is used in step (1) then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.  Also, consider adding a timelock delay for such sensitive actions. And at a minimum, use a multisig (with mutually independent and trustworthy owners) and not an EOA.  "}, {"title": "Gas optimizations - optimize reads in _distributeReward ", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Gas optimizations - optimize reads in _distributeReward "}, {"title": "Gas optimizations - Check first If blocksElapsed == 0 in _pendingRewardPerToken", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/76", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Gas optimizations - Check first If blocksElapsed == 0 in _pendingRewardPerToken"}, {"title": "Chainlink - Use latestRoundData instead latestAnswer to run more validations", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  `UniswapV3Oracle.sol` is calling `latestAnswer` to get the last WETH price. This method will return the last value, but you won't be able to check if the data is fresh. On the other hand, calling the method `latestRoundData` allow you to run some extra validations  ```        (           roundId,           rawPrice,           ,           updateTime,           answeredInRound         ) = AggregatorV3Interface(XXXXX).latestRoundData();         require(rawPrice > 0, \"Chainlink price <= 0\");         require(updateTime != 0, \"Incomplete round\");         require(answeredInRound >= roundId, \"Stale price\"); ```  More information:  https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  "}, {"title": "Gas optimizations - Use bytesX instead of string", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "Gas optimizations - Use bytesX instead of string"}, {"title": "_wethWithdrawTo is vulnerable re-entrancy", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function withdrawBorrowETH invokes _wethWithdrawTo and later _checkMinReserve, however, the check of reserve is not necessary here, as function _wethWithdrawTo also does that after transferring the ether. However, this reserve check might be bypassed as TransferHelper._wethWithdrawTo uses a low level call that is vulnerable to re-entrancy attacks. As this MIN_RESERVE sounds like an important value, you should consider preventing re-entrancy attacks here.   // Prevents division by zero and other undesirable behavior   uint public constant MIN_RESERVE = 1000;  ## Recommended Mitigation Steps Consider using re-entrancy guard on all main action functions (e.g. deposit, withdraw, borrow, repay, etc): https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  "}, {"title": "setReward does not check if pid exists", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setReward does not check if pid actually exists. Provided wrong _pair, _token and _isSupply params it will return a default value of 0, thus the first pool will be updated even though the caller may intended to update another pool. The risk is very low as this function can only be called by onlyOwner but I still think the code should prevent such scenarios from accidentally happening.  ## Recommended Mitigation Steps Check that pidByPairToken added value is true.  "}, {"title": "addPool emits PoolUpdate with wrong pid", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Function addPool emits event PoolUpdate passing pools.length as pid while the actual pid is pools.length-1.  ## Recommended Mitigation Steps    emit PoolUpdate(pools.length-1, _pair, _token, _isSupply, _points); or even better store it in a temporary variable and re-use multiple times.  "}, {"title": "safeTransferFrom in TransferHelper is not safeTransferFrom", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact A non standard erc20 token would always raise error when calling `_safeTransferFrom`.  If a user creates a USDT/DAI pool and deposit into the pool he would find out there's never a counterpart deposit.  ## Proof of Concept  https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L19  TransferHelper does not uses `SafeERC20` library as the function name implies.   A sample POC: script: ``` usdt.functions.approve(lending_pair.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) lending_pair.functions.deposit(w3.eth.accounts[0], usdt.address, deposit_amount).transact({'from': w3.eth.accounts[0]}) ```  Error Message: ```   Error: Transaction reverted: function returned an unexpected amount of data       at LendingPair._safeTransferFrom (contracts/TransferHelper.sol:20)       at LendingPair.deposit (contracts/LendingPair.sol:95) ``` ## Tools Used  Hardhat  ## Recommended Mitigation Steps Uses openzeppelin `SafeERC20` in transfer helper (and any other contract that uses IERC20).  "}, {"title": "Code size exceed limit", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor disputed"], "target": "2021-07-wildcredit-findings", "body": "Code size exceed limit"}, {"title": "LendingPair: Missing validation check for ETH methods [Updated]", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  The `depositRepayETH()`, `withdrawBorrowETH()`, `withdrawAllETH()` and `repayAllETH()` fail to check if ETH is an asset of the lending pair (ie. if ETH is either tokenA or tokenB).  From manually tracing the `depositRepayETH()` function, attempts to call it will revert in `_mintSupply()` when `lpToken[_token].mint(_account, _amount);` is called, since the `lpToken` is only initialized for only tokenA and tokenB.  Nevertheless, it is recommended to perform token validation for the ETH methods as well, since it should be treated like other ERC20 tokens. It also helps to avoid wasting gas.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L83)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L131)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L156)  ## Recommended Mitigation Steps  Include `_validateToken()` in the equivalent ETH functions. An alternative suggestion is to drop the ETH methods (eg. combine `depositRepayETH()` into `depositRepay()` and doing a bit of refactoring to make native ETH deposits / withdrawals possible.  ```jsx // public constant ETH_ADDRESS = ''; // define a special constant address for ether != WETH address function depositRepay(address _account, address _token, uint _amount) external payable {     _validateTokenAndValue(_token, msg.value, _amount);     accrueAccount(_account);      _depositRepay(_account, _token, _amount);   _handleDeposit{value:msg.value}(_token, _amount); }  function _validateTokenAndValue(address _token, uint etherWei, uint amount) internal view {   address token;   if (_token == ETH_ADDRESS) {    token = WETH;    require(etherWei == amount, \"LendingPair: invalid etherWei\");   } else {    token = _token;    require(etherWei == 0, \"LendingPair: invalid etherWei\");   }     require(token == tokenA || token == tokenB, \"LendingPair: invalid token\"); }  function _handleDeposit(address _token, uint _amount) internal payable {  (_token == ETH_ADDRESS) ?    WETH.deposit{ value: msg.value }() :    _safeTransferFrom(_token, msg.sender, _amount); } ```  "}, {"title": "LendingPair: Unnecessary Casting", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  The address casting of `_token` in `lpToken[address(_token)]` can be removed in the `withdrawAll()`, `_withdraw()` and `_borrow()` functions, since `_token` is already an address in these functions.   In other words, `lpToken[address(_token)]` *\u2192* `lpToken[token]`  "}, {"title": "External call does not have amount check in TransferHelper", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "disagree with severity", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  There is occurrence in the code of the TransferHelper contract where amount is checked after the external call.  ## Proof of Concept  - Navigate to [TransferHelper.sol](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol) -  Amount is checked after an external call. [TransferHelper.sol amount check](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol#L22)  -  To favor readability and avoid confusions, consider applying check at the beginning of function.  ## Tools Used  None  ## Recommended Mitigation Steps  To favor readability and avoid confusions, consider applying check at the beginning of function.  ```sh   function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     require(_amount > 0, \"TransferHelper: amount must be > 0\");     ...   } ```  "}, {"title": "UniswapV3Oracle: Reduce minObservations to uint16", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  Will help prevent erraneous `minObservations` values from being set (ie. `> 65535`) by the owner without needing checks. Otherwise, the `isPoolValid` will always return false, causing reverts in calling `tokenPrice` and `addPool` functions (and other functions calling these).  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L25)  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L101)  ## Proof Of Concept  The maximum number of observations available is `65535` (see [https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39](https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Pool.sol#L39)), which is equivalent to `type(uint16).max`.  Hence,   - `uint public minObservations` can be reduced to `uint16 public minObservations`. - `(, , , , uint observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();` becomes `(, , , , uint16 observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();`  "}, {"title": "UniswapV3Oracle: No events emitted for setUniPriceConverter, setTwapPeriod, setMinObservations", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  No impact but personally, I think it's good practice to emit an event whenever you update the state of the contract via a setter function.  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/UniswapV3Oracle.sol#L65-L75)  "}, {"title": "RewardDistribution: Optimise pendingSupplyReward, pendingBorrowReward, _distributeReward and _poolRewardRate", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "RewardDistribution: Optimise pendingSupplyReward, pendingBorrowReward, _distributeReward and _poolRewardRate"}, {"title": "RewardDistribution: Optimise _getPid", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  A repeated call to `pidByPairToken[_pair][_token][_isSupply]` can be avoided since it is stored in `poolPosition`. Simply return [poolPosition.pid](http://poolposition.pid).   ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/RewardDistribution.sol#L245-L250)  ## Proof of Concept  ```jsx function _getPid(address _pair, address _token, bool _isSupply) internal view returns(uint) {     PoolPosition memory poolPosition = pidByPairToken[_pair][_token][_isSupply];     require(poolPosition.added, \"RewardDistribution: invalid pool\");      return poolPosition.pid; } ```  "}, {"title": "RewardDistribution: Redundant boolean flag check in _getPid()", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "RewardDistribution: Redundant boolean flag check in _getPid()"}, {"title": "RewardDistribution: Avoid 0 pid to drop boolean flag use", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "RewardDistribution: Avoid 0 pid to drop boolean flag use"}, {"title": "LPTokenMaster: underlying() \u2192 address underlyingToken", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "LPTokenMaster: underlying() \u2192 address underlyingToken"}, {"title": "LPTokenMaster: CEI Pattern", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  greiart   # Vulnerability details  ## Impact  It would be better to perform the allowance check before handling the token transfer. This is in line with the best practice of the CEI (checks-effects-interactions) pattern to avoid possible re-entrancy attacks.  [https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk](https://dev.to/mxmaster2s/quick-guide-to-the-checks-effect-interactions-pattern-to-remember-when-writing-your-smart-contracts-gfk)  ## Referenced Codelines  [https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46)  ## Recommended Mitigation Steps  ```jsx function transferFrom(address _sender, address _recipient, uint _amount) external returns (bool) {     _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);     _transfer(_sender, _recipient, _amount);     return true; } ```  "}, {"title": "LendingPair: Optimise liquidation parameter calculations", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "LendingPair: Optimise liquidation parameter calculations"}, {"title": "LendingPair: Error Messages can be improved", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/40", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "LendingPair: Error Messages can be improved"}, {"title": "LendingPair: Cache token decimals", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "LendingPair: Cache token decimals"}, {"title": "LendingPair: Avoid rounding error in _accrueAccountSupply()", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "LendingPair: Avoid rounding error in _accrueAccountSupply()"}, {"title": "InterestRateModel: Use constant for 100e18", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "InterestRateModel: Use constant for 100e18"}, {"title": "InterestRateModel: Infallible logic", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-07-wildcredit-findings", "body": "InterestRateModel: Infallible logic"}, {"title": "difference between _safeTransferFrom and _safeTransfer", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact   The functions _safeTransferFrom and _safeTransfer are similar but there is one difference: _safeTransferFrom reverts when _amount == 0 _safeTransfer  doesn't do any action when _amount == 0  I don't see any reason for the different behavior.  ## Proof of Concept https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/TransferHelper.sol function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {     bool success = IERC20(_token).transferFrom(_sender, address(this), _amount);     require(success, \"TransferHelper: transfer failed\");     require(_amount > 0, \"TransferHelper: amount must be > 0\");   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L468   function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {     if (_amount > 0) {       bool success = _token.transfer(_recipient, _amount);       require(success, \"LendingPair: transfer failed\");       _checkMinReserve(address(_token));     }   }  ## Tools Used  ## Recommended Mitigation Steps Double check the difference and perhaps apply the same logic for amount==0 to both functions.  "}, {"title": "Use immutable keyword", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/28", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "Use immutable keyword"}, {"title": "redundant call to _checkMinReserve in withdrawBorrowETH ", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function withdrawBorrowETH of the contract LendingPair calls _wethWithdrawTo and then calls _checkMinReserve. However _wethWithdrawTo also calls _checkMinReserve  (except when _amount but then not much happens anyway.  So the call to _checkMinReserve in withdrawBorrowETH is redundant and uses some extra gas.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L106  function withdrawBorrowETH(uint _amount) external {    ..     _wethWithdrawTo(msg.sender, _amount);     _checkMinReserve(address(WETH)); // is also called in _wethWithdrawTo   }   function _wethWithdrawTo(address _to, uint _amount) internal override {     if (_amount > 0) {       TransferHelper._wethWithdrawTo(_to, _amount);       _checkMinReserve(address(WETH));     }   }  ## Tools Used  ## Recommended Mitigation Steps Consider removing the _checkMinReserve in withdrawBorrowETH Or consider moving the _checkMinReserve to all functions where _wethWithdrawTo is called  "}, {"title": "minBorrowUSD not initialized in the contract", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The parameter minBorrowUSD of the contract Controller isn't initialized. If someone is able to Borrow before the function setMinBorrowUSD is called, he might be able to borrow a very small amount. This might be unwanted.  ## Proof of Concept //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L27   uint public minBorrowUSD;    function setMinBorrowUSD(uint _value) external onlyOwner {     minBorrowUSD = _value;   }  //https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LendingPair.sol#L553 function _checkBorrowLimits(address _token, address _account) internal view {    ...     require(accountBorrowUSD >= controller.minBorrowUSD(), \"LendingPair: borrow amount below minimum\");   ## Tools Used  ## Recommended Mitigation Steps Initialize minBorrowUSD via the constructor or set a reasonable default in the contract.  "}, {"title": "No check of MAX_LIQ_FEES in contructor of Controller", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Both the functions setLiqParamsToken and setLiqParamsDefault have a check to make sure that _liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES  However the constructor of Controller sets the same parameters and doesn't have this check. It seems logical to also do the check in the controller otherwise the parameters could be set outside of the wanted range.  ## Proof of Concept // https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L49 constructor( address _interestRateModel, uint _liqFeeSystemDefault, uint _liqFeeCallerDefault) {     ...     liqFeeSystemDefault = _liqFeeSystemDefault;     liqFeeCallerDefault = _liqFeeCallerDefault;  function setLiqParamsToken( address _token, uint    _liqFeeSystem, uint    _liqFeeCaller ) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, \"Controller: fees too high\"); ...     liqFeeSystemToken[_token] = _liqFeeSystem;     liqFeeCallerToken[_token] = _liqFeeCaller;  function setLiqParamsDefault( uint    _liqFeeSystem, uint    _liqFeeCaller) external onlyOwner {     require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, \"Controller: fees too high\");     liqFeeSystemDefault = _liqFeeSystem;     liqFeeCallerDefault = _liqFeeCaller;  ## Tools Used  ## Recommended Mitigation Steps Add something like the following in the constructor of Controller  require(liqFeeCallerDefault + liqFeeSystemDefault <= MAX_LIQ_FEES, \"Controller: fees too high\");  "}, {"title": "Undefined Event", "html_url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-wildcredit-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Without Event, it is difficult to identify in real-time whether correct values are recorded on the blockchain. In this case, it becomes problematic to determine whether the corresponding value has been changed in the application and whether the corresponding function has been called. setMinBorrowUSD function is missing event.  ## Proof of Concept  1. Go to following the function [setMinBorrowUSD Function](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/Controller.sol#L137) 2. There is missing event definition on the function.   ## Tools Used  None  ## Recommended Mitigation Steps  Add Event corresponding to the change occurring in the function.  <code>Add `emit NewMinBorrowUSD(_value);`</code>  "}, {"title": "Flash loan manipulation on `getPoolShareWeight` of `Utils`", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/238", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `getPoolShareWeight` function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.  ## Proof of Concept  According to the implementation of `getPoolShareWeight,` a user's pool share weight is calculated by `uints * baseAmount / totalSupply`, where `uints` is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:  1. Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool. 2. The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool's `baseAmount`. He could split his trade into small amounts to reduce slip-based fees. 3. The attacker now wants to increase his weight in the `DaoVault`. He adds his LP tokens to the pool by calling the `deposit` function of `Dao.` 4. `Dao` then calls `depositLP` of `DaoVault`, causing the attacker's weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker's weight is artificially increased. 5. With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when calling `harvest` of the `Dao` contract. 6. The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.  Referenced code: [Utils.sol#L46-L50](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L46-L50) [Utils.sol#L70-L77](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L70-L77) [DaoVault.sol#L44-L56](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/DaoVault.sol#L44-L56) [Dao.sol#L201](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L201) [Dao.sol#L570](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L570)  ## Recommended Mitigation Steps  A possible mitigation is to record the current timestamp when a user's weight in the `DaoVault` or `BondVault` is recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.  "}, {"title": "Improper access control of `claimAllForMember` allows anyone to reduce the weight of a member", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/235", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `claimAllForMember` function of `Dao` is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member's LP tokens could decrease the member's weight in the `BondVault`, thus affecting the member's votes and rewards in the `Dao` contract.   ## Proof of Concept  For example, an attacker can intentionally front-run a victim's `voteProposal` call to decrease the victim's vote weight to prevent the proposal from being finalized:  1. Supposing the victim's member weight in the `BondVault` is 201, the total weight is 300. The victim has some LP tokens claimable from the vault, and if claimed, the victim's weight will be decreased to 101. To simplify the situation, assuming that the victim's weight in the `DaoVault` and the total weight of the `DaoVault` are both 0. 2. The victim wants to vote on the current proposal, which requires the majority consensus. If the victim calls `voteProposal`, the proposal will be finalized since the victim has the majority weight (201/300 > 66.6%). 3. An attacker does not want the proposal to be finalized, so he calls `claimAllForMember` with the victim as the parameter to intentionally decrease the victim's weight. 4. As a result, the victim's weight is decreased to 101, and the total weight is decreased to 200. The victim cannot finalize the proposal since he has no majority anymore (101/200 < 66.6%).  Similarly, an attacker can front-run a victim's `harvest` call to intentionally decrease the victim's reward since the amount of reward is calculated based on the victim's current weight.  Referenced code: [Dao.sol#L179-L206](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L179-L206) [Dao.sol#L276-L285](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L276-L285) [Dao.sol#L369-L383](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L369-L383) [Dao.sol#L568-L574](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L568-L574) [Dao.sol#L577-L586](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L577-L586) [BondVault.sol#L104-L117](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L104-L117) [BondVault.sol#L120-L129](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L120-L129) [BondVault.sol#L155-L162](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L155-L162)  ## Recommended Mitigation Steps  Consider removing the `member` parameter in the `claimAllForMember` function and replace all `member` to `msg.sender` to allow only the user himself to claim unlocked bonded LP tokens.  "}, {"title": "Possible divide by zero errors in `Utils`", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/232", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Several functions in `Utils` do not handle edge cases where the divisor is 0, caused mainly by no liquidity in the pool. In such cases, the transactions revert without returning a proper error message.  ## Proof of Concept  Referenced code: [Utils.sol#L75](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L75) [Utils.sol#L90](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L90) [Utils.sol#L109-L110](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L109-L110) [Utils.sol#L123-L124](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L123-L124) [Utils.sol#L131](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L131) [Utils.sol#L138](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L138) [Utils.sol#L155](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L155) [Utils.sol#L189](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L189) [Utils.sol#L195](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L195) [Utils.sol#L215](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L215)  ## Recommended Mitigation Steps  Check if the divisors are 0 in the above functions to handle edge cases.  "}, {"title": "Assuming `BEP20.name` of a token is implemented", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/226", "labels": ["bug", "invalid", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Assuming `BEP20.name` of a token is implemented"}, {"title": "Missing input validation in addLiquidityForMember()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/225", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Router.sol, the function addLiquidityForMember() doesn't check inputBase and inputToken. Since we know they can't both be zero (it wouldn't change anything and user pays the gas for nothing).  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L51  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a require `inputBase>0 || inputToken>0`.  "}, {"title": "Loss of precision", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/224", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "Loss of precision"}, {"title": "Missing input validation zapLiquidity()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact zapLiquidity() in Router.sol misses an input validation unitsInput > 0.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L59  ## Tools Used editor  ## Recommended Mitigation Steps Add an input validation for unitsInput.  "}, {"title": "Missing function setParams in Dao", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/220", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "Missing function setParams in Dao"}, {"title": "state variable that can be declared as constant", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/219", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L11  ## Tools Used  manual review  ## Recommended Mitigation Steps   "}, {"title": "state variables that can be declared as immutable", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact  https://docs.soliditylang.org/en/v0.8.6/contracts.html#constant-and-immutable-state-variables  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L15  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L14  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L18  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L7 https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L12  ## Tools Used  manual review  ## Recommended Mitigation Steps  "}, {"title": "Missing input validation in realise()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/216", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "Missing input validation in realise()"}, {"title": "Lack of emission of event when changing  dao fees", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/215", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Lack of emission of event when changing  dao fees"}, {"title": "Missing revert if denominator = 0", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/214", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Synth.sol, the function burnSynth() calculates a division between two variables. Since they can be zero, it's better to have a require with a clear error message when the division is not possible, otherwise an user wouldn't know why a transaction reverted.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Synth.sol#L176  ## Tools Used editor  ## Recommended Mitigation Steps Add a require(denom != 0, \"LPDebt = 0\").  "}, {"title": "lack of zero address validation for recipent in _transfer() of pool.sol, synth.sol", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/213", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "lack of zero address validation for recipent in _transfer() of pool.sol, synth.sol"}, {"title": "No checking of recipient address validation during low-level call", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/212", "labels": ["bug", "invalid", "0 (Non-critical)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "No checking of recipient address validation during low-level call"}, {"title": "Mismatch in event definition", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/210", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In synthFactory.sol, there's an `event CreateSynth(address indexed token, address indexed pool)`. However the event is emitted with \"synth\" as second output.  ## Proof of Concept https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L13 https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L46  ## Tools Used editor  ## Recommended Mitigation Steps Think about what's the better variable to be emitted, and correct one of the lines.  "}, {"title": "[Pool] - Anyone can remove liquidity from Pools, allowing them to alter the price  ", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/206", "labels": ["bug", "invalid", "3 (High Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "[Pool] - Anyone can remove liquidity from Pools, allowing them to alter the price  "}, {"title": "Pool.burnSynth(address,address) is potentially reentrant", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/203", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  Pool.burnSynth(address,address) is potentially a reentrant method because it executes transfers and burning before updating balances/metrics.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L245  ## Tools Used  Slither  ## Recommended Mitigation Steps  The function should update state before external calls.  Consider using a nonReentrant guard as provided by OpenZeppelin:  https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard  "}, {"title": "Pool._addPoolMetrics(uint256) is subject to potential miner manipulation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "Pool._addPoolMetrics(uint256) is subject to potential miner manipulation"}, {"title": "DaoVault.constructor(address) is missing a zero address check", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/198", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "DaoVault.constructor(address) is missing a zero address check"}, {"title": "Router.revenueDetails(uint256,address) potentially vulnerable to miner manipulation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/194", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "Router.revenueDetails(uint256,address) potentially vulnerable to miner manipulation"}, {"title": "Dividend reward can be gamed", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/182", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Router.addDividend` function tells the reserve to send dividends to the pool depending on the fees.  - The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent. - The `normalAverageFee` variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool `arrayFeeSize` (20) times (use `buyTo`). The fees of the single wei trades will be zero and thus the `normalAverageFee` will also be zero as, see `addTradeFee`. - The attacker then does a trade that generates some non-zero fees, setting the `normalAverageFee` to this trade's fee. The `feeDividend` is then computed as `_fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2`. Half of the `dailyAllocation` is sent to the pool. - The attacker repeats the above steps until the reserve is almost empty. Each time the `dailyAllocation` gets smaller but it's still possible to withdraw almost all of it. - They redeem their LP tokens and gain a share of the profits  ## Impact The reserve can be emptied by the attacker.  ## Recommended Mitigation Steps Counting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short. I think a better idea is to compute the dividends based on **volume** traded over a timespan instead of looking at individual trades.   "}, {"title": "BondVault `BASE` incentive can be gamed", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/178", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "BondVault `BASE` incentive can be gamed"}, {"title": "Vote weight can be manipulated", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/176", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Vote weight can be manipulated"}, {"title": "BondVault fails if no SPARTA in DAO", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/175", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "BondVault fails if no SPARTA in DAO"}, {"title": "delisting bond assets does not remove from array", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/174", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "delisting bond assets does not remove from array"}, {"title": "DAO.setGenesisFactors sets wrong `erasToEarn`", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/173", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "DAO.setGenesisFactors sets wrong `erasToEarn`"}, {"title": "Missleading onlyDAO modifiers", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/172", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Missleading onlyDAO modifiers"}, {"title": "`calcAsymmetricValueToken` never used", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/170", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "`calcAsymmetricValueToken` never used"}, {"title": "SynthVault withdraw forfeits rewards", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/168", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.  ## Impact Usually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.  ## Recommended Mitigation Steps Claim the rewards with the user's deposited balance first in `withdraw`.   "}, {"title": "SynthVault deposit lockup bypass", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/167", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault.harvestSingle` function can be used to mint & deposit synths without using a lockup. An attacker sends `BASE` tokens to the pool and then calls `harvestSingle`. The inner `iPOOL(_poolOUT).mintSynth(synth, address(this));` call will mint synth tokens to the vault based on the total `BASE` balance sent to the pool, including the attacker's previous transfer. They are then credited the entire amount to their `weight`.  This essentially acts as a (mint +) deposit without a lock-up period.  ## Recommended Mitigation Steps Sync the pool before sending `BASE` to it through `iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT);` such that any previous `BASE` transfer is wasted. This way only the actual reward's weight is increased.  "}, {"title": "SynthVault rewards can be gamed", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/166", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`. This spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity. However, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool. Therefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:  1. Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `BASE` per `token` price. 2. Call `SynthVault.depositForMember` and deposit a _small_ amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price. 3. Optionally drip more `BASE` into the pool and repeat the deposits 4. Drip back `token` to the pool to rebalance it  The user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards.  ## Impact The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.  ## Recommended Mitigation Steps Track a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.  "}, {"title": "Unbounded iteration in Synth Vault", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/163", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "Unbounded iteration in Synth Vault"}, {"title": "Can accidentally lose tokens when removing liquidity from pool 2", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/161", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "Can accidentally lose tokens when removing liquidity from pool 2"}, {"title": "Synth: Can accidentally burn tokens by sending them to zero", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/159", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Synth._transfer` function does not check if `recipient != 0`. Unlike standard ERC20, tokens can be accidentally burned this way.  ## Recommended Mitigation Steps Prevent user errors by denying transfers to the zero address and forcing them to call `burn` instead.  "}, {"title": "Pool: Can accidentally burn tokens by sending them to zero", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/158", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Pool: Can accidentally burn tokens by sending them to zero"}, {"title": "DAO approval amount too high for token", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "DAO approval amount too high for token"}, {"title": "DAO approval amount too high for BASE", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/156", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "DAO approval amount too high for BASE"}, {"title": "Synth: approveAndCall sets unnecessary approval", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Synth: approveAndCall sets unnecessary approval"}, {"title": "Pool: approveAndCall sets unnecessary approval", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/154", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Pool: approveAndCall sets unnecessary approval"}, {"title": "Pools can be created without initial liquidity", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/151", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  The protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call `PoolFactory.createPoolADD`, receive the LP tokens in `addForMember` and withdraw liquidity again.  ## Recommended Mitigation Steps Consider burning some initial LP tokens or taking a pool creation fee instead.   "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/147", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "Missing parameter validation"}, {"title": "Variable one in Utils.sol can be set to constant  ", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/146", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  maplesyrup   # Vulnerability details  ## Impact Gas optimizations Does not affect the contract in any harmful way. Suggestions allow for smart contract gas optimizations.  ## Proof of Concept According to Slither analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant), the variable in contract Utils.sol called \"one\" or Utils.one can be set to a constant as it is considered a variable that does not change throughout the contract.   Slither Detectors:  constable-states:  Utils.one (contracts/Utils.sol, lines#11) should be constant  ------------  Code in contract:  uint public one = 10**18; <---- can be constant as it does not change  --------------  Console output (via Slither in JSON format):    \"constable-states\": [     \"Utils.one (contracts/Utils.sol#11) should be constant\\n\"   ],  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  "}, {"title": "Function purgeDeployer() should be declared external in BondVault.sol", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/145", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  maplesyrup   # Vulnerability details  ## Impact  Gas Optimization This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract.  ## Proof of Concept According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.   Slither Detector:  external-function:  purgeDeployer() should be declared external:  BondVault.purgeDeployer() (contracts/BondVault.sol, lines#50-52)  -----------------------  Console output (via Slither in JSON format):  \"external-function\": [     \"purgeDeployer() should be declared external:\\n\\t- BondVault.purgeDeployer() (contracts/BondVault.sol#50-52)\\n\",     \"hasMinority(uint256) should be declared external:\\n\\t- Dao.hasMinority(uint256) (contracts/Dao.sol#601-610)\\n\",     \"ROUTER() should be declared external:\\n\\t- Dao.ROUTER() (contracts/Dao.sol#615-621)\\n\",     \"UTILS() should be declared external:\\n\\t- Dao.UTILS() (contracts/Dao.sol#624-630)\\n\",     \"BONDVAULT() should be declared external:\\n\\t- Dao.BONDVAULT() (contracts/Dao.sol#633-639)\\n\",     \"DAOVAULT() should be declared external:\\n\\t- Dao.DAOVAULT() (contracts/Dao.sol#642-648)\\n\",     \"POOLFACTORY() should be declared external:\\n\\t- Dao.POOLFACTORY() (contracts/Dao.sol#651-657)\\n\",     \"SYNTHFACTORY() should be declared external:\\n\\t- Dao.SYNTHFACTORY() (contracts/Dao.sol#660-666)\\n\",     \"RESERVE() should be declared external:\\n\\t- Dao.RESERVE() (contracts/Dao.sol#669-675)\\n\",     \"SYNTHVAULT() should be declared external:\\n\\t- Dao.SYNTHVAULT() (contracts/Dao.sol#678-684)\\n\",     \"greet() should be declared external:\\n\\t- Greeter.greet() (contracts/Greeter.sol#15-17)\\n\",     \"setGreeting(string) should be declared external:\\n\\t- Greeter.setGreeting(string) (contracts/Greeter.sol#19-22)\\n\"   ]  ## Tools Used  Spartan Contracts Solidity (v 0.8.3) Slither Analyzer (v 0.8.0)  ## Recommended Mitigation Steps  1. Clone repository for Spartan Smart Contracts 2. Create a python virtual environment with a stable python version 3. Install Slither Analyzer on the python VEM 4. Run Slither against all contracts  "}, {"title": "Missing zero address check on BondVault constructor", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/144", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Missing zero address check on BondVault constructor"}, {"title": "Strict equality used in claimForMemeber()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/143", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "Strict equality used in claimForMemeber()"}, {"title": "Missing check for already curated pool being re-curated", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  addCuratedPool() is missing a require(isCuratedPool[_pool] == false) check, similar to the one in removeCuratedPool to ensure that the DAO is not trying to curate an already curated pool which indicates a mismatch of assumption/accounting compared to the contract state.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L79-L87  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L93   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add require(isCuratedPool[_pool] == false) before setting isCuratedPool[_pool] = true.  "}, {"title": "Missing check for token type/decimals in createPool", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/136", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Missing check for token type/decimals in createPool"}, {"title": "Incorrect event parameter logs zero address instead of WBNB", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The token argument used in CreatePool event emit of createPoolADD() should really be _token so that WBNB address is logged in the event instead of zero address when token == 0. Logging a zero address could confuse off-chain user interfaces because it is treated as a burn address by convention.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L60  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use _token instead of token in event emit.  "}, {"title": "Number of curated pools can only be 10 at any point", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/134", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Number of curated pools can only be 10 at any point"}, {"title": "Members lose SPARTA tokens in removeLiquiditySingle()", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/133", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  When a member calls removeLiquiditySingle() requesting only SPARTA in return, i.e. toBASE = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member\u2019s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.   In other words, the _member's BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the _member because the _token's transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via swapTo().   This effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.  ## Proof of Concept  LPs sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L121  SPARTA and TOKENs withdrawn from Pool to Router: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L122  TOKENs from Router sent to Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L126  TOKENs in Pool converted to BASE SPARTA and sent to member directly from the Pool: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L127   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  1. BASE SPARTA should also be transferred to the Pool before swapTo() so they get sent to the member along with the converted TOKENs via swapTo() 2. Use swap(BASE) instead of swapTo() so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.  "}, {"title": "Potential reentrancy may lead to unexpected behavior", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/132", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "Potential reentrancy may lead to unexpected behavior"}, {"title": "Lack of require() allows control flow to proceed leading to undefined behavior", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/131", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The _handleTransferIn() functions use a conditional check (_amount > 0) to execute the transfer-in logic of tokens. This should really be a require() to prevent zero amount transfers into the protocol which will allow subsequent logic to execute and potentially utilize any dust/stuck funds from earlier to be accounted to the sender.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L198-L210  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L202-L206  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L110-L114  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change condition check to a require() which will revert any transfers of zero tokens/funds.  "}, {"title": "Missing isListedPool checks may lead to lock/loss of user funds", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/130", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  This isListedPool check implemented by isPool() is missing in many functions of the contract that accept pool/token addresses from users. getPool() returns the default mapping value of 0 for token that do not have valid pools. This lack of input validation may lead to use of zero/invalid pool addresses in the protocol context and reverts in the best case or burn/loss of user funds in the worst case.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L119-L133  Use of getPool() without isPool() check: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L108  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L52  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L81  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L139  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L155  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L232  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L247-L248  Several usages of getPool() in Utils.sol and other places.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Combine isPool() isListedPool check to getPool() so that it always returns a valid/listed pool in the protocol.  "}, {"title": "Unnecessary redundant check for basisPoints", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/129", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The threshold check for basisPoints while a required part of input validation is an unnecessary redundant check because calcPart() does a similar upper bound check and the lower bound check on 0 is only an optimization.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L95  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L65   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove redundant check to save gas and improve readability/maintainability.  "}, {"title": "Unused _token potentially indicates missing logic or is dead code", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  _token is conditionally set (to WBNB) but never used in addLiquiditySingleForMember() function unlike its usage in other functions. Such usage typically indicates missing/incorrect functionality. It looks like _handleTransferIn checks token == 0 again to consider BNB.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L83  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Recommend re-evaluating _token usage in this function, adding any missing logic or removing it for readability/maintainability.  "}, {"title": "Missing check for toPool != fromPool", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/127", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  zapLiquidity() used to trade LP tokens of one pool to another is missing a check for toPool != fromPool which may happen accidentally. The check will prevent unnecessary transfers and avoid any fees/slippage or accounting errors.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L58-L71   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add toPool != fromPool as part of input validation.  "}, {"title": "receive() function in Router allows locking of accidentally sent user\u2019s BNB", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/126", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "receive() function in Router allows locking of accidentally sent user\u2019s BNB"}, {"title": "Duplicated functionality in two functions is a maintainability risk", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/125", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "Duplicated functionality in two functions is a maintainability risk"}, {"title": "isMember and arrayMembers are only added to but never removed from", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/122", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-07-spartan-findings", "body": "isMember and arrayMembers are only added to but never removed from"}, {"title": "Attacker can trigger pool sync leading to user fund loss", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  An attacker can front-run any operation that depends on the pool contract's internal balance amounts being unsynced to pool's balance on token/base contracts effectively nullifying the transfer of base/tokens for those operations. This will make _getAddedBaseAmount() and _getAddedTokenAmount() return 0 (because the balances are synced) from such operations.   Impact: The affected operations are: addForMember(), swapTo() and mintSynth() which will all take the user funds to respective contracts but will treat it as 0 (because of the syncing) and thus not add liquidity, return swapped tokens or mint any synths to the affected users. User loses deposited funds to the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L308-L312  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L261-L270  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L272-L281  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L216-L220  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L231  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L174-L175  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L279  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add access control to sync() function so that only Router can call it via addDividend().  "}, {"title": "Incorrect event parameter used in emit", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Incorrect event parameter outputAmount is used (instead of output) in the MintSynth event emit. outputAmount is a named return variable that is never set in this function and so will always be 0. This should instead be output. This will confuse the UI or offchain monitoring tools that 0 synths were minted and will lead to users panicking/complaining or trying to mint synth again.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L240  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L232  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Replace outputAmount with output in the emit.  "}, {"title": "Missing zero-address check on recipient address in transfer", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/117", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "Missing zero-address check on recipient address in transfer"}, {"title": "withdraw() not defined (Router.sol#217)", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/110", "labels": ["bug", "invalid", "2 (Med Risk)", "sponsor disputed"], "target": "2021-07-spartan-findings", "body": "withdraw() not defined (Router.sol#217)"}, {"title": "Old DAO continues to exist/function even after moving to a new DAO", "html_url": "https://github.com/code-423n4/2021-07-spartan-findings/issues/107", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-07-spartan-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  If moveDAO() is executed after voting, the existing DAO contract continues to function as before whereas it should ideally cease to function/exist from the users\u2019 perspective or at least function as a clone of the new DAO by using the same addresses as it does.  Scenario: moveDAO is executed to make DAO and BASE.DAO point to the new address. Existing DAO contract continues to function but all the other interfacing contracts (ROUTER, UTILS, DAOVAULT, BONDVAULT, SYNTHVAULT, POOLFACTORY, SYNTHFACTORY and RESERVE) use the updated DAO address as updated in BASE. At a minimum, this leads to undefined behavior and at worst an attack where the old DAOs (there could be many) are exploited because it still points to valid router, pool and vault contracts.  ## Proof of Concept  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L451-L459   changeDAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/outside-scope/Sparta.sol#L189-L193   Use of BASE.DAO: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/BondVault.sol#L54-L57  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/DaoVault.sol#L32-L34  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L39-L41  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L41-L43  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L20-L22  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L29-L31  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L35-L37  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthFactory.sol#L27-L29  https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L45-L47  Updated Getters: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L614-L684  Example uses of stale interface contract addresses _* instead of using Dao(DAO).* versions: _ROUTER: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L259  _BONDVAULT: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L281  _UTILS: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L205  _RESERVE: https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L188  etc.  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  At a minimum, all DAO public/external functions should check and revert if daoHasMoved or the design can even consider a selfdestruct to destroy the DAO contract once it has successfully handed over to the new DAO contract and all pending actions have been cleared. In the unlikely requirement of older DAO contracts continuing to exist, they should at least use addresses of interfacing contracts as reported by the new DAO which could have updated them.  "}]